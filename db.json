{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/oyr/Redis/Redis-集群模式.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1635302758988},{"_id":"source/about/index.md","hash":"08a1583c86bb1218a9d1a0cfc65bb3dd9325f55b","modified":1626085904000},{"_id":"source/categories/index.md","hash":"d74dea876104aae5e86f128ddbc114701e5ff5b7","modified":1626085904000},{"_id":"source/_posts/lh/elasticsearch/es-初级应用.md","hash":"0a41af4e5f651c04b775ad5306e462d3617f8b50","modified":1635325210554},{"_id":"source/tags/index.md","hash":"9c54d025494f9b8c74259a9cc61380809eac8719","modified":1626085904000},{"_id":"source/_posts/lh/DDD/DDD领域模型设计.md","hash":"2b85c8c790082deb7e329c054ef0607b177bdb91","modified":1628586971444},{"_id":"source/_posts/lh/elasticsearch/es分布式架构.md","hash":"dd373a415286c1940462e3925921f81c0c1cf75e","modified":1635150146503},{"_id":"source/_posts/demo/MD.md","hash":"71c5f1481d0601305ca4ea0c57debec69ba33896","modified":1626160448474},{"_id":"source/_posts/lh/elasticsearch/es初讲.md","hash":"be92953a577721cd813f2516f69fd23301b0957c","modified":1635315865820},{"_id":"source/_posts/lh/spring/注解编程.md","hash":"cbbbc999ffcbbfd8ac37142294655cf797ede85f","modified":1631245131341},{"_id":"source/_posts/lh/设计模式/设计模式初讲.md","hash":"b1e696d8a08eefed17cf234271b62dbe60185027","modified":1630464365676},{"_id":"source/_posts/hello-world.md","hash":"0be6d5855abd247eaf7b2536e235a9bfd7dbceda","modified":1625820895927},{"_id":"source/_posts/oyr/Dubbo/Dubbo-基础.md","hash":"068a60db0cfd19551bdc68583d54c4d8a3498e41","modified":1635244105951},{"_id":"source/_posts/lh/elasticsearch/es-初识搜索引擎.md","hash":"9775d4312e39499fa9eb813a0127db408442fdf0","modified":1635231925436},{"_id":"source/_posts/oyr/Dubbo/Dubbo-整合Hystrix.md","hash":"1f97a894ab05c121c5417dc8c8466049dfb8a208","modified":1635244105957},{"_id":"source/_posts/oyr/Dubbo/Dubbo-面试题.md","hash":"39ee6b3e20e392e04e2ed67f3eb95cad31e10b23","modified":1635244105938},{"_id":"source/_posts/oyr/Dubbo/Dubbo-高级.md","hash":"3ca52e53aa396b3098918f7bd93a420935560d18","modified":1635244105945},{"_id":"source/_posts/lh/并发编程/并发编程初讲.md","hash":"92c5f8519851dd6fe5f2e038cffc693561deed33","modified":1630464302553},{"_id":"source/_posts/oyr/Hexo/Hexo常用命令.md","hash":"9c8569ee8e5597d477ac800703f84398e01ee300","modified":1635244226423},{"_id":"source/_posts/lh/并发编程/线程池.md","hash":"1c4dd84e3614278ab62fc4da551cf60b5e272664","modified":1630464313477},{"_id":"source/_posts/lh/并发编程/CAS.md","hash":"b6d2994bb817e95305cdc465f5d699f74eeadcbd","modified":1630464339283},{"_id":"source/_posts/oyr/Feign/Feign.md","hash":"d9c0ccfc1b8a263662fe7f2bbc73d1983dbc02b3","modified":1635244111381},{"_id":"source/_posts/lh/并发编程/AQS.md","hash":"4908e2c952d15677e7569bb420af6a25b34c778f","modified":1630464326187},{"_id":"source/_posts/oyr/Job/Elastic-Job.md","hash":"ab506d7fc6adf998a0f63fbc493a80b24f3adf8e","modified":1635303201661},{"_id":"source/_posts/lh/并发编程/锁相关.md","hash":"e1a1c836a3b7a74ee8b7dbbc620e43c2bbc82762","modified":1630464289150},{"_id":"source/_posts/lh/并发编程/volatile.md","hash":"17973ef5741849d2e67c53fb11112e1acd8490c7","modified":1630566526865},{"_id":"source/_posts/oyr/MQ/ActiveMQ.md","hash":"c140d09ce491e8d1154de5915ef581732dffa14b","modified":1635244226429},{"_id":"source/_posts/oyr/Java/Java8新特性.md","hash":"57d9034744cc301f3065e9612e8cd786b45abb30","modified":1635244226374},{"_id":"source/_posts/oyr/MQ/Kafka.md","hash":"b4481aaeff9da6a0e18e3a58187023fbf532a84d","modified":1635302845605},{"_id":"source/_posts/oyr/Markdown/Markdown语法.md","hash":"8a8cc477584f20cb9e2b601a66738288d14a5db3","modified":1631691523000},{"_id":"source/_posts/oyr/Nginx/Nginx.md","hash":"5ce8ed807bce0523371afdf8aa31858e8031b754","modified":1635302824281},{"_id":"source/_posts/oyr/MQ/消息中间件入门与简介.md","hash":"5b96f8e032fe7faa84fa6da0912797e81b1e009f","modified":1635244226368},{"_id":"source/_posts/oyr/MySQL/MySQL-主从复制.md","hash":"25587bff7f906a96561409c3b9fcbe4a4b618650","modified":1635244244761},{"_id":"source/_posts/oyr/MySQL/MySQL-基础.md","hash":"77d1b0106b7ff3944f5d6ed6db78ef611c3b9d12","modified":1635244244712},{"_id":"source/_posts/oyr/MQ/JMS.md","hash":"9c858f0ea3168b33bab00fbc74275c6a89fa8089","modified":1635244226456},{"_id":"source/_posts/oyr/Redis/Redis-主从复制.md","hash":"7a73cf83eaa199c1d61769d942df86551e43e7d6","modified":1635244263798},{"_id":"source/_posts/oyr/分布式/分布式session.md","hash":"fe84dd3674e25ba2424d3e27364f611a546dec7b","modified":1635303094789},{"_id":"source/_posts/oyr/Redis/Redis-哨兵模式.md","hash":"f093d0764817a3c2b743a9155e1bbd339e05328b","modified":1635244263853},{"_id":"source/_posts/oyr/MQ/AMQP.md","hash":"24de8391cb4c8e18485220c6dbd08ea6ecc16f41","modified":1635244226485},{"_id":"source/_posts/oyr/MySQL/MySQL-日志系统.md","hash":"8689627d4ca84842ab8c18f6aff1c198e3107453","modified":1635244244718},{"_id":"source/_posts/oyr/Redis/Redis-基础.md","hash":"dc275290ad02a4dafb79f36bc1a458c6669ea44a","modified":1635244263912},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-SpringBoot整合.md","hash":"4bbef139a99f04c5b6a8939c4eb66cf2583e5e40","modified":1635244226381},{"_id":"source/_posts/oyr/分布式/链路追踪.md","hash":"37aea205818b6b7c055b367a043b92265a216bbe","modified":1635303098524},{"_id":"source/_posts/oyr/MySQL/MySQL-事务日志.md","hash":"7b9fe64f8d6b6269817fb25978772c6e4cc3a46b","modified":1635244244724},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-Spring整合.md","hash":"8a78950ce2f27b478930e05322d5dd8db26e9ce5","modified":1635244226440},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-集群.md","hash":"5f5dc828adea26c810d3e002111bc713f1dc6179","modified":1635244226520},{"_id":"source/_posts/oyr/Redis/Redis-数据过期策略.md","hash":"8c9a6ddd9427a3f83ad727d7356f7156c06162f8","modified":1635244263825},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-高级.md","hash":"dd4771b413c554f565e823e794abfedd13c3590e","modified":1635244226326},{"_id":"source/_posts/oyr/分布式/链路追踪/SkyWalking.md","hash":"23a08537fc58c2bad39571ac5f1431c5b8c598ee","modified":1635303075549},{"_id":"source/_posts/oyr/分布式/分库分表/ShardingSphere.md","hash":"23a08537fc58c2bad39571ac5f1431c5b8c598ee","modified":1635303082802},{"_id":"source/_posts/oyr/分布式/分库分表/MyCat.md","hash":"de4d2c405db24e561567446485f318e334964156","modified":1635303087878},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-应用问题.md","hash":"a585f94342d67b9ee7ebc7ae74be63b4988be481","modified":1635244226434},{"_id":"source/_posts/oyr/MQ/RabbitMQ/RabbitMQ-基础.md","hash":"d8fa0be062c85e16103f3aa44c564448a54cc0e5","modified":1635244226447},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1626085904000},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1626085904000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1626085904000},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1626085904000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1626085904000},{"_id":"source/_posts/oyr/Redis/Redis-穿透&雪崩&击穿.md","hash":"66c5511b0282d5060f7aec3d2b782fed584f6b11","modified":1635244263820},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1626085904000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1626085904000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1626085904000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1626085904000},{"_id":"themes/next/_config.yml","hash":"7f6756a6d26f6994c5ebfc88579c614f1755f2cd","modified":1626085904000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1626085904000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1626085904000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1626085904000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1626085904000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1626085904000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1626085904000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1626085904000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1626085904000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1626085904000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1626085904000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1626085904000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1626085904000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1626085904000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1626085904000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1626085904000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1626085904000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1626085904000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1626085904000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1626085904000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1626085904000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1626085904000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1626085904000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1626085904000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1626085904000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1626085904000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1626085904000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1626085904000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1626085904000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1626085904000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1626085904000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1626085904000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1626085904000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1626085904000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1626085904000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1626085904000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1626085904000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1626085904000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1626085904000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1626085904000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1626085904000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1626085904000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1626085904000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1626085904000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1626085904000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1626085904000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1626085904000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1626085904000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1626085904000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1626085904000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1626085904000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1626085904000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1626085904000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1626085904000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1626085904000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1626085904000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1626085904000},{"_id":"themes/next/layout/_macro/post.swig","hash":"71e4dc5a56cbc403d9785526f7719d824f4c8911","modified":1626085904000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1626085904000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1626085904000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1626085904000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1626085904000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1626085904000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1626085904000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ce2c1000be53443914517aa90c70f9b72c30a672","modified":1626085904000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1626085904000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c4ec5822d644ddcedf2401837e6f6e6d3b63fbcd","modified":1626085904000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1626085904000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1626085904000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1626085904000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1626085904000},{"_id":"themes/next/source/css/_colors.styl","hash":"19c836f367977fb712b9868f3281ff5d757a8d5c","modified":1626085904000},{"_id":"themes/next/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1626085904000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1626085904000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626085904000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1626085904000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1626085904000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1626085904000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1626085904000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1626085904000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1626085904000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1626085904000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1626085904000},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1626085904000},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1626085904000},{"_id":"themes/next/source/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1626085904000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1626085904000},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1626085904000},{"_id":"themes/next/source/js/utils.js","hash":"0343eb03ed76c0b030f7807b82a00772135ba463","modified":1626085904000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1626085904000},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1626085904000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1626085904000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1626085904000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1626085904000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1626085904000},{"_id":"themes/next/scripts/filters/post.js","hash":"d86849559ae54a4098aef4e2ab9dc8f99a1d186c","modified":1626085904000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"22d77bd511fc7c1bbd12339d65004ed5bfb0713c","modified":1626085904000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1626085904000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1626085904000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1626085904000},{"_id":"themes/next/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1626085904000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1626085904000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1626085904000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1626085904000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1626085904000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1626085904000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1626085904000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1626085904000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1626085904000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1626085904000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1626085904000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1626085904000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1626085904000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1626085904000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"12aeb9ee0d1d49d347f82a91e6bab568e1b59037","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"958e097790551c9520426a1233add03515034f35","modified":1626085904000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"12cd9adb0c33adc484201f9e8a4e64ccf3011bae","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1626085904000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1626085904000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"ec20ff43845723e0ac2a245047c7a7e5aead6e88","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1626085904000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1626085904000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1626085904000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"799fdf4f258a51d45d1e2b02fb59b337e46b5b3c","modified":1626085904000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dae390efcb5da9c021ad7f25fe2d39ff36938cc6","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1626085904000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1626085904000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1626085904000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"220da37051ed5dac9cf7bd126451f6aba4f94d21","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1626085904000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"5e644b1303ab6dcd1b65ee0fd6b91309b04ce64d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1626085904000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"89f76380091f1be49936c69bac02e984dae5ff87","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"66211794e4ed47e779ca81150cef588e0b4f2fc5","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9b3cce30c58e57b59e45d3f668a71a4129d3a8e4","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1626085904000},{"_id":"public/about/index.html","hash":"3ca6e23ddac8613959f0889e62c1fb05d7d99fd6","modified":1635325235503},{"_id":"public/tags/index.html","hash":"b2cdbd04e021f87c98e0508aed5425357f9780c6","modified":1635325235503},{"_id":"public/categories/index.html","hash":"8a7277c2b137f19d4a1b64952975a892f6a9af32","modified":1635325235503},{"_id":"public/2021/09/22/oyr/MQ/RabbitMQ/RabbitMQ-集群/index.html","hash":"33d5763928b229f289be5310997ad0f5a38a38b7","modified":1635325235503},{"_id":"public/2021/08/13/oyr/MQ/Kafka/index.html","hash":"80386497cd672c74c3c24eb866677a188995a7ac","modified":1635325235503},{"_id":"public/2021/07/27/lh/DDD/DDD领域模型设计/index.html","hash":"69d8b9318fa8e90213f9c4fb8e8e1c35a09fea01","modified":1635325235503},{"_id":"public/2021/07/13/oyr/Redis/Redis-集群模式/index.html","hash":"af6f3f70d213897cf5bac27fcceb4bc673644956","modified":1635325235503},{"_id":"public/2021/07/08/hello-world/index.html","hash":"639d8c12f5246cfd7a4cc99f89e9495bc63ef8ed","modified":1635325235503},{"_id":"public/2021/06/23/oyr/MySQL/MySQL-主从复制/index.html","hash":"50f2b09faff6ecc14466b9cbb694561c786cd05f","modified":1635325235503},{"_id":"public/2021/06/23/oyr/Nginx/Nginx/index.html","hash":"bfa9a9f8fe4d1745189eac3e5a57c0b3994d68ea","modified":1635325235503},{"_id":"public/2021/06/23/oyr/分布式/分布式session/index.html","hash":"e59b67b6bed23346b9a343eacc601550f9d57967","modified":1635325235503},{"_id":"public/2021/06/23/oyr/分布式/链路追踪/index.html","hash":"b3015eb86c2f29cf6ea92fbbf0e344e2de2091c5","modified":1635325235503},{"_id":"public/2021/06/23/oyr/分布式/分库分表/ShardingSphere/index.html","hash":"cbce82f81f1bb7175692deb5947faa271eeaefd4","modified":1635325235503},{"_id":"public/2021/06/23/oyr/分布式/链路追踪/SkyWalking/index.html","hash":"633fead146da11938432e868606bb03ffd075823","modified":1635325235503},{"_id":"public/2021/06/23/oyr/分布式/分库分表/MyCat/index.html","hash":"41a6ea4100f33d3aaba3e178069d568bcfb72a98","modified":1635325235503},{"_id":"public/2021/06/20/oyr/Hexo/Hexo常用命令/index.html","hash":"da1ab08ab149bae1a3b9d35acf48e1e4707499fd","modified":1635325235503},{"_id":"public/2021/06/20/oyr/Job/Elastic-Job/index.html","hash":"e643f4a9ed33991d9ae836efffbfc072e3891294","modified":1635325235503},{"_id":"public/2020/06/22/oyr/Redis/Redis-哨兵模式/index.html","hash":"85654854322efeb09f1422305f6908d43a1a85e1","modified":1635325235503},{"_id":"public/2020/06/21/oyr/Redis/Redis-主从复制/index.html","hash":"5568642f44866714e1cb43b6497db798655add9c","modified":1635325235503},{"_id":"public/archives/index.html","hash":"5044342ed2c43cc77012f2df3d8b77df6b04ffae","modified":1635325235503},{"_id":"public/archives/page/2/index.html","hash":"2c92b643e450b877dbe4f93f9a144abf152855d1","modified":1635325235503},{"_id":"public/archives/page/3/index.html","hash":"b8cb03705a53fc1ce9952f272dec8426510344cb","modified":1635325235503},{"_id":"public/archives/page/4/index.html","hash":"323d59a1dd5d7cbe78214dce4412dff31949683b","modified":1635325235503},{"_id":"public/archives/page/5/index.html","hash":"69936a4c14f13cdcb90f62ec2ea54b050c75066f","modified":1635325235503},{"_id":"public/archives/page/6/index.html","hash":"75be45c8a367590591e82067a0dbdc387ab16979","modified":1635325235503},{"_id":"public/archives/2020/index.html","hash":"7d6ca84aaf3439fe9bc944e62cbff9130638a439","modified":1635325235503},{"_id":"public/archives/2020/06/index.html","hash":"d7f6575215ad0f9c34c39639b4d7271a4e7caa91","modified":1635325235503},{"_id":"public/archives/2021/index.html","hash":"397654fe48e02efbe26368ce9617521cd7544497","modified":1635325235503},{"_id":"public/archives/2021/page/2/index.html","hash":"a8a1d57da402a6f94fcbcbd5bcf2b8d70239d97f","modified":1635325235503},{"_id":"public/archives/2021/page/3/index.html","hash":"720044dfa568de63c441e5d24375064d379f807a","modified":1635325235503},{"_id":"public/archives/2021/page/4/index.html","hash":"4ac6746feec28357c880b6bba4e9f7c4523755db","modified":1635325235503},{"_id":"public/archives/2021/page/5/index.html","hash":"12902b4a4e9437be92c6fd78b3ae9db891e7f4a0","modified":1635325235503},{"_id":"public/archives/2021/05/index.html","hash":"6fb8cbcc27adab9c4901c350e8b03b2af1d650cc","modified":1635325235503},{"_id":"public/archives/2021/06/index.html","hash":"256f4d70c8c50c1e07b699aefe0b30b7fd5bd999","modified":1635325235503},{"_id":"public/archives/2021/06/page/2/index.html","hash":"b7162eb2006aef0b1a4edb9dfe7da7a5211901bb","modified":1635325235503},{"_id":"public/archives/2021/06/page/3/index.html","hash":"9faa217ce75a9df0e8179bb07b1d8add9e72c3ef","modified":1635325235503},{"_id":"public/archives/2021/07/index.html","hash":"9df790dedb5566328e6d6c588d9d180ecf5f909a","modified":1635325235503},{"_id":"public/archives/2021/08/index.html","hash":"6b02b9fe52bccb3e7978d9e28598d30c61413565","modified":1635325235503},{"_id":"public/archives/2021/08/page/2/index.html","hash":"5ec5857c7d702dd730c10c8fc0e5d0e53b60a9a3","modified":1635325235503},{"_id":"public/archives/2021/09/index.html","hash":"78fd213770f91f4bd68be5733978af9ee4fda25f","modified":1635325235503},{"_id":"public/archives/2021/10/index.html","hash":"1165415ec635c1caff4acc9f174802d5545eb86f","modified":1635325235503},{"_id":"public/categories/MD/index.html","hash":"423966437605b867b8b29fe812581c5b5ae9eb34","modified":1635325235503},{"_id":"public/categories/DDD/index.html","hash":"bcdbad081f9f35eb3e73b0c6512690df7f1adcd8","modified":1635325235503},{"_id":"public/categories/es/index.html","hash":"1731485b12bf398ca3976d2166626874988e62bc","modified":1635325235503},{"_id":"public/categories/spring/index.html","hash":"68726ae0a4e45f7ff8a302361f05a94dde2b3857","modified":1635325235503},{"_id":"public/categories/设计模式/index.html","hash":"5d7ce2b69b5c7dabb0f12a74d859245c5ce6cc87","modified":1635325235503},{"_id":"public/categories/ory-Dubbo/index.html","hash":"0159c365bc648fde1d850332cbab9f8e4fc611b4","modified":1635325235503},{"_id":"public/categories/并发编程/index.html","hash":"295914671ab4d3e14847a6d62b7a81ec7405d348","modified":1635325235503},{"_id":"public/categories/ory-Hexo/index.html","hash":"d27a49b85f04a9d2d560d92f1a077ee423c41a31","modified":1635325235503},{"_id":"public/categories/ory-HTTP-客户端/index.html","hash":"7dd1c41105d998bd395679af57c5108e3d81e5f3","modified":1635325235503},{"_id":"public/categories/ory-Elastic-Job/index.html","hash":"fe4b5ba85eec301adcabdf7f291e52c5aa181777","modified":1635325235503},{"_id":"public/categories/ory-Java/index.html","hash":"ff3da74a1fb53bf21777c01fddef234899f890fd","modified":1635325235503},{"_id":"public/categories/ory-MQ/index.html","hash":"ef731e1cdd2b2a254f6c67c7d56abec6a2f174da","modified":1635325235503},{"_id":"public/categories/ory-MQ/page/2/index.html","hash":"b27043676509cb5b1be48c05c447241c72bbfe67","modified":1635325235503},{"_id":"public/categories/Markdown/index.html","hash":"815fb25685dfdf78964cfa1a6cf974e9d3f59643","modified":1635325235503},{"_id":"public/categories/ory-MySQL/index.html","hash":"13479ae5dbda8509101334ec823c4b6ba73430a2","modified":1635325235503},{"_id":"public/categories/ory-Nginx/index.html","hash":"6b16b6059e0e031e8a09c78531961538223c577e","modified":1635325235503},{"_id":"public/categories/ory-Redis/index.html","hash":"1fd8c8eee0e330e0bd9c923b2a7351c357bc928b","modified":1635325235503},{"_id":"public/categories/ory-分布式session/index.html","hash":"bdf2a78f7b1dc9c5c14ede0ee667fa18ee6f1a55","modified":1635325235503},{"_id":"public/categories/ory-链路追踪/index.html","hash":"79d161d6a07b139c5b02f79692bce4fd0c1a1835","modified":1635325235503},{"_id":"public/categories/ory-ShardingSphere/index.html","hash":"29ce4f6f7e29e954f237a28b8614f8a5188d341e","modified":1635325235503},{"_id":"public/categories/ory-MyCat/index.html","hash":"a11c27219da0891be0996f8977a282fa31ca1fc1","modified":1635325235503},{"_id":"public/page/6/index.html","hash":"eef627e301ba749caf2f8cfc53eec08e4b3966b3","modified":1635325235503},{"_id":"public/tags/Markdown/index.html","hash":"ae72f3060a08ce55fc2ad324bf7a0963f7efac31","modified":1635325235503},{"_id":"public/tags/DDD/index.html","hash":"adcf66452f21d18b96d834f8e772233d4e544d2a","modified":1635325235503},{"_id":"public/tags/es/index.html","hash":"994fc9bf02ee71c5ddb4555ba329a505e26ce9d1","modified":1635325235503},{"_id":"public/tags/spring/index.html","hash":"e236274775e899760a9c3f042a6f8ddf9cc418e9","modified":1635325235503},{"_id":"public/tags/设计模式/index.html","hash":"e60cfe591410cc8335fced2a04bb003e8ba22cc1","modified":1635325235503},{"_id":"public/tags/Dubbo/index.html","hash":"c3120f6d8625ff5a533fff8d1bc093f33916f3fa","modified":1635325235503},{"_id":"public/tags/分布式/index.html","hash":"e6a55da3be605479f4c3ccb05c34b06a220ab65b","modified":1635325235503},{"_id":"public/tags/面试/index.html","hash":"e1cbe5674a5f82ba3ac4c962dd3d50e7b2d6d1f4","modified":1635325235503},{"_id":"public/tags/并发编程/index.html","hash":"3fadc61060607d813661b2eca44a23dffb37e373","modified":1635325235503},{"_id":"public/tags/Hexo/index.html","hash":"57aec348ad48dd8b9266d13bef8a0fb364bdc461","modified":1635325235503},{"_id":"public/tags/Feign/index.html","hash":"cc61c40d90db3369a07bc44758b2cd44205fedad","modified":1635325235503},{"_id":"public/tags/java/index.html","hash":"8fa88a92aba363d7b8fe7e45fd53ab5d54a02f46","modified":1635325235503},{"_id":"public/tags/MQ/index.html","hash":"e0f0979c36ae1abba5f79589769037262070449b","modified":1635325235503},{"_id":"public/tags/MQ/page/2/index.html","hash":"c0bf3eae73a93dbc071fc2f3ed1c71179c2ee1b5","modified":1635325235503},{"_id":"public/tags/中间件/index.html","hash":"3545ec61749fc7257d00ed53ab73108b1752bb40","modified":1635325235503},{"_id":"public/tags/中间件/page/2/index.html","hash":"ceb15435d682de48f235d24dffebd1c973e6d35f","modified":1635325235503},{"_id":"public/tags/中间件/page/3/index.html","hash":"9e759e28eda12d8aaa2936d8b9ab6b03e25e5e53","modified":1635325235503},{"_id":"public/tags/MySQL/index.html","hash":"a02387a4d5adbb6fbcac0b59cbf6e5ab512bca96","modified":1635325235503},{"_id":"public/tags/数据库/index.html","hash":"c59c4c8a3f001bccd4d726a3c62da3d26446a8a2","modified":1635325235503},{"_id":"public/tags/Nginx/index.html","hash":"3db867a8eafe8747cd91d0a7795342f2bd82efd7","modified":1635325235503},{"_id":"public/tags/Redis/index.html","hash":"2f176162e52003cb43984a494e162466268b94df","modified":1635325235503},{"_id":"public/tags/分布式session/index.html","hash":"b42cb70a60649f78d123b32d8704d4ca113bcca9","modified":1635325235503},{"_id":"public/tags/链路追踪/index.html","hash":"2c3461ca5b08407ec5b98ecdfb4bc2de58901c6a","modified":1635325235503},{"_id":"public/tags/RabbitMQ/index.html","hash":"4a702313d71e00bf6a95f43be7220959f679567b","modified":1635325235503},{"_id":"public/tags/ShardingSphere/index.html","hash":"c377593299be83f7f718ede6909f42175785cdef","modified":1635325235503},{"_id":"public/tags/MyCat/index.html","hash":"7e3c3d00f0014b764ecdd77b895ff66d1bec7303","modified":1635325235503},{"_id":"public/2021/10/26/oyr/MQ/RabbitMQ/RabbitMQ-应用问题/index.html","hash":"d95e81b29b95d6ac3ba039048fbbb7b8451597cc","modified":1635325235503},{"_id":"public/2021/10/25/lh/elasticsearch/es-初识搜索引擎/index.html","hash":"87e14f51ba1404f99db810b09cffc8ccb3b705d0","modified":1635325235503},{"_id":"public/2021/10/22/lh/elasticsearch/es分布式架构/index.html","hash":"f973246cf71ade9b45f24856b8e66cdc5c485615","modified":1635325235503},{"_id":"public/2021/09/18/lh/elasticsearch/es-初级应用/index.html","hash":"df1fb90d69757367232584cfbc3ff6f1517eae5a","modified":1635325235503},{"_id":"public/2021/09/17/lh/elasticsearch/es初讲/index.html","hash":"d373aff770e32d1c1568d01642b68ef14d3a780a","modified":1635325235503},{"_id":"public/2021/09/10/oyr/MQ/RabbitMQ/RabbitMQ-SpringBoot整合/index.html","hash":"24f25403c243f96a97a6064ed9265232f96dbe3f","modified":1635325235503},{"_id":"public/2021/09/10/oyr/MQ/RabbitMQ/RabbitMQ-Spring整合/index.html","hash":"be217ac0bf60249c9c3086429f7c100ec2baea98","modified":1635325235503},{"_id":"public/2021/08/31/lh/spring/注解编程/index.html","hash":"f8c0bf13e2b0d25fbdd59b0fce163e30a75016e8","modified":1635325235503},{"_id":"public/2021/08/30/lh/并发编程/线程池/index.html","hash":"ebac7e492114a2bde39a54ab885892eb1b56a96a","modified":1635325235503},{"_id":"public/2021/08/30/lh/并发编程/锁相关/index.html","hash":"2420fd49166e13f831d653064086a0a11b937d56","modified":1635325235503},{"_id":"public/2021/08/27/lh/并发编程/AQS/index.html","hash":"4ead9f34664b8a07cd3a7dff904703c594be72f4","modified":1635325235503},{"_id":"public/2021/08/13/oyr/MQ/RabbitMQ/RabbitMQ-高级/index.html","hash":"9fed620d854fb7bd6fe66e22aad73ea6403b0348","modified":1635325235503},{"_id":"public/2021/08/11/lh/并发编程/CAS/index.html","hash":"519127a9415e488fbdf0b89b46088c768c59c127","modified":1635325235503},{"_id":"public/2021/08/10/lh/并发编程/并发编程初讲/index.html","hash":"534cb9e2147ac20f3da6dc371eb3815ceef0ac29","modified":1635325235503},{"_id":"public/2021/08/10/lh/并发编程/volatile/index.html","hash":"e3cb2af21f5dc9990e6bcb74a8f7adfc711e9696","modified":1635325235503},{"_id":"public/2021/08/05/oyr/Dubbo/Dubbo-整合Hystrix/index.html","hash":"1c8aa855f82561de5d2c14cd08efe2c6e3fb81bf","modified":1635325235503},{"_id":"public/2021/08/04/oyr/Dubbo/Dubbo-面试题/index.html","hash":"b78d6bee47aad8e8615d7a36c25948ab5ebaf599","modified":1635325235503},{"_id":"public/2021/07/27/lh/设计模式/设计模式初讲/index.html","hash":"fab3f17e642ccd88538661c1a36d97b5cce253ae","modified":1635325235503},{"_id":"public/2021/07/13/oyr/MQ/RabbitMQ/RabbitMQ-基础/index.html","hash":"bce75a5809b9b7a9b6047580102cbe893fe7d1ca","modified":1635325235503},{"_id":"public/2021/07/12/demo/MD/index.html","hash":"62126b402ce4a70b2b6eb0c8f0f8a75f7f549593","modified":1635325235503},{"_id":"public/2021/07/08/oyr/Dubbo/Dubbo-高级/index.html","hash":"cb1277de7c6c71b597c6ca16f4463132c4285ed4","modified":1635325235503},{"_id":"public/2021/06/25/oyr/Dubbo/Dubbo-基础/index.html","hash":"d58aeebe4cda04be3a35f42c8092c92bd6ab5582","modified":1635325235503},{"_id":"public/2021/06/23/oyr/MySQL/MySQL-事务日志/index.html","hash":"906368e1891bff5bb63f575dc11d0b69524856f0","modified":1635325235503},{"_id":"public/2021/06/22/oyr/MySQL/MySQL-日志系统/index.html","hash":"1c8a4a88bd175f07b67bd7e530438c6084e682f8","modified":1635325235503},{"_id":"public/2021/06/21/oyr/MQ/AMQP/index.html","hash":"73eb892544a76e63a20dc43b3c856ad8b25214a5","modified":1635325235503},{"_id":"public/2021/06/21/oyr/Redis/Redis-数据过期策略/index.html","hash":"277ffc0589e16cc94e3817d1f2ef4136c28f1d52","modified":1635325235503},{"_id":"public/2021/06/20/oyr/Feign/Feign/index.html","hash":"0094c1baa2f6ba0febe3541e211513e8c9b084d3","modified":1635325235503},{"_id":"public/2021/06/20/oyr/Java/Java8新特性/index.html","hash":"e527341c3be3f5eeccf7717f25d31b4b93fb05cd","modified":1635325235503},{"_id":"public/2021/06/20/oyr/MySQL/MySQL-基础/index.html","hash":"0a29aa1dc92e693b35e657d60c090a32a24522df","modified":1635325235503},{"_id":"public/2021/06/20/oyr/Redis/Redis-穿透&雪崩&击穿/index.html","hash":"ad3771bbda2cf493237b1761bd83db3e05c165cb","modified":1635325235503},{"_id":"public/2021/06/16/oyr/MQ/ActiveMQ/index.html","hash":"a7ece480ce7390bc1eb54355de79230dc8cefbaf","modified":1635325235503},{"_id":"public/2021/06/15/oyr/MQ/JMS/index.html","hash":"0acb2ec7f587ba51d7684d3056d4729d8a2714bc","modified":1635325235503},{"_id":"public/2021/06/10/oyr/MQ/消息中间件入门与简介/index.html","hash":"5c09cc027e42421a74262d8f04b421c6e0a5f859","modified":1635325235503},{"_id":"public/2021/05/01/oyr/Markdown/Markdown语法/index.html","hash":"2a9213323f686696ac81a24b3eb3eb150656f393","modified":1635325235503},{"_id":"public/2020/06/20/oyr/Redis/Redis-基础/index.html","hash":"dc8613a907428380ff9d26327b5200f93c19b0fa","modified":1635325235503},{"_id":"public/index.html","hash":"5977c21c08c29c383337e1c521271415d3ffe5bf","modified":1635325235503},{"_id":"public/page/2/index.html","hash":"4f04694871b0f7774eefda59eb8489246dc374b9","modified":1635325235503},{"_id":"public/page/3/index.html","hash":"5b53c013d3883f30fd6cec6d60ffee66a2a9d69c","modified":1635325235503},{"_id":"public/page/4/index.html","hash":"236bd65e6d53d0fa17da57547906c4dc8c860aeb","modified":1635325235503},{"_id":"public/page/5/index.html","hash":"64eac2f5cc10e2296ddf045afe2e98297c0ebb4a","modified":1635325235503},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1635325235503},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1635325235503},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1635325235503},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1635325235503},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1635325235503},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1635325235503},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1635325235503},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1635325235503},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1635325235503},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1635325235503},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1635325235503},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1635325235503},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1635325235503},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1635325235503},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1635325235503},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1635325235503},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1635325235503},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1635325235503},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1635325235503},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1635325235503},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1635325235503},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1635325235503},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1635325235503},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1635325235503},{"_id":"public/js/utils.js","hash":"0343eb03ed76c0b030f7807b82a00772135ba463","modified":1635325235503},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1635325235503},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1635325235503},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1635325235503},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1635325235503},{"_id":"public/css/main.css","hash":"e9a617b36929cc3b98dbc3cb6ee739f7871531ec","modified":1635325235503},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1635325235503},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1635325235503},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1635325235503},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1635325235503},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1635325235503}],"Category":[{"name":"MD","_id":"ckv9af8610004cst75dizaxdv"},{"name":"DDD","_id":"ckv9af864000acst7ducadx2i"},{"name":"es","_id":"ckv9af865000gcst74ty512on"},{"name":"spring","_id":"ckv9af86d0013cst7aq69b77n"},{"name":"设计模式","_id":"ckv9af86f001acst73bq77dn3"},{"name":"ory-Dubbo","_id":"ckv9af86g001hcst72crfckci"},{"name":"并发编程","_id":"ckv9af86m0023cst7gx5b9870"},{"name":"ory-Hexo","_id":"ckv9af86u0033cst7glzp3ub0"},{"name":"ory-HTTP 客户端","_id":"ckv9af86v003bcst72ofh1md9"},{"name":"ory-Elastic-Job","_id":"ckv9af86v003fcst7df62cufh"},{"name":"ory-Java","_id":"ckv9af86w003kcst71ktk679e"},{"name":"ory-MQ","_id":"ckv9af86w003ocst73x4g0hy0"},{"name":"Markdown","_id":"ckv9af86y0046cst78t1mdsk0"},{"name":"ory-MySQL","_id":"ckv9af86z004bcst7cr9sbwp4"},{"name":"ory-Nginx","_id":"ckv9af86z004ecst7a3d6g0x1"},{"name":"ory-Redis","_id":"ckv9af871004ucst75g07hgdn"},{"name":"ory-分布式session","_id":"ckv9af874005acst72oz3fb7m"},{"name":"ory-链路追踪","_id":"ckv9af87d006rcst79av7hwvs"},{"name":"ory-ShardingSphere","_id":"ckv9af87s0078cst774o2dosw"},{"name":"ory-MyCat","_id":"ckv9af87u007mcst7fvpadj6y"}],"Data":[],"Page":[{"title":"关于","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ntype: \"about\"\n---\n","date":"2021-07-13T06:36:39.572Z","updated":"2021-07-12T10:31:44.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckv9af85v0000cst75i3dboei","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\n---\n","date":"2021-07-13T06:36:39.574Z","updated":"2021-07-12T10:31:44.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckv9af85z0002cst75dyb0k54","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\n---\n","date":"2021-07-13T06:36:39.574Z","updated":"2021-07-12T10:31:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckv9af8620006cst7fz227pc3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown 菜鸟教程","date":"2021-07-11T16:00:00.000Z","author":"lh","summary":"","_content":"\n# Markdown 描述 \nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n# Markdown 实操\n\n我展示的是一级标题\n================\n\n我展示的是二级标题\n----------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 。。。。\n\n## Markdown 段落\n段落换行是已 两个或以上空格+回车即可  \n开始新的一个段落\n\n## Markdown 字体  \n*斜体文本*  \n_斜体文本_ \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___  \n\n## 分隔线  \n可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  \n***  \n* * *  \n******  \n- - -  \n---------\n\n## 删除线  \n段落需要添加删除线 在文本两端添加 两个波浪线即可  \n~~当前版本1.0~~  \n\n## 下划线  \n使用与html相同的标签 u\n<u>下划线文本</u> \n\n## 脚注  \n脚注是对文本的补充说明  \n有一个 [234]\n\n\n[234]: 1231231233  \n\n## Markdown 列表  \n无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  \n* 第一列\n+ 第二列\n- 第三列   \n\n有序列表 \n\n","source":"_posts/demo/MD.md","raw":"---\ntitle: Markdown 菜鸟教程\ndate: 2021-07-12 00:00:00\nauthor: lh\nsummary: \"\"\ntags: Markdown\ncategories: MD\n---\n\n# Markdown 描述 \nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n# Markdown 实操\n\n我展示的是一级标题\n================\n\n我展示的是二级标题\n----------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 。。。。\n\n## Markdown 段落\n段落换行是已 两个或以上空格+回车即可  \n开始新的一个段落\n\n## Markdown 字体  \n*斜体文本*  \n_斜体文本_ \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___  \n\n## 分隔线  \n可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  \n***  \n* * *  \n******  \n- - -  \n---------\n\n## 删除线  \n段落需要添加删除线 在文本两端添加 两个波浪线即可  \n~~当前版本1.0~~  \n\n## 下划线  \n使用与html相同的标签 u\n<u>下划线文本</u> \n\n## 脚注  \n脚注是对文本的补充说明  \n有一个 [234]\n\n\n[234]: 1231231233  \n\n## Markdown 列表  \n无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  \n* 第一列\n+ 第二列\n- 第三列   \n\n有序列表 \n\n","slug":"demo/MD","published":1,"updated":"2021-07-13T07:14:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af85x0001cst7cro6hcuw","content":"<h1 id=\"Markdown-描述\"><a href=\"#Markdown-描述\" class=\"headerlink\" title=\"Markdown 描述\"></a>Markdown 描述</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 .md, .markdown。</p>\n<h1 id=\"Markdown-实操\"><a href=\"#Markdown-实操\" class=\"headerlink\" title=\"Markdown 实操\"></a>Markdown 实操</h1><h1 id=\"我展示的是一级标题\"><a href=\"#我展示的是一级标题\" class=\"headerlink\" title=\"我展示的是一级标题\"></a>我展示的是一级标题</h1><h2 id=\"我展示的是二级标题\"><a href=\"#我展示的是二级标题\" class=\"headerlink\" title=\"我展示的是二级标题\"></a>我展示的是二级标题</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"。。。。\"><a href=\"#。。。。\" class=\"headerlink\" title=\"。。。。\"></a>。。。。</h5><h2 id=\"Markdown-段落\"><a href=\"#Markdown-段落\" class=\"headerlink\" title=\"Markdown 段落\"></a>Markdown 段落</h2><p>段落换行是已 两个或以上空格+回车即可<br>开始新的一个段落</p>\n<h2 id=\"Markdown-字体\"><a href=\"#Markdown-字体\" class=\"headerlink\" title=\"Markdown 字体\"></a>Markdown 字体</h2><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em>  </p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  </p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>段落需要添加删除线 在文本两端添加 两个波浪线即可<br><del>当前版本1.0</del>  </p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>使用与html相同的标签 u<br><u>下划线文本</u> </p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明<br>有一个 <a href=\"1231231233\">234</a></p>\n<h2 id=\"Markdown-列表\"><a href=\"#Markdown-列表\" class=\"headerlink\" title=\"Markdown 列表\"></a>Markdown 列表</h2><p>无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  </p>\n<ul>\n<li>第一列</li>\n</ul>\n<ul>\n<li>第二列</li>\n</ul>\n<ul>\n<li>第三列   </li>\n</ul>\n<p>有序列表 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Markdown-描述\"><a href=\"#Markdown-描述\" class=\"headerlink\" title=\"Markdown 描述\"></a>Markdown 描述</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 .md, .markdown。</p>\n<h1 id=\"Markdown-实操\"><a href=\"#Markdown-实操\" class=\"headerlink\" title=\"Markdown 实操\"></a>Markdown 实操</h1><h1 id=\"我展示的是一级标题\"><a href=\"#我展示的是一级标题\" class=\"headerlink\" title=\"我展示的是一级标题\"></a>我展示的是一级标题</h1><h2 id=\"我展示的是二级标题\"><a href=\"#我展示的是二级标题\" class=\"headerlink\" title=\"我展示的是二级标题\"></a>我展示的是二级标题</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"。。。。\"><a href=\"#。。。。\" class=\"headerlink\" title=\"。。。。\"></a>。。。。</h5><h2 id=\"Markdown-段落\"><a href=\"#Markdown-段落\" class=\"headerlink\" title=\"Markdown 段落\"></a>Markdown 段落</h2><p>段落换行是已 两个或以上空格+回车即可<br>开始新的一个段落</p>\n<h2 id=\"Markdown-字体\"><a href=\"#Markdown-字体\" class=\"headerlink\" title=\"Markdown 字体\"></a>Markdown 字体</h2><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em>  </p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  </p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>段落需要添加删除线 在文本两端添加 两个波浪线即可<br><del>当前版本1.0</del>  </p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>使用与html相同的标签 u<br><u>下划线文本</u> </p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明<br>有一个 <a href=\"1231231233\">234</a></p>\n<h2 id=\"Markdown-列表\"><a href=\"#Markdown-列表\" class=\"headerlink\" title=\"Markdown 列表\"></a>Markdown 列表</h2><p>无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  </p>\n<ul>\n<li>第一列</li>\n</ul>\n<ul>\n<li>第二列</li>\n</ul>\n<ul>\n<li>第三列   </li>\n</ul>\n<p>有序列表 </p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-07-08T09:05:48.553Z","updated":"2021-07-09T08:54:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af8600003cst76lcugfg1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"DDD领域模型初讲","date":"2021-07-26T16:00:00.000Z","author":"lh","summary":"","_content":"# 还在一脸懵逼中。。。","source":"_posts/lh/DDD/DDD领域模型设计.md","raw":"---\ntitle: DDD领域模型初讲\ndate: 2021-07-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: DDD\ntags: \n    - DDD\n---\n# 还在一脸懵逼中。。。","slug":"lh/DDD/DDD领域模型设计","published":1,"updated":"2021-08-10T09:16:11.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af8620007cst72rnrhpaa","content":"<h1 id=\"还在一脸懵逼中。。。\"><a href=\"#还在一脸懵逼中。。。\" class=\"headerlink\" title=\"还在一脸懵逼中。。。\"></a>还在一脸懵逼中。。。</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"还在一脸懵逼中。。。\"><a href=\"#还在一脸懵逼中。。。\" class=\"headerlink\" title=\"还在一脸懵逼中。。。\"></a>还在一脸懵逼中。。。</h1>"},{"title":"es初级应用","date":"2021-09-17T16:00:00.000Z","author":"lh","summary":"","_content":"\n# es 集群健康状态\n## es 查询集群健康状态\n\n  \n```ssh\nGET /_cat/health?v\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488006741 15:12:21  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488007113 15:18:33  elasticsearch green           2         2      2   1    0    0        0             0                  -                100.0%\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488007216 15:20:16  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%\n```\n\n## 集群健康状态 green、yellow、red\n* green：每个索引的primary shard和replica shard都是active状态的\n* yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态\n* red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了\n\n## 为什么会会处于yellow状态？\n比如当前es只有一台服务启动即只有一个node，此时只启动了一个primary shard，而依据es的 容错机制 replica shard 不予 primary shard 同服务，即单机情况下 集群状态为yellow     \n也有当集群环境下 一台机器出现故障 处理正常运行的 primary shard 的 replica shard 恰好在故障服务器上 这时也是会显示yellow\n\n# es 基础操作\n## 查询集群下的 索引\n```ssh\nGET /_cat/indices?v\n\nhealth status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size\nyellow open   student rUm9n9wMRQCCrRDEhqneBg   1   1          1            0      3.1kb          3.1kb\n\n```\n\n## 新建索引\n```ssh\nPUT /student?pretty\n\n```\n\n\n## 删除索引\n```ssh\nDELETE /student?pretty\n\n```\n\n## 索引的 CURD\n* 新建搜索内容 document  \nPUT /index/type/id (这里的id 不添加时，系统会默认一个值)    \n{   \n    \"filed\":\"value\"     \n} // 整个大括号 则为 一个document \n<font color=\"red\">注意:</font> 当PUT作为update操作时，需要将所有filed全部写上，否则全覆盖，一般不建议用于update\n\n```ssh\nPUT /student/class/1\n{\n    \"name\":\"tom\"\n    \"age\":15\n}\n\n//数据下面有用到\nPUT /student/class/2\n{\n    \"name\":\"ajo\"\n    \"age\":20\n}\n\nPUT /student/class/3\n{\n    \"name\":\"jack\"\n    \"age\":25\n}\n```\n\n* 修改搜索内容    \n 通过调用api _update 对指定索引下的字段进行更新\nPOST /index/type/id/_update (这里的id必填)   \n{   \n    \"doc\":{     \n        \"filed\":\"value\" //filed 表示要修改的字段    \n    }     \n} \n\n```ssh\nPUT /student/class/1/_update\n{\n    \"doc\":{\n        \"name\":\"jack\"\n    }\n}\n\n```\n\n\n* 删除指定搜索内容      \n删除索引下的一条记录\n```ssh\nDELETE /student/class/1\n\n```\n\n## es 查询操作相关\n* 查询索引下全部的内容（全文搜索）\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match_all\":{}\n  }\n}\n\n```\n\n* 查询 包含指定关键字        \n这里搜索通过倒排索引 去搜索 如下：name 为tom 则会通过上面已经新增的document 得到一个列表   \n\n|id|doc|     \n|:---:| :---:|     \n|1|tom|\n|2|ajo|\n\n|doc|id|\n|---|---|\n|tom|1|\n|o|1,2|\n\n即返回结果为 document id 为1、2的数据\n\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match\":{\n      \"name\":\"tom\"  \n    }\n  }\n}\n\n```\n\n* phrase search 短语查询    \n跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回\nphrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回\n\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match_phrase\":{\n      \"name\":\"tom\"  \n    }\n  }\n}\n\n```\n\n* 查询条件\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"bool\": {\n      \"filter\": [\n        {\"range\": {\n          \"ago\": {\n            \"gte\": 10,//大于等于\n            \"lte\": 20//小于等于\n          }\n        }}\n      ]\n    }\n  }\n}\n```\n\n* highlight search（高亮搜索结果）\n```ssh\nGET /ecommerce/product/_search\n{\n    \"query\" : {\n        \"match\" : {\n            \"producer\" : \"producer\"\n        }\n    },\n    \"highlight\": {\n        \"fields\" : {\n            \"producer\" : {}\n        }\n    }\n}\n```\n\n## mget批量查询api  \nmget批量查询可以将多个操作合并一个读操作去执行，可以减少网络请求次数，提升系统性能，当然如果请求数据过多，也会在一定程度上影响了影响速度  \nmget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍，非常非常之重要  \n\n* 场景1 不同index下 的查询\n```ssh\nGET /_mget\n{\n   \"docs\" : [\n      {\n         \"_index\" : \"test_index1\",\n         \"_type\" :  \"test_type\",\n         \"_id\" :    1\n      },\n      {\n         \"_index\" : \"test_index2\",\n         \"_type\" :  \"test_type\",\n         \"_id\" :    2\n      }\n   ]\n}\n```\n\n* 场景2 同一index下 的查询\n```ssh\nGET /test_index/type/_mget\n{\n   \"ids\": [1, 2]\n}\n```\n\n## 批量写操作 _bulk \nbulk api对json的语法有严格要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行，bulk 的语法格式如下\n```ssh\n{\"action\": {\"metadata\"}}\n{\"data\"}\n```\n\nbulk 主要支持一下类型的操作：\n* delete: 删除一个文档，只要1个json串就可以了\n* create: PUT /index/type/id/_create，强制创建\n* index：普通的put操作，可以是创建文档，也可以是全量替换文档\n* update：执行的partial update操作\n\n```ssh\nPOST /_bulk\n{ \"delete\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"3\" }} \n{ \"create\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"12\" }}\n{ \"test_field\":    \"test12\" }\n{ \"index\":  { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"2\" }}\n{ \"test_field\":    \"replaced test2\" }\n{ \"update\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"1\", \"_retry_on_conflict\" : 3} }\n{ \"doc\" : {\"test_field2\" : \"bulk test1\"} }\n```\n\n### bulk 操作出现异常\nbulk操作中，任意一个操作失败，是不会影响其他的操作，但是会在返回的结果里面告诉异常日志  \n\n### bulk 性能\nbulk request会加载到内存里，如果太大的话，性能反而会下降，需要反复尝试得出一个最佳的bulk size，一般从1000-5000条数据开始，尝试逐渐增加  \n如果看大小的话，最好控制在5~15MB之间\n\n## 分页查询\n分页主要有两个参数  \n    size：每一页多少条数据 \n    from：表示从第多少条开始分页 <font color=red>起始页为0</font> 为0 与不传from 单传size效果一致\n    \n请求方式主要有：\n```shell script\nGET _search?size=2\nGET _search?size=2&from=0 # 返回结果与第一条执行结果一致\nGET _search?size=2&from=2\n```\n\n### deep paging 问题\n集群环境下，当查询的目标数据很多，比如超过几十万甚至几百万数据时，这个时候进行分页，这个时候:\n* step1 client 分页请求 如 _search?size=1000&from=1000000  到 coordinate node ,节点会找到该查询多个对应的shard（假设3shard）\n* step2 请求到达对应的shard 开始执行分页操作 _search?size=1000&from=1000000 取1000条数据 并返回给coordinate node\n* step3 coordinate收到shard返回的总数据条数为3000条，这个时候开始做重排序，默认是<font color=red>通过相关度分数排序</font>,取前1000条数据返回给client \n\ndeep paging问题 其实是一个深度查询的问题，如涉及分页查询较深时且数据较大时，非常消耗网络带宽，消耗内存，所以存在性能问题，应尽量避免 deep paging操作\n\n# 多种搜索方式\n## query string search\nquery string search的由来：\n因为search参数都是以http请求的query string来附带的。\n注意，这个查询在生产环境上使用的是不多的。\n\n（1）搜索所有的商品：\n```\nGET /sell/product/_search\n返回值：\n{\n  \"took\": 12,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 1,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"oyr yaogao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"latiao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n返回值说明：\ntook：耗费了多少毫秒\ntimed_out：是否超时，这里是没有\n_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也是可以）\nhits.total：查询结果的数量，3个document\nhits.max_score:score的含义：就是document对应一个search的相关度的匹配分数，越相关，就越匹配，分数也越高。这里显示的是最大的一个匹配分数\nhits.hits：包含了匹配搜索的document的详细数据\n\n（2）搜索商品名称中包含yagao的商品，而且按照售价降序排序\n```\nGET /sell/product/_search?q=name:yagao&sort=price:desc\n返回值：\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": null,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        },\n        \"sort\": [\n          3000\n        ]\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        },\n        \"sort\": [\n          30\n        ]\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"latiao yagao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        },\n        \"sort\": [\n          15\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n## query DSL\nDSL：Domain Specified Language，特定领域的语言\n参数是放在http request body中的。\nhttp request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了\n\n（1）查询所有的商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n（2）查询名称包含yagao的商品，同时按照价格降序排序\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  }\n  , \"sort\": [\n    {\n      \"price\": \"desc\"\n    }\n  ]\n}\n或\n\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  },\n  \"sort\": [\n    {\n      \"price\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}\n```\n\n（3）分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 1, // 从第一条开始查,并不包含第一条\n  \"size\": 1 // 查一条数据\n}\n```\n\n（4）指定要查询出来商品的名称和价格就可以，也就是具体要显示哪些field。\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"_source\": [\"name\", \"price\"]\n}\n```\n\n## query filter\n\n（1）搜索商品名称包含yagao，而且售价大于25元的商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": {\n        \"match\": {\n          \"name\": \"yagao\"\n        }\n      },\n      \"filter\": {\n        \"range\": {\n          \"price\": {\n            \"gt\": 25\n          }\n        }\n      }\n    }\n  }\n}\n```\n## full-text search\n全文检索\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"producer\": \"oyr yagao producer\"\n    }\n  }\n}\n```\nproducer这个字段，会先被分词拆解\nyagao\nproducer\n然后一个个去匹配文档中producer对应的倒排索引\n```\n返回值：\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0.7594807,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 0.7594807,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": 0.5063205,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": 0.5063205,\n        \"_source\": {\n          \"name\": \"latiao yagao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n\n## phrase search\n短语搜索\n跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回\nphrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_phrase\": {\n      \"producer\": \"oyr yagao producer\"\n    }\n  }\n}\n返回值：\n{\n  \"took\": 15,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 1,\n    \"max_score\": 0.7594808,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 0.7594808,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n\n## 聚合查询\n\n（1）计算每个tag下的商品数量\n先将文本field的fielddata属性设置为true，不然执行聚合查询会报错。\n```\nPUT /sell/_mapping/product\n{\n  \"properties\": {\n    \"tags\":{\n      \"type\": \"text\",\n      \"fielddata\": true\n    }\n  }\n}\n\n查询：\nGET /sell/product/_search\n{\n  \"size\": 0, \n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*) from product group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n```\n\n（2）对名称中包含yagao的商品，计算每个tag下的商品数量\n```\nGET /sell/product/_search\n{\n  \"size\": 0, \n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  }, \n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*) from product where name='yagao' group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n```\n\n（3）先分组，再算每组的平均值，计算每个tag下的商品的平均价格\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      },\n      \"aggs\": {\n        \"avg_price\": {\n          \"avg\": {\"field\": \"price\"}\n        }\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*), avg(price) from product group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1515\n          }\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1507.5\n          }\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1,\n          \"avg_price\": {\n            \"value\": 30\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n（4）计算每个tag下的商品的平均价格，并且按照平均价格降序排序\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\",\n        \"order\": {\n          \"avg_price\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"avg_price\": {\n          \"avg\": {\"field\": \"price\"}\n        }\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*), avg(price) as avg_price from product group by tags order by avg_price\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1515\n          }\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1507.5\n          }\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1,\n          \"avg_price\": {\n            \"value\": 30\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n（5）按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_price\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"ranges\": [\n          {\n            \"from\": 0,\n            \"to\": 20\n          },\n          {\n            \"from\": 20,\n            \"to\": 10000\n          }\n        ]\n      },\n      \"aggs\": {\n        \"group_by_tags\": {\n          \"terms\": {\n            \"field\": \"tags\"\n          },\n          \"aggs\": {\n            \"avg_price\": {\n              \"avg\": {\n                \"field\": \"price\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n返回值：\n```\n{\n  \"took\": 3,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_price\": {\n      \"buckets\": [\n        {\n          \"key\": \"0.0-20.0\",\n          \"from\": 0,\n          \"to\": 20,\n          \"doc_count\": 1,\n          \"group_by_tags\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              {\n                \"key\": \"meiwei\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 15\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"key\": \"20.0-10000.0\",\n          \"from\": 20,\n          \"to\": 10000,\n          \"doc_count\": 2,\n          \"group_by_tags\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              {\n                \"key\": \"meibai\",\n                \"doc_count\": 2,\n                \"avg_price\": {\n                  \"value\": 1515\n                }\n              },\n              {\n                \"key\": \"fangzhu\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 30\n                }\n              },\n              {\n                \"key\": \"meiwei\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 3000\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n## filter 与 query的深入比较\n### filter与query示例\n```shell script\nPUT /company/employee/2\n{\n  \"address\": {\n    \"country\": \"china\",\n    \"province\": \"jiangsu\",\n    \"city\": \"nanjing\"\n  },\n  \"name\": \"tom\",\n  \"age\": 30,\n  \"join_date\": \"2016-01-01\"\n}\n\nPUT /company/employee/3\n{\n  \"address\": {\n    \"country\": \"china\",\n    \"province\": \"shanxi\",\n    \"city\": \"xian\"\n  },\n  \"name\": \"marry\",\n  \"age\": 35,\n  \"join_date\": \"2015-01-01\"\n}\n\n#搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01\nGET /company/employee/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match\": {\n            \"join_date\": \"2016-01-01\"\n          }\n        }\n      ],\n      \"filter\": {\n        \"range\": {\n          \"age\": {\n            \"gte\": 30\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n### filter 与 query对比 \n* filter: 仅仅只是按搜索条件过滤出所需要的数据而已，不涉及相关度分数的计算，对相关度没有影响\n* query： 会去计算每个document相对搜索条件的相关度，并按相关度进行排序\n\n总结： \n* 如果是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query。\n* 如果只是想根据搜索条件筛选出一部分数据，那么用filter\n* 如果需要将符合条件的document排名靠前，用query包含，如果想其他的条件不影响到前面的document排序则用filter过滤\n\n### filter与query性能\n* filter： 不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据\n* query： 相反，要计算相关度分数，按照分数进行排序，而且无法cache结果\n\n### 单执行filter需注意\n```shell script\n# 参数 constant_score 必传 否则会出现异常\nGET /student/class/_search \n{\n  \"query\": {\n    \"constant_score\": {\n      \"filter\": {\n        \"range\": {\n          \"mark\": {\n            \"gte\": 30\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 几种query的搜索语法\n### match all \n    查询所有\n```shell script\n#查询所有index的内容\nGET /_search\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n```\n```shell script\n#查询指定index下的所有内容\nGET student/class/_search\n{\n  \"query\":{\n    \"match_all\": {}\n  }\n}\n```\n### match\n    匹配某一个filed是否包含某个文本，会触发分词，相当于是 full text(全文检索)\n```shell script\n# 查询所有index 指定field是否包含查询内容\nGET /_search\n{\n  \"query\":{\n    \"match\": {\n      \"title\": \"学习\"\n    }\n  }\n}\n```\n```shell script\n# 查询指定index 指定field是否包含查询内容\nGET student/class/_search\n{\n  \"query\":{\n    \"match\": {\n      \"title\": \"学习\"\n    }\n  }\n}\n```\n\n### multi match\n    查询多个field是否包含查询内容\n```shell script\n# 查询所有index 指定的fields下是否包含查询内容\nGET /_search\n{\n  \"query\":{\n    \"multi_match\":{\n      \"query\":\"学习\",\n      \"fields\":[\"title\",\"desc\"]\n    }\n  }\n}\n```\n```shell script\n# 查询指定index 指定的fields下是否包含查询内容\nGET student/class/_search\n{\n  \"query\":{\n    \"multi_match\":{\n      \"query\":\"学习\",\n      \"fields\":[\"title\",\"desc\"]\n    }\n  }\n}\n\n```\n    \n### range query\n    查询field是否在指定的范围值内，放query里会对相关度产生影响，放filter里面无影响\n```shell script\n# 查询所有index 指定的field是否在查询内容范围内\nGET /_search\n{\n  \"query\":{\n    \"range\":{\n      \"mark\":{\n        #\"gt\":80, 大于\n        #\"lt\":120 小于\n        \"gte\":80, #大于等于\n        \"lte\":120 #小于等于\n\n      }\n    }\n  }\n}\n```\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"range\":{\n      \"mark\":{\"gte\":80}\n    }\n  }\n}\n```\n\n### term query\n   把查询的数据当成 exact value（精准匹配）进行查询。  \n   这里查询的内容是要精准匹配field内容  \n   需要建立索引的时候，指定<font color=red>field不分词</font>才能查询到  \n   或者field已经是<font color=red>最小分词单位</font>\n```shell script\nGET /_search\n{\n  \"query\":{\n    \"term\": {\n      \"name\": \"八\"\n    }\n  }\n}\n```\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"term\": {\n      \"name\": \"八\"\n    }\n  }\n}\n```\n\n### terms query\n    原理与term一致，不过对指定的field可以查询指定多个搜索词\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"terms\": {\n      \"name\": [\"八\",\"九\"]\n    }\n  }\n}\n```\n\n## 组合查询\n参数 bool 多条件组合查询参数，bool中可以使用 must、 must_not 、should 来组合查询条件 ,bool 可嵌套  \n一下参数在与match、multi match、term、terms一起使用时注意查询方式是exact value or full value \n* must: 需要满足条件 ==或like\n* must_not: 不需要在满足条件内的 !=或 not like\n* should: should中的两个条件至少满足一个就可以,should下有多个条件时注意加参数 minimum_should_match\n* filter\n\n```shell script\n# 查询学习成绩在30~100的学生信息，成绩倒叙，备注含学习,李四作弊取消成绩\nGET student/class/_search?sort=mark:desc\n{\n  \"query\":{\n    \"bool\": {\n     \"must_not\": [\n       {\"match\": {\n         \"name\": \"李四\"\n       }}\n     ],\n     \"minimum_should_match\":2, # should下满足几个条件\n     \"should\": [\n      {\"match\":{\"title\":\"委员\"}}\n      ,\n      {\"match\":{\"desc\":\"突出\"}}\n     ], \n      \"filter\": {\n        \"bool\": {\n          \"must\":\n          [\n            {\"range\":{\"mark\": {\"gte\":20,\"lte\":100}}},\n            {\"match\":{\"desc\": \"学习\"}}\n          ]\n        }\n        \n      }\n    }\n  }\n}\n```\n\n## 校验不合法的搜索\n特别复杂庞大的搜索下，比如你一下子写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法\n```shell script\n#格式: GET index/type/_validate/query?explain\nGET student/class/_validate/query?explain\n{\n  \"query\":{\n    \"match_all\": {}\n  }\n}\n```\n返回结果\n```shell script\n{\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"failed\" : 0\n  },\n  \"valid\" : true,\n  \"explanations\" : [\n    {\n      \"index\" : \"student\",\n      \"valid\" : true,\n      \"explanation\" : \"+*:* #*:*\"\n    }\n  ]\n}\n```","source":"_posts/lh/elasticsearch/es-初级应用.md","raw":"---\ntitle: es初级应用\ndate: 2021-09-18 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: es\ntags: \n    - es\n---\n\n# es 集群健康状态\n## es 查询集群健康状态\n\n  \n```ssh\nGET /_cat/health?v\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488006741 15:12:21  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488007113 15:18:33  elasticsearch green           2         2      2   1    0    0        0             0                  -                100.0%\n\nepoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent\n1488007216 15:20:16  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%\n```\n\n## 集群健康状态 green、yellow、red\n* green：每个索引的primary shard和replica shard都是active状态的\n* yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态\n* red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了\n\n## 为什么会会处于yellow状态？\n比如当前es只有一台服务启动即只有一个node，此时只启动了一个primary shard，而依据es的 容错机制 replica shard 不予 primary shard 同服务，即单机情况下 集群状态为yellow     \n也有当集群环境下 一台机器出现故障 处理正常运行的 primary shard 的 replica shard 恰好在故障服务器上 这时也是会显示yellow\n\n# es 基础操作\n## 查询集群下的 索引\n```ssh\nGET /_cat/indices?v\n\nhealth status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size\nyellow open   student rUm9n9wMRQCCrRDEhqneBg   1   1          1            0      3.1kb          3.1kb\n\n```\n\n## 新建索引\n```ssh\nPUT /student?pretty\n\n```\n\n\n## 删除索引\n```ssh\nDELETE /student?pretty\n\n```\n\n## 索引的 CURD\n* 新建搜索内容 document  \nPUT /index/type/id (这里的id 不添加时，系统会默认一个值)    \n{   \n    \"filed\":\"value\"     \n} // 整个大括号 则为 一个document \n<font color=\"red\">注意:</font> 当PUT作为update操作时，需要将所有filed全部写上，否则全覆盖，一般不建议用于update\n\n```ssh\nPUT /student/class/1\n{\n    \"name\":\"tom\"\n    \"age\":15\n}\n\n//数据下面有用到\nPUT /student/class/2\n{\n    \"name\":\"ajo\"\n    \"age\":20\n}\n\nPUT /student/class/3\n{\n    \"name\":\"jack\"\n    \"age\":25\n}\n```\n\n* 修改搜索内容    \n 通过调用api _update 对指定索引下的字段进行更新\nPOST /index/type/id/_update (这里的id必填)   \n{   \n    \"doc\":{     \n        \"filed\":\"value\" //filed 表示要修改的字段    \n    }     \n} \n\n```ssh\nPUT /student/class/1/_update\n{\n    \"doc\":{\n        \"name\":\"jack\"\n    }\n}\n\n```\n\n\n* 删除指定搜索内容      \n删除索引下的一条记录\n```ssh\nDELETE /student/class/1\n\n```\n\n## es 查询操作相关\n* 查询索引下全部的内容（全文搜索）\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match_all\":{}\n  }\n}\n\n```\n\n* 查询 包含指定关键字        \n这里搜索通过倒排索引 去搜索 如下：name 为tom 则会通过上面已经新增的document 得到一个列表   \n\n|id|doc|     \n|:---:| :---:|     \n|1|tom|\n|2|ajo|\n\n|doc|id|\n|---|---|\n|tom|1|\n|o|1,2|\n\n即返回结果为 document id 为1、2的数据\n\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match\":{\n      \"name\":\"tom\"  \n    }\n  }\n}\n\n```\n\n* phrase search 短语查询    \n跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回\nphrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回\n\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"match_phrase\":{\n      \"name\":\"tom\"  \n    }\n  }\n}\n\n```\n\n* 查询条件\n```ssh\nGET /student/class/_search\n{\n  \"query\":{\n    \"bool\": {\n      \"filter\": [\n        {\"range\": {\n          \"ago\": {\n            \"gte\": 10,//大于等于\n            \"lte\": 20//小于等于\n          }\n        }}\n      ]\n    }\n  }\n}\n```\n\n* highlight search（高亮搜索结果）\n```ssh\nGET /ecommerce/product/_search\n{\n    \"query\" : {\n        \"match\" : {\n            \"producer\" : \"producer\"\n        }\n    },\n    \"highlight\": {\n        \"fields\" : {\n            \"producer\" : {}\n        }\n    }\n}\n```\n\n## mget批量查询api  \nmget批量查询可以将多个操作合并一个读操作去执行，可以减少网络请求次数，提升系统性能，当然如果请求数据过多，也会在一定程度上影响了影响速度  \nmget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍，非常非常之重要  \n\n* 场景1 不同index下 的查询\n```ssh\nGET /_mget\n{\n   \"docs\" : [\n      {\n         \"_index\" : \"test_index1\",\n         \"_type\" :  \"test_type\",\n         \"_id\" :    1\n      },\n      {\n         \"_index\" : \"test_index2\",\n         \"_type\" :  \"test_type\",\n         \"_id\" :    2\n      }\n   ]\n}\n```\n\n* 场景2 同一index下 的查询\n```ssh\nGET /test_index/type/_mget\n{\n   \"ids\": [1, 2]\n}\n```\n\n## 批量写操作 _bulk \nbulk api对json的语法有严格要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行，bulk 的语法格式如下\n```ssh\n{\"action\": {\"metadata\"}}\n{\"data\"}\n```\n\nbulk 主要支持一下类型的操作：\n* delete: 删除一个文档，只要1个json串就可以了\n* create: PUT /index/type/id/_create，强制创建\n* index：普通的put操作，可以是创建文档，也可以是全量替换文档\n* update：执行的partial update操作\n\n```ssh\nPOST /_bulk\n{ \"delete\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"3\" }} \n{ \"create\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"12\" }}\n{ \"test_field\":    \"test12\" }\n{ \"index\":  { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"2\" }}\n{ \"test_field\":    \"replaced test2\" }\n{ \"update\": { \"_index\": \"test_index\", \"_type\": \"test_type\", \"_id\": \"1\", \"_retry_on_conflict\" : 3} }\n{ \"doc\" : {\"test_field2\" : \"bulk test1\"} }\n```\n\n### bulk 操作出现异常\nbulk操作中，任意一个操作失败，是不会影响其他的操作，但是会在返回的结果里面告诉异常日志  \n\n### bulk 性能\nbulk request会加载到内存里，如果太大的话，性能反而会下降，需要反复尝试得出一个最佳的bulk size，一般从1000-5000条数据开始，尝试逐渐增加  \n如果看大小的话，最好控制在5~15MB之间\n\n## 分页查询\n分页主要有两个参数  \n    size：每一页多少条数据 \n    from：表示从第多少条开始分页 <font color=red>起始页为0</font> 为0 与不传from 单传size效果一致\n    \n请求方式主要有：\n```shell script\nGET _search?size=2\nGET _search?size=2&from=0 # 返回结果与第一条执行结果一致\nGET _search?size=2&from=2\n```\n\n### deep paging 问题\n集群环境下，当查询的目标数据很多，比如超过几十万甚至几百万数据时，这个时候进行分页，这个时候:\n* step1 client 分页请求 如 _search?size=1000&from=1000000  到 coordinate node ,节点会找到该查询多个对应的shard（假设3shard）\n* step2 请求到达对应的shard 开始执行分页操作 _search?size=1000&from=1000000 取1000条数据 并返回给coordinate node\n* step3 coordinate收到shard返回的总数据条数为3000条，这个时候开始做重排序，默认是<font color=red>通过相关度分数排序</font>,取前1000条数据返回给client \n\ndeep paging问题 其实是一个深度查询的问题，如涉及分页查询较深时且数据较大时，非常消耗网络带宽，消耗内存，所以存在性能问题，应尽量避免 deep paging操作\n\n# 多种搜索方式\n## query string search\nquery string search的由来：\n因为search参数都是以http请求的query string来附带的。\n注意，这个查询在生产环境上使用的是不多的。\n\n（1）搜索所有的商品：\n```\nGET /sell/product/_search\n返回值：\n{\n  \"took\": 12,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 1,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"oyr yaogao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": 1,\n        \"_source\": {\n          \"name\": \"latiao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n返回值说明：\ntook：耗费了多少毫秒\ntimed_out：是否超时，这里是没有\n_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也是可以）\nhits.total：查询结果的数量，3个document\nhits.max_score:score的含义：就是document对应一个search的相关度的匹配分数，越相关，就越匹配，分数也越高。这里显示的是最大的一个匹配分数\nhits.hits：包含了匹配搜索的document的详细数据\n\n（2）搜索商品名称中包含yagao的商品，而且按照售价降序排序\n```\nGET /sell/product/_search?q=name:yagao&sort=price:desc\n返回值：\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": null,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        },\n        \"sort\": [\n          3000\n        ]\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        },\n        \"sort\": [\n          30\n        ]\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": null,\n        \"_source\": {\n          \"name\": \"latiao yagao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        },\n        \"sort\": [\n          15\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n## query DSL\nDSL：Domain Specified Language，特定领域的语言\n参数是放在http request body中的。\nhttp request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了\n\n（1）查询所有的商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n（2）查询名称包含yagao的商品，同时按照价格降序排序\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  }\n  , \"sort\": [\n    {\n      \"price\": \"desc\"\n    }\n  ]\n}\n或\n\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  },\n  \"sort\": [\n    {\n      \"price\": {\n        \"order\": \"desc\"\n      }\n    }\n  ]\n}\n```\n\n（3）分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 1, // 从第一条开始查,并不包含第一条\n  \"size\": 1 // 查一条数据\n}\n```\n\n（4）指定要查询出来商品的名称和价格就可以，也就是具体要显示哪些field。\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"_source\": [\"name\", \"price\"]\n}\n```\n\n## query filter\n\n（1）搜索商品名称包含yagao，而且售价大于25元的商品\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": {\n        \"match\": {\n          \"name\": \"yagao\"\n        }\n      },\n      \"filter\": {\n        \"range\": {\n          \"price\": {\n            \"gt\": 25\n          }\n        }\n      }\n    }\n  }\n}\n```\n## full-text search\n全文检索\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match\": {\n      \"producer\": \"oyr yagao producer\"\n    }\n  }\n}\n```\nproducer这个字段，会先被分词拆解\nyagao\nproducer\n然后一个个去匹配文档中producer对应的倒排索引\n```\n返回值：\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0.7594807,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 0.7594807,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"1\",\n        \"_score\": 0.5063205,\n        \"_source\": {\n          \"name\": \"gaolujie yagao\",\n          \"desc\": \"zheshi gaolujie yigeyagao\",\n          \"price\": 30,\n          \"producer\": \"gaolujie yagao producer\",\n          \"tags\": [\n            \"meibai\",\n            \"fangzhu\"\n          ]\n        }\n      },\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"3\",\n        \"_score\": 0.5063205,\n        \"_source\": {\n          \"name\": \"latiao yagao\",\n          \"desc\": \"zheshi latiao yagao\",\n          \"price\": 15,\n          \"producer\": \"latiao yagao producer\",\n          \"tags\": [\n            \"la\",\n            \"meiwei\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n\n## phrase search\n短语搜索\n跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回\nphrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回\n```\nGET /sell/product/_search\n{\n  \"query\": {\n    \"match_phrase\": {\n      \"producer\": \"oyr yagao producer\"\n    }\n  }\n}\n返回值：\n{\n  \"took\": 15,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 1,\n    \"max_score\": 0.7594808,\n    \"hits\": [\n      {\n        \"_index\": \"sell\",\n        \"_type\": \"product\",\n        \"_id\": \"2\",\n        \"_score\": 0.7594808,\n        \"_source\": {\n          \"name\": \"oyr yagao\",\n          \"desc\": \"zheshi oyr yagao\",\n          \"price\": 3000,\n          \"producer\": \"oyr yagao producer\",\n          \"tags\": [\n            \"lengcang\",\n            \"baoxian\"\n          ]\n        }\n      }\n    ]\n  }\n}\n```\n\n\n## 聚合查询\n\n（1）计算每个tag下的商品数量\n先将文本field的fielddata属性设置为true，不然执行聚合查询会报错。\n```\nPUT /sell/_mapping/product\n{\n  \"properties\": {\n    \"tags\":{\n      \"type\": \"text\",\n      \"fielddata\": true\n    }\n  }\n}\n\n查询：\nGET /sell/product/_search\n{\n  \"size\": 0, \n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*) from product group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n```\n\n（2）对名称中包含yagao的商品，计算每个tag下的商品数量\n```\nGET /sell/product/_search\n{\n  \"size\": 0, \n  \"query\": {\n    \"match\": {\n      \"name\": \"yagao\"\n    }\n  }, \n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*) from product where name='yagao' group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1\n        }\n      ]\n    }\n  }\n}\n```\n\n（3）先分组，再算每组的平均值，计算每个tag下的商品的平均价格\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\"\n      },\n      \"aggs\": {\n        \"avg_price\": {\n          \"avg\": {\"field\": \"price\"}\n        }\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*), avg(price) from product group by tags\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1515\n          }\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1507.5\n          }\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1,\n          \"avg_price\": {\n            \"value\": 30\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n（4）计算每个tag下的商品的平均价格，并且按照平均价格降序排序\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_tags\": {\n      \"terms\": {\n        \"field\": \"tags\",\n        \"order\": {\n          \"avg_price\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"avg_price\": {\n          \"avg\": {\"field\": \"price\"}\n        }\n      }\n    }\n  }\n}\n```\n类似于数据库sql:\n```sql\nSelect tags, count(*), avg(price) as avg_price from product group by tags order by avg_price\n```\n返回值：\n```\n{\n  \"took\": 2,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_tags\": {\n      \"doc_count_error_upper_bound\": 0,\n      \"sum_other_doc_count\": 0,\n      \"buckets\": [\n        {\n          \"key\": \"meibai\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1515\n          }\n        },\n        {\n          \"key\": \"meiwei\",\n          \"doc_count\": 2,\n          \"avg_price\": {\n            \"value\": 1507.5\n          }\n        },\n        {\n          \"key\": \"fangzhu\",\n          \"doc_count\": 1,\n          \"avg_price\": {\n            \"value\": 30\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n（5）按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格\n```\nGET /sell/product/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"group_by_price\": {\n      \"range\": {\n        \"field\": \"price\",\n        \"ranges\": [\n          {\n            \"from\": 0,\n            \"to\": 20\n          },\n          {\n            \"from\": 20,\n            \"to\": 10000\n          }\n        ]\n      },\n      \"aggs\": {\n        \"group_by_tags\": {\n          \"terms\": {\n            \"field\": \"tags\"\n          },\n          \"aggs\": {\n            \"avg_price\": {\n              \"avg\": {\n                \"field\": \"price\"\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n返回值：\n```\n{\n  \"took\": 3,\n  \"timed_out\": false,\n  \"_shards\": {\n    \"total\": 5,\n    \"successful\": 5,\n    \"failed\": 0\n  },\n  \"hits\": {\n    \"total\": 3,\n    \"max_score\": 0,\n    \"hits\": []\n  },\n  \"aggregations\": {\n    \"group_by_price\": {\n      \"buckets\": [\n        {\n          \"key\": \"0.0-20.0\",\n          \"from\": 0,\n          \"to\": 20,\n          \"doc_count\": 1,\n          \"group_by_tags\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              {\n                \"key\": \"meiwei\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 15\n                }\n              }\n            ]\n          }\n        },\n        {\n          \"key\": \"20.0-10000.0\",\n          \"from\": 20,\n          \"to\": 10000,\n          \"doc_count\": 2,\n          \"group_by_tags\": {\n            \"doc_count_error_upper_bound\": 0,\n            \"sum_other_doc_count\": 0,\n            \"buckets\": [\n              {\n                \"key\": \"meibai\",\n                \"doc_count\": 2,\n                \"avg_price\": {\n                  \"value\": 1515\n                }\n              },\n              {\n                \"key\": \"fangzhu\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 30\n                }\n              },\n              {\n                \"key\": \"meiwei\",\n                \"doc_count\": 1,\n                \"avg_price\": {\n                  \"value\": 3000\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n## filter 与 query的深入比较\n### filter与query示例\n```shell script\nPUT /company/employee/2\n{\n  \"address\": {\n    \"country\": \"china\",\n    \"province\": \"jiangsu\",\n    \"city\": \"nanjing\"\n  },\n  \"name\": \"tom\",\n  \"age\": 30,\n  \"join_date\": \"2016-01-01\"\n}\n\nPUT /company/employee/3\n{\n  \"address\": {\n    \"country\": \"china\",\n    \"province\": \"shanxi\",\n    \"city\": \"xian\"\n  },\n  \"name\": \"marry\",\n  \"age\": 35,\n  \"join_date\": \"2015-01-01\"\n}\n\n#搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01\nGET /company/employee/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match\": {\n            \"join_date\": \"2016-01-01\"\n          }\n        }\n      ],\n      \"filter\": {\n        \"range\": {\n          \"age\": {\n            \"gte\": 30\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n### filter 与 query对比 \n* filter: 仅仅只是按搜索条件过滤出所需要的数据而已，不涉及相关度分数的计算，对相关度没有影响\n* query： 会去计算每个document相对搜索条件的相关度，并按相关度进行排序\n\n总结： \n* 如果是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query。\n* 如果只是想根据搜索条件筛选出一部分数据，那么用filter\n* 如果需要将符合条件的document排名靠前，用query包含，如果想其他的条件不影响到前面的document排序则用filter过滤\n\n### filter与query性能\n* filter： 不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据\n* query： 相反，要计算相关度分数，按照分数进行排序，而且无法cache结果\n\n### 单执行filter需注意\n```shell script\n# 参数 constant_score 必传 否则会出现异常\nGET /student/class/_search \n{\n  \"query\": {\n    \"constant_score\": {\n      \"filter\": {\n        \"range\": {\n          \"mark\": {\n            \"gte\": 30\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 几种query的搜索语法\n### match all \n    查询所有\n```shell script\n#查询所有index的内容\nGET /_search\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n```\n```shell script\n#查询指定index下的所有内容\nGET student/class/_search\n{\n  \"query\":{\n    \"match_all\": {}\n  }\n}\n```\n### match\n    匹配某一个filed是否包含某个文本，会触发分词，相当于是 full text(全文检索)\n```shell script\n# 查询所有index 指定field是否包含查询内容\nGET /_search\n{\n  \"query\":{\n    \"match\": {\n      \"title\": \"学习\"\n    }\n  }\n}\n```\n```shell script\n# 查询指定index 指定field是否包含查询内容\nGET student/class/_search\n{\n  \"query\":{\n    \"match\": {\n      \"title\": \"学习\"\n    }\n  }\n}\n```\n\n### multi match\n    查询多个field是否包含查询内容\n```shell script\n# 查询所有index 指定的fields下是否包含查询内容\nGET /_search\n{\n  \"query\":{\n    \"multi_match\":{\n      \"query\":\"学习\",\n      \"fields\":[\"title\",\"desc\"]\n    }\n  }\n}\n```\n```shell script\n# 查询指定index 指定的fields下是否包含查询内容\nGET student/class/_search\n{\n  \"query\":{\n    \"multi_match\":{\n      \"query\":\"学习\",\n      \"fields\":[\"title\",\"desc\"]\n    }\n  }\n}\n\n```\n    \n### range query\n    查询field是否在指定的范围值内，放query里会对相关度产生影响，放filter里面无影响\n```shell script\n# 查询所有index 指定的field是否在查询内容范围内\nGET /_search\n{\n  \"query\":{\n    \"range\":{\n      \"mark\":{\n        #\"gt\":80, 大于\n        #\"lt\":120 小于\n        \"gte\":80, #大于等于\n        \"lte\":120 #小于等于\n\n      }\n    }\n  }\n}\n```\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"range\":{\n      \"mark\":{\"gte\":80}\n    }\n  }\n}\n```\n\n### term query\n   把查询的数据当成 exact value（精准匹配）进行查询。  \n   这里查询的内容是要精准匹配field内容  \n   需要建立索引的时候，指定<font color=red>field不分词</font>才能查询到  \n   或者field已经是<font color=red>最小分词单位</font>\n```shell script\nGET /_search\n{\n  \"query\":{\n    \"term\": {\n      \"name\": \"八\"\n    }\n  }\n}\n```\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"term\": {\n      \"name\": \"八\"\n    }\n  }\n}\n```\n\n### terms query\n    原理与term一致，不过对指定的field可以查询指定多个搜索词\n```shell script\nGET student/class/_search\n{\n  \"query\":{\n    \"terms\": {\n      \"name\": [\"八\",\"九\"]\n    }\n  }\n}\n```\n\n## 组合查询\n参数 bool 多条件组合查询参数，bool中可以使用 must、 must_not 、should 来组合查询条件 ,bool 可嵌套  \n一下参数在与match、multi match、term、terms一起使用时注意查询方式是exact value or full value \n* must: 需要满足条件 ==或like\n* must_not: 不需要在满足条件内的 !=或 not like\n* should: should中的两个条件至少满足一个就可以,should下有多个条件时注意加参数 minimum_should_match\n* filter\n\n```shell script\n# 查询学习成绩在30~100的学生信息，成绩倒叙，备注含学习,李四作弊取消成绩\nGET student/class/_search?sort=mark:desc\n{\n  \"query\":{\n    \"bool\": {\n     \"must_not\": [\n       {\"match\": {\n         \"name\": \"李四\"\n       }}\n     ],\n     \"minimum_should_match\":2, # should下满足几个条件\n     \"should\": [\n      {\"match\":{\"title\":\"委员\"}}\n      ,\n      {\"match\":{\"desc\":\"突出\"}}\n     ], \n      \"filter\": {\n        \"bool\": {\n          \"must\":\n          [\n            {\"range\":{\"mark\": {\"gte\":20,\"lte\":100}}},\n            {\"match\":{\"desc\": \"学习\"}}\n          ]\n        }\n        \n      }\n    }\n  }\n}\n```\n\n## 校验不合法的搜索\n特别复杂庞大的搜索下，比如你一下子写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法\n```shell script\n#格式: GET index/type/_validate/query?explain\nGET student/class/_validate/query?explain\n{\n  \"query\":{\n    \"match_all\": {}\n  }\n}\n```\n返回结果\n```shell script\n{\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"failed\" : 0\n  },\n  \"valid\" : true,\n  \"explanations\" : [\n    {\n      \"index\" : \"student\",\n      \"valid\" : true,\n      \"explanation\" : \"+*:* #*:*\"\n    }\n  ]\n}\n```","slug":"lh/elasticsearch/es-初级应用","published":1,"updated":"2021-10-27T09:00:10.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af8630008cst7b7rj82h0","content":"<h1 id=\"es-集群健康状态\"><a href=\"#es-集群健康状态\" class=\"headerlink\" title=\"es 集群健康状态\"></a>es 集群健康状态</h1><h2 id=\"es-查询集群健康状态\"><a href=\"#es-查询集群健康状态\" class=\"headerlink\" title=\"es 查询集群健康状态\"></a>es 查询集群健康状态</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_cat/health?v</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488006741 15:12:21  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488007113 15:18:33  elasticsearch green           2         2      2   1    0    0        0             0                  -                100.0%</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488007216 15:20:16  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群健康状态-green、yellow、red\"><a href=\"#集群健康状态-green、yellow、red\" class=\"headerlink\" title=\"集群健康状态 green、yellow、red\"></a>集群健康状态 green、yellow、red</h2><ul>\n<li>green：每个索引的primary shard和replica shard都是active状态的</li>\n<li>yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li>\n<li>red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li>\n</ul>\n<h2 id=\"为什么会会处于yellow状态？\"><a href=\"#为什么会会处于yellow状态？\" class=\"headerlink\" title=\"为什么会会处于yellow状态？\"></a>为什么会会处于yellow状态？</h2><p>比如当前es只有一台服务启动即只有一个node，此时只启动了一个primary shard，而依据es的 容错机制 replica shard 不予 primary shard 同服务，即单机情况下 集群状态为yellow<br>也有当集群环境下 一台机器出现故障 处理正常运行的 primary shard 的 replica shard 恰好在故障服务器上 这时也是会显示yellow</p>\n<h1 id=\"es-基础操作\"><a href=\"#es-基础操作\" class=\"headerlink\" title=\"es 基础操作\"></a>es 基础操作</h1><h2 id=\"查询集群下的-索引\"><a href=\"#查询集群下的-索引\" class=\"headerlink\" title=\"查询集群下的 索引\"></a>查询集群下的 索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_cat/indices?v</span><br><span class=\"line\"></span><br><span class=\"line\">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class=\"line\">yellow open   student rUm9n9wMRQCCrRDEhqneBg   1   1          1            0      3.1kb          3.1kb</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建索引\"><a href=\"#新建索引\" class=\"headerlink\" title=\"新建索引\"></a>新建索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student?pretty</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE /student?pretty</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引的-CURD\"><a href=\"#索引的-CURD\" class=\"headerlink\" title=\"索引的 CURD\"></a>索引的 CURD</h2><ul>\n<li>新建搜索内容 document<br>PUT /index/type/id (这里的id 不添加时，系统会默认一个值)<br>{<br>  “filed”:”value”<br>} // 整个大括号 则为 一个document<br><font color=\"red\">注意:</font> 当PUT作为update操作时，需要将所有filed全部写上，否则全覆盖，一般不建议用于update</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student/class/1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;tom&quot;</span><br><span class=\"line\">    &quot;age&quot;:15</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//数据下面有用到</span><br><span class=\"line\">PUT /student/class/2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;ajo&quot;</span><br><span class=\"line\">    &quot;age&quot;:20</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /student/class/3</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;jack&quot;</span><br><span class=\"line\">    &quot;age&quot;:25</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改搜索内容<br>通过调用api _update 对指定索引下的字段进行更新<br>POST /index/type/id/_update (这里的id必填)<br>{<br>  “doc”:{     <pre><code>  &quot;filed&quot;:&quot;value&quot; //filed 表示要修改的字段    \n</code></pre>\n  }<br>} </li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student/class/1/_update</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;doc&quot;:&#123;</span><br><span class=\"line\">        &quot;name&quot;:&quot;jack&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>删除指定搜索内容<br>删除索引下的一条记录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE /student/class/1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"es-查询操作相关\"><a href=\"#es-查询操作相关\" class=\"headerlink\" title=\"es 查询操作相关\"></a>es 查询操作相关</h2><ul>\n<li><p>查询索引下全部的内容（全文搜索）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;:&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>查询 包含指定关键字<br>这里搜索通过倒排索引 去搜索 如下：name 为tom 则会通过上面已经新增的document 得到一个列表   </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">doc</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">tom</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">ajo</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>doc</th>\n<th>id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tom</td>\n<td>1</td>\n</tr>\n<tr>\n<td>o</td>\n<td>1,2</td>\n</tr>\n</tbody></table>\n<p>即返回结果为 document id 为1、2的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;:&#123;</span><br><span class=\"line\">      &quot;name&quot;:&quot;tom&quot;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>phrase search 短语查询<br>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回<br>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_phrase&quot;:&#123;</span><br><span class=\"line\">      &quot;name&quot;:&quot;tom&quot;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>查询条件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;filter&quot;: [</span><br><span class=\"line\">        &#123;&quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;ago&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 10,//大于等于</span><br><span class=\"line\">            &quot;lte&quot;: 20//小于等于</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>highlight search（高亮搜索结果）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /ecommerce/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot; : &#123;</span><br><span class=\"line\">        &quot;match&quot; : &#123;</span><br><span class=\"line\">            &quot;producer&quot; : &quot;producer&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;highlight&quot;: &#123;</span><br><span class=\"line\">        &quot;fields&quot; : &#123;</span><br><span class=\"line\">            &quot;producer&quot; : &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"mget批量查询api\"><a href=\"#mget批量查询api\" class=\"headerlink\" title=\"mget批量查询api\"></a>mget批量查询api</h2><p>mget批量查询可以将多个操作合并一个读操作去执行，可以减少网络请求次数，提升系统性能，当然如果请求数据过多，也会在一定程度上影响了影响速度<br>mget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍，非常非常之重要  </p>\n<ul>\n<li><p>场景1 不同index下 的查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_mget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;docs&quot; : [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_index&quot; : &quot;test_index1&quot;,</span><br><span class=\"line\">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class=\"line\">         &quot;_id&quot; :    1</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_index&quot; : &quot;test_index2&quot;,</span><br><span class=\"line\">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class=\"line\">         &quot;_id&quot; :    2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>场景2 同一index下 的查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /test_index/type/_mget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;ids&quot;: [1, 2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"批量写操作-bulk\"><a href=\"#批量写操作-bulk\" class=\"headerlink\" title=\"批量写操作 _bulk\"></a>批量写操作 _bulk</h2><p>bulk api对json的语法有严格要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行，bulk 的语法格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;action&quot;: &#123;&quot;metadata&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&quot;data&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>bulk 主要支持一下类型的操作：</p>\n<ul>\n<li>delete: 删除一个文档，只要1个json串就可以了</li>\n<li>create: PUT /index/type/id/_create，强制创建</li>\n<li>index：普通的put操作，可以是创建文档，也可以是全量替换文档</li>\n<li>update：执行的partial update操作</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_bulk</span><br><span class=\"line\">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; </span><br><span class=\"line\">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;</span><br><span class=\"line\">&#123; &quot;test_field&quot;:    &quot;test12&quot; &#125;</span><br><span class=\"line\">&#123; &quot;index&quot;:  &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;</span><br><span class=\"line\">&#123; &quot;test_field&quot;:    &quot;replaced test2&quot; &#125;</span><br><span class=\"line\">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class=\"line\">&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bulk-操作出现异常\"><a href=\"#bulk-操作出现异常\" class=\"headerlink\" title=\"bulk 操作出现异常\"></a>bulk 操作出现异常</h3><p>bulk操作中，任意一个操作失败，是不会影响其他的操作，但是会在返回的结果里面告诉异常日志  </p>\n<h3 id=\"bulk-性能\"><a href=\"#bulk-性能\" class=\"headerlink\" title=\"bulk 性能\"></a>bulk 性能</h3><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，需要反复尝试得出一个最佳的bulk size，一般从1000-5000条数据开始，尝试逐渐增加<br>如果看大小的话，最好控制在5~15MB之间</p>\n<h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2><p>分页主要有两个参数<br>    size：每一页多少条数据<br>    from：表示从第多少条开始分页 <font color=red>起始页为0</font> 为0 与不传from 单传size效果一致</p>\n<p>请求方式主要有：</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET _search?size=2</span><br><span class=\"line\">GET _search?size=2&amp;from=0 # 返回结果与第一条执行结果一致</span><br><span class=\"line\">GET _search?size=2&amp;from=2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deep-paging-问题\"><a href=\"#deep-paging-问题\" class=\"headerlink\" title=\"deep paging 问题\"></a>deep paging 问题</h3><p>集群环境下，当查询的目标数据很多，比如超过几十万甚至几百万数据时，这个时候进行分页，这个时候:</p>\n<ul>\n<li>step1 client 分页请求 如 _search?size=1000&amp;from=1000000  到 coordinate node ,节点会找到该查询多个对应的shard（假设3shard）</li>\n<li>step2 请求到达对应的shard 开始执行分页操作 _search?size=1000&amp;from=1000000 取1000条数据 并返回给coordinate node</li>\n<li>step3 coordinate收到shard返回的总数据条数为3000条，这个时候开始做重排序，默认是<font color=red>通过相关度分数排序</font>,取前1000条数据返回给client </li>\n</ul>\n<p>deep paging问题 其实是一个深度查询的问题，如涉及分页查询较深时且数据较大时，非常消耗网络带宽，消耗内存，所以存在性能问题，应尽量避免 deep paging操作</p>\n<h1 id=\"多种搜索方式\"><a href=\"#多种搜索方式\" class=\"headerlink\" title=\"多种搜索方式\"></a>多种搜索方式</h1><h2 id=\"query-string-search\"><a href=\"#query-string-search\" class=\"headerlink\" title=\"query string search\"></a>query string search</h2><p>query string search的由来：<br>因为search参数都是以http请求的query string来附带的。<br>注意，这个查询在生产环境上使用的是不多的。</p>\n<p>（1）搜索所有的商品：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 12,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 1,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yaogao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回值说明：<br>took：耗费了多少毫秒<br>timed_out：是否超时，这里是没有<br>_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也是可以）<br>hits.total：查询结果的数量，3个document<br>hits.max_score:score的含义：就是document对应一个search的相关度的匹配分数，越相关，就越匹配，分数也越高。这里显示的是最大的一个匹配分数<br>hits.hits：包含了匹配搜索的document的详细数据</p>\n<p>（2）搜索商品名称中包含yagao的商品，而且按照售价降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search?q=name:yagao&amp;sort=price:desc</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: null,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          3000</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          30</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          15</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"query-DSL\"><a href=\"#query-DSL\" class=\"headerlink\" title=\"query DSL\"></a>query DSL</h2><p>DSL：Domain Specified Language，特定领域的语言<br>参数是放在http request body中的。<br>http request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了</p>\n<p>（1）查询所有的商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）查询名称包含yagao的商品，同时按照价格降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  , &quot;sort&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;price&quot;: &quot;desc&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;sort&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;price&quot;: &#123;</span><br><span class=\"line\">        &quot;order&quot;: &quot;desc&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;from&quot;: 1, // 从第一条开始查,并不包含第一条</span><br><span class=\"line\">  &quot;size&quot;: 1 // 查一条数据</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）指定要查询出来商品的名称和价格就可以，也就是具体要显示哪些field。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"query-filter\"><a href=\"#query-filter\" class=\"headerlink\" title=\"query filter\"></a>query filter</h2><p>（1）搜索商品名称包含yagao，而且售价大于25元的商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;must&quot;: &#123;</span><br><span class=\"line\">        &quot;match&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;price&quot;: &#123;</span><br><span class=\"line\">            &quot;gt&quot;: 25</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"full-text-search\"><a href=\"#full-text-search\" class=\"headerlink\" title=\"full-text search\"></a>full-text search</h2><p>全文检索</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;producer&quot;: &quot;oyr yagao producer&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>producer这个字段，会先被分词拆解<br>yagao<br>producer<br>然后一个个去匹配文档中producer对应的倒排索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0.7594807,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.7594807,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.5063205,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.5063205,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"phrase-search\"><a href=\"#phrase-search\" class=\"headerlink\" title=\"phrase search\"></a>phrase search</h2><p>短语搜索<br>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回<br>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_phrase&quot;: &#123;</span><br><span class=\"line\">      &quot;producer&quot;: &quot;oyr yagao producer&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 15,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 1,</span><br><span class=\"line\">    &quot;max_score&quot;: 0.7594808,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.7594808,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"聚合查询\"><a href=\"#聚合查询\" class=\"headerlink\" title=\"聚合查询\"></a>聚合查询</h2><p>（1）计算每个tag下的商品数量<br>先将文本field的fielddata属性设置为true，不然执行聚合查询会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /sell/_mapping/product</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;properties&quot;: &#123;</span><br><span class=\"line\">    &quot;tags&quot;:&#123;</span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">      &quot;fielddata&quot;: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">查询：</span><br><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0, </span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）对名称中包含yagao的商品，计算每个tag下的商品数量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0, </span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> product <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;yagao&#x27;</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）先分组，再算每组的平均值，计算每个tag下的商品的平均价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">          &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>), <span class=\"built_in\">avg</span>(price) <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1515</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1507.5</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）计算每个tag下的商品的平均价格，并且按照平均价格降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;,</span><br><span class=\"line\">        &quot;order&quot;: &#123;</span><br><span class=\"line\">          &quot;avg_price&quot;: &quot;desc&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">          &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>), <span class=\"built_in\">avg</span>(price) <span class=\"keyword\">as</span> avg_price <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> avg_price</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1515</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1507.5</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_price&quot;: &#123;</span><br><span class=\"line\">      &quot;range&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;price&quot;,</span><br><span class=\"line\">        &quot;ranges&quot;: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            &quot;from&quot;: 0,</span><br><span class=\"line\">            &quot;to&quot;: 20</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            &quot;from&quot;: 20,</span><br><span class=\"line\">            &quot;to&quot;: 10000</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">          &quot;terms&quot;: &#123;</span><br><span class=\"line\">            &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &quot;aggs&quot;: &#123;</span><br><span class=\"line\">            &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">              &quot;avg&quot;: &#123;</span><br><span class=\"line\">                &quot;field&quot;: &quot;price&quot;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 3,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_price&quot;: &#123;</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;0.0-20.0&quot;,</span><br><span class=\"line\">          &quot;from&quot;: 0,</span><br><span class=\"line\">          &quot;to&quot;: 20,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">            &quot;buckets&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 15</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;20.0-10000.0&quot;,</span><br><span class=\"line\">          &quot;from&quot;: 20,</span><br><span class=\"line\">          &quot;to&quot;: 10000,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">            &quot;buckets&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 2,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 1515</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 30</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 3000</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"filter-与-query的深入比较\"><a href=\"#filter-与-query的深入比较\" class=\"headerlink\" title=\"filter 与 query的深入比较\"></a>filter 与 query的深入比较</h2><h3 id=\"filter与query示例\"><a href=\"#filter与query示例\" class=\"headerlink\" title=\"filter与query示例\"></a>filter与query示例</h3><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /company/employee/2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;address&quot;: &#123;</span><br><span class=\"line\">    &quot;country&quot;: &quot;china&quot;,</span><br><span class=\"line\">    &quot;province&quot;: &quot;jiangsu&quot;,</span><br><span class=\"line\">    &quot;city&quot;: &quot;nanjing&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;tom&quot;,</span><br><span class=\"line\">  &quot;age&quot;: 30,</span><br><span class=\"line\">  &quot;join_date&quot;: &quot;2016-01-01&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /company/employee/3</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;address&quot;: &#123;</span><br><span class=\"line\">    &quot;country&quot;: &quot;china&quot;,</span><br><span class=\"line\">    &quot;province&quot;: &quot;shanxi&quot;,</span><br><span class=\"line\">    &quot;city&quot;: &quot;xian&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;marry&quot;,</span><br><span class=\"line\">  &quot;age&quot;: 35,</span><br><span class=\"line\">  &quot;join_date&quot;: &quot;2015-01-01&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01</span></span><br><span class=\"line\">GET /company/employee/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;must&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;match&quot;: &#123;</span><br><span class=\"line\">            &quot;join_date&quot;: &quot;2016-01-01&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;age&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter-与-query对比\"><a href=\"#filter-与-query对比\" class=\"headerlink\" title=\"filter 与 query对比\"></a>filter 与 query对比</h3><ul>\n<li>filter: 仅仅只是按搜索条件过滤出所需要的数据而已，不涉及相关度分数的计算，对相关度没有影响</li>\n<li>query： 会去计算每个document相对搜索条件的相关度，并按相关度进行排序</li>\n</ul>\n<p>总结： </p>\n<ul>\n<li>如果是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query。</li>\n<li>如果只是想根据搜索条件筛选出一部分数据，那么用filter</li>\n<li>如果需要将符合条件的document排名靠前，用query包含，如果想其他的条件不影响到前面的document排序则用filter过滤</li>\n</ul>\n<h3 id=\"filter与query性能\"><a href=\"#filter与query性能\" class=\"headerlink\" title=\"filter与query性能\"></a>filter与query性能</h3><ul>\n<li>filter： 不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据</li>\n<li>query： 相反，要计算相关度分数，按照分数进行排序，而且无法cache结果</li>\n</ul>\n<h3 id=\"单执行filter需注意\"><a href=\"#单执行filter需注意\" class=\"headerlink\" title=\"单执行filter需注意\"></a>单执行filter需注意</h3><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 constant_score 必传 否则会出现异常</span></span><br><span class=\"line\">GET /student/class/_search </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;constant_score&quot;: &#123;</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;mark&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"几种query的搜索语法\"><a href=\"#几种query的搜索语法\" class=\"headerlink\" title=\"几种query的搜索语法\"></a>几种query的搜索语法</h2><h3 id=\"match-all\"><a href=\"#match-all\" class=\"headerlink\" title=\"match all\"></a>match all</h3><pre><code>查询所有\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查询所有index的内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &#123;</span><br><span class=\"line\">        &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查询指定index下的所有内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h3><pre><code>匹配某一个filed是否包含某个文本，会触发分词，相当于是 full text(全文检索)\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定field是否包含查询内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;title&quot;: &quot;学习&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询指定index 指定field是否包含查询内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;title&quot;: &quot;学习&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"multi-match\"><a href=\"#multi-match\" class=\"headerlink\" title=\"multi match\"></a>multi match</h3><pre><code>查询多个field是否包含查询内容\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定的fields下是否包含查询内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;multi_match&quot;:&#123;</span><br><span class=\"line\">      &quot;query&quot;:&quot;学习&quot;,</span><br><span class=\"line\">      &quot;fields&quot;:[&quot;title&quot;,&quot;desc&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询指定index 指定的fields下是否包含查询内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;multi_match&quot;:&#123;</span><br><span class=\"line\">      &quot;query&quot;:&quot;学习&quot;,</span><br><span class=\"line\">      &quot;fields&quot;:[&quot;title&quot;,&quot;desc&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"range-query\"><a href=\"#range-query\" class=\"headerlink\" title=\"range query\"></a>range query</h3><pre><code>查询field是否在指定的范围值内，放query里会对相关度产生影响，放filter里面无影响\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定的field是否在查询内容范围内</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;range&quot;:&#123;</span><br><span class=\"line\">      &quot;mark&quot;:&#123;</span><br><span class=\"line\">        #&quot;gt&quot;:80, 大于</span><br><span class=\"line\">        #&quot;lt&quot;:120 小于</span><br><span class=\"line\">        &quot;gte&quot;:80, #大于等于</span><br><span class=\"line\">        &quot;lte&quot;:120 #小于等于</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;range&quot;:&#123;</span><br><span class=\"line\">      &quot;mark&quot;:&#123;&quot;gte&quot;:80&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"term-query\"><a href=\"#term-query\" class=\"headerlink\" title=\"term query\"></a>term query</h3><p>   把查询的数据当成 exact value（精准匹配）进行查询。<br>   这里查询的内容是要精准匹配field内容<br>   需要建立索引的时候，指定<font color=red>field不分词</font>才能查询到<br>   或者field已经是<font color=red>最小分词单位</font></p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;八&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;八&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"terms-query\"><a href=\"#terms-query\" class=\"headerlink\" title=\"terms query\"></a>terms query</h3><pre><code>原理与term一致，不过对指定的field可以查询指定多个搜索词\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;terms&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: [&quot;八&quot;,&quot;九&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h2><p>参数 bool 多条件组合查询参数，bool中可以使用 must、 must_not 、should 来组合查询条件 ,bool 可嵌套<br>一下参数在与match、multi match、term、terms一起使用时注意查询方式是exact value or full value </p>\n<ul>\n<li>must: 需要满足条件 ==或like</li>\n<li>must_not: 不需要在满足条件内的 !=或 not like</li>\n<li>should: should中的两个条件至少满足一个就可以,should下有多个条件时注意加参数 minimum_should_match</li>\n<li>filter</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询学习成绩在30~100的学生信息，成绩倒叙，备注含学习,李四作弊取消成绩</span></span><br><span class=\"line\">GET student/class/_search?sort=mark:desc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">     &quot;must_not&quot;: [</span><br><span class=\"line\">       &#123;&quot;match&quot;: &#123;</span><br><span class=\"line\">         &quot;name&quot;: &quot;李四&quot;</span><br><span class=\"line\">       &#125;&#125;</span><br><span class=\"line\">     ],</span><br><span class=\"line\">     &quot;minimum_should_match&quot;:2, # should下满足几个条件</span><br><span class=\"line\">     &quot;should&quot;: [</span><br><span class=\"line\">      &#123;&quot;match&quot;:&#123;&quot;title&quot;:&quot;委员&quot;&#125;&#125;</span><br><span class=\"line\">      ,</span><br><span class=\"line\">      &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;突出&quot;&#125;&#125;</span><br><span class=\"line\">     ], </span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;bool&quot;: &#123;</span><br><span class=\"line\">          &quot;must&quot;:</span><br><span class=\"line\">          [</span><br><span class=\"line\">            &#123;&quot;range&quot;:&#123;&quot;mark&quot;: &#123;&quot;gte&quot;:20,&quot;lte&quot;:100&#125;&#125;&#125;,</span><br><span class=\"line\">            &#123;&quot;match&quot;:&#123;&quot;desc&quot;: &quot;学习&quot;&#125;&#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"校验不合法的搜索\"><a href=\"#校验不合法的搜索\" class=\"headerlink\" title=\"校验不合法的搜索\"></a>校验不合法的搜索</h2><p>特别复杂庞大的搜索下，比如你一下子写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">格式: GET index/<span class=\"built_in\">type</span>/_validate/query?explain</span></span><br><span class=\"line\">GET student/class/_validate/query?explain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回结果</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;_shards&quot; : &#123;</span><br><span class=\"line\">    &quot;total&quot; : 1,</span><br><span class=\"line\">    &quot;successful&quot; : 1,</span><br><span class=\"line\">    &quot;failed&quot; : 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;valid&quot; : true,</span><br><span class=\"line\">  &quot;explanations&quot; : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;index&quot; : &quot;student&quot;,</span><br><span class=\"line\">      &quot;valid&quot; : true,</span><br><span class=\"line\">      &quot;explanation&quot; : &quot;+*:* #*:*&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"es-集群健康状态\"><a href=\"#es-集群健康状态\" class=\"headerlink\" title=\"es 集群健康状态\"></a>es 集群健康状态</h1><h2 id=\"es-查询集群健康状态\"><a href=\"#es-查询集群健康状态\" class=\"headerlink\" title=\"es 查询集群健康状态\"></a>es 查询集群健康状态</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_cat/health?v</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488006741 15:12:21  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488007113 15:18:33  elasticsearch green           2         2      2   1    0    0        0             0                  -                100.0%</span><br><span class=\"line\"></span><br><span class=\"line\">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class=\"line\">1488007216 15:20:16  elasticsearch yellow          1         1      1   1    0    0        1             0                  -                 50.0%</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群健康状态-green、yellow、red\"><a href=\"#集群健康状态-green、yellow、red\" class=\"headerlink\" title=\"集群健康状态 green、yellow、red\"></a>集群健康状态 green、yellow、red</h2><ul>\n<li>green：每个索引的primary shard和replica shard都是active状态的</li>\n<li>yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li>\n<li>red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li>\n</ul>\n<h2 id=\"为什么会会处于yellow状态？\"><a href=\"#为什么会会处于yellow状态？\" class=\"headerlink\" title=\"为什么会会处于yellow状态？\"></a>为什么会会处于yellow状态？</h2><p>比如当前es只有一台服务启动即只有一个node，此时只启动了一个primary shard，而依据es的 容错机制 replica shard 不予 primary shard 同服务，即单机情况下 集群状态为yellow<br>也有当集群环境下 一台机器出现故障 处理正常运行的 primary shard 的 replica shard 恰好在故障服务器上 这时也是会显示yellow</p>\n<h1 id=\"es-基础操作\"><a href=\"#es-基础操作\" class=\"headerlink\" title=\"es 基础操作\"></a>es 基础操作</h1><h2 id=\"查询集群下的-索引\"><a href=\"#查询集群下的-索引\" class=\"headerlink\" title=\"查询集群下的 索引\"></a>查询集群下的 索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_cat/indices?v</span><br><span class=\"line\"></span><br><span class=\"line\">health status index   uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class=\"line\">yellow open   student rUm9n9wMRQCCrRDEhqneBg   1   1          1            0      3.1kb          3.1kb</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建索引\"><a href=\"#新建索引\" class=\"headerlink\" title=\"新建索引\"></a>新建索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student?pretty</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE /student?pretty</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引的-CURD\"><a href=\"#索引的-CURD\" class=\"headerlink\" title=\"索引的 CURD\"></a>索引的 CURD</h2><ul>\n<li>新建搜索内容 document<br>PUT /index/type/id (这里的id 不添加时，系统会默认一个值)<br>{<br>  “filed”:”value”<br>} // 整个大括号 则为 一个document<br><font color=\"red\">注意:</font> 当PUT作为update操作时，需要将所有filed全部写上，否则全覆盖，一般不建议用于update</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student/class/1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;tom&quot;</span><br><span class=\"line\">    &quot;age&quot;:15</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//数据下面有用到</span><br><span class=\"line\">PUT /student/class/2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;ajo&quot;</span><br><span class=\"line\">    &quot;age&quot;:20</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /student/class/3</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;jack&quot;</span><br><span class=\"line\">    &quot;age&quot;:25</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改搜索内容<br>通过调用api _update 对指定索引下的字段进行更新<br>POST /index/type/id/_update (这里的id必填)<br>{<br>  “doc”:{     <pre><code>  &quot;filed&quot;:&quot;value&quot; //filed 表示要修改的字段    \n</code></pre>\n  }<br>} </li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /student/class/1/_update</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;doc&quot;:&#123;</span><br><span class=\"line\">        &quot;name&quot;:&quot;jack&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>删除指定搜索内容<br>删除索引下的一条记录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE /student/class/1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"es-查询操作相关\"><a href=\"#es-查询操作相关\" class=\"headerlink\" title=\"es 查询操作相关\"></a>es 查询操作相关</h2><ul>\n<li><p>查询索引下全部的内容（全文搜索）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;:&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>查询 包含指定关键字<br>这里搜索通过倒排索引 去搜索 如下：name 为tom 则会通过上面已经新增的document 得到一个列表   </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">doc</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">tom</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">ajo</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>doc</th>\n<th>id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tom</td>\n<td>1</td>\n</tr>\n<tr>\n<td>o</td>\n<td>1,2</td>\n</tr>\n</tbody></table>\n<p>即返回结果为 document id 为1、2的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;:&#123;</span><br><span class=\"line\">      &quot;name&quot;:&quot;tom&quot;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>phrase search 短语查询<br>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回<br>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_phrase&quot;:&#123;</span><br><span class=\"line\">      &quot;name&quot;:&quot;tom&quot;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>查询条件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;filter&quot;: [</span><br><span class=\"line\">        &#123;&quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;ago&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 10,//大于等于</span><br><span class=\"line\">            &quot;lte&quot;: 20//小于等于</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>highlight search（高亮搜索结果）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /ecommerce/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot; : &#123;</span><br><span class=\"line\">        &quot;match&quot; : &#123;</span><br><span class=\"line\">            &quot;producer&quot; : &quot;producer&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;highlight&quot;: &#123;</span><br><span class=\"line\">        &quot;fields&quot; : &#123;</span><br><span class=\"line\">            &quot;producer&quot; : &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"mget批量查询api\"><a href=\"#mget批量查询api\" class=\"headerlink\" title=\"mget批量查询api\"></a>mget批量查询api</h2><p>mget批量查询可以将多个操作合并一个读操作去执行，可以减少网络请求次数，提升系统性能，当然如果请求数据过多，也会在一定程度上影响了影响速度<br>mget是很重要的，一般来说，在进行查询的时候，如果一次性要查询多条数据的话，那么一定要用batch批量操作的api，尽可能减少网络开销次数，可能可以将性能提升数倍，甚至数十倍，非常非常之重要  </p>\n<ul>\n<li><p>场景1 不同index下 的查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_mget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;docs&quot; : [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_index&quot; : &quot;test_index1&quot;,</span><br><span class=\"line\">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class=\"line\">         &quot;_id&quot; :    1</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         &quot;_index&quot; : &quot;test_index2&quot;,</span><br><span class=\"line\">         &quot;_type&quot; :  &quot;test_type&quot;,</span><br><span class=\"line\">         &quot;_id&quot; :    2</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>场景2 同一index下 的查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /test_index/type/_mget</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &quot;ids&quot;: [1, 2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"批量写操作-bulk\"><a href=\"#批量写操作-bulk\" class=\"headerlink\" title=\"批量写操作 _bulk\"></a>批量写操作 _bulk</h2><p>bulk api对json的语法有严格要求，每个json串不能换行，只能放一行，同时一个json串和一个json串之间，必须有一个换行，bulk 的语法格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;action&quot;: &#123;&quot;metadata&quot;&#125;&#125;</span><br><span class=\"line\">&#123;&quot;data&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>bulk 主要支持一下类型的操作：</p>\n<ul>\n<li>delete: 删除一个文档，只要1个json串就可以了</li>\n<li>create: PUT /index/type/id/_create，强制创建</li>\n<li>index：普通的put操作，可以是创建文档，也可以是全量替换文档</li>\n<li>update：执行的partial update操作</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /_bulk</span><br><span class=\"line\">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;3&quot; &#125;&#125; </span><br><span class=\"line\">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;12&quot; &#125;&#125;</span><br><span class=\"line\">&#123; &quot;test_field&quot;:    &quot;test12&quot; &#125;</span><br><span class=\"line\">&#123; &quot;index&quot;:  &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;2&quot; &#125;&#125;</span><br><span class=\"line\">&#123; &quot;test_field&quot;:    &quot;replaced test2&quot; &#125;</span><br><span class=\"line\">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;test_index&quot;, &quot;_type&quot;: &quot;test_type&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class=\"line\">&#123; &quot;doc&quot; : &#123;&quot;test_field2&quot; : &quot;bulk test1&quot;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bulk-操作出现异常\"><a href=\"#bulk-操作出现异常\" class=\"headerlink\" title=\"bulk 操作出现异常\"></a>bulk 操作出现异常</h3><p>bulk操作中，任意一个操作失败，是不会影响其他的操作，但是会在返回的结果里面告诉异常日志  </p>\n<h3 id=\"bulk-性能\"><a href=\"#bulk-性能\" class=\"headerlink\" title=\"bulk 性能\"></a>bulk 性能</h3><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，需要反复尝试得出一个最佳的bulk size，一般从1000-5000条数据开始，尝试逐渐增加<br>如果看大小的话，最好控制在5~15MB之间</p>\n<h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2><p>分页主要有两个参数<br>    size：每一页多少条数据<br>    from：表示从第多少条开始分页 <font color=red>起始页为0</font> 为0 与不传from 单传size效果一致</p>\n<p>请求方式主要有：</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET _search?size=2</span><br><span class=\"line\">GET _search?size=2&amp;from=0 # 返回结果与第一条执行结果一致</span><br><span class=\"line\">GET _search?size=2&amp;from=2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deep-paging-问题\"><a href=\"#deep-paging-问题\" class=\"headerlink\" title=\"deep paging 问题\"></a>deep paging 问题</h3><p>集群环境下，当查询的目标数据很多，比如超过几十万甚至几百万数据时，这个时候进行分页，这个时候:</p>\n<ul>\n<li>step1 client 分页请求 如 _search?size=1000&amp;from=1000000  到 coordinate node ,节点会找到该查询多个对应的shard（假设3shard）</li>\n<li>step2 请求到达对应的shard 开始执行分页操作 _search?size=1000&amp;from=1000000 取1000条数据 并返回给coordinate node</li>\n<li>step3 coordinate收到shard返回的总数据条数为3000条，这个时候开始做重排序，默认是<font color=red>通过相关度分数排序</font>,取前1000条数据返回给client </li>\n</ul>\n<p>deep paging问题 其实是一个深度查询的问题，如涉及分页查询较深时且数据较大时，非常消耗网络带宽，消耗内存，所以存在性能问题，应尽量避免 deep paging操作</p>\n<h1 id=\"多种搜索方式\"><a href=\"#多种搜索方式\" class=\"headerlink\" title=\"多种搜索方式\"></a>多种搜索方式</h1><h2 id=\"query-string-search\"><a href=\"#query-string-search\" class=\"headerlink\" title=\"query string search\"></a>query string search</h2><p>query string search的由来：<br>因为search参数都是以http请求的query string来附带的。<br>注意，这个查询在生产环境上使用的是不多的。</p>\n<p>（1）搜索所有的商品：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 12,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 1,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yaogao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 1,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回值说明：<br>took：耗费了多少毫秒<br>timed_out：是否超时，这里是没有<br>_shards：数据拆成了5个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也是可以）<br>hits.total：查询结果的数量，3个document<br>hits.max_score:score的含义：就是document对应一个search的相关度的匹配分数，越相关，就越匹配，分数也越高。这里显示的是最大的一个匹配分数<br>hits.hits：包含了匹配搜索的document的详细数据</p>\n<p>（2）搜索商品名称中包含yagao的商品，而且按照售价降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search?q=name:yagao&amp;sort=price:desc</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: null,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          3000</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          30</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: null,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;sort&quot;: [</span><br><span class=\"line\">          15</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"query-DSL\"><a href=\"#query-DSL\" class=\"headerlink\" title=\"query DSL\"></a>query DSL</h2><p>DSL：Domain Specified Language，特定领域的语言<br>参数是放在http request body中的。<br>http request body：请求体，可以用json的格式来构建查询语法，比较方便，可以构建各种复杂的语法，比query string search肯定强大多了</p>\n<p>（1）查询所有的商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）查询名称包含yagao的商品，同时按照价格降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  , &quot;sort&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;price&quot;: &quot;desc&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;sort&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;price&quot;: &#123;</span><br><span class=\"line\">        &quot;order&quot;: &quot;desc&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）分页查询商品，总共3条商品，假设每页就显示1条商品，现在显示第2页，所以就查出来第2个商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;from&quot;: 1, // 从第一条开始查,并不包含第一条</span><br><span class=\"line\">  &quot;size&quot;: 1 // 查一条数据</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）指定要查询出来商品的名称和价格就可以，也就是具体要显示哪些field。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"query-filter\"><a href=\"#query-filter\" class=\"headerlink\" title=\"query filter\"></a>query filter</h2><p>（1）搜索商品名称包含yagao，而且售价大于25元的商品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;must&quot;: &#123;</span><br><span class=\"line\">        &quot;match&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;price&quot;: &#123;</span><br><span class=\"line\">            &quot;gt&quot;: 25</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"full-text-search\"><a href=\"#full-text-search\" class=\"headerlink\" title=\"full-text search\"></a>full-text search</h2><p>全文检索</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;producer&quot;: &quot;oyr yagao producer&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>producer这个字段，会先被分词拆解<br>yagao<br>producer<br>然后一个个去匹配文档中producer对应的倒排索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0.7594807,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.7594807,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.5063205,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;gaolujie yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi gaolujie yigeyagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 30,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;gaolujie yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;meibai&quot;,</span><br><span class=\"line\">            &quot;fangzhu&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.5063205,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;latiao yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi latiao yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 15,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;latiao yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;la&quot;,</span><br><span class=\"line\">            &quot;meiwei&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"phrase-search\"><a href=\"#phrase-search\" class=\"headerlink\" title=\"phrase search\"></a>phrase search</h2><p>短语搜索<br>跟全文检索相对应，相反，全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回<br>phrase search，要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match_phrase&quot;: &#123;</span><br><span class=\"line\">      &quot;producer&quot;: &quot;oyr yagao producer&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">返回值：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 15,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 1,</span><br><span class=\"line\">    &quot;max_score&quot;: 0.7594808,</span><br><span class=\"line\">    &quot;hits&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;_index&quot;: &quot;sell&quot;,</span><br><span class=\"line\">        &quot;_type&quot;: &quot;product&quot;,</span><br><span class=\"line\">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class=\"line\">        &quot;_score&quot;: 0.7594808,</span><br><span class=\"line\">        &quot;_source&quot;: &#123;</span><br><span class=\"line\">          &quot;name&quot;: &quot;oyr yagao&quot;,</span><br><span class=\"line\">          &quot;desc&quot;: &quot;zheshi oyr yagao&quot;,</span><br><span class=\"line\">          &quot;price&quot;: 3000,</span><br><span class=\"line\">          &quot;producer&quot;: &quot;oyr yagao producer&quot;,</span><br><span class=\"line\">          &quot;tags&quot;: [</span><br><span class=\"line\">            &quot;lengcang&quot;,</span><br><span class=\"line\">            &quot;baoxian&quot;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"聚合查询\"><a href=\"#聚合查询\" class=\"headerlink\" title=\"聚合查询\"></a>聚合查询</h2><p>（1）计算每个tag下的商品数量<br>先将文本field的fielddata属性设置为true，不然执行聚合查询会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /sell/_mapping/product</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;properties&quot;: &#123;</span><br><span class=\"line\">    &quot;tags&quot;:&#123;</span><br><span class=\"line\">      &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">      &quot;fielddata&quot;: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">查询：</span><br><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0, </span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）对名称中包含yagao的商品，计算每个tag下的商品数量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0, </span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;yagao&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> product <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;yagao&#x27;</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）先分组，再算每组的平均值，计算每个tag下的商品的平均价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">          &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>), <span class=\"built_in\">avg</span>(price) <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1515</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1507.5</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）计算每个tag下的商品的平均价格，并且按照平均价格降序排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;terms&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;tags&quot;,</span><br><span class=\"line\">        &quot;order&quot;: &#123;</span><br><span class=\"line\">          &quot;avg_price&quot;: &quot;desc&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">          &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类似于数据库sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> tags, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>), <span class=\"built_in\">avg</span>(price) <span class=\"keyword\">as</span> avg_price <span class=\"keyword\">from</span> product <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> tags <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> avg_price</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 2,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">      &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1515</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 1507.5</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">            &quot;value&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /sell/product/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;size&quot;: 0,</span><br><span class=\"line\">  &quot;aggs&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_price&quot;: &#123;</span><br><span class=\"line\">      &quot;range&quot;: &#123;</span><br><span class=\"line\">        &quot;field&quot;: &quot;price&quot;,</span><br><span class=\"line\">        &quot;ranges&quot;: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            &quot;from&quot;: 0,</span><br><span class=\"line\">            &quot;to&quot;: 20</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            &quot;from&quot;: 20,</span><br><span class=\"line\">            &quot;to&quot;: 10000</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;aggs&quot;: &#123;</span><br><span class=\"line\">        &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">          &quot;terms&quot;: &#123;</span><br><span class=\"line\">            &quot;field&quot;: &quot;tags&quot;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &quot;aggs&quot;: &#123;</span><br><span class=\"line\">            &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">              &quot;avg&quot;: &#123;</span><br><span class=\"line\">                &quot;field&quot;: &quot;price&quot;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;took&quot;: 3,</span><br><span class=\"line\">  &quot;timed_out&quot;: false,</span><br><span class=\"line\">  &quot;_shards&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 5,</span><br><span class=\"line\">    &quot;successful&quot;: 5,</span><br><span class=\"line\">    &quot;failed&quot;: 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;hits&quot;: &#123;</span><br><span class=\"line\">    &quot;total&quot;: 3,</span><br><span class=\"line\">    &quot;max_score&quot;: 0,</span><br><span class=\"line\">    &quot;hits&quot;: []</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;aggregations&quot;: &#123;</span><br><span class=\"line\">    &quot;group_by_price&quot;: &#123;</span><br><span class=\"line\">      &quot;buckets&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;0.0-20.0&quot;,</span><br><span class=\"line\">          &quot;from&quot;: 0,</span><br><span class=\"line\">          &quot;to&quot;: 20,</span><br><span class=\"line\">          &quot;doc_count&quot;: 1,</span><br><span class=\"line\">          &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">            &quot;buckets&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 15</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;key&quot;: &quot;20.0-10000.0&quot;,</span><br><span class=\"line\">          &quot;from&quot;: 20,</span><br><span class=\"line\">          &quot;to&quot;: 10000,</span><br><span class=\"line\">          &quot;doc_count&quot;: 2,</span><br><span class=\"line\">          &quot;group_by_tags&quot;: &#123;</span><br><span class=\"line\">            &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class=\"line\">            &quot;sum_other_doc_count&quot;: 0,</span><br><span class=\"line\">            &quot;buckets&quot;: [</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meibai&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 2,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 1515</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;fangzhu&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 30</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                &quot;key&quot;: &quot;meiwei&quot;,</span><br><span class=\"line\">                &quot;doc_count&quot;: 1,</span><br><span class=\"line\">                &quot;avg_price&quot;: &#123;</span><br><span class=\"line\">                  &quot;value&quot;: 3000</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"filter-与-query的深入比较\"><a href=\"#filter-与-query的深入比较\" class=\"headerlink\" title=\"filter 与 query的深入比较\"></a>filter 与 query的深入比较</h2><h3 id=\"filter与query示例\"><a href=\"#filter与query示例\" class=\"headerlink\" title=\"filter与query示例\"></a>filter与query示例</h3><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUT /company/employee/2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;address&quot;: &#123;</span><br><span class=\"line\">    &quot;country&quot;: &quot;china&quot;,</span><br><span class=\"line\">    &quot;province&quot;: &quot;jiangsu&quot;,</span><br><span class=\"line\">    &quot;city&quot;: &quot;nanjing&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;tom&quot;,</span><br><span class=\"line\">  &quot;age&quot;: 30,</span><br><span class=\"line\">  &quot;join_date&quot;: &quot;2016-01-01&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /company/employee/3</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;address&quot;: &#123;</span><br><span class=\"line\">    &quot;country&quot;: &quot;china&quot;,</span><br><span class=\"line\">    &quot;province&quot;: &quot;shanxi&quot;,</span><br><span class=\"line\">    &quot;city&quot;: &quot;xian&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;marry&quot;,</span><br><span class=\"line\">  &quot;age&quot;: 35,</span><br><span class=\"line\">  &quot;join_date&quot;: &quot;2015-01-01&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01</span></span><br><span class=\"line\">GET /company/employee/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">      &quot;must&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;match&quot;: &#123;</span><br><span class=\"line\">            &quot;join_date&quot;: &quot;2016-01-01&quot;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;age&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filter-与-query对比\"><a href=\"#filter-与-query对比\" class=\"headerlink\" title=\"filter 与 query对比\"></a>filter 与 query对比</h3><ul>\n<li>filter: 仅仅只是按搜索条件过滤出所需要的数据而已，不涉及相关度分数的计算，对相关度没有影响</li>\n<li>query： 会去计算每个document相对搜索条件的相关度，并按相关度进行排序</li>\n</ul>\n<p>总结： </p>\n<ul>\n<li>如果是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query。</li>\n<li>如果只是想根据搜索条件筛选出一部分数据，那么用filter</li>\n<li>如果需要将符合条件的document排名靠前，用query包含，如果想其他的条件不影响到前面的document排序则用filter过滤</li>\n</ul>\n<h3 id=\"filter与query性能\"><a href=\"#filter与query性能\" class=\"headerlink\" title=\"filter与query性能\"></a>filter与query性能</h3><ul>\n<li>filter： 不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据</li>\n<li>query： 相反，要计算相关度分数，按照分数进行排序，而且无法cache结果</li>\n</ul>\n<h3 id=\"单执行filter需注意\"><a href=\"#单执行filter需注意\" class=\"headerlink\" title=\"单执行filter需注意\"></a>单执行filter需注意</h3><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 参数 constant_score 必传 否则会出现异常</span></span><br><span class=\"line\">GET /student/class/_search </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;constant_score&quot;: &#123;</span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;range&quot;: &#123;</span><br><span class=\"line\">          &quot;mark&quot;: &#123;</span><br><span class=\"line\">            &quot;gte&quot;: 30</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"几种query的搜索语法\"><a href=\"#几种query的搜索语法\" class=\"headerlink\" title=\"几种query的搜索语法\"></a>几种query的搜索语法</h2><h3 id=\"match-all\"><a href=\"#match-all\" class=\"headerlink\" title=\"match all\"></a>match all</h3><pre><code>查询所有\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查询所有index的内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;query&quot;: &#123;</span><br><span class=\"line\">        &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">查询指定index下的所有内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h3><pre><code>匹配某一个filed是否包含某个文本，会触发分词，相当于是 full text(全文检索)\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定field是否包含查询内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;title&quot;: &quot;学习&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询指定index 指定field是否包含查询内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;title&quot;: &quot;学习&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"multi-match\"><a href=\"#multi-match\" class=\"headerlink\" title=\"multi match\"></a>multi match</h3><pre><code>查询多个field是否包含查询内容\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定的fields下是否包含查询内容</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;multi_match&quot;:&#123;</span><br><span class=\"line\">      &quot;query&quot;:&quot;学习&quot;,</span><br><span class=\"line\">      &quot;fields&quot;:[&quot;title&quot;,&quot;desc&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询指定index 指定的fields下是否包含查询内容</span></span><br><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;multi_match&quot;:&#123;</span><br><span class=\"line\">      &quot;query&quot;:&quot;学习&quot;,</span><br><span class=\"line\">      &quot;fields&quot;:[&quot;title&quot;,&quot;desc&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"range-query\"><a href=\"#range-query\" class=\"headerlink\" title=\"range query\"></a>range query</h3><pre><code>查询field是否在指定的范围值内，放query里会对相关度产生影响，放filter里面无影响\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询所有index 指定的field是否在查询内容范围内</span></span><br><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;range&quot;:&#123;</span><br><span class=\"line\">      &quot;mark&quot;:&#123;</span><br><span class=\"line\">        #&quot;gt&quot;:80, 大于</span><br><span class=\"line\">        #&quot;lt&quot;:120 小于</span><br><span class=\"line\">        &quot;gte&quot;:80, #大于等于</span><br><span class=\"line\">        &quot;lte&quot;:120 #小于等于</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;range&quot;:&#123;</span><br><span class=\"line\">      &quot;mark&quot;:&#123;&quot;gte&quot;:80&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"term-query\"><a href=\"#term-query\" class=\"headerlink\" title=\"term query\"></a>term query</h3><p>   把查询的数据当成 exact value（精准匹配）进行查询。<br>   这里查询的内容是要精准匹配field内容<br>   需要建立索引的时候，指定<font color=red>field不分词</font>才能查询到<br>   或者field已经是<font color=red>最小分词单位</font></p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;八&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: &quot;八&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"terms-query\"><a href=\"#terms-query\" class=\"headerlink\" title=\"terms query\"></a>terms query</h3><pre><code>原理与term一致，不过对指定的field可以查询指定多个搜索词\n</code></pre>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET student/class/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;terms&quot;: &#123;</span><br><span class=\"line\">      &quot;name&quot;: [&quot;八&quot;,&quot;九&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h2><p>参数 bool 多条件组合查询参数，bool中可以使用 must、 must_not 、should 来组合查询条件 ,bool 可嵌套<br>一下参数在与match、multi match、term、terms一起使用时注意查询方式是exact value or full value </p>\n<ul>\n<li>must: 需要满足条件 ==或like</li>\n<li>must_not: 不需要在满足条件内的 !=或 not like</li>\n<li>should: should中的两个条件至少满足一个就可以,should下有多个条件时注意加参数 minimum_should_match</li>\n<li>filter</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询学习成绩在30~100的学生信息，成绩倒叙，备注含学习,李四作弊取消成绩</span></span><br><span class=\"line\">GET student/class/_search?sort=mark:desc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;bool&quot;: &#123;</span><br><span class=\"line\">     &quot;must_not&quot;: [</span><br><span class=\"line\">       &#123;&quot;match&quot;: &#123;</span><br><span class=\"line\">         &quot;name&quot;: &quot;李四&quot;</span><br><span class=\"line\">       &#125;&#125;</span><br><span class=\"line\">     ],</span><br><span class=\"line\">     &quot;minimum_should_match&quot;:2, # should下满足几个条件</span><br><span class=\"line\">     &quot;should&quot;: [</span><br><span class=\"line\">      &#123;&quot;match&quot;:&#123;&quot;title&quot;:&quot;委员&quot;&#125;&#125;</span><br><span class=\"line\">      ,</span><br><span class=\"line\">      &#123;&quot;match&quot;:&#123;&quot;desc&quot;:&quot;突出&quot;&#125;&#125;</span><br><span class=\"line\">     ], </span><br><span class=\"line\">      &quot;filter&quot;: &#123;</span><br><span class=\"line\">        &quot;bool&quot;: &#123;</span><br><span class=\"line\">          &quot;must&quot;:</span><br><span class=\"line\">          [</span><br><span class=\"line\">            &#123;&quot;range&quot;:&#123;&quot;mark&quot;: &#123;&quot;gte&quot;:20,&quot;lte&quot;:100&#125;&#125;&#125;,</span><br><span class=\"line\">            &#123;&quot;match&quot;:&#123;&quot;desc&quot;: &quot;学习&quot;&#125;&#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"校验不合法的搜索\"><a href=\"#校验不合法的搜索\" class=\"headerlink\" title=\"校验不合法的搜索\"></a>校验不合法的搜索</h2><p>特别复杂庞大的搜索下，比如你一下子写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">格式: GET index/<span class=\"built_in\">type</span>/_validate/query?explain</span></span><br><span class=\"line\">GET student/class/_validate/query?explain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;query&quot;:&#123;</span><br><span class=\"line\">    &quot;match_all&quot;: &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回结果</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;_shards&quot; : &#123;</span><br><span class=\"line\">    &quot;total&quot; : 1,</span><br><span class=\"line\">    &quot;successful&quot; : 1,</span><br><span class=\"line\">    &quot;failed&quot; : 0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;valid&quot; : true,</span><br><span class=\"line\">  &quot;explanations&quot; : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;index&quot; : &quot;student&quot;,</span><br><span class=\"line\">      &quot;valid&quot; : true,</span><br><span class=\"line\">      &quot;explanation&quot; : &quot;+*:* #*:*&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"es-搜索引擎","date":"2021-10-24T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 为什么要用搜索引擎\n* 数据类型  \n全文索引搜索支持非结构化数据的搜索，可以更好地快速搜索大量存在的任何单词或单词组的非结构化文本。\n例如 Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。\n\n* 索引的维护  \n一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。\n\n## 什么时候使用全文搜索引擎\n* 搜索的数据对象是大量的非结构化的文本数据。\n* 文件记录量达到数十万或数百万个甚至更多。\n* 支持大量基于交互式文本的查询。\n* 需求非常灵活的全文搜索查询。\n* 对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。\n* 对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。\n\n## 倒排索引\n倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。例如   \ndocument1 ： welcome to china\ndocument2 ： china is beautiful  \ndocument3 ： tom like china  \n\n|单词字典|倒排文件|\n|:---:|:---:|\n|welcome|1|\n|to|1|\n|china|1,2,3|\n|is|2|\n|beautiful|2|  \n|tom|3|  \n|like|3|  \n\n在建立倒排索引时，会<font color=red>使用标准化规则（normalization）</font>，会将document分词出来的单词字典 进行标准化处理，比如：  \n        * 缩写 vs. 全程：cn vs. china\n        * 格式转化：like liked likes\n        * 大小写：Tom vs tom\n        * 同义词：like vs love\n        \n## 什么是分词器\n切分词语，normalization（提升recall召回率），将一段文本进行各种处理，最后处理好的结果才会拿去建立倒排索引  \nrecall-召回率：搜索时增加能够搜索到的结果数量 \n\n分词其包含三部分：\n* character filter-过滤特殊字符：分词前先进行预处理，最常见的就是过滤html标签等\n* tokenizer-分词： hello you and me --> hello, you, and, me\n* token filter-进行标准化处理：标准化处理，比如缩写、格式转化、大小写、同义词等\n\n\n\n## 内置分词器的介绍\ndocument 案例：Set the shape to semi-transparent by calling set_trans(5)\n* standard analyzer： 大小写转化，去除一些特殊符号、大小写拆分(es默认的分词器)  \n    set, the, shape, to, semi, transparent, by, calling, set_trans, 5\n* simple analyzer：去除一些特殊符号,可以依据-,_来拆分字符  \n    set, the, shape, to, semi, transparent, by, calling, set, trans\n* whitespace analyzer： 自会根据空格进行拆分，不会处理大小写 特殊字符  \n    Set, the, shape, to, semi-transparent, by, calling, set_trans(5)\n* language analyzer: 特定的语言的分词器，比如说，english，英语分词器  \n    set, shape, semi, transpar, call, set_tran, 5\n    \n## 测试分词器 \n```shell script\nGET /_analyze\n{\n  \"analyzer\": \"standard\", # 给定的分词器\n  \"text\": \"Text to analyze\" # 待分词的文本\n}\n```\n返回结果\n```shell script\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"text\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 4,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"to\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"analyze\",\n      \"start_offset\" : 8,\n      \"end_offset\" : 15,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 2\n    }\n  ]\n}\n```\n","source":"_posts/lh/elasticsearch/es-初识搜索引擎.md","raw":"---\ntitle: es-搜索引擎\ndate: 2021-10-25 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: es\ntags:  \n    - es\n---\n\n# 为什么要用搜索引擎\n* 数据类型  \n全文索引搜索支持非结构化数据的搜索，可以更好地快速搜索大量存在的任何单词或单词组的非结构化文本。\n例如 Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。\n\n* 索引的维护  \n一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。\n\n## 什么时候使用全文搜索引擎\n* 搜索的数据对象是大量的非结构化的文本数据。\n* 文件记录量达到数十万或数百万个甚至更多。\n* 支持大量基于交互式文本的查询。\n* 需求非常灵活的全文搜索查询。\n* 对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。\n* 对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。\n\n## 倒排索引\n倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。例如   \ndocument1 ： welcome to china\ndocument2 ： china is beautiful  \ndocument3 ： tom like china  \n\n|单词字典|倒排文件|\n|:---:|:---:|\n|welcome|1|\n|to|1|\n|china|1,2,3|\n|is|2|\n|beautiful|2|  \n|tom|3|  \n|like|3|  \n\n在建立倒排索引时，会<font color=red>使用标准化规则（normalization）</font>，会将document分词出来的单词字典 进行标准化处理，比如：  \n        * 缩写 vs. 全程：cn vs. china\n        * 格式转化：like liked likes\n        * 大小写：Tom vs tom\n        * 同义词：like vs love\n        \n## 什么是分词器\n切分词语，normalization（提升recall召回率），将一段文本进行各种处理，最后处理好的结果才会拿去建立倒排索引  \nrecall-召回率：搜索时增加能够搜索到的结果数量 \n\n分词其包含三部分：\n* character filter-过滤特殊字符：分词前先进行预处理，最常见的就是过滤html标签等\n* tokenizer-分词： hello you and me --> hello, you, and, me\n* token filter-进行标准化处理：标准化处理，比如缩写、格式转化、大小写、同义词等\n\n\n\n## 内置分词器的介绍\ndocument 案例：Set the shape to semi-transparent by calling set_trans(5)\n* standard analyzer： 大小写转化，去除一些特殊符号、大小写拆分(es默认的分词器)  \n    set, the, shape, to, semi, transparent, by, calling, set_trans, 5\n* simple analyzer：去除一些特殊符号,可以依据-,_来拆分字符  \n    set, the, shape, to, semi, transparent, by, calling, set, trans\n* whitespace analyzer： 自会根据空格进行拆分，不会处理大小写 特殊字符  \n    Set, the, shape, to, semi-transparent, by, calling, set_trans(5)\n* language analyzer: 特定的语言的分词器，比如说，english，英语分词器  \n    set, shape, semi, transpar, call, set_tran, 5\n    \n## 测试分词器 \n```shell script\nGET /_analyze\n{\n  \"analyzer\": \"standard\", # 给定的分词器\n  \"text\": \"Text to analyze\" # 待分词的文本\n}\n```\n返回结果\n```shell script\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"text\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 4,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"to\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"analyze\",\n      \"start_offset\" : 8,\n      \"end_offset\" : 15,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 2\n    }\n  ]\n}\n```\n","slug":"lh/elasticsearch/es-初识搜索引擎","published":1,"updated":"2021-10-26T07:05:25.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af8630009cst7272s8pa8","content":"<h1 id=\"为什么要用搜索引擎\"><a href=\"#为什么要用搜索引擎\" class=\"headerlink\" title=\"为什么要用搜索引擎\"></a>为什么要用搜索引擎</h1><ul>\n<li><p>数据类型<br>全文索引搜索支持非结构化数据的搜索，可以更好地快速搜索大量存在的任何单词或单词组的非结构化文本。<br>例如 Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</p>\n</li>\n<li><p>索引的维护<br>一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</p>\n</li>\n</ul>\n<h2 id=\"什么时候使用全文搜索引擎\"><a href=\"#什么时候使用全文搜索引擎\" class=\"headerlink\" title=\"什么时候使用全文搜索引擎\"></a>什么时候使用全文搜索引擎</h2><ul>\n<li>搜索的数据对象是大量的非结构化的文本数据。</li>\n<li>文件记录量达到数十万或数百万个甚至更多。</li>\n<li>支持大量基于交互式文本的查询。</li>\n<li>需求非常灵活的全文搜索查询。</li>\n<li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。</li>\n<li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。</li>\n</ul>\n<h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。例如<br>document1 ： welcome to china<br>document2 ： china is beautiful<br>document3 ： tom like china  </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">单词字典</th>\n<th align=\"center\">倒排文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">welcome</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">to</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">china</td>\n<td align=\"center\">1,2,3</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">beautiful</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">tom</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">like</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<p>在建立倒排索引时，会<font color=red>使用标准化规则（normalization）</font>，会将document分词出来的单词字典 进行标准化处理，比如：<br>        * 缩写 vs. 全程：cn vs. china<br>        * 格式转化：like liked likes<br>        * 大小写：Tom vs tom<br>        * 同义词：like vs love</p>\n<h2 id=\"什么是分词器\"><a href=\"#什么是分词器\" class=\"headerlink\" title=\"什么是分词器\"></a>什么是分词器</h2><p>切分词语，normalization（提升recall召回率），将一段文本进行各种处理，最后处理好的结果才会拿去建立倒排索引<br>recall-召回率：搜索时增加能够搜索到的结果数量 </p>\n<p>分词其包含三部分：</p>\n<ul>\n<li>character filter-过滤特殊字符：分词前先进行预处理，最常见的就是过滤html标签等</li>\n<li>tokenizer-分词： hello you and me –&gt; hello, you, and, me</li>\n<li>token filter-进行标准化处理：标准化处理，比如缩写、格式转化、大小写、同义词等</li>\n</ul>\n<h2 id=\"内置分词器的介绍\"><a href=\"#内置分词器的介绍\" class=\"headerlink\" title=\"内置分词器的介绍\"></a>内置分词器的介绍</h2><p>document 案例：Set the shape to semi-transparent by calling set_trans(5)</p>\n<ul>\n<li>standard analyzer： 大小写转化，去除一些特殊符号、大小写拆分(es默认的分词器)<br>  set, the, shape, to, semi, transparent, by, calling, set_trans, 5</li>\n<li>simple analyzer：去除一些特殊符号,可以依据-,_来拆分字符<br>  set, the, shape, to, semi, transparent, by, calling, set, trans</li>\n<li>whitespace analyzer： 自会根据空格进行拆分，不会处理大小写 特殊字符<br>  Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</li>\n<li>language analyzer: 特定的语言的分词器，比如说，english，英语分词器<br>  set, shape, semi, transpar, call, set_tran, 5</li>\n</ul>\n<h2 id=\"测试分词器\"><a href=\"#测试分词器\" class=\"headerlink\" title=\"测试分词器\"></a>测试分词器</h2><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;, # 给定的分词器</span><br><span class=\"line\">  &quot;text&quot;: &quot;Text to analyze&quot; # 待分词的文本</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回结果</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;tokens&quot; : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;text&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 0,</span><br><span class=\"line\">      &quot;end_offset&quot; : 4,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;to&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 5,</span><br><span class=\"line\">      &quot;end_offset&quot; : 7,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;analyze&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 8,</span><br><span class=\"line\">      &quot;end_offset&quot; : 15,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要用搜索引擎\"><a href=\"#为什么要用搜索引擎\" class=\"headerlink\" title=\"为什么要用搜索引擎\"></a>为什么要用搜索引擎</h1><ul>\n<li><p>数据类型<br>全文索引搜索支持非结构化数据的搜索，可以更好地快速搜索大量存在的任何单词或单词组的非结构化文本。<br>例如 Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</p>\n</li>\n<li><p>索引的维护<br>一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</p>\n</li>\n</ul>\n<h2 id=\"什么时候使用全文搜索引擎\"><a href=\"#什么时候使用全文搜索引擎\" class=\"headerlink\" title=\"什么时候使用全文搜索引擎\"></a>什么时候使用全文搜索引擎</h2><ul>\n<li>搜索的数据对象是大量的非结构化的文本数据。</li>\n<li>文件记录量达到数十万或数百万个甚至更多。</li>\n<li>支持大量基于交互式文本的查询。</li>\n<li>需求非常灵活的全文搜索查询。</li>\n<li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。</li>\n<li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。</li>\n</ul>\n<h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。例如<br>document1 ： welcome to china<br>document2 ： china is beautiful<br>document3 ： tom like china  </p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">单词字典</th>\n<th align=\"center\">倒排文件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">welcome</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">to</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">china</td>\n<td align=\"center\">1,2,3</td>\n</tr>\n<tr>\n<td align=\"center\">is</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">beautiful</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">tom</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">like</td>\n<td align=\"center\">3</td>\n</tr>\n</tbody></table>\n<p>在建立倒排索引时，会<font color=red>使用标准化规则（normalization）</font>，会将document分词出来的单词字典 进行标准化处理，比如：<br>        * 缩写 vs. 全程：cn vs. china<br>        * 格式转化：like liked likes<br>        * 大小写：Tom vs tom<br>        * 同义词：like vs love</p>\n<h2 id=\"什么是分词器\"><a href=\"#什么是分词器\" class=\"headerlink\" title=\"什么是分词器\"></a>什么是分词器</h2><p>切分词语，normalization（提升recall召回率），将一段文本进行各种处理，最后处理好的结果才会拿去建立倒排索引<br>recall-召回率：搜索时增加能够搜索到的结果数量 </p>\n<p>分词其包含三部分：</p>\n<ul>\n<li>character filter-过滤特殊字符：分词前先进行预处理，最常见的就是过滤html标签等</li>\n<li>tokenizer-分词： hello you and me –&gt; hello, you, and, me</li>\n<li>token filter-进行标准化处理：标准化处理，比如缩写、格式转化、大小写、同义词等</li>\n</ul>\n<h2 id=\"内置分词器的介绍\"><a href=\"#内置分词器的介绍\" class=\"headerlink\" title=\"内置分词器的介绍\"></a>内置分词器的介绍</h2><p>document 案例：Set the shape to semi-transparent by calling set_trans(5)</p>\n<ul>\n<li>standard analyzer： 大小写转化，去除一些特殊符号、大小写拆分(es默认的分词器)<br>  set, the, shape, to, semi, transparent, by, calling, set_trans, 5</li>\n<li>simple analyzer：去除一些特殊符号,可以依据-,_来拆分字符<br>  set, the, shape, to, semi, transparent, by, calling, set, trans</li>\n<li>whitespace analyzer： 自会根据空格进行拆分，不会处理大小写 特殊字符<br>  Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</li>\n<li>language analyzer: 特定的语言的分词器，比如说，english，英语分词器<br>  set, shape, semi, transpar, call, set_tran, 5</li>\n</ul>\n<h2 id=\"测试分词器\"><a href=\"#测试分词器\" class=\"headerlink\" title=\"测试分词器\"></a>测试分词器</h2><figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;analyzer&quot;: &quot;standard&quot;, # 给定的分词器</span><br><span class=\"line\">  &quot;text&quot;: &quot;Text to analyze&quot; # 待分词的文本</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回结果</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;tokens&quot; : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;text&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 0,</span><br><span class=\"line\">      &quot;end_offset&quot; : 4,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 0</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;to&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 5,</span><br><span class=\"line\">      &quot;end_offset&quot; : 7,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;token&quot; : &quot;analyze&quot;,</span><br><span class=\"line\">      &quot;start_offset&quot; : 8,</span><br><span class=\"line\">      &quot;end_offset&quot; : 15,</span><br><span class=\"line\">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class=\"line\">      &quot;position&quot; : 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"es分布式架构","date":"2021-10-21T16:00:00.000Z","author":"lh","summary":"","_content":"# es 分布式框架简述\n## es 对分布式机制的透明隐藏特性\nElasticsearch是一套分布式的系统，分布式是为了应对大数据量隐藏了复杂的分布式机制\n * 分片机制 \n    将数据写入document时，数据如何进行分片，写入那个shard中等等\n * cluster discovery（集群发现机制）：\n    如扩展集群时，启动第二个es进程，那个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard\n * shard的负载均衡 \n    举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求  \n    其实是通过coordinate node 来处理的\n\n## es 集群的扩容方式\n    如现有集群 3集群 每台服务器能容纳1T数据 3个node 3个primary shard replica shard 设置为2  \n * 水平扩容\n    集群数量+1 当前服务器*4 增加一个node节点 now 4个node 通过master node 将 replica shard copy过去 （现有primary shard 已经最大）\n    优点：提升集群的容错性能，多一个node 可以更好的应对单节点故障所产生的风险，提供并发处理能力\n    ![es 集群 结构图](https://kubpang.gitee.io/sourceFile/elasticsearch/es集群水平扩容.jpg) \n * 垂直扩容\n    集群数量不变，增加某台服务内存或者集群内所有的机器加内存，比如 由现有的1T 变为2T \n    优点：使得单台node的处理性能变的更佳\n    缺点：垂直扩容，成本相对应的成倍增加，应对节点故障，对比扩容前无改变\n  一般采用水平扩容。\n    \n### 水平扩容的极限 以及如何提高容错性\n    * primary&replica自动负载均衡，6个shard 3个primary shard 3个replica shard\n    * 每个node 有更少的shard，这是 IO/CUP/Mamory 资源给每个shard也就越多，每个shard的性能也就越好\n    * 扩容极限 6个shard（3个primary 3个replica） 最多扩容到6台机器，一个shard独享node的 所有资源 性能最好\n    * 超出扩容极限 动态修改replica数量，9个shard（3个primary 6个replica），9台机器比3台机器时 拥有了3倍的吞吐量\n    * 容错 3台机器 6个shard（3个primary 3个replica）容忍1台机器宕机，3台机器 9个shard（3个primary 6个replica）容忍2台机器宕机，同一个primary与replica不能同时在一个node上出现\n\n## es 集群的master节点 \n    * master 节点不会承载所有的请求，所有不会有单点瓶颈\n    * 管理es集群的元数据：\n        比如document的创建、修改和删除，维护索引的元数据；节点的新增和删除，维护集群的元数据（水平扩容）\n    * 默认情况下，集群会自动选举出一个master节点，如master节点出现故障后，集群会在剩余节点中选出一个master节点\n    \n## 节点平等的分布式架构\n    * 节点对等，每个节点都可以接收到所有请求\n    * 自动请求路由 client的请求发送到某个节点时，这个节点会自动去请求对应的index  \n    * 相应收集 收到请求的节点，将请求转发出去后，相应结果会返回改节点 有改节点统一发给client 这个节点 就是 coordidata node\n    \n## 写一致性以及quorum机制\n### 写一致性\n    在发送任何es的 增删改操作时，都可以带一个consistency参数，来指明想要的写一致性是什么  \n    consistency： one、all、quorum\n    * one: 要求写操作时，只要<font color=red>有一个primary shard</font> 是active，就可以执行\n    * all：要求写操作时，必须<font color=red>所有的primary shard 和replica shard</font> 都是active，才可以执行这个写操作\n    * quorum: 要求所有的shard中，必须是<font color=red>大部分shard</font> 都是active，才可以执行这个写操作\n\n### quorum机制\n    写之前 需确保大多数的shard是可用的，且只有在 <font color=red>number_of_replica > 1是才生效</font>  \n    quroum = int((primary + number_of_replica)/2 ) + 1  \n\n    * 场景1 3台服务器 3个primary replicas 为1 6个shard： 3primary replica：1*3 \n        quroum = int ((3+ 1)/2) + 1 = 3  \n        也就是说明 3台服务器 6个shard 时 有两个node 也就是4个shard是active时 可以进行写操作\n    * 场景2 3台服务器 3个primary 3个replica  \n         quroum = int ((3+ 3)/2) + 1 = 4 当shard 中active数>4时可进行写操作  \n         注：如果此时宕机2台机器 那么shard的active数 只有3 这时不能进行写操作 但是可以进行读操作\n         \n    * 场景3 单机场景下 一个primary shard replica 默认为1 0个active  \n        因为 number_of_replica = 1 不触发quroum 一致性 也就是说可以支持读写操作\n    \n    * time_out 当quorum 不齐全时，es会等待wait  \n        默认1分钟 time_out可以设置时长 可长可短 time_out=30s time_out=30ms time_out=1m  \n        超时则写入失败\n        格式 PUT test_index/type/1?time_out=30ms\n    \n## 如何进行版本控制  \n* 乐观锁并发控制方案  \n    基于版本号来判断，当前操作的document是否为最新，每次操作前对比当前版本号与es集群之前的差别\n\n* 悲观锁并发控制方案  \n    在各种情况下都上锁，上锁之后，就只有一个线程可以操作这一条数据了，不同场景下锁不同，如：行锁，表锁，读锁，写锁等。\n    \n### es基于乐观锁实现的版本控制\n* 基于系统自带的版本号\n    * 老版本 进行写操作时，在操作语句后面添加_version=n(n:表示es集群中document的版本号)，与集群中的version比较，小于版本号时不执行更新操作\n    * 新版本 在写操作时，取消_version字段，改为 if_seq_no=n&if_primary_term来比较版本，取值分别取查询结果中的_seq_no和_primary_term\n```shell\n{\n  \"_index\" : \"test_index\",\n  \"_type\" : \"type\",\n  \"_id\" : \"1\",\n  \"_version\" : 4,\n  \"_seq_no\" : 4,\n  \"_primary_term\" : 1,\n  \"found\" : true,\n  \"_source\" : {\n    \"test_fild\" : \"test1-3\"\n  }\n}\n```\n\n* 业务所用的版本号  \n   在写操作时，添加version=5&version_type=external 这里的5位外部业务系统控制的版本号为5\n   \n### partial update乐观锁并发控制  \npartial update 内部会自动执行 乐观锁的并发控制策略 如果发现版本号不一致时，partial update 会自动 fail掉\n\n重试策略： retry策略\n* 再次获取document数据和最新的版本号  \n* 基于最新的版本号再次去更新，如果成功就return\n* 如果失败了，重复执行1和2步骤，具体重试次数,可通过设置retry的参数指定执行次数","source":"_posts/lh/elasticsearch/es分布式架构.md","raw":"---\ntitle: es分布式架构\ndate: 2021-10-22 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: es\ntags:  \n    - es\n---\n# es 分布式框架简述\n## es 对分布式机制的透明隐藏特性\nElasticsearch是一套分布式的系统，分布式是为了应对大数据量隐藏了复杂的分布式机制\n * 分片机制 \n    将数据写入document时，数据如何进行分片，写入那个shard中等等\n * cluster discovery（集群发现机制）：\n    如扩展集群时，启动第二个es进程，那个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard\n * shard的负载均衡 \n    举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求  \n    其实是通过coordinate node 来处理的\n\n## es 集群的扩容方式\n    如现有集群 3集群 每台服务器能容纳1T数据 3个node 3个primary shard replica shard 设置为2  \n * 水平扩容\n    集群数量+1 当前服务器*4 增加一个node节点 now 4个node 通过master node 将 replica shard copy过去 （现有primary shard 已经最大）\n    优点：提升集群的容错性能，多一个node 可以更好的应对单节点故障所产生的风险，提供并发处理能力\n    ![es 集群 结构图](https://kubpang.gitee.io/sourceFile/elasticsearch/es集群水平扩容.jpg) \n * 垂直扩容\n    集群数量不变，增加某台服务内存或者集群内所有的机器加内存，比如 由现有的1T 变为2T \n    优点：使得单台node的处理性能变的更佳\n    缺点：垂直扩容，成本相对应的成倍增加，应对节点故障，对比扩容前无改变\n  一般采用水平扩容。\n    \n### 水平扩容的极限 以及如何提高容错性\n    * primary&replica自动负载均衡，6个shard 3个primary shard 3个replica shard\n    * 每个node 有更少的shard，这是 IO/CUP/Mamory 资源给每个shard也就越多，每个shard的性能也就越好\n    * 扩容极限 6个shard（3个primary 3个replica） 最多扩容到6台机器，一个shard独享node的 所有资源 性能最好\n    * 超出扩容极限 动态修改replica数量，9个shard（3个primary 6个replica），9台机器比3台机器时 拥有了3倍的吞吐量\n    * 容错 3台机器 6个shard（3个primary 3个replica）容忍1台机器宕机，3台机器 9个shard（3个primary 6个replica）容忍2台机器宕机，同一个primary与replica不能同时在一个node上出现\n\n## es 集群的master节点 \n    * master 节点不会承载所有的请求，所有不会有单点瓶颈\n    * 管理es集群的元数据：\n        比如document的创建、修改和删除，维护索引的元数据；节点的新增和删除，维护集群的元数据（水平扩容）\n    * 默认情况下，集群会自动选举出一个master节点，如master节点出现故障后，集群会在剩余节点中选出一个master节点\n    \n## 节点平等的分布式架构\n    * 节点对等，每个节点都可以接收到所有请求\n    * 自动请求路由 client的请求发送到某个节点时，这个节点会自动去请求对应的index  \n    * 相应收集 收到请求的节点，将请求转发出去后，相应结果会返回改节点 有改节点统一发给client 这个节点 就是 coordidata node\n    \n## 写一致性以及quorum机制\n### 写一致性\n    在发送任何es的 增删改操作时，都可以带一个consistency参数，来指明想要的写一致性是什么  \n    consistency： one、all、quorum\n    * one: 要求写操作时，只要<font color=red>有一个primary shard</font> 是active，就可以执行\n    * all：要求写操作时，必须<font color=red>所有的primary shard 和replica shard</font> 都是active，才可以执行这个写操作\n    * quorum: 要求所有的shard中，必须是<font color=red>大部分shard</font> 都是active，才可以执行这个写操作\n\n### quorum机制\n    写之前 需确保大多数的shard是可用的，且只有在 <font color=red>number_of_replica > 1是才生效</font>  \n    quroum = int((primary + number_of_replica)/2 ) + 1  \n\n    * 场景1 3台服务器 3个primary replicas 为1 6个shard： 3primary replica：1*3 \n        quroum = int ((3+ 1)/2) + 1 = 3  \n        也就是说明 3台服务器 6个shard 时 有两个node 也就是4个shard是active时 可以进行写操作\n    * 场景2 3台服务器 3个primary 3个replica  \n         quroum = int ((3+ 3)/2) + 1 = 4 当shard 中active数>4时可进行写操作  \n         注：如果此时宕机2台机器 那么shard的active数 只有3 这时不能进行写操作 但是可以进行读操作\n         \n    * 场景3 单机场景下 一个primary shard replica 默认为1 0个active  \n        因为 number_of_replica = 1 不触发quroum 一致性 也就是说可以支持读写操作\n    \n    * time_out 当quorum 不齐全时，es会等待wait  \n        默认1分钟 time_out可以设置时长 可长可短 time_out=30s time_out=30ms time_out=1m  \n        超时则写入失败\n        格式 PUT test_index/type/1?time_out=30ms\n    \n## 如何进行版本控制  \n* 乐观锁并发控制方案  \n    基于版本号来判断，当前操作的document是否为最新，每次操作前对比当前版本号与es集群之前的差别\n\n* 悲观锁并发控制方案  \n    在各种情况下都上锁，上锁之后，就只有一个线程可以操作这一条数据了，不同场景下锁不同，如：行锁，表锁，读锁，写锁等。\n    \n### es基于乐观锁实现的版本控制\n* 基于系统自带的版本号\n    * 老版本 进行写操作时，在操作语句后面添加_version=n(n:表示es集群中document的版本号)，与集群中的version比较，小于版本号时不执行更新操作\n    * 新版本 在写操作时，取消_version字段，改为 if_seq_no=n&if_primary_term来比较版本，取值分别取查询结果中的_seq_no和_primary_term\n```shell\n{\n  \"_index\" : \"test_index\",\n  \"_type\" : \"type\",\n  \"_id\" : \"1\",\n  \"_version\" : 4,\n  \"_seq_no\" : 4,\n  \"_primary_term\" : 1,\n  \"found\" : true,\n  \"_source\" : {\n    \"test_fild\" : \"test1-3\"\n  }\n}\n```\n\n* 业务所用的版本号  \n   在写操作时，添加version=5&version_type=external 这里的5位外部业务系统控制的版本号为5\n   \n### partial update乐观锁并发控制  \npartial update 内部会自动执行 乐观锁的并发控制策略 如果发现版本号不一致时，partial update 会自动 fail掉\n\n重试策略： retry策略\n* 再次获取document数据和最新的版本号  \n* 基于最新的版本号再次去更新，如果成功就return\n* 如果失败了，重复执行1和2步骤，具体重试次数,可通过设置retry的参数指定执行次数","slug":"lh/elasticsearch/es分布式架构","published":1,"updated":"2021-10-25T08:22:26.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af864000dcst784eh885u","content":"<h1 id=\"es-分布式框架简述\"><a href=\"#es-分布式框架简述\" class=\"headerlink\" title=\"es 分布式框架简述\"></a>es 分布式框架简述</h1><h2 id=\"es-对分布式机制的透明隐藏特性\"><a href=\"#es-对分布式机制的透明隐藏特性\" class=\"headerlink\" title=\"es 对分布式机制的透明隐藏特性\"></a>es 对分布式机制的透明隐藏特性</h2><p>Elasticsearch是一套分布式的系统，分布式是为了应对大数据量隐藏了复杂的分布式机制</p>\n<ul>\n<li>分片机制<br> 将数据写入document时，数据如何进行分片，写入那个shard中等等</li>\n<li>cluster discovery（集群发现机制）：<br> 如扩展集群时，启动第二个es进程，那个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard</li>\n<li>shard的负载均衡<br> 举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求<br> 其实是通过coordinate node 来处理的</li>\n</ul>\n<h2 id=\"es-集群的扩容方式\"><a href=\"#es-集群的扩容方式\" class=\"headerlink\" title=\"es 集群的扩容方式\"></a>es 集群的扩容方式</h2><pre><code>如现有集群 3集群 每台服务器能容纳1T数据 3个node 3个primary shard replica shard 设置为2  \n</code></pre>\n<ul>\n<li>水平扩容<br> 集群数量+1 当前服务器*4 增加一个node节点 now 4个node 通过master node 将 replica shard copy过去 （现有primary shard 已经最大）<br> 优点：提升集群的容错性能，多一个node 可以更好的应对单节点故障所产生的风险，提供并发处理能力<br> <img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/es%E9%9B%86%E7%BE%A4%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9.jpg\" alt=\"es 集群 结构图\"> </li>\n<li>垂直扩容<br> 集群数量不变，增加某台服务内存或者集群内所有的机器加内存，比如 由现有的1T 变为2T<br> 优点：使得单台node的处理性能变的更佳<br> 缺点：垂直扩容，成本相对应的成倍增加，应对节点故障，对比扩容前无改变<br>一般采用水平扩容。</li>\n</ul>\n<h3 id=\"水平扩容的极限-以及如何提高容错性\"><a href=\"#水平扩容的极限-以及如何提高容错性\" class=\"headerlink\" title=\"水平扩容的极限 以及如何提高容错性\"></a>水平扩容的极限 以及如何提高容错性</h3><pre><code>* primary&amp;replica自动负载均衡，6个shard 3个primary shard 3个replica shard\n* 每个node 有更少的shard，这是 IO/CUP/Mamory 资源给每个shard也就越多，每个shard的性能也就越好\n* 扩容极限 6个shard（3个primary 3个replica） 最多扩容到6台机器，一个shard独享node的 所有资源 性能最好\n* 超出扩容极限 动态修改replica数量，9个shard（3个primary 6个replica），9台机器比3台机器时 拥有了3倍的吞吐量\n* 容错 3台机器 6个shard（3个primary 3个replica）容忍1台机器宕机，3台机器 9个shard（3个primary 6个replica）容忍2台机器宕机，同一个primary与replica不能同时在一个node上出现\n</code></pre>\n<h2 id=\"es-集群的master节点\"><a href=\"#es-集群的master节点\" class=\"headerlink\" title=\"es 集群的master节点\"></a>es 集群的master节点</h2><pre><code>* master 节点不会承载所有的请求，所有不会有单点瓶颈\n* 管理es集群的元数据：\n    比如document的创建、修改和删除，维护索引的元数据；节点的新增和删除，维护集群的元数据（水平扩容）\n* 默认情况下，集群会自动选举出一个master节点，如master节点出现故障后，集群会在剩余节点中选出一个master节点\n</code></pre>\n<h2 id=\"节点平等的分布式架构\"><a href=\"#节点平等的分布式架构\" class=\"headerlink\" title=\"节点平等的分布式架构\"></a>节点平等的分布式架构</h2><pre><code>* 节点对等，每个节点都可以接收到所有请求\n* 自动请求路由 client的请求发送到某个节点时，这个节点会自动去请求对应的index  \n* 相应收集 收到请求的节点，将请求转发出去后，相应结果会返回改节点 有改节点统一发给client 这个节点 就是 coordidata node\n</code></pre>\n<h2 id=\"写一致性以及quorum机制\"><a href=\"#写一致性以及quorum机制\" class=\"headerlink\" title=\"写一致性以及quorum机制\"></a>写一致性以及quorum机制</h2><h3 id=\"写一致性\"><a href=\"#写一致性\" class=\"headerlink\" title=\"写一致性\"></a>写一致性</h3><pre><code>在发送任何es的 增删改操作时，都可以带一个consistency参数，来指明想要的写一致性是什么  \nconsistency： one、all、quorum\n* one: 要求写操作时，只要&lt;font color=red&gt;有一个primary shard&lt;/font&gt; 是active，就可以执行\n* all：要求写操作时，必须&lt;font color=red&gt;所有的primary shard 和replica shard&lt;/font&gt; 都是active，才可以执行这个写操作\n* quorum: 要求所有的shard中，必须是&lt;font color=red&gt;大部分shard&lt;/font&gt; 都是active，才可以执行这个写操作\n</code></pre>\n<h3 id=\"quorum机制\"><a href=\"#quorum机制\" class=\"headerlink\" title=\"quorum机制\"></a>quorum机制</h3><pre><code>写之前 需确保大多数的shard是可用的，且只有在 &lt;font color=red&gt;number_of_replica &gt; 1是才生效&lt;/font&gt;  \nquroum = int((primary + number_of_replica)/2 ) + 1  \n\n* 场景1 3台服务器 3个primary replicas 为1 6个shard： 3primary replica：1*3 \n    quroum = int ((3+ 1)/2) + 1 = 3  \n    也就是说明 3台服务器 6个shard 时 有两个node 也就是4个shard是active时 可以进行写操作\n* 场景2 3台服务器 3个primary 3个replica  \n     quroum = int ((3+ 3)/2) + 1 = 4 当shard 中active数&gt;4时可进行写操作  \n     注：如果此时宕机2台机器 那么shard的active数 只有3 这时不能进行写操作 但是可以进行读操作\n     \n* 场景3 单机场景下 一个primary shard replica 默认为1 0个active  \n    因为 number_of_replica = 1 不触发quroum 一致性 也就是说可以支持读写操作\n\n* time_out 当quorum 不齐全时，es会等待wait  \n    默认1分钟 time_out可以设置时长 可长可短 time_out=30s time_out=30ms time_out=1m  \n    超时则写入失败\n    格式 PUT test_index/type/1?time_out=30ms\n</code></pre>\n<h2 id=\"如何进行版本控制\"><a href=\"#如何进行版本控制\" class=\"headerlink\" title=\"如何进行版本控制\"></a>如何进行版本控制</h2><ul>\n<li><p>乐观锁并发控制方案<br>  基于版本号来判断，当前操作的document是否为最新，每次操作前对比当前版本号与es集群之前的差别</p>\n</li>\n<li><p>悲观锁并发控制方案<br>  在各种情况下都上锁，上锁之后，就只有一个线程可以操作这一条数据了，不同场景下锁不同，如：行锁，表锁，读锁，写锁等。</p>\n</li>\n</ul>\n<h3 id=\"es基于乐观锁实现的版本控制\"><a href=\"#es基于乐观锁实现的版本控制\" class=\"headerlink\" title=\"es基于乐观锁实现的版本控制\"></a>es基于乐观锁实现的版本控制</h3><ul>\n<li><p>基于系统自带的版本号</p>\n<ul>\n<li>老版本 进行写操作时，在操作语句后面添加_version=n(n:表示es集群中document的版本号)，与集群中的version比较，小于版本号时不执行更新操作</li>\n<li>新版本 在写操作时，取消_version字段，改为 if_seq_no=n&amp;if_primary_term来比较版本，取值分别取查询结果中的_seq_no和_primary_term<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class=\"line\">  &quot;_type&quot; : &quot;type&quot;,</span><br><span class=\"line\">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class=\"line\">  &quot;_version&quot; : 4,</span><br><span class=\"line\">  &quot;_seq_no&quot; : 4,</span><br><span class=\"line\">  &quot;_primary_term&quot; : 1,</span><br><span class=\"line\">  &quot;found&quot; : true,</span><br><span class=\"line\">  &quot;_source&quot; : &#123;</span><br><span class=\"line\">    &quot;test_fild&quot; : &quot;test1-3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>业务所用的版本号<br> 在写操作时，添加version=5&amp;version_type=external 这里的5位外部业务系统控制的版本号为5</p>\n</li>\n</ul>\n<h3 id=\"partial-update乐观锁并发控制\"><a href=\"#partial-update乐观锁并发控制\" class=\"headerlink\" title=\"partial update乐观锁并发控制\"></a>partial update乐观锁并发控制</h3><p>partial update 内部会自动执行 乐观锁的并发控制策略 如果发现版本号不一致时，partial update 会自动 fail掉</p>\n<p>重试策略： retry策略</p>\n<ul>\n<li>再次获取document数据和最新的版本号  </li>\n<li>基于最新的版本号再次去更新，如果成功就return</li>\n<li>如果失败了，重复执行1和2步骤，具体重试次数,可通过设置retry的参数指定执行次数</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"es-分布式框架简述\"><a href=\"#es-分布式框架简述\" class=\"headerlink\" title=\"es 分布式框架简述\"></a>es 分布式框架简述</h1><h2 id=\"es-对分布式机制的透明隐藏特性\"><a href=\"#es-对分布式机制的透明隐藏特性\" class=\"headerlink\" title=\"es 对分布式机制的透明隐藏特性\"></a>es 对分布式机制的透明隐藏特性</h2><p>Elasticsearch是一套分布式的系统，分布式是为了应对大数据量隐藏了复杂的分布式机制</p>\n<ul>\n<li>分片机制<br> 将数据写入document时，数据如何进行分片，写入那个shard中等等</li>\n<li>cluster discovery（集群发现机制）：<br> 如扩展集群时，启动第二个es进程，那个进程作为一个node自动就发现了集群，并且加入了进去，还接受了部分数据，replica shard</li>\n<li>shard的负载均衡<br> 举例，假设现在有3个节点，总共有25个shard要分配到3个节点上去，es会自动进行均匀分配，以保持每个节点的均衡的读写负载请求<br> 其实是通过coordinate node 来处理的</li>\n</ul>\n<h2 id=\"es-集群的扩容方式\"><a href=\"#es-集群的扩容方式\" class=\"headerlink\" title=\"es 集群的扩容方式\"></a>es 集群的扩容方式</h2><pre><code>如现有集群 3集群 每台服务器能容纳1T数据 3个node 3个primary shard replica shard 设置为2  \n</code></pre>\n<ul>\n<li>水平扩容<br> 集群数量+1 当前服务器*4 增加一个node节点 now 4个node 通过master node 将 replica shard copy过去 （现有primary shard 已经最大）<br> 优点：提升集群的容错性能，多一个node 可以更好的应对单节点故障所产生的风险，提供并发处理能力<br> <img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/es%E9%9B%86%E7%BE%A4%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9.jpg\" alt=\"es 集群 结构图\"> </li>\n<li>垂直扩容<br> 集群数量不变，增加某台服务内存或者集群内所有的机器加内存，比如 由现有的1T 变为2T<br> 优点：使得单台node的处理性能变的更佳<br> 缺点：垂直扩容，成本相对应的成倍增加，应对节点故障，对比扩容前无改变<br>一般采用水平扩容。</li>\n</ul>\n<h3 id=\"水平扩容的极限-以及如何提高容错性\"><a href=\"#水平扩容的极限-以及如何提高容错性\" class=\"headerlink\" title=\"水平扩容的极限 以及如何提高容错性\"></a>水平扩容的极限 以及如何提高容错性</h3><pre><code>* primary&amp;replica自动负载均衡，6个shard 3个primary shard 3个replica shard\n* 每个node 有更少的shard，这是 IO/CUP/Mamory 资源给每个shard也就越多，每个shard的性能也就越好\n* 扩容极限 6个shard（3个primary 3个replica） 最多扩容到6台机器，一个shard独享node的 所有资源 性能最好\n* 超出扩容极限 动态修改replica数量，9个shard（3个primary 6个replica），9台机器比3台机器时 拥有了3倍的吞吐量\n* 容错 3台机器 6个shard（3个primary 3个replica）容忍1台机器宕机，3台机器 9个shard（3个primary 6个replica）容忍2台机器宕机，同一个primary与replica不能同时在一个node上出现\n</code></pre>\n<h2 id=\"es-集群的master节点\"><a href=\"#es-集群的master节点\" class=\"headerlink\" title=\"es 集群的master节点\"></a>es 集群的master节点</h2><pre><code>* master 节点不会承载所有的请求，所有不会有单点瓶颈\n* 管理es集群的元数据：\n    比如document的创建、修改和删除，维护索引的元数据；节点的新增和删除，维护集群的元数据（水平扩容）\n* 默认情况下，集群会自动选举出一个master节点，如master节点出现故障后，集群会在剩余节点中选出一个master节点\n</code></pre>\n<h2 id=\"节点平等的分布式架构\"><a href=\"#节点平等的分布式架构\" class=\"headerlink\" title=\"节点平等的分布式架构\"></a>节点平等的分布式架构</h2><pre><code>* 节点对等，每个节点都可以接收到所有请求\n* 自动请求路由 client的请求发送到某个节点时，这个节点会自动去请求对应的index  \n* 相应收集 收到请求的节点，将请求转发出去后，相应结果会返回改节点 有改节点统一发给client 这个节点 就是 coordidata node\n</code></pre>\n<h2 id=\"写一致性以及quorum机制\"><a href=\"#写一致性以及quorum机制\" class=\"headerlink\" title=\"写一致性以及quorum机制\"></a>写一致性以及quorum机制</h2><h3 id=\"写一致性\"><a href=\"#写一致性\" class=\"headerlink\" title=\"写一致性\"></a>写一致性</h3><pre><code>在发送任何es的 增删改操作时，都可以带一个consistency参数，来指明想要的写一致性是什么  \nconsistency： one、all、quorum\n* one: 要求写操作时，只要&lt;font color=red&gt;有一个primary shard&lt;/font&gt; 是active，就可以执行\n* all：要求写操作时，必须&lt;font color=red&gt;所有的primary shard 和replica shard&lt;/font&gt; 都是active，才可以执行这个写操作\n* quorum: 要求所有的shard中，必须是&lt;font color=red&gt;大部分shard&lt;/font&gt; 都是active，才可以执行这个写操作\n</code></pre>\n<h3 id=\"quorum机制\"><a href=\"#quorum机制\" class=\"headerlink\" title=\"quorum机制\"></a>quorum机制</h3><pre><code>写之前 需确保大多数的shard是可用的，且只有在 &lt;font color=red&gt;number_of_replica &gt; 1是才生效&lt;/font&gt;  \nquroum = int((primary + number_of_replica)/2 ) + 1  \n\n* 场景1 3台服务器 3个primary replicas 为1 6个shard： 3primary replica：1*3 \n    quroum = int ((3+ 1)/2) + 1 = 3  \n    也就是说明 3台服务器 6个shard 时 有两个node 也就是4个shard是active时 可以进行写操作\n* 场景2 3台服务器 3个primary 3个replica  \n     quroum = int ((3+ 3)/2) + 1 = 4 当shard 中active数&gt;4时可进行写操作  \n     注：如果此时宕机2台机器 那么shard的active数 只有3 这时不能进行写操作 但是可以进行读操作\n     \n* 场景3 单机场景下 一个primary shard replica 默认为1 0个active  \n    因为 number_of_replica = 1 不触发quroum 一致性 也就是说可以支持读写操作\n\n* time_out 当quorum 不齐全时，es会等待wait  \n    默认1分钟 time_out可以设置时长 可长可短 time_out=30s time_out=30ms time_out=1m  \n    超时则写入失败\n    格式 PUT test_index/type/1?time_out=30ms\n</code></pre>\n<h2 id=\"如何进行版本控制\"><a href=\"#如何进行版本控制\" class=\"headerlink\" title=\"如何进行版本控制\"></a>如何进行版本控制</h2><ul>\n<li><p>乐观锁并发控制方案<br>  基于版本号来判断，当前操作的document是否为最新，每次操作前对比当前版本号与es集群之前的差别</p>\n</li>\n<li><p>悲观锁并发控制方案<br>  在各种情况下都上锁，上锁之后，就只有一个线程可以操作这一条数据了，不同场景下锁不同，如：行锁，表锁，读锁，写锁等。</p>\n</li>\n</ul>\n<h3 id=\"es基于乐观锁实现的版本控制\"><a href=\"#es基于乐观锁实现的版本控制\" class=\"headerlink\" title=\"es基于乐观锁实现的版本控制\"></a>es基于乐观锁实现的版本控制</h3><ul>\n<li><p>基于系统自带的版本号</p>\n<ul>\n<li>老版本 进行写操作时，在操作语句后面添加_version=n(n:表示es集群中document的版本号)，与集群中的version比较，小于版本号时不执行更新操作</li>\n<li>新版本 在写操作时，取消_version字段，改为 if_seq_no=n&amp;if_primary_term来比较版本，取值分别取查询结果中的_seq_no和_primary_term<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class=\"line\">  &quot;_type&quot; : &quot;type&quot;,</span><br><span class=\"line\">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class=\"line\">  &quot;_version&quot; : 4,</span><br><span class=\"line\">  &quot;_seq_no&quot; : 4,</span><br><span class=\"line\">  &quot;_primary_term&quot; : 1,</span><br><span class=\"line\">  &quot;found&quot; : true,</span><br><span class=\"line\">  &quot;_source&quot; : &#123;</span><br><span class=\"line\">    &quot;test_fild&quot; : &quot;test1-3&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>业务所用的版本号<br> 在写操作时，添加version=5&amp;version_type=external 这里的5位外部业务系统控制的版本号为5</p>\n</li>\n</ul>\n<h3 id=\"partial-update乐观锁并发控制\"><a href=\"#partial-update乐观锁并发控制\" class=\"headerlink\" title=\"partial update乐观锁并发控制\"></a>partial update乐观锁并发控制</h3><p>partial update 内部会自动执行 乐观锁的并发控制策略 如果发现版本号不一致时，partial update 会自动 fail掉</p>\n<p>重试策略： retry策略</p>\n<ul>\n<li>再次获取document数据和最新的版本号  </li>\n<li>基于最新的版本号再次去更新，如果成功就return</li>\n<li>如果失败了，重复执行1和2步骤，具体重试次数,可通过设置retry的参数指定执行次数</li>\n</ul>\n"},{"title":"es基础知识","date":"2021-09-16T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是 elasticsearch？\n它是一个分布式、可扩展、实时的搜索与数据分析引擎。  \n它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。  \n以下 简称 es\n\n## es在Windows环境下的安装\n1、安装JDK，至少1.8.0_73以上版本，java -version  \n2、下载和解压缩Elasticsearch安装包，目录结构,<a href=\"https://pan.baidu.com/s/1HsHIWr2NMdQsg5jC1F9LwQ\"><font color=red>安装包链接</font></a>,提取码：bepq\n3、启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了出现started就是启动成功了。\n![es-windows启动](https://kubpang.gitee.io/sourceFile/elasticsearch/es-windows启动.jpg) \n4、检查ES是否启动成功：http://localhost:9200/?pretty\n```\nname: node名称\ncluster_name: 集群名称（默认的集群名称就是elasticsearch）\nversion.number: 5.2.0，es版本号\n{\n  \"name\" : \"4onsTYV\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"nKZ9VK_vQdSQ1J0Dx9gx1Q\",\n  \"version\" : {\n    \"number\" : \"5.2.0\",\n    \"build_hash\" : \"24e05b9\",\n    \"build_date\" : \"2017-01-24T19:52:35.800Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"6.4.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n5、修改集群名称：elasticsearch.yml\n6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口\n7、启动Kibana：bin\\kibana.bat\n8、访问http://localhost:5601 进入Dev Tools界面\n9、在Dev Tools界面上运行 GET _cluster/health\n\n## 端口号9300与9200区别\n    区别：  \n    9300端口：ES节点之间通讯使用  \n    9200端口：ES节点和外部通讯使用  \n\n    9300是TCP协议端口号，ES集群之间通讯的端口号  \n    9200端口号，暴露ES Restful接口端口号\n\n# lucene 与 es 的关系\nlucene 是最先进、功能最强大的搜索库。  \n如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。  \n\nes 基于lucene， 隐蔽了 lucene的复杂性，提供了restful api 和 java api接口（还有其他语言的api接口）  \n特点：  \n* 分布式的文档存储引擎\n* 分布式的搜索引擎和分析引擎\n* 分布式 支持PB级数据\n\n# es 的核心概念 \n    near realtime(准实时)、cluster集群、node节点、  \n    document&field、index、shard、replica\n\n## Near realtime 准实时\n* 从写入数据到数据可以被搜索有一个时间延迟（大概1s）\n* 基于es执行搜索和分析可以达到秒级 \n  \n## Node 节点 \nNode 是集群中的一个节点，节点也有一个名称，默认是随机分配的。  \n默认节点会去加入一个名称为 elasticsearch 的集群。  \n如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。\n\n## cluster 集群\n集群包含多个节点，每个节点属于哪个集群可以<font color=red>通过 elasticsearch.yml </font>配置文件来决定  \n中小型应用开始一个集群一个节点也正常\n\n## Document & field\n文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据。  \n通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。  \n一个 document 里面<font color=red>有多个 field</font>，每个 field 就是一个数据字段。\n```json\n{\n    \"product_id\": \"1\",\n    \"product_name\": \"iPhone X\",\n    \"product_desc\": \"苹果手机\",\n    \"category_id\": \"2\",\n    \"category_name\": \"电子产品\"\n}\n```  \n### document -文档 \nes集群中document 有点类似于 DB中的表，而document中的field则对应DB中的表字段 所以es依据这个结构特性，适应在NOSQL中使用\n\n### document查询内部原理\n* client 请求到任意一个node 使其成为coordinate node\n* coordinate node 对document进行路由，将请求转发对应的node，此时会使用round-robin随机轮询算法，在所有的primary shard 和replica shard中随机取一个，让读请求负载均衡\n* 接收请求shard对应的node 会将响应结果返回coordinate node\n* coordinate node 再返回的client\n\n特殊场景可能无法读取到document：document还在建立索引过程中，可能只在primary shard上有，replica没有，此时round-robin刚好随机指定了replica，从而导致document无法正常读取到，但是在其索引建立完成后，primary 和 replica可以正常读取\n\n![document读请求内部原理](https://kubpang.gitee.io/sourceFile/elasticsearch/document读请求内部原理.png) \n\n## index - 索引\n索引包含了一堆有相似结构的文档数据，比如商品索引。   \n一个索引包含<font color=red>很多 document</font>，一个索引就代表了一类相似或者相同的 document,操作时<font color=red>index能是小写，可以包含下划线</font>。\n\n## type - 类型 \n每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。    \n每个 type 下的 document 的 field 可能不太一样。 \n<font color=red>注意：</font> 6.x 只有一个type 7.x后 type取消\n\n\n## mapping \nindex的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为，简称为mapping  \ndynamic mapping：自动建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及分词等设置  \nes 在自动建立mapping的时候，对不同的field设置了data type，而不同data type的 分词、搜索等行为是不一致的，所以会导致 在在_search时，_all_field 和 指定字段的查询方式返回的结果可能不一致  \n查看mapping\n```shell script\n#GET /index/_mapping/?pretty\nGET /student/_mapping/?pretty\n```\n\n### 精准匹配与全文搜索的对比\n* exact value: 精准匹配\n    只有搜索内容与查询内容一致时才可以被查询出来\n* full text： 全文检索 不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配\n    * 缩写 vs. 全程：cn vs. china\n    * 格式转化：like liked likes\n    * 大小写：Tom vs tom\n    * 同义词：like vs love\n\n### mapping的核心数据类型\n字符串类型：string\n整形：byte，short，integer，long\n浮点类型：float，double\n布尔类型：boolean\n日期类型：date\n\n### dynamic mapping\ntrue or false\t-->\tboolean\n123\t\t-->\tlong\n123.45\t\t-->\tdouble\n2017-01-01\t-->\tdate\n\"hello world\"\t-->\tstring/text\n\n### 如何建立索引\nanalyzed ：建立分词\nnot_analyzed: 不建立分词\nno：不被索引和搜索\n\n### 修改mapping\n只能建立index是手动建立mapping，或者新增field mapping，但是不能 update field mapping\n```shell script\n#6.x 版本正常运行 7.x 版本执行错误\n#新建field mapping\nPUT /website\n{\n  \"mappings\": {\n    \"article\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"long\"\n        },\n        \"title\": {\n          \"type\": \"text\",\n          \"analyzer\": \"english\"\n        },\n        \"content\": {\n          \"type\": \"text\"\n        },\n        \"post_date\": {\n          \"type\": \"date\"\n        },\n        \"publisher_id\": {\n          \"type\": \"text\",\n          \"index\": \"not_analyzed\"\n        }\n      }\n    }\n  }\n}\n\n#7.x 去掉了type \nPUT /website\n{\n  \"mappings\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"long\"\n        },\n        \"title\": {\n          \"type\": \"text\",\n          \"analyzer\": \"english\"\n        },\n        \"content\": {\n          \"type\": \"text\"\n        },\n        \"post_date\": {\n          \"type\": \"date\"\n        },\n        \"publisher_id\": {\n          \"type\": \"text\",\n          \"index\": false\n        }\n      }\n  }\n}\n\nPUT /website/_mapping/article\n{\n  \"properties\" : {\n    \"new_field\" : {\n      \"type\" :    \"string\",\n      \"index\":    \"not_analyzed\"\n    }\n  }\n}\n\n# 修改field mapping 异常\nPUT /website\n{\n  \"mappings\": {\n    \"article\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"text\"\n        }\n      }\n    }\n  }\n}\n\n{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"index_already_exists_exception\",\n        \"reason\": \"index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists\",\n        \"index_uuid\": \"co1dgJ-uTYGBEEOOL8GsQQ\",\n        \"index\": \"website\"\n      }\n    ],\n    \"type\": \"index_already_exists_exception\",\n    \"reason\": \"index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists\",\n    \"index_uuid\": \"co1dgJ-uTYGBEEOOL8GsQQ\",\n    \"index\": \"website\"\n  },\n  \"status\": 400\n}\n```\n\n### mapping 总结\n* 往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping\n* mapping中就自动定义了每个field的数据类型\n* 不同的数据类型（比如说text和date），可能有的是exact value，有的是full text\n* exact value，在建立倒排索引的时候，分词的时候，是将整个值一起作为<font color=red>一个关键词</font>建立到倒排索引中的；full text，会经历各种各样的处理，分词，normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中\n* 同时呢，exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索\n* 可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为，包括分词器，等等\n\n## shard & replica\n* index包含多个shard\n\n* 每个shard都是一个最小工作单元，承载部分数据，每个 shard 都是一个 <font color=red>lucene 实例</font>。，有完整的建立索引和处理请求的能力。\n\n* 增减节点时，shard会自动在nodes中负载均衡（尽量保证每个节点都是一样的负载）\n\n* primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard\n\n* replica shard是primary shard的副本，负责容错，以及承担读请求负载\n\n* primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改，primary shard的数量是不能的修改的。\n\n* primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard（每个primary shard都对应一个replica shard）\n\n* primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上\n\n## replica - 副本 (replica shard 简称 replica)\n当服务出现宕机时，shard可能会丢失，因此可以为每个shard创建多个replica副本。  \nreplica 可以在shard出现故障时提供备用服务，保障数据不会丢失，多个replica可以提升搜索的吞吐量和性能。    \nprimary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。\n\n![es 集群 结构图](https://kubpang.gitee.io/sourceFile/elasticsearch/elasticsearch-2.png) \n\n# es 核心数据 与 db的比较 \n|es|db|\n|:---:|:---:|\n|index|库|\n|type|表|\n|document|一行数据|     \n\n\n\n\n资源路径：https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction\n\n","source":"_posts/lh/elasticsearch/es初讲.md","raw":"---\ntitle: es基础知识\ndate: 2021-09-17 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: es\ntags:  \n    - es\n---\n\n# 什么是 elasticsearch？\n它是一个分布式、可扩展、实时的搜索与数据分析引擎。  \n它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。  \n以下 简称 es\n\n## es在Windows环境下的安装\n1、安装JDK，至少1.8.0_73以上版本，java -version  \n2、下载和解压缩Elasticsearch安装包，目录结构,<a href=\"https://pan.baidu.com/s/1HsHIWr2NMdQsg5jC1F9LwQ\"><font color=red>安装包链接</font></a>,提取码：bepq\n3、启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了出现started就是启动成功了。\n![es-windows启动](https://kubpang.gitee.io/sourceFile/elasticsearch/es-windows启动.jpg) \n4、检查ES是否启动成功：http://localhost:9200/?pretty\n```\nname: node名称\ncluster_name: 集群名称（默认的集群名称就是elasticsearch）\nversion.number: 5.2.0，es版本号\n{\n  \"name\" : \"4onsTYV\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"nKZ9VK_vQdSQ1J0Dx9gx1Q\",\n  \"version\" : {\n    \"number\" : \"5.2.0\",\n    \"build_hash\" : \"24e05b9\",\n    \"build_date\" : \"2017-01-24T19:52:35.800Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"6.4.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n5、修改集群名称：elasticsearch.yml\n6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口\n7、启动Kibana：bin\\kibana.bat\n8、访问http://localhost:5601 进入Dev Tools界面\n9、在Dev Tools界面上运行 GET _cluster/health\n\n## 端口号9300与9200区别\n    区别：  \n    9300端口：ES节点之间通讯使用  \n    9200端口：ES节点和外部通讯使用  \n\n    9300是TCP协议端口号，ES集群之间通讯的端口号  \n    9200端口号，暴露ES Restful接口端口号\n\n# lucene 与 es 的关系\nlucene 是最先进、功能最强大的搜索库。  \n如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。  \n\nes 基于lucene， 隐蔽了 lucene的复杂性，提供了restful api 和 java api接口（还有其他语言的api接口）  \n特点：  \n* 分布式的文档存储引擎\n* 分布式的搜索引擎和分析引擎\n* 分布式 支持PB级数据\n\n# es 的核心概念 \n    near realtime(准实时)、cluster集群、node节点、  \n    document&field、index、shard、replica\n\n## Near realtime 准实时\n* 从写入数据到数据可以被搜索有一个时间延迟（大概1s）\n* 基于es执行搜索和分析可以达到秒级 \n  \n## Node 节点 \nNode 是集群中的一个节点，节点也有一个名称，默认是随机分配的。  \n默认节点会去加入一个名称为 elasticsearch 的集群。  \n如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。\n\n## cluster 集群\n集群包含多个节点，每个节点属于哪个集群可以<font color=red>通过 elasticsearch.yml </font>配置文件来决定  \n中小型应用开始一个集群一个节点也正常\n\n## Document & field\n文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据。  \n通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。  \n一个 document 里面<font color=red>有多个 field</font>，每个 field 就是一个数据字段。\n```json\n{\n    \"product_id\": \"1\",\n    \"product_name\": \"iPhone X\",\n    \"product_desc\": \"苹果手机\",\n    \"category_id\": \"2\",\n    \"category_name\": \"电子产品\"\n}\n```  \n### document -文档 \nes集群中document 有点类似于 DB中的表，而document中的field则对应DB中的表字段 所以es依据这个结构特性，适应在NOSQL中使用\n\n### document查询内部原理\n* client 请求到任意一个node 使其成为coordinate node\n* coordinate node 对document进行路由，将请求转发对应的node，此时会使用round-robin随机轮询算法，在所有的primary shard 和replica shard中随机取一个，让读请求负载均衡\n* 接收请求shard对应的node 会将响应结果返回coordinate node\n* coordinate node 再返回的client\n\n特殊场景可能无法读取到document：document还在建立索引过程中，可能只在primary shard上有，replica没有，此时round-robin刚好随机指定了replica，从而导致document无法正常读取到，但是在其索引建立完成后，primary 和 replica可以正常读取\n\n![document读请求内部原理](https://kubpang.gitee.io/sourceFile/elasticsearch/document读请求内部原理.png) \n\n## index - 索引\n索引包含了一堆有相似结构的文档数据，比如商品索引。   \n一个索引包含<font color=red>很多 document</font>，一个索引就代表了一类相似或者相同的 document,操作时<font color=red>index能是小写，可以包含下划线</font>。\n\n## type - 类型 \n每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。    \n每个 type 下的 document 的 field 可能不太一样。 \n<font color=red>注意：</font> 6.x 只有一个type 7.x后 type取消\n\n\n## mapping \nindex的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为，简称为mapping  \ndynamic mapping：自动建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及分词等设置  \nes 在自动建立mapping的时候，对不同的field设置了data type，而不同data type的 分词、搜索等行为是不一致的，所以会导致 在在_search时，_all_field 和 指定字段的查询方式返回的结果可能不一致  \n查看mapping\n```shell script\n#GET /index/_mapping/?pretty\nGET /student/_mapping/?pretty\n```\n\n### 精准匹配与全文搜索的对比\n* exact value: 精准匹配\n    只有搜索内容与查询内容一致时才可以被查询出来\n* full text： 全文检索 不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配\n    * 缩写 vs. 全程：cn vs. china\n    * 格式转化：like liked likes\n    * 大小写：Tom vs tom\n    * 同义词：like vs love\n\n### mapping的核心数据类型\n字符串类型：string\n整形：byte，short，integer，long\n浮点类型：float，double\n布尔类型：boolean\n日期类型：date\n\n### dynamic mapping\ntrue or false\t-->\tboolean\n123\t\t-->\tlong\n123.45\t\t-->\tdouble\n2017-01-01\t-->\tdate\n\"hello world\"\t-->\tstring/text\n\n### 如何建立索引\nanalyzed ：建立分词\nnot_analyzed: 不建立分词\nno：不被索引和搜索\n\n### 修改mapping\n只能建立index是手动建立mapping，或者新增field mapping，但是不能 update field mapping\n```shell script\n#6.x 版本正常运行 7.x 版本执行错误\n#新建field mapping\nPUT /website\n{\n  \"mappings\": {\n    \"article\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"long\"\n        },\n        \"title\": {\n          \"type\": \"text\",\n          \"analyzer\": \"english\"\n        },\n        \"content\": {\n          \"type\": \"text\"\n        },\n        \"post_date\": {\n          \"type\": \"date\"\n        },\n        \"publisher_id\": {\n          \"type\": \"text\",\n          \"index\": \"not_analyzed\"\n        }\n      }\n    }\n  }\n}\n\n#7.x 去掉了type \nPUT /website\n{\n  \"mappings\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"long\"\n        },\n        \"title\": {\n          \"type\": \"text\",\n          \"analyzer\": \"english\"\n        },\n        \"content\": {\n          \"type\": \"text\"\n        },\n        \"post_date\": {\n          \"type\": \"date\"\n        },\n        \"publisher_id\": {\n          \"type\": \"text\",\n          \"index\": false\n        }\n      }\n  }\n}\n\nPUT /website/_mapping/article\n{\n  \"properties\" : {\n    \"new_field\" : {\n      \"type\" :    \"string\",\n      \"index\":    \"not_analyzed\"\n    }\n  }\n}\n\n# 修改field mapping 异常\nPUT /website\n{\n  \"mappings\": {\n    \"article\": {\n      \"properties\": {\n        \"author_id\": {\n          \"type\": \"text\"\n        }\n      }\n    }\n  }\n}\n\n{\n  \"error\": {\n    \"root_cause\": [\n      {\n        \"type\": \"index_already_exists_exception\",\n        \"reason\": \"index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists\",\n        \"index_uuid\": \"co1dgJ-uTYGBEEOOL8GsQQ\",\n        \"index\": \"website\"\n      }\n    ],\n    \"type\": \"index_already_exists_exception\",\n    \"reason\": \"index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists\",\n    \"index_uuid\": \"co1dgJ-uTYGBEEOOL8GsQQ\",\n    \"index\": \"website\"\n  },\n  \"status\": 400\n}\n```\n\n### mapping 总结\n* 往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping\n* mapping中就自动定义了每个field的数据类型\n* 不同的数据类型（比如说text和date），可能有的是exact value，有的是full text\n* exact value，在建立倒排索引的时候，分词的时候，是将整个值一起作为<font color=red>一个关键词</font>建立到倒排索引中的；full text，会经历各种各样的处理，分词，normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中\n* 同时呢，exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索\n* 可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为，包括分词器，等等\n\n## shard & replica\n* index包含多个shard\n\n* 每个shard都是一个最小工作单元，承载部分数据，每个 shard 都是一个 <font color=red>lucene 实例</font>。，有完整的建立索引和处理请求的能力。\n\n* 增减节点时，shard会自动在nodes中负载均衡（尽量保证每个节点都是一样的负载）\n\n* primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard\n\n* replica shard是primary shard的副本，负责容错，以及承担读请求负载\n\n* primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改，primary shard的数量是不能的修改的。\n\n* primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard（每个primary shard都对应一个replica shard）\n\n* primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上\n\n## replica - 副本 (replica shard 简称 replica)\n当服务出现宕机时，shard可能会丢失，因此可以为每个shard创建多个replica副本。  \nreplica 可以在shard出现故障时提供备用服务，保障数据不会丢失，多个replica可以提升搜索的吞吐量和性能。    \nprimary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。\n\n![es 集群 结构图](https://kubpang.gitee.io/sourceFile/elasticsearch/elasticsearch-2.png) \n\n# es 核心数据 与 db的比较 \n|es|db|\n|:---:|:---:|\n|index|库|\n|type|表|\n|document|一行数据|     \n\n\n\n\n资源路径：https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction\n\n","slug":"lh/elasticsearch/es初讲","published":1,"updated":"2021-10-27T06:24:25.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af865000ecst7bot331t1","content":"<h1 id=\"什么是-elasticsearch？\"><a href=\"#什么是-elasticsearch？\" class=\"headerlink\" title=\"什么是 elasticsearch？\"></a>什么是 elasticsearch？</h1><p>它是一个分布式、可扩展、实时的搜索与数据分析引擎。<br>它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。<br>以下 简称 es</p>\n<h2 id=\"es在Windows环境下的安装\"><a href=\"#es在Windows环境下的安装\" class=\"headerlink\" title=\"es在Windows环境下的安装\"></a>es在Windows环境下的安装</h2><p>1、安装JDK，至少1.8.0_73以上版本，java -version<br>2、下载和解压缩Elasticsearch安装包，目录结构,<a href=\"https://pan.baidu.com/s/1HsHIWr2NMdQsg5jC1F9LwQ\"><font color=red>安装包链接</font></a>,提取码：bepq<br>3、启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了出现started就是启动成功了。<br><img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/es-windows%E5%90%AF%E5%8A%A8.jpg\" alt=\"es-windows启动\"><br>4、检查ES是否启动成功：<a href=\"http://localhost:9200/?pretty\">http://localhost:9200/?pretty</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: node名称</span><br><span class=\"line\">cluster_name: 集群名称（默认的集群名称就是elasticsearch）</span><br><span class=\"line\">version.number: 5.2.0，es版本号</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot; : &quot;4onsTYV&quot;,</span><br><span class=\"line\">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class=\"line\">  &quot;cluster_uuid&quot; : &quot;nKZ9VK_vQdSQ1J0Dx9gx1Q&quot;,</span><br><span class=\"line\">  &quot;version&quot; : &#123;</span><br><span class=\"line\">    &quot;number&quot; : &quot;5.2.0&quot;,</span><br><span class=\"line\">    &quot;build_hash&quot; : &quot;24e05b9&quot;,</span><br><span class=\"line\">    &quot;build_date&quot; : &quot;2017-01-24T19:52:35.800Z&quot;,</span><br><span class=\"line\">    &quot;build_snapshot&quot; : false,</span><br><span class=\"line\">    &quot;lucene_version&quot; : &quot;6.4.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、修改集群名称：elasticsearch.yml<br>6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口<br>7、启动Kibana：bin\\kibana.bat<br>8、访问<a href=\"http://localhost:5601/\">http://localhost:5601</a> 进入Dev Tools界面<br>9、在Dev Tools界面上运行 GET _cluster/health</p>\n<h2 id=\"端口号9300与9200区别\"><a href=\"#端口号9300与9200区别\" class=\"headerlink\" title=\"端口号9300与9200区别\"></a>端口号9300与9200区别</h2><pre><code>区别：  \n9300端口：ES节点之间通讯使用  \n9200端口：ES节点和外部通讯使用  \n\n9300是TCP协议端口号，ES集群之间通讯的端口号  \n9200端口号，暴露ES Restful接口端口号\n</code></pre>\n<h1 id=\"lucene-与-es-的关系\"><a href=\"#lucene-与-es-的关系\" class=\"headerlink\" title=\"lucene 与 es 的关系\"></a>lucene 与 es 的关系</h1><p>lucene 是最先进、功能最强大的搜索库。<br>如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。  </p>\n<p>es 基于lucene， 隐蔽了 lucene的复杂性，提供了restful api 和 java api接口（还有其他语言的api接口）<br>特点：  </p>\n<ul>\n<li>分布式的文档存储引擎</li>\n<li>分布式的搜索引擎和分析引擎</li>\n<li>分布式 支持PB级数据</li>\n</ul>\n<h1 id=\"es-的核心概念\"><a href=\"#es-的核心概念\" class=\"headerlink\" title=\"es 的核心概念\"></a>es 的核心概念</h1><pre><code>near realtime(准实时)、cluster集群、node节点、  \ndocument&amp;field、index、shard、replica\n</code></pre>\n<h2 id=\"Near-realtime-准实时\"><a href=\"#Near-realtime-准实时\" class=\"headerlink\" title=\"Near realtime 准实时\"></a>Near realtime 准实时</h2><ul>\n<li>从写入数据到数据可以被搜索有一个时间延迟（大概1s）</li>\n<li>基于es执行搜索和分析可以达到秒级 </li>\n</ul>\n<h2 id=\"Node-节点\"><a href=\"#Node-节点\" class=\"headerlink\" title=\"Node 节点\"></a>Node 节点</h2><p>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。<br>默认节点会去加入一个名称为 elasticsearch 的集群。<br>如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</p>\n<h2 id=\"cluster-集群\"><a href=\"#cluster-集群\" class=\"headerlink\" title=\"cluster 集群\"></a>cluster 集群</h2><p>集群包含多个节点，每个节点属于哪个集群可以<font color=red>通过 elasticsearch.yml </font>配置文件来决定<br>中小型应用开始一个集群一个节点也正常</p>\n<h2 id=\"Document-amp-field\"><a href=\"#Document-amp-field\" class=\"headerlink\" title=\"Document &amp; field\"></a>Document &amp; field</h2><p>文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据。<br>通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。<br>一个 document 里面<font color=red>有多个 field</font>，每个 field 就是一个数据字段。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_id&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_name&quot;</span>: <span class=\"string\">&quot;iPhone X&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_desc&quot;</span>: <span class=\"string\">&quot;苹果手机&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;category_id&quot;</span>: <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;category_name&quot;</span>: <span class=\"string\">&quot;电子产品&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">### document -文档 </span><br><span class=\"line\">es集群中document 有点类似于 DB中的表，而document中的field则对应DB中的表字段 所以es依据这个结构特性，适应在NOSQL中使用</span><br><span class=\"line\"></span><br><span class=\"line\">### document查询内部原理</span><br><span class=\"line\">* client 请求到任意一个node 使其成为coordinate node</span><br><span class=\"line\">* coordinate node 对document进行路由，将请求转发对应的node，此时会使用round-robin随机轮询算法，在所有的primary shard 和replica shard中随机取一个，让读请求负载均衡</span><br><span class=\"line\">* 接收请求shard对应的node 会将响应结果返回coordinate node</span><br><span class=\"line\">* coordinate node 再返回的client</span><br><span class=\"line\"></span><br><span class=\"line\">特殊场景可能无法读取到document：document还在建立索引过程中，可能只在primary shard上有，replica没有，此时round-robin刚好随机指定了replica，从而导致document无法正常读取到，但是在其索引建立完成后，primary 和 replica可以正常读取</span><br><span class=\"line\"></span><br><span class=\"line\">![document读请求内部原理](https:<span class=\"comment\">//kubpang.gitee.io/sourceFile/elasticsearch/document读请求内部原理.png) </span></span><br><span class=\"line\"></span><br><span class=\"line\">## index - 索引</span><br><span class=\"line\">索引包含了一堆有相似结构的文档数据，比如商品索引。   </span><br><span class=\"line\">一个索引包含&lt;font color=red&gt;很多 document&lt;/font&gt;，一个索引就代表了一类相似或者相同的 document,操作时&lt;font color=red&gt;index能是小写，可以包含下划线&lt;/font&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\">## type - 类型 </span><br><span class=\"line\">每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。    </span><br><span class=\"line\">每个 type 下的 document 的 field 可能不太一样。 </span><br><span class=\"line\">&lt;font color=red&gt;注意：&lt;/font&gt; <span class=\"number\">6.</span>x 只有一个type <span class=\"number\">7.</span>x后 type取消</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## mapping </span><br><span class=\"line\">index的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为，简称为mapping  </span><br><span class=\"line\">dynamic mapping：自动建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及分词等设置  </span><br><span class=\"line\">es 在自动建立mapping的时候，对不同的field设置了data type，而不同data type的 分词、搜索等行为是不一致的，所以会导致 在在_search时，_all_field 和 指定字段的查询方式返回的结果可能不一致  </span><br><span class=\"line\">查看mapping</span><br><span class=\"line\">```shell script</span><br><span class=\"line\">#GET /index/_mapping/?pretty</span><br><span class=\"line\">GET /student/_mapping/?pretty</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"精准匹配与全文搜索的对比\"><a href=\"#精准匹配与全文搜索的对比\" class=\"headerlink\" title=\"精准匹配与全文搜索的对比\"></a>精准匹配与全文搜索的对比</h3><ul>\n<li>exact value: 精准匹配<br>  只有搜索内容与查询内容一致时才可以被查询出来</li>\n<li>full text： 全文检索 不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配<ul>\n<li>缩写 vs. 全程：cn vs. china</li>\n<li>格式转化：like liked likes</li>\n<li>大小写：Tom vs tom</li>\n<li>同义词：like vs love</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mapping的核心数据类型\"><a href=\"#mapping的核心数据类型\" class=\"headerlink\" title=\"mapping的核心数据类型\"></a>mapping的核心数据类型</h3><p>字符串类型：string<br>整形：byte，short，integer，long<br>浮点类型：float，double<br>布尔类型：boolean<br>日期类型：date</p>\n<h3 id=\"dynamic-mapping\"><a href=\"#dynamic-mapping\" class=\"headerlink\" title=\"dynamic mapping\"></a>dynamic mapping</h3><p>true or false    –&gt;    boolean<br>123        –&gt;    long<br>123.45        –&gt;    double<br>2017-01-01    –&gt;    date<br>“hello world”    –&gt;    string/text</p>\n<h3 id=\"如何建立索引\"><a href=\"#如何建立索引\" class=\"headerlink\" title=\"如何建立索引\"></a>如何建立索引</h3><p>analyzed ：建立分词<br>not_analyzed: 不建立分词<br>no：不被索引和搜索</p>\n<h3 id=\"修改mapping\"><a href=\"#修改mapping\" class=\"headerlink\" title=\"修改mapping\"></a>修改mapping</h3><p>只能建立index是手动建立mapping，或者新增field mapping，但是不能 update field mapping</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">6.x 版本正常运行 7.x 版本执行错误</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">新建field mapping</span></span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">    &quot;article&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;long&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;title&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;content&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;post_date&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;date&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;publisher_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">7.x 去掉了<span class=\"built_in\">type</span></span> </span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;long&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;title&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;content&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;post_date&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;date&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;publisher_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;index&quot;: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /website/_mapping/article</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;properties&quot; : &#123;</span><br><span class=\"line\">    &quot;new_field&quot; : &#123;</span><br><span class=\"line\">      &quot;type&quot; :    &quot;string&quot;,</span><br><span class=\"line\">      &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改field mapping 异常</span></span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">    &quot;article&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;error&quot;: &#123;</span><br><span class=\"line\">    &quot;root_cause&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;index_already_exists_exception&quot;,</span><br><span class=\"line\">        &quot;reason&quot;: &quot;index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists&quot;,</span><br><span class=\"line\">        &quot;index_uuid&quot;: &quot;co1dgJ-uTYGBEEOOL8GsQQ&quot;,</span><br><span class=\"line\">        &quot;index&quot;: &quot;website&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;type&quot;: &quot;index_already_exists_exception&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists&quot;,</span><br><span class=\"line\">    &quot;index_uuid&quot;: &quot;co1dgJ-uTYGBEEOOL8GsQQ&quot;,</span><br><span class=\"line\">    &quot;index&quot;: &quot;website&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;status&quot;: 400</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mapping-总结\"><a href=\"#mapping-总结\" class=\"headerlink\" title=\"mapping 总结\"></a>mapping 总结</h3><ul>\n<li>往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping</li>\n<li>mapping中就自动定义了每个field的数据类型</li>\n<li>不同的数据类型（比如说text和date），可能有的是exact value，有的是full text</li>\n<li>exact value，在建立倒排索引的时候，分词的时候，是将整个值一起作为<font color=red>一个关键词</font>建立到倒排索引中的；full text，会经历各种各样的处理，分词，normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中</li>\n<li>同时呢，exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索</li>\n<li>可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为，包括分词器，等等</li>\n</ul>\n<h2 id=\"shard-amp-replica\"><a href=\"#shard-amp-replica\" class=\"headerlink\" title=\"shard &amp; replica\"></a>shard &amp; replica</h2><ul>\n<li><p>index包含多个shard</p>\n</li>\n<li><p>每个shard都是一个最小工作单元，承载部分数据，每个 shard 都是一个 <font color=red>lucene 实例</font>。，有完整的建立索引和处理请求的能力。</p>\n</li>\n<li><p>增减节点时，shard会自动在nodes中负载均衡（尽量保证每个节点都是一样的负载）</p>\n</li>\n<li><p>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard</p>\n</li>\n<li><p>replica shard是primary shard的副本，负责容错，以及承担读请求负载</p>\n</li>\n<li><p>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改，primary shard的数量是不能的修改的。</p>\n</li>\n<li><p>primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard（每个primary shard都对应一个replica shard）</p>\n</li>\n<li><p>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上</p>\n</li>\n</ul>\n<h2 id=\"replica-副本-replica-shard-简称-replica\"><a href=\"#replica-副本-replica-shard-简称-replica\" class=\"headerlink\" title=\"replica - 副本 (replica shard 简称 replica)\"></a>replica - 副本 (replica shard 简称 replica)</h2><p>当服务出现宕机时，shard可能会丢失，因此可以为每个shard创建多个replica副本。<br>replica 可以在shard出现故障时提供备用服务，保障数据不会丢失，多个replica可以提升搜索的吞吐量和性能。<br>primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/elasticsearch-2.png\" alt=\"es 集群 结构图\"> </p>\n<h1 id=\"es-核心数据-与-db的比较\"><a href=\"#es-核心数据-与-db的比较\" class=\"headerlink\" title=\"es 核心数据 与 db的比较\"></a>es 核心数据 与 db的比较</h1><table>\n<thead>\n<tr>\n<th align=\"center\">es</th>\n<th align=\"center\">db</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">index</td>\n<td align=\"center\">库</td>\n</tr>\n<tr>\n<td align=\"center\">type</td>\n<td align=\"center\">表</td>\n</tr>\n<tr>\n<td align=\"center\">document</td>\n<td align=\"center\">一行数据</td>\n</tr>\n</tbody></table>\n<p>资源路径：<a href=\"https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction\">https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-elasticsearch？\"><a href=\"#什么是-elasticsearch？\" class=\"headerlink\" title=\"什么是 elasticsearch？\"></a>什么是 elasticsearch？</h1><p>它是一个分布式、可扩展、实时的搜索与数据分析引擎。<br>它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。<br>以下 简称 es</p>\n<h2 id=\"es在Windows环境下的安装\"><a href=\"#es在Windows环境下的安装\" class=\"headerlink\" title=\"es在Windows环境下的安装\"></a>es在Windows环境下的安装</h2><p>1、安装JDK，至少1.8.0_73以上版本，java -version<br>2、下载和解压缩Elasticsearch安装包，目录结构,<a href=\"https://pan.baidu.com/s/1HsHIWr2NMdQsg5jC1F9LwQ\"><font color=red>安装包链接</font></a>,提取码：bepq<br>3、启动Elasticsearch：bin\\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了出现started就是启动成功了。<br><img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/es-windows%E5%90%AF%E5%8A%A8.jpg\" alt=\"es-windows启动\"><br>4、检查ES是否启动成功：<a href=\"http://localhost:9200/?pretty\">http://localhost:9200/?pretty</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name: node名称</span><br><span class=\"line\">cluster_name: 集群名称（默认的集群名称就是elasticsearch）</span><br><span class=\"line\">version.number: 5.2.0，es版本号</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot; : &quot;4onsTYV&quot;,</span><br><span class=\"line\">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class=\"line\">  &quot;cluster_uuid&quot; : &quot;nKZ9VK_vQdSQ1J0Dx9gx1Q&quot;,</span><br><span class=\"line\">  &quot;version&quot; : &#123;</span><br><span class=\"line\">    &quot;number&quot; : &quot;5.2.0&quot;,</span><br><span class=\"line\">    &quot;build_hash&quot; : &quot;24e05b9&quot;,</span><br><span class=\"line\">    &quot;build_date&quot; : &quot;2017-01-24T19:52:35.800Z&quot;,</span><br><span class=\"line\">    &quot;build_snapshot&quot; : false,</span><br><span class=\"line\">    &quot;lucene_version&quot; : &quot;6.4.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、修改集群名称：elasticsearch.yml<br>6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口<br>7、启动Kibana：bin\\kibana.bat<br>8、访问<a href=\"http://localhost:5601/\">http://localhost:5601</a> 进入Dev Tools界面<br>9、在Dev Tools界面上运行 GET _cluster/health</p>\n<h2 id=\"端口号9300与9200区别\"><a href=\"#端口号9300与9200区别\" class=\"headerlink\" title=\"端口号9300与9200区别\"></a>端口号9300与9200区别</h2><pre><code>区别：  \n9300端口：ES节点之间通讯使用  \n9200端口：ES节点和外部通讯使用  \n\n9300是TCP协议端口号，ES集群之间通讯的端口号  \n9200端口号，暴露ES Restful接口端口号\n</code></pre>\n<h1 id=\"lucene-与-es-的关系\"><a href=\"#lucene-与-es-的关系\" class=\"headerlink\" title=\"lucene 与 es 的关系\"></a>lucene 与 es 的关系</h1><p>lucene 是最先进、功能最强大的搜索库。<br>如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。  </p>\n<p>es 基于lucene， 隐蔽了 lucene的复杂性，提供了restful api 和 java api接口（还有其他语言的api接口）<br>特点：  </p>\n<ul>\n<li>分布式的文档存储引擎</li>\n<li>分布式的搜索引擎和分析引擎</li>\n<li>分布式 支持PB级数据</li>\n</ul>\n<h1 id=\"es-的核心概念\"><a href=\"#es-的核心概念\" class=\"headerlink\" title=\"es 的核心概念\"></a>es 的核心概念</h1><pre><code>near realtime(准实时)、cluster集群、node节点、  \ndocument&amp;field、index、shard、replica\n</code></pre>\n<h2 id=\"Near-realtime-准实时\"><a href=\"#Near-realtime-准实时\" class=\"headerlink\" title=\"Near realtime 准实时\"></a>Near realtime 准实时</h2><ul>\n<li>从写入数据到数据可以被搜索有一个时间延迟（大概1s）</li>\n<li>基于es执行搜索和分析可以达到秒级 </li>\n</ul>\n<h2 id=\"Node-节点\"><a href=\"#Node-节点\" class=\"headerlink\" title=\"Node 节点\"></a>Node 节点</h2><p>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。<br>默认节点会去加入一个名称为 elasticsearch 的集群。<br>如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</p>\n<h2 id=\"cluster-集群\"><a href=\"#cluster-集群\" class=\"headerlink\" title=\"cluster 集群\"></a>cluster 集群</h2><p>集群包含多个节点，每个节点属于哪个集群可以<font color=red>通过 elasticsearch.yml </font>配置文件来决定<br>中小型应用开始一个集群一个节点也正常</p>\n<h2 id=\"Document-amp-field\"><a href=\"#Document-amp-field\" class=\"headerlink\" title=\"Document &amp; field\"></a>Document &amp; field</h2><p>文档是 es 中最小的数据单元，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据。<br>通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。<br>一个 document 里面<font color=red>有多个 field</font>，每个 field 就是一个数据字段。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_id&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_name&quot;</span>: <span class=\"string\">&quot;iPhone X&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;product_desc&quot;</span>: <span class=\"string\">&quot;苹果手机&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;category_id&quot;</span>: <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;category_name&quot;</span>: <span class=\"string\">&quot;电子产品&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">### document -文档 </span><br><span class=\"line\">es集群中document 有点类似于 DB中的表，而document中的field则对应DB中的表字段 所以es依据这个结构特性，适应在NOSQL中使用</span><br><span class=\"line\"></span><br><span class=\"line\">### document查询内部原理</span><br><span class=\"line\">* client 请求到任意一个node 使其成为coordinate node</span><br><span class=\"line\">* coordinate node 对document进行路由，将请求转发对应的node，此时会使用round-robin随机轮询算法，在所有的primary shard 和replica shard中随机取一个，让读请求负载均衡</span><br><span class=\"line\">* 接收请求shard对应的node 会将响应结果返回coordinate node</span><br><span class=\"line\">* coordinate node 再返回的client</span><br><span class=\"line\"></span><br><span class=\"line\">特殊场景可能无法读取到document：document还在建立索引过程中，可能只在primary shard上有，replica没有，此时round-robin刚好随机指定了replica，从而导致document无法正常读取到，但是在其索引建立完成后，primary 和 replica可以正常读取</span><br><span class=\"line\"></span><br><span class=\"line\">![document读请求内部原理](https:<span class=\"comment\">//kubpang.gitee.io/sourceFile/elasticsearch/document读请求内部原理.png) </span></span><br><span class=\"line\"></span><br><span class=\"line\">## index - 索引</span><br><span class=\"line\">索引包含了一堆有相似结构的文档数据，比如商品索引。   </span><br><span class=\"line\">一个索引包含&lt;font color=red&gt;很多 document&lt;/font&gt;，一个索引就代表了一类相似或者相同的 document,操作时&lt;font color=red&gt;index能是小写，可以包含下划线&lt;/font&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\">## type - 类型 </span><br><span class=\"line\">每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。    </span><br><span class=\"line\">每个 type 下的 document 的 field 可能不太一样。 </span><br><span class=\"line\">&lt;font color=red&gt;注意：&lt;/font&gt; <span class=\"number\">6.</span>x 只有一个type <span class=\"number\">7.</span>x后 type取消</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## mapping </span><br><span class=\"line\">index的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，还有进行搜索的行为，简称为mapping  </span><br><span class=\"line\">dynamic mapping：自动建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及分词等设置  </span><br><span class=\"line\">es 在自动建立mapping的时候，对不同的field设置了data type，而不同data type的 分词、搜索等行为是不一致的，所以会导致 在在_search时，_all_field 和 指定字段的查询方式返回的结果可能不一致  </span><br><span class=\"line\">查看mapping</span><br><span class=\"line\">```shell script</span><br><span class=\"line\">#GET /index/_mapping/?pretty</span><br><span class=\"line\">GET /student/_mapping/?pretty</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"精准匹配与全文搜索的对比\"><a href=\"#精准匹配与全文搜索的对比\" class=\"headerlink\" title=\"精准匹配与全文搜索的对比\"></a>精准匹配与全文搜索的对比</h3><ul>\n<li>exact value: 精准匹配<br>  只有搜索内容与查询内容一致时才可以被查询出来</li>\n<li>full text： 全文检索 不是说单纯的只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配<ul>\n<li>缩写 vs. 全程：cn vs. china</li>\n<li>格式转化：like liked likes</li>\n<li>大小写：Tom vs tom</li>\n<li>同义词：like vs love</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mapping的核心数据类型\"><a href=\"#mapping的核心数据类型\" class=\"headerlink\" title=\"mapping的核心数据类型\"></a>mapping的核心数据类型</h3><p>字符串类型：string<br>整形：byte，short，integer，long<br>浮点类型：float，double<br>布尔类型：boolean<br>日期类型：date</p>\n<h3 id=\"dynamic-mapping\"><a href=\"#dynamic-mapping\" class=\"headerlink\" title=\"dynamic mapping\"></a>dynamic mapping</h3><p>true or false    –&gt;    boolean<br>123        –&gt;    long<br>123.45        –&gt;    double<br>2017-01-01    –&gt;    date<br>“hello world”    –&gt;    string/text</p>\n<h3 id=\"如何建立索引\"><a href=\"#如何建立索引\" class=\"headerlink\" title=\"如何建立索引\"></a>如何建立索引</h3><p>analyzed ：建立分词<br>not_analyzed: 不建立分词<br>no：不被索引和搜索</p>\n<h3 id=\"修改mapping\"><a href=\"#修改mapping\" class=\"headerlink\" title=\"修改mapping\"></a>修改mapping</h3><p>只能建立index是手动建立mapping，或者新增field mapping，但是不能 update field mapping</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">6.x 版本正常运行 7.x 版本执行错误</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">新建field mapping</span></span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">    &quot;article&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;long&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;title&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;content&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;post_date&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;date&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;publisher_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">7.x 去掉了<span class=\"built_in\">type</span></span> </span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;long&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;title&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;content&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;post_date&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;date&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;publisher_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;,</span><br><span class=\"line\">          &quot;index&quot;: false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /website/_mapping/article</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;properties&quot; : &#123;</span><br><span class=\"line\">    &quot;new_field&quot; : &#123;</span><br><span class=\"line\">      &quot;type&quot; :    &quot;string&quot;,</span><br><span class=\"line\">      &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改field mapping 异常</span></span><br><span class=\"line\">PUT /website</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;mappings&quot;: &#123;</span><br><span class=\"line\">    &quot;article&quot;: &#123;</span><br><span class=\"line\">      &quot;properties&quot;: &#123;</span><br><span class=\"line\">        &quot;author_id&quot;: &#123;</span><br><span class=\"line\">          &quot;type&quot;: &quot;text&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;error&quot;: &#123;</span><br><span class=\"line\">    &quot;root_cause&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;index_already_exists_exception&quot;,</span><br><span class=\"line\">        &quot;reason&quot;: &quot;index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists&quot;,</span><br><span class=\"line\">        &quot;index_uuid&quot;: &quot;co1dgJ-uTYGBEEOOL8GsQQ&quot;,</span><br><span class=\"line\">        &quot;index&quot;: &quot;website&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;type&quot;: &quot;index_already_exists_exception&quot;,</span><br><span class=\"line\">    &quot;reason&quot;: &quot;index [website/co1dgJ-uTYGBEEOOL8GsQQ] already exists&quot;,</span><br><span class=\"line\">    &quot;index_uuid&quot;: &quot;co1dgJ-uTYGBEEOOL8GsQQ&quot;,</span><br><span class=\"line\">    &quot;index&quot;: &quot;website&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;status&quot;: 400</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mapping-总结\"><a href=\"#mapping-总结\" class=\"headerlink\" title=\"mapping 总结\"></a>mapping 总结</h3><ul>\n<li>往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping</li>\n<li>mapping中就自动定义了每个field的数据类型</li>\n<li>不同的数据类型（比如说text和date），可能有的是exact value，有的是full text</li>\n<li>exact value，在建立倒排索引的时候，分词的时候，是将整个值一起作为<font color=red>一个关键词</font>建立到倒排索引中的；full text，会经历各种各样的处理，分词，normaliztion（时态转换，同义词转换，大小写转换），才会建立到倒排索引中</li>\n<li>同时呢，exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string，也会进行分词和normalization再去倒排索引中去搜索</li>\n<li>可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为，包括分词器，等等</li>\n</ul>\n<h2 id=\"shard-amp-replica\"><a href=\"#shard-amp-replica\" class=\"headerlink\" title=\"shard &amp; replica\"></a>shard &amp; replica</h2><ul>\n<li><p>index包含多个shard</p>\n</li>\n<li><p>每个shard都是一个最小工作单元，承载部分数据，每个 shard 都是一个 <font color=red>lucene 实例</font>。，有完整的建立索引和处理请求的能力。</p>\n</li>\n<li><p>增减节点时，shard会自动在nodes中负载均衡（尽量保证每个节点都是一样的负载）</p>\n</li>\n<li><p>primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard</p>\n</li>\n<li><p>replica shard是primary shard的副本，负责容错，以及承担读请求负载</p>\n</li>\n<li><p>primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改，primary shard的数量是不能的修改的。</p>\n</li>\n<li><p>primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard（每个primary shard都对应一个replica shard）</p>\n</li>\n<li><p>primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上</p>\n</li>\n</ul>\n<h2 id=\"replica-副本-replica-shard-简称-replica\"><a href=\"#replica-副本-replica-shard-简称-replica\" class=\"headerlink\" title=\"replica - 副本 (replica shard 简称 replica)\"></a>replica - 副本 (replica shard 简称 replica)</h2><p>当服务出现宕机时，shard可能会丢失，因此可以为每个shard创建多个replica副本。<br>replica 可以在shard出现故障时提供备用服务，保障数据不会丢失，多个replica可以提升搜索的吞吐量和性能。<br>primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/elasticsearch/elasticsearch-2.png\" alt=\"es 集群 结构图\"> </p>\n<h1 id=\"es-核心数据-与-db的比较\"><a href=\"#es-核心数据-与-db的比较\" class=\"headerlink\" title=\"es 核心数据 与 db的比较\"></a>es 核心数据 与 db的比较</h1><table>\n<thead>\n<tr>\n<th align=\"center\">es</th>\n<th align=\"center\">db</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">index</td>\n<td align=\"center\">库</td>\n</tr>\n<tr>\n<td align=\"center\">type</td>\n<td align=\"center\">表</td>\n</tr>\n<tr>\n<td align=\"center\">document</td>\n<td align=\"center\">一行数据</td>\n</tr>\n</tbody></table>\n<p>资源路径：<a href=\"https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction\">https://shishan100.gitee.io/docs/#/./docs/high-concurrency/es-introduction</a></p>\n"},{"title":"注解编程","date":"2021-08-30T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 为什么要使用注解编程\n    注解编程可以使得代码更简洁，提供开发效率。  \n    替换xml这种配置形式，简化配置\n例如 开发一个User类：\n```java\npublic class User(){....}\n```\n添加注解@Component后如下：\n```java\n@Component\npublic class User(){....}\n```\n\n该形式等价于在spring配置文件中的\n```xml\n<bean id=\"user\" class=\"com.study.User\"></bean>\n```\n\n# 容器相关注解\n## 组件注册 \n### @Configuration\n作用在类上，表示这个是一个配置类，相当于配置文件xml一样\n\n### @Bean \n作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定\n\n### @ComponentScan \n作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    \n\n使用excludeFilters：过滤掉哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n})\t//配置扫描包\n```\n\n使用includeFilters：包含哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, includeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Service.class})\n}, useDefaultFilters=false)\t//配置扫描包\n```\n\n### @ComponentScans\n配置扫描包，可以设置多个值 \n\n```java \n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n\t})\t//配置扫描包\n})\n```\n自动过滤规则：\n```java\npublic class MyTypeFilter implements TypeFilter{\n\n\tpublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\n\t\t//注解信息\n\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t//类信息\n\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();\n\t\t//路径信息\n\t\tResource resource = metadataReader.getResource();\n\t\t//获取类名\n\t\tString className = classMetadata.getClassName();\n\t\tSystem.out.println(className);\n\t\tif(className.contains(\"er\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class}),\n\t\t\t@Filter(type=FilterType.CUSTOM, value={MyTypeFilter.class})\t//使用自定义的过滤规则\n\t})\t//配置扫描包\n})\n```\n\n### @Scope\n作用在方法上，相当于 bean 中的scope属性\n```java\n/**\n\t * prototype\t多实例，当要用到时才会创建实例\n\t * singleton\t单例（默认），在spring容器创建时就创建实例了\n\t * request\t\t同一个请求创建一个实例（很少用到）\n\t * session\t\t同一个session创建一个实例（很少用到）\n\t * @return\n\t */\n\t@Scope(\"prototype\")\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n\n```\n\n### @Lazy\n懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。\n\n```java\n@Lazy\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n```\n\n### @Conditional\n可以作用在类或方法上。  \n作用在方法上： 如果条件返回true，则创建bean\n作用在类上： 如果返回true，此类的注册bean才会生效。\n```java\n    @Conditional({WindowsCondition.class})\n\t@Bean(\"windows\")\n\tpublic Student student2(){\n\t\treturn new Student(\"my is windows\", 60);\n\t}\n\t\n\t@Conditional({LinuxCondition.class})\n\t@Bean(\"linux\")\n\tpublic Student student3(){\n\t\treturn new Student(\"my is linux\", 50);\n\t}\n```\n\n```java\n//判断是否是Linux系统\npublic class LinuxCondition implements Condition {\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tEnvironment environment = context.getEnvironment();\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"linux\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n\n//判断是否是windows系统\npublic class WindowsCondition implements Condition{\n\n\t/**\n\t * context：程序上下文\n\t * metadata：注解信息\n\t */\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t//bean工厂\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t//程序运行环境\n\t\tEnvironment environment = context.getEnvironment();\n\t\t//bean注册信息\n\t\tBeanDefinitionRegistry registry = context.getRegistry();\n\t\t\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"Windows\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n```\n\n### @Import\n作用：快速的给容器导入一个组件\n\n* 使用方法1：\n```java\n@Import({要导入到容器中的组件})，容器中就会自动注册这个组件，id是类的全路径\n@Import({RedisUtils.class})\n```\n\n* 使用方法2：\nImportSelector：返回需要导入的组件的全类名数组，这个在springboot中底层很常用\t\n```java\n//实现ImportSelector接口\npublic class MyImportSelector implements ImportSelector{\n\n\t//importingClassMetadata：注解信息\n\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\treturn new String[]{\"com.oyr.bean.Red\", \"com.oyr.bean.Yellow\"};\n\t}\n\n}\n@Import({ MyImportSelector.class})\n```\n\n* 使用方法3：\nImportBeanDefinitionRegistrar：手动注册bean到容器中\n```java\n//实现ImportBeanDefinitionRegistrar接口\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{\n\n\t/**\n\t * importingClassMetadata：注解信息\n\t * registry：bean注册对象\n\t */\n\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\t\t//是否有id为red Bean\n\t\tboolean b1 = registry.containsBeanDefinition(\"com.oyr.bean.Red\");\n\t\t//是否有id为yellow bean\n\t\tboolean b2 = registry.containsBeanDefinition(\"com.oyr.bean.Yellow\");\n\t\tif(b1 && b2){\n\t\t\tregistry.registerBeanDefinition(\"blue\", new RootBeanDefinition(Blue.class));\n\t\t}\n\t}\n\n}\n```\n\n容器注册逐渐总结：\n1. 包扫描 + 逐渐标注注解（@Controller/ @Service/ @Repository/ @Componnet）\n2. Bean 导入的第三方包里面的组件\n3. import 快速的给融资导入一个组件\n\t* @Import 需要导入容器中的bean，容器就会自动注解这个Bean,id是类的全路径\n\t* ImportSelector： 返回需要导入的组件的全类名数组\n\t* ImportBeanDefinitionRegistrar 手动注册bean到容器中\n4. 使用spring提供的FactoryBean(goncBean)\n\t* 默认获取到的是工厂bean调用getObject()创建的对象\n\t* 要获取到工厂bean本身，我们要在id前面加一个&\n\n# Bean 生命周期 \n指定初始化方法和销毁方法\n* 对象的创建:\n\t* 单实例: 在容器启动的时候创建对象\n\t* 多实例: 在每次获取对象时创建\n* 初始化: \n\t* 对象创建完成，并赋值好，调用初始化方法\n* 销毁:\n\t* 单实例在容器关闭的时候销毁\n\t* 多实例不会调用销毁方法，spring并不销毁，需要自己调用销毁方法。\n\n1. 使用@Bean指定初始化方法和销毁方法\n```java\n@Bean(initMethod=\"init\", destroyMethod=\"destroy\")\n\tpublic Color color(){\n\t\treturn new Color();\n\t}\n```\n\n2. 通过让bena实现InitializingBean（定义初始化逻辑）， DisposableBean（定义销毁逻辑）\n```java\npublic class Color2 implements InitializingBean, DisposableBean{\n\n\tpublic void destroy() throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"destroy\");\n\t}\n\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"afterPropertiesSet\");\n\t}\n}\n```\n\n3. 使用JSR250   \n@PostConstruct：在bean创建完成并且属性赋值完成：来执行初始化方法  \n@PreDestroy：在容器销毁bena之前通知我们进行销毁工作  \n\nBeanPostProcessor：bean的前后置处理器  \n在bean初始化前后进行一些处理工作  \npostProcessBeforeInitialization：在初始化之前工作  \npostProcessAfterInitialization：在初始化之后进行工作  \n\nspring底层对BeanPostProcessor的使用：  \nBean赋值，注入其他组件，@AutoWitred，生命周期注解功能，@Async,等等\n都是使用BeanPostProcessor实现的。","source":"_posts/lh/spring/注解编程.md","raw":"---\ntitle: 注解编程\ndate: 2021-08-31 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: spring\ntags: \n    - spring\n---\n\n# 为什么要使用注解编程\n    注解编程可以使得代码更简洁，提供开发效率。  \n    替换xml这种配置形式，简化配置\n例如 开发一个User类：\n```java\npublic class User(){....}\n```\n添加注解@Component后如下：\n```java\n@Component\npublic class User(){....}\n```\n\n该形式等价于在spring配置文件中的\n```xml\n<bean id=\"user\" class=\"com.study.User\"></bean>\n```\n\n# 容器相关注解\n## 组件注册 \n### @Configuration\n作用在类上，表示这个是一个配置类，相当于配置文件xml一样\n\n### @Bean \n作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定\n\n### @ComponentScan \n作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    \n\n使用excludeFilters：过滤掉哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n})\t//配置扫描包\n```\n\n使用includeFilters：包含哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, includeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Service.class})\n}, useDefaultFilters=false)\t//配置扫描包\n```\n\n### @ComponentScans\n配置扫描包，可以设置多个值 \n\n```java \n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n\t})\t//配置扫描包\n})\n```\n自动过滤规则：\n```java\npublic class MyTypeFilter implements TypeFilter{\n\n\tpublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\n\t\t//注解信息\n\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t//类信息\n\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();\n\t\t//路径信息\n\t\tResource resource = metadataReader.getResource();\n\t\t//获取类名\n\t\tString className = classMetadata.getClassName();\n\t\tSystem.out.println(className);\n\t\tif(className.contains(\"er\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class}),\n\t\t\t@Filter(type=FilterType.CUSTOM, value={MyTypeFilter.class})\t//使用自定义的过滤规则\n\t})\t//配置扫描包\n})\n```\n\n### @Scope\n作用在方法上，相当于 bean 中的scope属性\n```java\n/**\n\t * prototype\t多实例，当要用到时才会创建实例\n\t * singleton\t单例（默认），在spring容器创建时就创建实例了\n\t * request\t\t同一个请求创建一个实例（很少用到）\n\t * session\t\t同一个session创建一个实例（很少用到）\n\t * @return\n\t */\n\t@Scope(\"prototype\")\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n\n```\n\n### @Lazy\n懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。\n\n```java\n@Lazy\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n```\n\n### @Conditional\n可以作用在类或方法上。  \n作用在方法上： 如果条件返回true，则创建bean\n作用在类上： 如果返回true，此类的注册bean才会生效。\n```java\n    @Conditional({WindowsCondition.class})\n\t@Bean(\"windows\")\n\tpublic Student student2(){\n\t\treturn new Student(\"my is windows\", 60);\n\t}\n\t\n\t@Conditional({LinuxCondition.class})\n\t@Bean(\"linux\")\n\tpublic Student student3(){\n\t\treturn new Student(\"my is linux\", 50);\n\t}\n```\n\n```java\n//判断是否是Linux系统\npublic class LinuxCondition implements Condition {\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tEnvironment environment = context.getEnvironment();\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"linux\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n\n//判断是否是windows系统\npublic class WindowsCondition implements Condition{\n\n\t/**\n\t * context：程序上下文\n\t * metadata：注解信息\n\t */\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t//bean工厂\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t//程序运行环境\n\t\tEnvironment environment = context.getEnvironment();\n\t\t//bean注册信息\n\t\tBeanDefinitionRegistry registry = context.getRegistry();\n\t\t\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"Windows\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n```\n\n### @Import\n作用：快速的给容器导入一个组件\n\n* 使用方法1：\n```java\n@Import({要导入到容器中的组件})，容器中就会自动注册这个组件，id是类的全路径\n@Import({RedisUtils.class})\n```\n\n* 使用方法2：\nImportSelector：返回需要导入的组件的全类名数组，这个在springboot中底层很常用\t\n```java\n//实现ImportSelector接口\npublic class MyImportSelector implements ImportSelector{\n\n\t//importingClassMetadata：注解信息\n\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\treturn new String[]{\"com.oyr.bean.Red\", \"com.oyr.bean.Yellow\"};\n\t}\n\n}\n@Import({ MyImportSelector.class})\n```\n\n* 使用方法3：\nImportBeanDefinitionRegistrar：手动注册bean到容器中\n```java\n//实现ImportBeanDefinitionRegistrar接口\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar{\n\n\t/**\n\t * importingClassMetadata：注解信息\n\t * registry：bean注册对象\n\t */\n\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\t\t//是否有id为red Bean\n\t\tboolean b1 = registry.containsBeanDefinition(\"com.oyr.bean.Red\");\n\t\t//是否有id为yellow bean\n\t\tboolean b2 = registry.containsBeanDefinition(\"com.oyr.bean.Yellow\");\n\t\tif(b1 && b2){\n\t\t\tregistry.registerBeanDefinition(\"blue\", new RootBeanDefinition(Blue.class));\n\t\t}\n\t}\n\n}\n```\n\n容器注册逐渐总结：\n1. 包扫描 + 逐渐标注注解（@Controller/ @Service/ @Repository/ @Componnet）\n2. Bean 导入的第三方包里面的组件\n3. import 快速的给融资导入一个组件\n\t* @Import 需要导入容器中的bean，容器就会自动注解这个Bean,id是类的全路径\n\t* ImportSelector： 返回需要导入的组件的全类名数组\n\t* ImportBeanDefinitionRegistrar 手动注册bean到容器中\n4. 使用spring提供的FactoryBean(goncBean)\n\t* 默认获取到的是工厂bean调用getObject()创建的对象\n\t* 要获取到工厂bean本身，我们要在id前面加一个&\n\n# Bean 生命周期 \n指定初始化方法和销毁方法\n* 对象的创建:\n\t* 单实例: 在容器启动的时候创建对象\n\t* 多实例: 在每次获取对象时创建\n* 初始化: \n\t* 对象创建完成，并赋值好，调用初始化方法\n* 销毁:\n\t* 单实例在容器关闭的时候销毁\n\t* 多实例不会调用销毁方法，spring并不销毁，需要自己调用销毁方法。\n\n1. 使用@Bean指定初始化方法和销毁方法\n```java\n@Bean(initMethod=\"init\", destroyMethod=\"destroy\")\n\tpublic Color color(){\n\t\treturn new Color();\n\t}\n```\n\n2. 通过让bena实现InitializingBean（定义初始化逻辑）， DisposableBean（定义销毁逻辑）\n```java\npublic class Color2 implements InitializingBean, DisposableBean{\n\n\tpublic void destroy() throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"destroy\");\n\t}\n\n\tpublic void afterPropertiesSet() throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"afterPropertiesSet\");\n\t}\n}\n```\n\n3. 使用JSR250   \n@PostConstruct：在bean创建完成并且属性赋值完成：来执行初始化方法  \n@PreDestroy：在容器销毁bena之前通知我们进行销毁工作  \n\nBeanPostProcessor：bean的前后置处理器  \n在bean初始化前后进行一些处理工作  \npostProcessBeforeInitialization：在初始化之前工作  \npostProcessAfterInitialization：在初始化之后进行工作  \n\nspring底层对BeanPostProcessor的使用：  \nBean赋值，注入其他组件，@AutoWitred，生命周期注解功能，@Async,等等\n都是使用BeanPostProcessor实现的。","slug":"lh/spring/注解编程","published":1,"updated":"2021-09-10T03:38:51.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af866000icst7g9nl7qhl","content":"<h1 id=\"为什么要使用注解编程\"><a href=\"#为什么要使用注解编程\" class=\"headerlink\" title=\"为什么要使用注解编程\"></a>为什么要使用注解编程</h1><pre><code>注解编程可以使得代码更简洁，提供开发效率。  \n替换xml这种配置形式，简化配置\n</code></pre>\n<p>例如 开发一个User类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n<p>添加注解@Component后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该形式等价于在spring配置文件中的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.User&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器相关注解\"><a href=\"#容器相关注解\" class=\"headerlink\" title=\"容器相关注解\"></a>容器相关注解</h1><h2 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h2><h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h3><p>作用在类上，表示这个是一个配置类，相当于配置文件xml一样</p>\n<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定</p>\n<h3 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h3><p>作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    </p>\n<p>使用excludeFilters：过滤掉哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<p>使用includeFilters：包含哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, includeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;, useDefaultFilters=false)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ComponentScans\"><a href=\"#ComponentScans\" class=\"headerlink\" title=\"@ComponentScans\"></a>@ComponentScans</h3><p>配置扫描包，可以设置多个值 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>自动过滤规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTypeFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeFilter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注解信息</span></span><br><span class=\"line\">\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//类信息</span></span><br><span class=\"line\">\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//路径信息</span></span><br><span class=\"line\">\t\tResource resource = metadataReader.getResource();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取类名</span></span><br><span class=\"line\">\t\tString className = classMetadata.getClassName();</span><br><span class=\"line\">\t\tSystem.out.println(className);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(className.contains(<span class=\"string\">&quot;er&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.CUSTOM, value=&#123;MyTypeFilter.class&#125;)\t//使用自定义的过滤规则</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"@Scope\"></a>@Scope</h3><p>作用在方法上，相当于 bean 中的scope属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * prototype\t多实例，当要用到时才会创建实例</span></span><br><span class=\"line\"><span class=\"comment\">\t * singleton\t单例（默认），在spring容器创建时就创建实例了</span></span><br><span class=\"line\"><span class=\"comment\">\t * request\t\t同一个请求创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * session\t\t同一个session创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h3><p>懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Conditional\"><a href=\"#Conditional\" class=\"headerlink\" title=\"@Conditional\"></a>@Conditional</h3><p>可以作用在类或方法上。<br>作用在方法上： 如果条件返回true，则创建bean<br>作用在类上： 如果返回true，此类的注册bean才会生效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;windows&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is windows&quot;</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;linux&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is linux&quot;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否是Linux系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinuxCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;linux&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断是否是windows系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * context：程序上下文</span></span><br><span class=\"line\"><span class=\"comment\">\t * metadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean工厂</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//程序运行环境</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean注册信息</span></span><br><span class=\"line\">\t\tBeanDefinitionRegistry registry = context.getRegistry();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;Windows&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Import\"><a href=\"#Import\" class=\"headerlink\" title=\"@Import\"></a>@Import</h3><p>作用：快速的给容器导入一个组件</p>\n<ul>\n<li><p>使用方法1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Import(&#123;要导入到容器中的组件&#125;)</span>，容器中就会自动注册这个组件，id是类的全路径</span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;RedisUtils.class&#125;)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用方法2：<br>ImportSelector：返回需要导入的组件的全类名数组，这个在springboot中底层很常用    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ImportSelector接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportSelector</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//importingClassMetadata：注解信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;com.oyr.bean.Red&quot;</span>, <span class=\"string\">&quot;com.oyr.bean.Yellow&quot;</span>&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; MyImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用方法3：<br>ImportBeanDefinitionRegistrar：手动注册bean到容器中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ImportBeanDefinitionRegistrar接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyImportBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * importingClassMetadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t * registry：bean注册对象</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//是否有id为red Bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> b1 = registry.containsBeanDefinition(<span class=\"string\">&quot;com.oyr.bean.Red&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//是否有id为yellow bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> b2 = registry.containsBeanDefinition(<span class=\"string\">&quot;com.oyr.bean.Yellow&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b1 &amp;&amp; b2)&#123;</span><br><span class=\"line\">\t\t\tregistry.registerBeanDefinition(<span class=\"string\">&quot;blue&quot;</span>, <span class=\"keyword\">new</span> RootBeanDefinition(Blue.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>容器注册逐渐总结：</p>\n<ol>\n<li>包扫描 + 逐渐标注注解（@Controller/ @Service/ @Repository/ @Componnet）</li>\n<li>Bean 导入的第三方包里面的组件</li>\n<li>import 快速的给融资导入一个组件<ul>\n<li>@Import 需要导入容器中的bean，容器就会自动注解这个Bean,id是类的全路径</li>\n<li>ImportSelector： 返回需要导入的组件的全类名数组</li>\n<li>ImportBeanDefinitionRegistrar 手动注册bean到容器中</li>\n</ul>\n</li>\n<li>使用spring提供的FactoryBean(goncBean)<ul>\n<li>默认获取到的是工厂bean调用getObject()创建的对象</li>\n<li>要获取到工厂bean本身，我们要在id前面加一个&amp;</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Bean-生命周期\"><a href=\"#Bean-生命周期\" class=\"headerlink\" title=\"Bean 生命周期\"></a>Bean 生命周期</h1><p>指定初始化方法和销毁方法</p>\n<ul>\n<li>对象的创建:<ul>\n<li>单实例: 在容器启动的时候创建对象</li>\n<li>多实例: 在每次获取对象时创建</li>\n</ul>\n</li>\n<li>初始化: <ul>\n<li>对象创建完成，并赋值好，调用初始化方法</li>\n</ul>\n</li>\n<li>销毁:<ul>\n<li>单实例在容器关闭的时候销毁</li>\n<li>多实例不会调用销毁方法，spring并不销毁，需要自己调用销毁方法。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>使用@Bean指定初始化方法和销毁方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Color <span class=\"title\">color</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Color();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>通过让bena实现InitializingBean（定义初始化逻辑）， DisposableBean（定义销毁逻辑）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color2</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;destroy&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;afterPropertiesSet&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用JSR250<br>@PostConstruct：在bean创建完成并且属性赋值完成：来执行初始化方法<br>@PreDestroy：在容器销毁bena之前通知我们进行销毁工作  </p>\n</li>\n</ol>\n<p>BeanPostProcessor：bean的前后置处理器<br>在bean初始化前后进行一些处理工作<br>postProcessBeforeInitialization：在初始化之前工作<br>postProcessAfterInitialization：在初始化之后进行工作  </p>\n<p>spring底层对BeanPostProcessor的使用：<br>Bean赋值，注入其他组件，@AutoWitred，生命周期注解功能，@Async,等等<br>都是使用BeanPostProcessor实现的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要使用注解编程\"><a href=\"#为什么要使用注解编程\" class=\"headerlink\" title=\"为什么要使用注解编程\"></a>为什么要使用注解编程</h1><pre><code>注解编程可以使得代码更简洁，提供开发效率。  \n替换xml这种配置形式，简化配置\n</code></pre>\n<p>例如 开发一个User类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n<p>添加注解@Component后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该形式等价于在spring配置文件中的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.User&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器相关注解\"><a href=\"#容器相关注解\" class=\"headerlink\" title=\"容器相关注解\"></a>容器相关注解</h1><h2 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h2><h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h3><p>作用在类上，表示这个是一个配置类，相当于配置文件xml一样</p>\n<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定</p>\n<h3 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h3><p>作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    </p>\n<p>使用excludeFilters：过滤掉哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<p>使用includeFilters：包含哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, includeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;, useDefaultFilters=false)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ComponentScans\"><a href=\"#ComponentScans\" class=\"headerlink\" title=\"@ComponentScans\"></a>@ComponentScans</h3><p>配置扫描包，可以设置多个值 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>自动过滤规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTypeFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeFilter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注解信息</span></span><br><span class=\"line\">\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//类信息</span></span><br><span class=\"line\">\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//路径信息</span></span><br><span class=\"line\">\t\tResource resource = metadataReader.getResource();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取类名</span></span><br><span class=\"line\">\t\tString className = classMetadata.getClassName();</span><br><span class=\"line\">\t\tSystem.out.println(className);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(className.contains(<span class=\"string\">&quot;er&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.CUSTOM, value=&#123;MyTypeFilter.class&#125;)\t//使用自定义的过滤规则</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"@Scope\"></a>@Scope</h3><p>作用在方法上，相当于 bean 中的scope属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * prototype\t多实例，当要用到时才会创建实例</span></span><br><span class=\"line\"><span class=\"comment\">\t * singleton\t单例（默认），在spring容器创建时就创建实例了</span></span><br><span class=\"line\"><span class=\"comment\">\t * request\t\t同一个请求创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * session\t\t同一个session创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h3><p>懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Conditional\"><a href=\"#Conditional\" class=\"headerlink\" title=\"@Conditional\"></a>@Conditional</h3><p>可以作用在类或方法上。<br>作用在方法上： 如果条件返回true，则创建bean<br>作用在类上： 如果返回true，此类的注册bean才会生效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;windows&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is windows&quot;</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;linux&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is linux&quot;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否是Linux系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinuxCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;linux&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断是否是windows系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * context：程序上下文</span></span><br><span class=\"line\"><span class=\"comment\">\t * metadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean工厂</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//程序运行环境</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean注册信息</span></span><br><span class=\"line\">\t\tBeanDefinitionRegistry registry = context.getRegistry();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;Windows&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Import\"><a href=\"#Import\" class=\"headerlink\" title=\"@Import\"></a>@Import</h3><p>作用：快速的给容器导入一个组件</p>\n<ul>\n<li><p>使用方法1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Import(&#123;要导入到容器中的组件&#125;)</span>，容器中就会自动注册这个组件，id是类的全路径</span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;RedisUtils.class&#125;)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用方法2：<br>ImportSelector：返回需要导入的组件的全类名数组，这个在springboot中底层很常用    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ImportSelector接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportSelector</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//importingClassMetadata：注解信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;com.oyr.bean.Red&quot;</span>, <span class=\"string\">&quot;com.oyr.bean.Yellow&quot;</span>&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; MyImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用方法3：<br>ImportBeanDefinitionRegistrar：手动注册bean到容器中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ImportBeanDefinitionRegistrar接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyImportBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * importingClassMetadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t * registry：bean注册对象</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//是否有id为red Bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> b1 = registry.containsBeanDefinition(<span class=\"string\">&quot;com.oyr.bean.Red&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//是否有id为yellow bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> b2 = registry.containsBeanDefinition(<span class=\"string\">&quot;com.oyr.bean.Yellow&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b1 &amp;&amp; b2)&#123;</span><br><span class=\"line\">\t\t\tregistry.registerBeanDefinition(<span class=\"string\">&quot;blue&quot;</span>, <span class=\"keyword\">new</span> RootBeanDefinition(Blue.class));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>容器注册逐渐总结：</p>\n<ol>\n<li>包扫描 + 逐渐标注注解（@Controller/ @Service/ @Repository/ @Componnet）</li>\n<li>Bean 导入的第三方包里面的组件</li>\n<li>import 快速的给融资导入一个组件<ul>\n<li>@Import 需要导入容器中的bean，容器就会自动注解这个Bean,id是类的全路径</li>\n<li>ImportSelector： 返回需要导入的组件的全类名数组</li>\n<li>ImportBeanDefinitionRegistrar 手动注册bean到容器中</li>\n</ul>\n</li>\n<li>使用spring提供的FactoryBean(goncBean)<ul>\n<li>默认获取到的是工厂bean调用getObject()创建的对象</li>\n<li>要获取到工厂bean本身，我们要在id前面加一个&amp;</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Bean-生命周期\"><a href=\"#Bean-生命周期\" class=\"headerlink\" title=\"Bean 生命周期\"></a>Bean 生命周期</h1><p>指定初始化方法和销毁方法</p>\n<ul>\n<li>对象的创建:<ul>\n<li>单实例: 在容器启动的时候创建对象</li>\n<li>多实例: 在每次获取对象时创建</li>\n</ul>\n</li>\n<li>初始化: <ul>\n<li>对象创建完成，并赋值好，调用初始化方法</li>\n</ul>\n</li>\n<li>销毁:<ul>\n<li>单实例在容器关闭的时候销毁</li>\n<li>多实例不会调用销毁方法，spring并不销毁，需要自己调用销毁方法。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>使用@Bean指定初始化方法和销毁方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;destroy&quot;)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Color <span class=\"title\">color</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Color();</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>通过让bena实现InitializingBean（定义初始化逻辑）， DisposableBean（定义销毁逻辑）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color2</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;destroy&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;afterPropertiesSet&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用JSR250<br>@PostConstruct：在bean创建完成并且属性赋值完成：来执行初始化方法<br>@PreDestroy：在容器销毁bena之前通知我们进行销毁工作  </p>\n</li>\n</ol>\n<p>BeanPostProcessor：bean的前后置处理器<br>在bean初始化前后进行一些处理工作<br>postProcessBeforeInitialization：在初始化之前工作<br>postProcessAfterInitialization：在初始化之后进行工作  </p>\n<p>spring底层对BeanPostProcessor的使用：<br>Bean赋值，注入其他组件，@AutoWitred，生命周期注解功能，@Async,等等<br>都是使用BeanPostProcessor实现的。</p>\n"},{"title":"设计模式初讲","date":"2021-07-26T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 扩展知识\n\n## 什么是设计模式\n\n设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。\n\n## 设计模式的三大分类及关键点\n\n![设计模式三大分类](https://kubpang.gitee.io/sourceFile/设计模式/设计模式三大分类.jpg)\n\n### 创建型模式  \n\n    对象实例化的模式，创建型模式用于解耦对象实例化的过程\n\n   1. [单列模式](https://blog.csdn.net/guorui_java/article/details/106585965): 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  \n   2. [工厂模式](https://blog.csdn.net/guorui_java/article/details/105087806): 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  \n   3. [抽象工厂模式](https://blog.csdn.net/guorui_java/article/details/106535411) : 创建相关或依赖对象的家族，而无需明确指定具体类。  \n   4. [建造者模式](https://blog.csdn.net/guorui_java/article/details/106684541) : 封装一个复杂对象的创建过程，并可以安步骤构造。  \n   5. [原型模式](https://blog.csdn.net/guorui_java/article/details/106544941) : 通过复制现有的实例来创建新的实例。\n\n\n### 结构型模式\n\n    把类或对象结合在一起形成一个更大的结构\n\n   1. [装饰模式](https://blog.csdn.net/guorui_java/article/details/106613220) : 动态的给对象添加新的功能。  \n   2. [代理模式](https://blog.csdn.net/guorui_java/article/details/106665200) : 未其他对象提供一个代理以便控制这个对象的访问。  \n   3. [桥接模式](https://blog.csdn.net/guorui_java/article/details/106688252) : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  \n   4. [适配器模式](https://blog.csdn.net/guorui_java/article/details/106584559) : 将一个类的方法接口转换到客户希望的另一个接口。  \n   5. [组合模式](https://blog.csdn.net/guorui_java/article/details/106617887) : 将对象组合成树形结构以表示“部分-整体”的结构层次。  \n   6. [外观模式](https://blog.csdn.net/guorui_java/article/details/104247938) : 对外提供一个统一的方法，来访问子系统的一群接口。  \n   7. [享元模式](https://blog.csdn.net/guorui_java/article/details/106640489) : 通过共享技术来有效的支持大量细粒度的对象。  \n\n\n### 行为型模式  \n\n    类和对象如何交互，以及划分责任和算法\n\n   1. [策略模式](https://blog.csdn.net/guorui_java/article/details/104039882) : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  \n   2. [模板模式](https://blog.csdn.net/guorui_java/article/details/106677554) : 定义一个算法结构，而将一些步骤延迟到子类中实现。  \n   3. [命令模式](https://blog.csdn.net/guorui_java/article/details/106718457) : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  \n   4. [迭代器模式](https://blog.csdn.net/guorui_java/article/details/104247911) : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  \n   5. [观察者模式](https://blog.csdn.net/guorui_java/article/details/104247965) : 对象间的一对多的依赖关系。  \n   6. [仲裁者模式](https://blog.csdn.net/guorui_java/article/details/104247966) : 用一个中介对象来封装一系列的对象交互。  \n   7. [备忘录模式](https://blog.csdn.net/guorui_java/article/details/104247969) : 在不破坏封装的前提下，保持对象的内部状态。  \n   8. [解释器模式](https://blog.csdn.net/guorui_java/article/details/104247972) : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  \n   9. [状态模式](https://blog.csdn.net/guorui_java/article/details/104247975) : 允许一个对象在对象内部状态改变时改变它的行为。  \n   10. [责任链模式](https://blog.csdn.net/guorui_java/article/details/104247978) : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  \n   11. [访问者模式](https://blog.csdn.net/guorui_java/article/details/104247935) : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  \n\n\n ## 设计模式的原则\n\n ### 1. 单一职责原则 \n    \n    对于一个类，只有一个引起该类变化的原因。  \n    该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n\n ### 2. 接口隔离原则  \n    \n    客户端不应该依赖它不需要的接口。  \n    一个类对另一个类的依赖应该建立在最小接口上。\n\n### 3. 依赖倒转原则  \n\n    程序要依赖于抽象接口，不要依赖于具体实现。  \n    简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n\n### 4. 里式代替原则  \n\n    1. 任何基类出现的地方，子类一定可以出现。  \n    2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n    3. 里式替代原则是对开闭原则的补充。  \n    4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n\n### 5. 开闭原则  \n\n1. 对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  \n2. 对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  \n\n### 6. 迪米特法则\n\n    迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n\n### 7. 合成复用原则  \n\n    1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n    2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n    3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n\n[设计模式七大原则总结](https://blog.csdn.net/guorui_java/article/details/106469226)  \n\n## 设计模式关系  \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式关系图.jpg) \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式之间的关系.png) \n\n## 设计模式感想  \n一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展\n性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。\n\n同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 \n\n## 设计模式回顾  \n从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；\n\n其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；\n\n然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；\n\n之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；\n\n然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；\n\n之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；\n\n然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；\n\n然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；\n\n然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；\n\n然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；\n\n接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；\n\n接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；\n\n然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；\n\n接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；\n\n然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；\n\n然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；\n\n然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；\n\n然后是享元模式，轻量级对象，通过共用不变对象来实现；\n\n然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；\n\n然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；\n\n最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。\n\n[友情链接](https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)","source":"_posts/lh/设计模式/设计模式初讲.md","raw":"---\ntitle: 设计模式初讲\ndate: 2021-07-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 设计模式\ntags: \n    - 设计模式\n---\n\n# 扩展知识\n\n## 什么是设计模式\n\n设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。\n\n## 设计模式的三大分类及关键点\n\n![设计模式三大分类](https://kubpang.gitee.io/sourceFile/设计模式/设计模式三大分类.jpg)\n\n### 创建型模式  \n\n    对象实例化的模式，创建型模式用于解耦对象实例化的过程\n\n   1. [单列模式](https://blog.csdn.net/guorui_java/article/details/106585965): 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  \n   2. [工厂模式](https://blog.csdn.net/guorui_java/article/details/105087806): 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  \n   3. [抽象工厂模式](https://blog.csdn.net/guorui_java/article/details/106535411) : 创建相关或依赖对象的家族，而无需明确指定具体类。  \n   4. [建造者模式](https://blog.csdn.net/guorui_java/article/details/106684541) : 封装一个复杂对象的创建过程，并可以安步骤构造。  \n   5. [原型模式](https://blog.csdn.net/guorui_java/article/details/106544941) : 通过复制现有的实例来创建新的实例。\n\n\n### 结构型模式\n\n    把类或对象结合在一起形成一个更大的结构\n\n   1. [装饰模式](https://blog.csdn.net/guorui_java/article/details/106613220) : 动态的给对象添加新的功能。  \n   2. [代理模式](https://blog.csdn.net/guorui_java/article/details/106665200) : 未其他对象提供一个代理以便控制这个对象的访问。  \n   3. [桥接模式](https://blog.csdn.net/guorui_java/article/details/106688252) : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  \n   4. [适配器模式](https://blog.csdn.net/guorui_java/article/details/106584559) : 将一个类的方法接口转换到客户希望的另一个接口。  \n   5. [组合模式](https://blog.csdn.net/guorui_java/article/details/106617887) : 将对象组合成树形结构以表示“部分-整体”的结构层次。  \n   6. [外观模式](https://blog.csdn.net/guorui_java/article/details/104247938) : 对外提供一个统一的方法，来访问子系统的一群接口。  \n   7. [享元模式](https://blog.csdn.net/guorui_java/article/details/106640489) : 通过共享技术来有效的支持大量细粒度的对象。  \n\n\n### 行为型模式  \n\n    类和对象如何交互，以及划分责任和算法\n\n   1. [策略模式](https://blog.csdn.net/guorui_java/article/details/104039882) : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  \n   2. [模板模式](https://blog.csdn.net/guorui_java/article/details/106677554) : 定义一个算法结构，而将一些步骤延迟到子类中实现。  \n   3. [命令模式](https://blog.csdn.net/guorui_java/article/details/106718457) : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  \n   4. [迭代器模式](https://blog.csdn.net/guorui_java/article/details/104247911) : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  \n   5. [观察者模式](https://blog.csdn.net/guorui_java/article/details/104247965) : 对象间的一对多的依赖关系。  \n   6. [仲裁者模式](https://blog.csdn.net/guorui_java/article/details/104247966) : 用一个中介对象来封装一系列的对象交互。  \n   7. [备忘录模式](https://blog.csdn.net/guorui_java/article/details/104247969) : 在不破坏封装的前提下，保持对象的内部状态。  \n   8. [解释器模式](https://blog.csdn.net/guorui_java/article/details/104247972) : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  \n   9. [状态模式](https://blog.csdn.net/guorui_java/article/details/104247975) : 允许一个对象在对象内部状态改变时改变它的行为。  \n   10. [责任链模式](https://blog.csdn.net/guorui_java/article/details/104247978) : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  \n   11. [访问者模式](https://blog.csdn.net/guorui_java/article/details/104247935) : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  \n\n\n ## 设计模式的原则\n\n ### 1. 单一职责原则 \n    \n    对于一个类，只有一个引起该类变化的原因。  \n    该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n\n ### 2. 接口隔离原则  \n    \n    客户端不应该依赖它不需要的接口。  \n    一个类对另一个类的依赖应该建立在最小接口上。\n\n### 3. 依赖倒转原则  \n\n    程序要依赖于抽象接口，不要依赖于具体实现。  \n    简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n\n### 4. 里式代替原则  \n\n    1. 任何基类出现的地方，子类一定可以出现。  \n    2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n    3. 里式替代原则是对开闭原则的补充。  \n    4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n\n### 5. 开闭原则  \n\n1. 对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  \n2. 对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  \n\n### 6. 迪米特法则\n\n    迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n\n### 7. 合成复用原则  \n\n    1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n    2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n    3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n\n[设计模式七大原则总结](https://blog.csdn.net/guorui_java/article/details/106469226)  \n\n## 设计模式关系  \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式关系图.jpg) \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式之间的关系.png) \n\n## 设计模式感想  \n一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展\n性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。\n\n同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 \n\n## 设计模式回顾  \n从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；\n\n其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；\n\n然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；\n\n之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；\n\n然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；\n\n之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；\n\n然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；\n\n然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；\n\n然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；\n\n然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；\n\n接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；\n\n接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；\n\n然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；\n\n接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；\n\n然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；\n\n然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；\n\n然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；\n\n然后是享元模式，轻量级对象，通过共用不变对象来实现；\n\n然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；\n\n然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；\n\n最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。\n\n[友情链接](https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)","slug":"lh/设计模式/设计模式初讲","published":1,"updated":"2021-09-01T02:46:05.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af866000kcst7bahgd2i5","content":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p>\n<h2 id=\"设计模式的三大分类及关键点\"><a href=\"#设计模式的三大分类及关键点\" class=\"headerlink\" title=\"设计模式的三大分类及关键点\"></a>设计模式的三大分类及关键点</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB.jpg\" alt=\"设计模式三大分类\"></p>\n<h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h3><pre><code>对象实例化的模式，创建型模式用于解耦对象实例化的过程\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106585965\">单列模式</a>: 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/105087806\">工厂模式</a>: 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106535411\">抽象工厂模式</a> : 创建相关或依赖对象的家族，而无需明确指定具体类。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106684541\">建造者模式</a> : 封装一个复杂对象的创建过程，并可以安步骤构造。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106544941\">原型模式</a> : 通过复制现有的实例来创建新的实例。</li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h3><pre><code>把类或对象结合在一起形成一个更大的结构\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106613220\">装饰模式</a> : 动态的给对象添加新的功能。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106665200\">代理模式</a> : 未其他对象提供一个代理以便控制这个对象的访问。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106688252\">桥接模式</a> : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106584559\">适配器模式</a> : 将一个类的方法接口转换到客户希望的另一个接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106617887\">组合模式</a> : 将对象组合成树形结构以表示“部分-整体”的结构层次。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247938\">外观模式</a> : 对外提供一个统一的方法，来访问子系统的一群接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106640489\">享元模式</a> : 通过共享技术来有效的支持大量细粒度的对象。  </li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h3><pre><code>类和对象如何交互，以及划分责任和算法\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104039882\">策略模式</a> : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106677554\">模板模式</a> : 定义一个算法结构，而将一些步骤延迟到子类中实现。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106718457\">命令模式</a> : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247911\">迭代器模式</a> : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247965\">观察者模式</a> : 对象间的一对多的依赖关系。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247966\">仲裁者模式</a> : 用一个中介对象来封装一系列的对象交互。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247969\">备忘录模式</a> : 在不破坏封装的前提下，保持对象的内部状态。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247972\">解释器模式</a> : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247975\">状态模式</a> : 允许一个对象在对象内部状态改变时改变它的行为。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247978\">责任链模式</a> : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247935\">访问者模式</a> : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  </li>\n</ol>\n<h2 id=\"设计模式的原则\"><a href=\"#设计模式的原则\" class=\"headerlink\" title=\"设计模式的原则\"></a>设计模式的原则</h2><h3 id=\"1-单一职责原则\"><a href=\"#1-单一职责原则\" class=\"headerlink\" title=\"1. 单一职责原则\"></a>1. 单一职责原则</h3><pre><code>对于一个类，只有一个引起该类变化的原因。  \n该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n</code></pre>\n<h3 id=\"2-接口隔离原则\"><a href=\"#2-接口隔离原则\" class=\"headerlink\" title=\"2. 接口隔离原则\"></a>2. 接口隔离原则</h3><pre><code>客户端不应该依赖它不需要的接口。  \n一个类对另一个类的依赖应该建立在最小接口上。\n</code></pre>\n<h3 id=\"3-依赖倒转原则\"><a href=\"#3-依赖倒转原则\" class=\"headerlink\" title=\"3. 依赖倒转原则\"></a>3. 依赖倒转原则</h3><pre><code>程序要依赖于抽象接口，不要依赖于具体实现。  \n简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n</code></pre>\n<h3 id=\"4-里式代替原则\"><a href=\"#4-里式代替原则\" class=\"headerlink\" title=\"4. 里式代替原则\"></a>4. 里式代替原则</h3><pre><code>1. 任何基类出现的地方，子类一定可以出现。  \n2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n3. 里式替代原则是对开闭原则的补充。  \n4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n</code></pre>\n<h3 id=\"5-开闭原则\"><a href=\"#5-开闭原则\" class=\"headerlink\" title=\"5. 开闭原则\"></a>5. 开闭原则</h3><ol>\n<li>对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  </li>\n<li>对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  </li>\n</ol>\n<h3 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6. 迪米特法则\"></a>6. 迪米特法则</h3><pre><code>迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n</code></pre>\n<h3 id=\"7-合成复用原则\"><a href=\"#7-合成复用原则\" class=\"headerlink\" title=\"7. 合成复用原则\"></a>7. 合成复用原则</h3><pre><code>1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n</code></pre>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/106469226\">设计模式七大原则总结</a>  </p>\n<h2 id=\"设计模式关系\"><a href=\"#设计模式关系\" class=\"headerlink\" title=\"设计模式关系\"></a>设计模式关系</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg\" alt=\"设计模式之间的关系\"> </p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"设计模式之间的关系\"> </p>\n<h2 id=\"设计模式感想\"><a href=\"#设计模式感想\" class=\"headerlink\" title=\"设计模式感想\"></a>设计模式感想</h2><p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展<br>性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p>\n<p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 </p>\n<h2 id=\"设计模式回顾\"><a href=\"#设计模式回顾\" class=\"headerlink\" title=\"设计模式回顾\"></a>设计模式回顾</h2><p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p>\n<p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p>\n<p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p>\n<p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p>\n<p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p>\n<p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p>\n<p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p>\n<p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p>\n<p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p>\n<p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p>\n<p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p>\n<p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p>\n<p>然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；</p>\n<p>接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；</p>\n<p>然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；</p>\n<p>然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；</p>\n<p>然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；</p>\n<p>然后是享元模式，轻量级对象，通过共用不变对象来实现；</p>\n<p>然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；</p>\n<p>然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；</p>\n<p>最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。</p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187\">友情链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p>\n<h2 id=\"设计模式的三大分类及关键点\"><a href=\"#设计模式的三大分类及关键点\" class=\"headerlink\" title=\"设计模式的三大分类及关键点\"></a>设计模式的三大分类及关键点</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB.jpg\" alt=\"设计模式三大分类\"></p>\n<h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h3><pre><code>对象实例化的模式，创建型模式用于解耦对象实例化的过程\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106585965\">单列模式</a>: 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/105087806\">工厂模式</a>: 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106535411\">抽象工厂模式</a> : 创建相关或依赖对象的家族，而无需明确指定具体类。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106684541\">建造者模式</a> : 封装一个复杂对象的创建过程，并可以安步骤构造。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106544941\">原型模式</a> : 通过复制现有的实例来创建新的实例。</li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h3><pre><code>把类或对象结合在一起形成一个更大的结构\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106613220\">装饰模式</a> : 动态的给对象添加新的功能。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106665200\">代理模式</a> : 未其他对象提供一个代理以便控制这个对象的访问。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106688252\">桥接模式</a> : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106584559\">适配器模式</a> : 将一个类的方法接口转换到客户希望的另一个接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106617887\">组合模式</a> : 将对象组合成树形结构以表示“部分-整体”的结构层次。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247938\">外观模式</a> : 对外提供一个统一的方法，来访问子系统的一群接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106640489\">享元模式</a> : 通过共享技术来有效的支持大量细粒度的对象。  </li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h3><pre><code>类和对象如何交互，以及划分责任和算法\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104039882\">策略模式</a> : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106677554\">模板模式</a> : 定义一个算法结构，而将一些步骤延迟到子类中实现。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106718457\">命令模式</a> : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247911\">迭代器模式</a> : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247965\">观察者模式</a> : 对象间的一对多的依赖关系。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247966\">仲裁者模式</a> : 用一个中介对象来封装一系列的对象交互。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247969\">备忘录模式</a> : 在不破坏封装的前提下，保持对象的内部状态。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247972\">解释器模式</a> : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247975\">状态模式</a> : 允许一个对象在对象内部状态改变时改变它的行为。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247978\">责任链模式</a> : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247935\">访问者模式</a> : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  </li>\n</ol>\n<h2 id=\"设计模式的原则\"><a href=\"#设计模式的原则\" class=\"headerlink\" title=\"设计模式的原则\"></a>设计模式的原则</h2><h3 id=\"1-单一职责原则\"><a href=\"#1-单一职责原则\" class=\"headerlink\" title=\"1. 单一职责原则\"></a>1. 单一职责原则</h3><pre><code>对于一个类，只有一个引起该类变化的原因。  \n该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n</code></pre>\n<h3 id=\"2-接口隔离原则\"><a href=\"#2-接口隔离原则\" class=\"headerlink\" title=\"2. 接口隔离原则\"></a>2. 接口隔离原则</h3><pre><code>客户端不应该依赖它不需要的接口。  \n一个类对另一个类的依赖应该建立在最小接口上。\n</code></pre>\n<h3 id=\"3-依赖倒转原则\"><a href=\"#3-依赖倒转原则\" class=\"headerlink\" title=\"3. 依赖倒转原则\"></a>3. 依赖倒转原则</h3><pre><code>程序要依赖于抽象接口，不要依赖于具体实现。  \n简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n</code></pre>\n<h3 id=\"4-里式代替原则\"><a href=\"#4-里式代替原则\" class=\"headerlink\" title=\"4. 里式代替原则\"></a>4. 里式代替原则</h3><pre><code>1. 任何基类出现的地方，子类一定可以出现。  \n2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n3. 里式替代原则是对开闭原则的补充。  \n4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n</code></pre>\n<h3 id=\"5-开闭原则\"><a href=\"#5-开闭原则\" class=\"headerlink\" title=\"5. 开闭原则\"></a>5. 开闭原则</h3><ol>\n<li>对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  </li>\n<li>对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  </li>\n</ol>\n<h3 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6. 迪米特法则\"></a>6. 迪米特法则</h3><pre><code>迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n</code></pre>\n<h3 id=\"7-合成复用原则\"><a href=\"#7-合成复用原则\" class=\"headerlink\" title=\"7. 合成复用原则\"></a>7. 合成复用原则</h3><pre><code>1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n</code></pre>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/106469226\">设计模式七大原则总结</a>  </p>\n<h2 id=\"设计模式关系\"><a href=\"#设计模式关系\" class=\"headerlink\" title=\"设计模式关系\"></a>设计模式关系</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg\" alt=\"设计模式之间的关系\"> </p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"设计模式之间的关系\"> </p>\n<h2 id=\"设计模式感想\"><a href=\"#设计模式感想\" class=\"headerlink\" title=\"设计模式感想\"></a>设计模式感想</h2><p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展<br>性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p>\n<p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 </p>\n<h2 id=\"设计模式回顾\"><a href=\"#设计模式回顾\" class=\"headerlink\" title=\"设计模式回顾\"></a>设计模式回顾</h2><p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p>\n<p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p>\n<p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p>\n<p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p>\n<p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p>\n<p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p>\n<p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p>\n<p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p>\n<p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p>\n<p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p>\n<p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p>\n<p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p>\n<p>然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；</p>\n<p>接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；</p>\n<p>然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；</p>\n<p>然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；</p>\n<p>然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；</p>\n<p>然后是享元模式，轻量级对象，通过共用不变对象来实现；</p>\n<p>然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；</p>\n<p>然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；</p>\n<p>最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。</p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187\">友情链接</a></p>\n"},{"title":"Dubbo-整合Hystrix","date":"2021-08-04T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n<!-- more -->\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n## Hystrix简介\n\nHystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。\n\n## 整合Hystrix\n\n当前整合是基于 spring boot + dubbo的案例；（详情看Dubbo-基础）\n\n### 提供者改造\n\n1）导入hystrix依赖（spring boot官方提供了对hystrix的集成）  \n直接在pom.xml里加入依赖：  \n```xml\n    <!-- hystrix -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        <version>2.2.9.RELEASE</version>\n    </dependency>\n```\n注意：需要找到版本合适的netflix导入（springboot2.2.4.RELEASE & hystrix2.2.9.RELEASE & dubbo2.7.7）\n\n2）修改代码  \n修改userServiceImpl  \n```java\n@DubboService\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        List<UserAddressDto> list3 = Stream.of(new UserAddressDto(6, \"3\", \"江西赣州\", \"异常用户\", \"152*****\", false))\n                .collect(Collectors.toList());\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n        map.put(\"3\", list3);\n    }\n\n    // 方法出现异常后，调用其他方法进行返回\n    @HystrixCommand(fallbackMethod = \"getUserAddressError\")\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        if (Math.random() > 0.5) {\n            throw new RuntimeException(\"错误的参数\");\n        }\n        return map.get(userId);\n    }\n\n    private List<UserAddressDto> getUserAddressError(String userId) {\n        return map.get(\"3\");\n    }\n}\n```\n\n3）开启hystrix  \n在Application类上增加@EnableHystrix来开启：\n```java\n// 开启Hystrix，进行代理\n@EnableHystrix\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n### 消费者改造\n\n当前是在服务提供者做熔断，所以消费者不需要改造。\n（如果需要在消费者中做熔断，改造步骤和提供者一致）\n\n### 启动查看效果\n\n启动提供者和消费者，访问：http://localhost:8080/dubbo\n\n正常访问：  \n![服务熔断正常访问](https://rong0624.gitee.io/images/Dubbo/1627894884676.jpg)\n\n异常访问：  \n![服务熔断异常访问](https://rong0624.gitee.io/images/Dubbo/1627894974462.jpg)\n\n结论：Hystrix有强大的容错能力，无论是超时还是错误，都可以调用备用方法返回。","source":"_posts/oyr/Dubbo/Dubbo-整合Hystrix.md","raw":"---\ntitle: Dubbo-整合Hystrix\ndate: 2021-08-05 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Dubbo\ntags: \n    - Dubbo\n    - 分布式\n---\n\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n<!-- more -->\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n## Hystrix简介\n\nHystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。\n\n## 整合Hystrix\n\n当前整合是基于 spring boot + dubbo的案例；（详情看Dubbo-基础）\n\n### 提供者改造\n\n1）导入hystrix依赖（spring boot官方提供了对hystrix的集成）  \n直接在pom.xml里加入依赖：  \n```xml\n    <!-- hystrix -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        <version>2.2.9.RELEASE</version>\n    </dependency>\n```\n注意：需要找到版本合适的netflix导入（springboot2.2.4.RELEASE & hystrix2.2.9.RELEASE & dubbo2.7.7）\n\n2）修改代码  \n修改userServiceImpl  \n```java\n@DubboService\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        List<UserAddressDto> list3 = Stream.of(new UserAddressDto(6, \"3\", \"江西赣州\", \"异常用户\", \"152*****\", false))\n                .collect(Collectors.toList());\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n        map.put(\"3\", list3);\n    }\n\n    // 方法出现异常后，调用其他方法进行返回\n    @HystrixCommand(fallbackMethod = \"getUserAddressError\")\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        if (Math.random() > 0.5) {\n            throw new RuntimeException(\"错误的参数\");\n        }\n        return map.get(userId);\n    }\n\n    private List<UserAddressDto> getUserAddressError(String userId) {\n        return map.get(\"3\");\n    }\n}\n```\n\n3）开启hystrix  \n在Application类上增加@EnableHystrix来开启：\n```java\n// 开启Hystrix，进行代理\n@EnableHystrix\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n### 消费者改造\n\n当前是在服务提供者做熔断，所以消费者不需要改造。\n（如果需要在消费者中做熔断，改造步骤和提供者一致）\n\n### 启动查看效果\n\n启动提供者和消费者，访问：http://localhost:8080/dubbo\n\n正常访问：  \n![服务熔断正常访问](https://rong0624.gitee.io/images/Dubbo/1627894884676.jpg)\n\n异常访问：  \n![服务熔断异常访问](https://rong0624.gitee.io/images/Dubbo/1627894974462.jpg)\n\n结论：Hystrix有强大的容错能力，无论是超时还是错误，都可以调用备用方法返回。","slug":"oyr/Dubbo/Dubbo-整合Hystrix","published":1,"updated":"2021-10-26T10:28:25.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af868000ocst72yks8d14","content":"<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h2 id=\"Hystrix简介\"><a href=\"#Hystrix简介\" class=\"headerlink\" title=\"Hystrix简介\"></a>Hystrix简介</h2><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>\n<h2 id=\"整合Hystrix\"><a href=\"#整合Hystrix\" class=\"headerlink\" title=\"整合Hystrix\"></a>整合Hystrix</h2><p>当前整合是基于 spring boot + dubbo的案例；（详情看Dubbo-基础）</p>\n<h3 id=\"提供者改造\"><a href=\"#提供者改造\" class=\"headerlink\" title=\"提供者改造\"></a>提供者改造</h3><p>1）导入hystrix依赖（spring boot官方提供了对hystrix的集成）<br>直接在pom.xml里加入依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- hystrix --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.9.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注意：需要找到版本合适的netflix导入（springboot2.2.4.RELEASE &amp; hystrix2.2.9.RELEASE &amp; dubbo2.7.7）</p>\n<p>2）修改代码<br>修改userServiceImpl  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list3 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">6</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;异常用户&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;3&quot;</span>, list3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法出现异常后，调用其他方法进行返回</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;getUserAddressError&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math.random() &gt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;错误的参数&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddressError</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）开启hystrix<br>在Application类上增加@EnableHystrix来开启：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Hystrix，进行代理</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span></span><br><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者改造\"><a href=\"#消费者改造\" class=\"headerlink\" title=\"消费者改造\"></a>消费者改造</h3><p>当前是在服务提供者做熔断，所以消费者不需要改造。<br>（如果需要在消费者中做熔断，改造步骤和提供者一致）</p>\n<h3 id=\"启动查看效果\"><a href=\"#启动查看效果\" class=\"headerlink\" title=\"启动查看效果\"></a>启动查看效果</h3><p>启动提供者和消费者，访问：<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a></p>\n<p>正常访问：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627894884676.jpg\" alt=\"服务熔断正常访问\"></p>\n<p>异常访问：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627894974462.jpg\" alt=\"服务熔断异常访问\"></p>\n<p>结论：Hystrix有强大的容错能力，无论是超时还是错误，都可以调用备用方法返回。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>","more":"<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h2 id=\"Hystrix简介\"><a href=\"#Hystrix简介\" class=\"headerlink\" title=\"Hystrix简介\"></a>Hystrix简介</h2><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>\n<h2 id=\"整合Hystrix\"><a href=\"#整合Hystrix\" class=\"headerlink\" title=\"整合Hystrix\"></a>整合Hystrix</h2><p>当前整合是基于 spring boot + dubbo的案例；（详情看Dubbo-基础）</p>\n<h3 id=\"提供者改造\"><a href=\"#提供者改造\" class=\"headerlink\" title=\"提供者改造\"></a>提供者改造</h3><p>1）导入hystrix依赖（spring boot官方提供了对hystrix的集成）<br>直接在pom.xml里加入依赖：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- hystrix --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.9.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注意：需要找到版本合适的netflix导入（springboot2.2.4.RELEASE &amp; hystrix2.2.9.RELEASE &amp; dubbo2.7.7）</p>\n<p>2）修改代码<br>修改userServiceImpl  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list3 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">6</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;异常用户&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;3&quot;</span>, list3);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方法出现异常后，调用其他方法进行返回</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;getUserAddressError&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math.random() &gt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;错误的参数&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddressError</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3）开启hystrix<br>在Application类上增加@EnableHystrix来开启：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Hystrix，进行代理</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span></span><br><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者改造\"><a href=\"#消费者改造\" class=\"headerlink\" title=\"消费者改造\"></a>消费者改造</h3><p>当前是在服务提供者做熔断，所以消费者不需要改造。<br>（如果需要在消费者中做熔断，改造步骤和提供者一致）</p>\n<h3 id=\"启动查看效果\"><a href=\"#启动查看效果\" class=\"headerlink\" title=\"启动查看效果\"></a>启动查看效果</h3><p>启动提供者和消费者，访问：<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a></p>\n<p>正常访问：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627894884676.jpg\" alt=\"服务熔断正常访问\"></p>\n<p>异常访问：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627894974462.jpg\" alt=\"服务熔断异常访问\"></p>\n<p>结论：Hystrix有强大的容错能力，无论是超时还是错误，都可以调用备用方法返回。</p>"},{"title":"Dubbo-基础","date":"2021-06-24T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://rong0624.gitee.io/images/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://rong0624.gitee.io/images/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n### 特点\n\nDubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。\n\n#### 连通性\n\n- 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小\n- 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示\n- 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销\n- 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销\n- 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外\n- 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者\n- 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表\n- 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者\n\n#### 健壮性\n\n- 监控中心宕掉不影响使用，只是丢失部分采样数据\n- 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\n- 注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n- 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\n- 服务提供者无状态，任意一台宕掉后，不影响使用\n- 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n#### 伸缩性\n\n- 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心\n- 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者\n\n#### 升级性\n\n当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。\n\n下图是未来可能的一种架构：  \n![dubbo未来可能的架构](https://rong0624.gitee.io/images/Dubbo/1627982970159.jpg)\n\n# Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：  \n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置  \n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：指定使用协议，默认是dubbo  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置优先级\n\n![属性配置优先级](https://rong0624.gitee.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件优先级\n\n![配置文件优先级](https://rong0624.gitee.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://rong0624.gitee.io/images/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心页面.png)\n\n# 通讯协议\n\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\nDubbo默认使用Dubbo协议；\n\n基于Dubbo的远程调用协议：\n连接个数：单连接\n连接方式：长连接  \n传输协议：TCP  \n传输方式：NIO异步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。  \n适用场景：常规远程服务方法调用\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。  \nHessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### RMI协议\n\nJava标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多连接  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化(JSON)  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n## 多协议\n\nDubbo 允许配置多协议，在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。\n\n### 不同服务上不同协议\n\n不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议；\n\n```xml\n\n<dubbo:application name=\"world\"  />\n<dubbo:registry id=\"registry\" address=\"10.20.141.150:9090\" username=\"admin\" password=\"hello1234\" />\n\n<!-- 多协议配置 -->\n<dubbo:protocol name=\"dubbo\" port=\"20880\" />\n<dubbo:protocol name=\"rmi\" port=\"1099\" />\n\n<!-- 使用dubbo协议暴露服务 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" protocol=\"dubbo\" />\n<!-- 使用rmi协议暴露服务 -->\n<dubbo:service interface=\"com.alibaba.hello.api.DemoService\" version=\"1.0.0\" ref=\"demoService\" protocol=\"rmi\" /> \n```\n\n### 同一服务上不同协议\n\n同一服务上同时支持多种协议；\n\n```xml\n<dubbo:application name=\"world\"  />\n<dubbo:registry id=\"registry\" address=\"10.20.141.150:9090\" username=\"admin\" password=\"hello1234\" />\n\n<!-- 多协议配置 -->\n<dubbo:protocol name=\"dubbo\" port=\"20880\" />\n<dubbo:protocol name=\"hessian\" port=\"8080\" />\n\n<!-- 使用多个协议暴露服务 -->\n<dubbo:service id=\"helloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" protocol=\"dubbo,hessian\" />\n```\n\n# 序列化\n\n## Dubbo支持哪些序列化\n\n![支持的序列化](https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg)\nDubbo 支持 Hession，Dubbo，Json、Java 多种序列化方式。但是 Hessian 是其默认的序列化方式。\n\n## Hessian 的数据结构\n\nHessian 的对象序列化机制有 8 种原始类型：\n- 原始二进制数据\n- boolean\n- 64-bit date（64 位毫秒值的日期）\n- 64-bit double\n- 32-bit int\n- 64-bit long\n- null\n- UTF-8 编码的 string\n\n另外还包括 3 种递归类型：\n- list for lists and arrays\n- map for maps and dictionaries\n- object for objects\n\n还有一种特殊的类型：\n- ref：用来表示对共享对象的引用。\n\n# 通讯框架\n\n## Dubbo支持哪些通讯框架\n\n![支持的通讯框架](https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg)  \nDubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo推荐并默认使用 Netty。\n\n# 注册中心\n\n## Dubbo支持哪些注册中心\n\n![支持的注册中心](https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg)  \nZookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。\n\n## 多注册中心\n\nDubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  \n另外，注册中心是支持自定义扩展的。\n\n### 多注册中心注册\n\n案例：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"hangzhouRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"qingdaoRegistry\" address=\"10.20.141.151:9010\" default=\"false\" />\n\n<!-- 向多个注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" registry=\"hangzhouRegistry,qingdaoRegistry\" />\n```\n\n### 不同服务使用不同注册中心\n\nCRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"chinaRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"intlRegistry\" address=\"10.20.154.177:9010\" default=\"false\" />\n\n<!-- 向中文站注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" registry=\"chinaRegistry\" />\n<!-- 向国际站注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.DemoService\" version=\"1.0.0\" ref=\"demoService\" registry=\"intlRegistry\" />\n```\n\n### 多注册中心引用\n\n案例：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"chinaRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"intlRegistry\" address=\"10.20.154.177:9010\" default=\"false\" />\n\n<!-- 引用中文站服务 -->\n<dubbo:reference id=\"chinaHelloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" registry=\"chinaRegistry\" />\n<!-- 引用国际站站服务 -->\n<dubbo:reference id=\"intlHelloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" registry=\"intlRegistry\" />\n```\n\n如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 -->\n<dubbo:registry address=\"10.20.141.150:9090|10.20.154.177:9010\" />\n<!-- 引用服务 -->\n<dubbo:reference id=\"helloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" />\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")\nUserService userService;\n```","source":"_posts/oyr/Dubbo/Dubbo-基础.md","raw":"---\ntitle: Dubbo-基础\ndate: 2021-06-25 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Dubbo\ntags: \n    - Dubbo\n    - 分布式\n---\n\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://rong0624.gitee.io/images/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://rong0624.gitee.io/images/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n### 特点\n\nDubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。\n\n#### 连通性\n\n- 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小\n- 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示\n- 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销\n- 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销\n- 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外\n- 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者\n- 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表\n- 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者\n\n#### 健壮性\n\n- 监控中心宕掉不影响使用，只是丢失部分采样数据\n- 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\n- 注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n- 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\n- 服务提供者无状态，任意一台宕掉后，不影响使用\n- 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n#### 伸缩性\n\n- 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心\n- 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者\n\n#### 升级性\n\n当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。\n\n下图是未来可能的一种架构：  \n![dubbo未来可能的架构](https://rong0624.gitee.io/images/Dubbo/1627982970159.jpg)\n\n# Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：  \n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置  \n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：指定使用协议，默认是dubbo  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置优先级\n\n![属性配置优先级](https://rong0624.gitee.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件优先级\n\n![配置文件优先级](https://rong0624.gitee.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://rong0624.gitee.io/images/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://rong0624.gitee.io/images/Dubbo/dubbo监控中心页面.png)\n\n# 通讯协议\n\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\nDubbo默认使用Dubbo协议；\n\n基于Dubbo的远程调用协议：\n连接个数：单连接\n连接方式：长连接  \n传输协议：TCP  \n传输方式：NIO异步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。  \n适用场景：常规远程服务方法调用\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。  \nHessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### RMI协议\n\nJava标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多连接  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化(JSON)  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n## 多协议\n\nDubbo 允许配置多协议，在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。\n\n### 不同服务上不同协议\n\n不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议；\n\n```xml\n\n<dubbo:application name=\"world\"  />\n<dubbo:registry id=\"registry\" address=\"10.20.141.150:9090\" username=\"admin\" password=\"hello1234\" />\n\n<!-- 多协议配置 -->\n<dubbo:protocol name=\"dubbo\" port=\"20880\" />\n<dubbo:protocol name=\"rmi\" port=\"1099\" />\n\n<!-- 使用dubbo协议暴露服务 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" protocol=\"dubbo\" />\n<!-- 使用rmi协议暴露服务 -->\n<dubbo:service interface=\"com.alibaba.hello.api.DemoService\" version=\"1.0.0\" ref=\"demoService\" protocol=\"rmi\" /> \n```\n\n### 同一服务上不同协议\n\n同一服务上同时支持多种协议；\n\n```xml\n<dubbo:application name=\"world\"  />\n<dubbo:registry id=\"registry\" address=\"10.20.141.150:9090\" username=\"admin\" password=\"hello1234\" />\n\n<!-- 多协议配置 -->\n<dubbo:protocol name=\"dubbo\" port=\"20880\" />\n<dubbo:protocol name=\"hessian\" port=\"8080\" />\n\n<!-- 使用多个协议暴露服务 -->\n<dubbo:service id=\"helloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" protocol=\"dubbo,hessian\" />\n```\n\n# 序列化\n\n## Dubbo支持哪些序列化\n\n![支持的序列化](https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg)\nDubbo 支持 Hession，Dubbo，Json、Java 多种序列化方式。但是 Hessian 是其默认的序列化方式。\n\n## Hessian 的数据结构\n\nHessian 的对象序列化机制有 8 种原始类型：\n- 原始二进制数据\n- boolean\n- 64-bit date（64 位毫秒值的日期）\n- 64-bit double\n- 32-bit int\n- 64-bit long\n- null\n- UTF-8 编码的 string\n\n另外还包括 3 种递归类型：\n- list for lists and arrays\n- map for maps and dictionaries\n- object for objects\n\n还有一种特殊的类型：\n- ref：用来表示对共享对象的引用。\n\n# 通讯框架\n\n## Dubbo支持哪些通讯框架\n\n![支持的通讯框架](https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg)  \nDubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo推荐并默认使用 Netty。\n\n# 注册中心\n\n## Dubbo支持哪些注册中心\n\n![支持的注册中心](https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg)  \nZookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。\n\n## 多注册中心\n\nDubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  \n另外，注册中心是支持自定义扩展的。\n\n### 多注册中心注册\n\n案例：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"hangzhouRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"qingdaoRegistry\" address=\"10.20.141.151:9010\" default=\"false\" />\n\n<!-- 向多个注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" registry=\"hangzhouRegistry,qingdaoRegistry\" />\n```\n\n### 不同服务使用不同注册中心\n\nCRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"chinaRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"intlRegistry\" address=\"10.20.154.177:9010\" default=\"false\" />\n\n<!-- 向中文站注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" ref=\"helloService\" registry=\"chinaRegistry\" />\n<!-- 向国际站注册中心注册 -->\n<dubbo:service interface=\"com.alibaba.hello.api.DemoService\" version=\"1.0.0\" ref=\"demoService\" registry=\"intlRegistry\" />\n```\n\n### 多注册中心引用\n\n案例：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。\n\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置 -->\n<dubbo:registry id=\"chinaRegistry\" address=\"10.20.141.150:9090\" />\n<dubbo:registry id=\"intlRegistry\" address=\"10.20.154.177:9010\" default=\"false\" />\n\n<!-- 引用中文站服务 -->\n<dubbo:reference id=\"chinaHelloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" registry=\"chinaRegistry\" />\n<!-- 引用国际站站服务 -->\n<dubbo:reference id=\"intlHelloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" registry=\"intlRegistry\" />\n```\n\n如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：\n```xml\n<dubbo:application name=\"world\"  />\n\n<!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 -->\n<dubbo:registry address=\"10.20.141.150:9090|10.20.154.177:9010\" />\n<!-- 引用服务 -->\n<dubbo:reference id=\"helloService\" interface=\"com.alibaba.hello.api.HelloService\" version=\"1.0.0\" />\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")\nUserService userService;\n```","slug":"oyr/Dubbo/Dubbo-基础","published":1,"updated":"2021-10-26T10:28:25.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af869000qcst714zc3215","content":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p>\n<h4 id=\"连通性\"><a href=\"#连通性\" class=\"headerlink\" title=\"连通性\"></a>连通性</h4><ul>\n<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>\n<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>\n<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>\n<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>\n<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>\n<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>\n<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>\n<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>\n</ul>\n<h4 id=\"健壮性\"><a href=\"#健壮性\" class=\"headerlink\" title=\"健壮性\"></a>健壮性</h4><ul>\n<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>\n<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>\n<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>\n<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>\n<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>\n<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>\n</ul>\n<h4 id=\"伸缩性\"><a href=\"#伸缩性\" class=\"headerlink\" title=\"伸缩性\"></a>伸缩性</h4><ul>\n<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>\n<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>\n</ul>\n<h4 id=\"升级性\"><a href=\"#升级性\" class=\"headerlink\" title=\"升级性\"></a>升级性</h4><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。</p>\n<p>下图是未来可能的一种架构：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627982970159.jpg\" alt=\"dubbo未来可能的架构\"></p>\n<h1 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：指定使用协议，默认是dubbo<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置优先级\"><a href=\"#属性配置优先级\" class=\"headerlink\" title=\"属性配置优先级\"></a>属性配置优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置优先级\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件优先级\"><a href=\"#配置文件优先级\" class=\"headerlink\" title=\"配置文件优先级\"></a>配置文件优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件优先级\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://rong0624.gitee.io/images/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>\n<h1 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h1><h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br>Dubbo默认使用Dubbo协议；</p>\n<p>基于Dubbo的远程调用协议：<br>连接个数：单连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO异步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<br>适用场景：常规远程服务方法调用</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。<br>Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>Java标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多连接<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化(JSON)<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h2 id=\"多协议\"><a href=\"#多协议\" class=\"headerlink\" title=\"多协议\"></a>多协议</h2><p>Dubbo 允许配置多协议，在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。</p>\n<h3 id=\"不同服务上不同协议\"><a href=\"#不同服务上不同协议\" class=\"headerlink\" title=\"不同服务上不同协议\"></a>不同服务上不同协议</h3><p>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;registry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> <span class=\"attr\">username</span>=<span class=\"string\">&quot;admin&quot;</span> <span class=\"attr\">password</span>=<span class=\"string\">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多协议配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rmi&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;1099&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;dubbo&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;rmi&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同一服务上不同协议\"><a href=\"#同一服务上不同协议\" class=\"headerlink\" title=\"同一服务上不同协议\"></a>同一服务上不同协议</h3><p>同一服务上同时支持多种协议；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;registry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> <span class=\"attr\">username</span>=<span class=\"string\">&quot;admin&quot;</span> <span class=\"attr\">password</span>=<span class=\"string\">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多协议配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hessian&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8080&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;dubbo,hessian&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><h2 id=\"Dubbo支持哪些序列化\"><a href=\"#Dubbo支持哪些序列化\" class=\"headerlink\" title=\"Dubbo支持哪些序列化\"></a>Dubbo支持哪些序列化</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg\" alt=\"支持的序列化\"><br>Dubbo 支持 Hession，Dubbo，Json、Java 多种序列化方式。但是 Hessian 是其默认的序列化方式。</p>\n<h2 id=\"Hessian-的数据结构\"><a href=\"#Hessian-的数据结构\" class=\"headerlink\" title=\"Hessian 的数据结构\"></a>Hessian 的数据结构</h2><p>Hessian 的对象序列化机制有 8 种原始类型：</p>\n<ul>\n<li>原始二进制数据</li>\n<li>boolean</li>\n<li>64-bit date（64 位毫秒值的日期）</li>\n<li>64-bit double</li>\n<li>32-bit int</li>\n<li>64-bit long</li>\n<li>null</li>\n<li>UTF-8 编码的 string</li>\n</ul>\n<p>另外还包括 3 种递归类型：</p>\n<ul>\n<li>list for lists and arrays</li>\n<li>map for maps and dictionaries</li>\n<li>object for objects</li>\n</ul>\n<p>还有一种特殊的类型：</p>\n<ul>\n<li>ref：用来表示对共享对象的引用。</li>\n</ul>\n<h1 id=\"通讯框架\"><a href=\"#通讯框架\" class=\"headerlink\" title=\"通讯框架\"></a>通讯框架</h1><h2 id=\"Dubbo支持哪些通讯框架\"><a href=\"#Dubbo支持哪些通讯框架\" class=\"headerlink\" title=\"Dubbo支持哪些通讯框架\"></a>Dubbo支持哪些通讯框架</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg\" alt=\"支持的通讯框架\"><br>Dubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo推荐并默认使用 Netty。</p>\n<h1 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h1><h2 id=\"Dubbo支持哪些注册中心\"><a href=\"#Dubbo支持哪些注册中心\" class=\"headerlink\" title=\"Dubbo支持哪些注册中心\"></a>Dubbo支持哪些注册中心</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg\" alt=\"支持的注册中心\"><br>Zookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。</p>\n<h2 id=\"多注册中心\"><a href=\"#多注册中心\" class=\"headerlink\" title=\"多注册中心\"></a>多注册中心</h2><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。<br>另外，注册中心是支持自定义扩展的。</p>\n<h3 id=\"多注册中心注册\"><a href=\"#多注册中心注册\" class=\"headerlink\" title=\"多注册中心注册\"></a>多注册中心注册</h3><p>案例：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;hangzhouRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;qingdaoRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.151:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向多个注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;hangzhouRegistry,qingdaoRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同服务使用不同注册中心\"><a href=\"#不同服务使用不同注册中心\" class=\"headerlink\" title=\"不同服务使用不同注册中心\"></a>不同服务使用不同注册中心</h3><p>CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.154.177:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向中文站注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向国际站注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多注册中心引用\"><a href=\"#多注册中心引用\" class=\"headerlink\" title=\"多注册中心引用\"></a>多注册中心引用</h3><p>案例：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.154.177:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用中文站服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaHelloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用国际站站服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlHelloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090|10.20.154.177:9010&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span></span><br><span class=\"line\">UserService userService;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>","more":"<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p>\n<h4 id=\"连通性\"><a href=\"#连通性\" class=\"headerlink\" title=\"连通性\"></a>连通性</h4><ul>\n<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>\n<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>\n<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>\n<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>\n<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>\n<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>\n<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>\n<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>\n</ul>\n<h4 id=\"健壮性\"><a href=\"#健壮性\" class=\"headerlink\" title=\"健壮性\"></a>健壮性</h4><ul>\n<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>\n<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>\n<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>\n<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>\n<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>\n<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>\n</ul>\n<h4 id=\"伸缩性\"><a href=\"#伸缩性\" class=\"headerlink\" title=\"伸缩性\"></a>伸缩性</h4><ul>\n<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>\n<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>\n</ul>\n<h4 id=\"升级性\"><a href=\"#升级性\" class=\"headerlink\" title=\"升级性\"></a>升级性</h4><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。</p>\n<p>下图是未来可能的一种架构：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/1627982970159.jpg\" alt=\"dubbo未来可能的架构\"></p>\n<h1 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：指定使用协议，默认是dubbo<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置优先级\"><a href=\"#属性配置优先级\" class=\"headerlink\" title=\"属性配置优先级\"></a>属性配置优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置优先级\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件优先级\"><a href=\"#配置文件优先级\" class=\"headerlink\" title=\"配置文件优先级\"></a>配置文件优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件优先级\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://rong0624.gitee.io/images/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://rong0624.gitee.io/images/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>\n<h1 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h1><h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br>Dubbo默认使用Dubbo协议；</p>\n<p>基于Dubbo的远程调用协议：<br>连接个数：单连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO异步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<br>适用场景：常规远程服务方法调用</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。<br>Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>Java标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多连接<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化(JSON)<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h2 id=\"多协议\"><a href=\"#多协议\" class=\"headerlink\" title=\"多协议\"></a>多协议</h2><p>Dubbo 允许配置多协议，在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。</p>\n<h3 id=\"不同服务上不同协议\"><a href=\"#不同服务上不同协议\" class=\"headerlink\" title=\"不同服务上不同协议\"></a>不同服务上不同协议</h3><p>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;registry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> <span class=\"attr\">username</span>=<span class=\"string\">&quot;admin&quot;</span> <span class=\"attr\">password</span>=<span class=\"string\">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多协议配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rmi&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;1099&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;dubbo&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;rmi&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同一服务上不同协议\"><a href=\"#同一服务上不同协议\" class=\"headerlink\" title=\"同一服务上不同协议\"></a>同一服务上不同协议</h3><p>同一服务上同时支持多种协议；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;registry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> <span class=\"attr\">username</span>=<span class=\"string\">&quot;admin&quot;</span> <span class=\"attr\">password</span>=<span class=\"string\">&quot;hello1234&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多协议配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hessian&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8080&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;dubbo,hessian&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><h2 id=\"Dubbo支持哪些序列化\"><a href=\"#Dubbo支持哪些序列化\" class=\"headerlink\" title=\"Dubbo支持哪些序列化\"></a>Dubbo支持哪些序列化</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg\" alt=\"支持的序列化\"><br>Dubbo 支持 Hession，Dubbo，Json、Java 多种序列化方式。但是 Hessian 是其默认的序列化方式。</p>\n<h2 id=\"Hessian-的数据结构\"><a href=\"#Hessian-的数据结构\" class=\"headerlink\" title=\"Hessian 的数据结构\"></a>Hessian 的数据结构</h2><p>Hessian 的对象序列化机制有 8 种原始类型：</p>\n<ul>\n<li>原始二进制数据</li>\n<li>boolean</li>\n<li>64-bit date（64 位毫秒值的日期）</li>\n<li>64-bit double</li>\n<li>32-bit int</li>\n<li>64-bit long</li>\n<li>null</li>\n<li>UTF-8 编码的 string</li>\n</ul>\n<p>另外还包括 3 种递归类型：</p>\n<ul>\n<li>list for lists and arrays</li>\n<li>map for maps and dictionaries</li>\n<li>object for objects</li>\n</ul>\n<p>还有一种特殊的类型：</p>\n<ul>\n<li>ref：用来表示对共享对象的引用。</li>\n</ul>\n<h1 id=\"通讯框架\"><a href=\"#通讯框架\" class=\"headerlink\" title=\"通讯框架\"></a>通讯框架</h1><h2 id=\"Dubbo支持哪些通讯框架\"><a href=\"#Dubbo支持哪些通讯框架\" class=\"headerlink\" title=\"Dubbo支持哪些通讯框架\"></a>Dubbo支持哪些通讯框架</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg\" alt=\"支持的通讯框架\"><br>Dubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo推荐并默认使用 Netty。</p>\n<h1 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h1><h2 id=\"Dubbo支持哪些注册中心\"><a href=\"#Dubbo支持哪些注册中心\" class=\"headerlink\" title=\"Dubbo支持哪些注册中心\"></a>Dubbo支持哪些注册中心</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg\" alt=\"支持的注册中心\"><br>Zookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。</p>\n<h2 id=\"多注册中心\"><a href=\"#多注册中心\" class=\"headerlink\" title=\"多注册中心\"></a>多注册中心</h2><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。<br>另外，注册中心是支持自定义扩展的。</p>\n<h3 id=\"多注册中心注册\"><a href=\"#多注册中心注册\" class=\"headerlink\" title=\"多注册中心注册\"></a>多注册中心注册</h3><p>案例：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;hangzhouRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;qingdaoRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.151:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向多个注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;hangzhouRegistry,qingdaoRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不同服务使用不同注册中心\"><a href=\"#不同服务使用不同注册中心\" class=\"headerlink\" title=\"不同服务使用不同注册中心\"></a>不同服务使用不同注册中心</h3><p>CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.154.177:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向中文站注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 向国际站注册中心注册 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.DemoService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多注册中心引用\"><a href=\"#多注册中心引用\" class=\"headerlink\" title=\"多注册中心引用\"></a>多注册中心引用</h3><p>案例：CRM 需同时调用中文站和国际站的 PC2 服务，PC2 在中文站和国际站均有部署，接口及版本号都一样，但连的数据库不一样。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.154.177:9010&quot;</span> <span class=\"attr\">default</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用中文站服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chinaHelloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;chinaRegistry&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用国际站站服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;intlHelloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> <span class=\"attr\">registry</span>=<span class=\"string\">&quot;intlRegistry&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果只是测试环境临时需要连接两个不同注册中心，使用竖号分隔多个不同注册中心地址：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;world&quot;</span>  /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 多注册中心配置，竖号分隔表示同时连接多个不同注册中心，同一注册中心的多个集群地址用逗号分隔 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;10.20.141.150:9090|10.20.154.177:9010&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 引用服务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;helloService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span></span><br><span class=\"line\">UserService userService;</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo-高级","date":"2021-07-07T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的```dubbo.application.name```相同，Dubbo则会认为是同一集群。\n\n<!-- more -->\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群容错配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 服务降级\n\n### 服务降级概念\n\n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n### Dubbo 服务降级机制\n\nDubbo的服务降级采用的是mock机制；即当服务提供者出错时（抛出 RpcException），进行 mock 调用；  \n同时也可以用于本地测试，用服务消费者端配置的 mock 服务替代要调用的远程服务，亦或者是对某个服务消费者屏蔽服务提供者，不让其进行远程调用。\n\n其具有两种策略方式：\n- fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n- force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n\n### fail 策略\n\n当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n\n#### mock=“true”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"true\" />\n\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:true\" />\n```\n解释：指定 mock 策略为布尔类型，且为 true，此时需要消费端提供服务接口的 mock 实现类，该类的包名需要与服务接口一致，且类名格式为 [接口名 + Mock], 即 com.oyr.user.service.UserServiceMock, 当调用远程服务失败后, 就会执行 UserServiceMock的相同方法（远程调用是hello方法，那么即会调用mock的hello方法）, 如果不提供此 mock 类，dubbo 消费端会启动失败。\n\n#### mock=“具体的mock实现类”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"com.oyr.user.service.mock.UserServiceMock\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:com.oyr.user.service.mock.UserServiceMock\" />\n```\n\n解释：指定 mock 策略为具体的 mock 实现类, 当调用远程服务失败时, 就会执行 mock 实现类的相同方法.\n\n#### mock=“抛出自定义异常”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"throw org.apache.dubbo.demo.consumer.exception.CustomException\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:throw org.apache.dubbo.demo.consumer.exception.CustomException\" />\n```\n\n解释：指定 mock 策略为抛出自定义异常, 当远程服务调用失败后, 会给服务消费者抛出自定义异常.\n\n#### mock=“返回 mock 数据”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"return null\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:return null\" />\n```\n\n解释：指定 mock 属性值为返回 mock 数据，当远程服务调用失败后，就会给服务消费者返回null。\n\n### force 策略\n\n当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n具体的策略跟 fail 策略一致，此处不再详细说明。\n\n#### mock=“force:true”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"“force:true\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n#### mock=“force: 执行Mock实现类”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:com.apache.dubbo.demo.DemoServiceMock2\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n#### mock=“force:抛出自定义异常”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:throw com.apache.dubbo.demo.XXXException\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n#### mock=“force:返回mock数据”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:return xxx\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n# Dubbo SPI 机制\n\n## SPI 是什么？\n\nSPI（service provider interface）。  \nSPI 就是通过动态加载机制实现面向接口编程;  \nSPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;\n\nSPI 一般用在哪儿？  \n主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。\n\n举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。\n\n## API 和 SPI 的区别\n\nAPI （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。\n\nSPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。\n\n## Java SPI\n\n### Java SPI 简介\n\nSPI 经典的思想体现，大家平时都在用，比如说 jdbc。\nJava 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。\n但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如 mysql，你就将 mysql-jdbc-connector.jar 引入进来；oracle，你就将 oracle-jdbc-connector.jar 引入进来。\n在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。\n\n### Java SPI 实现细节\n\nJava SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个**以服务接口命名的文件**，然后**文件里面记录的是此 jar 包提供的具体实现类的全限定名。**  \n这样当我们引用了某个jar包的时候，就可以去找这个jar包的META-INF/services/目录，再根据接口名找到文件，然后读取文件里面的内容去进行实现类的加载与实例化。\n\n看个案例：看下MySql是怎么做的：  \n![MySql SPI实现1](https://rong0624.gitee.io/images/Dubbo/MySql_SPI实现1.png)\n再看下文件里的内容：  \n![MySql SPI实现2](https://rong0624.gitee.io/images/Dubbo/MySql_SPI实现2.png)\n\n### Java SPI 缺点\n\nJava SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。\n\n所以说 Java SPI 无法按需加载实现类。\n\n## Dubbo SPI\n\n### Dubbo SPI 简介\n\nDubbo 也用了 SPI 思想，不过没有用 jdk 的 SPI 机制，是自己实现的一套 SPI 机制。\nDubbo SPI：是按需加载实现类的，按需加载的话首先你得给个名字，通过名字去文件里面找到对应的实现类全限定名然后加载实例化即可。Dubbo 就是这样设计的，配置文件里面存放的是键值对。\n\n我们先来看一下 Dubbo 对配置文件目录的约定，不同于 Java SPI ，Dubbo 分为了三类目录：\n- META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。\n- META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。\n- META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。\n\n注意：Dubbo SPI 除了可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有个自适应扩展机制。\n\n### Dubbo SPI 实现细节\n\n注意：当前拿 Dubbo Protocol 来演示。\n\nProtocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。\n它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。\n```java\n@SPI(\"dubbo\")  \npublic interface Protocol {  \n      \n    int getDefaultPort();  \n  \n    @Adaptive  \n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;  \n  \n    @Adaptive  \n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;  \n\n    void destroy();  \n  \n}  \n```\n\n在 dubbo 自己的 jar 里，在/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件中：\n```\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol\ninjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol\nhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol\nrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol\norg.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol\nnative-thrift=org.apache.dubbo.rpc.protocol.nativethrift.ThriftProtocol\nmemcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol\nrest=org.apache.dubbo.rpc.protocol.rest.RestProtocol\nxmlrpc=org.apache.dubbo.xml.rpc.protocol.xmlrpc.XmlRpcProtocol\ngrpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol\n```\n\n所以说，这就看到了 dubbo 的 SPI 机制默认是怎么玩儿的了，其实就是 Protocol 接口，@SPI(\"dubbo\") 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。\n\n如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口，Protocol 接口中，有两个方法加了 @Adaptive 注解，就是说那俩接口会被代理实现。\n比如这个 Protocol 接口搞了俩 @Adaptive 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。\n\n### Dubbo 自定义扩展组件\n\n这里展示一下，如何去扩展 Dubbo Protocol 的组件；\n\n#### 新开一个maven工程（protocol-demo），打包方式为jar；\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.oyr</groupId>\n    <artifactId>protocol-demo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <dependencies>\n        <!-- dubbo -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n            <version>2.7.7</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n#### Protocol 自定义实现\n\n以下代码，是将 Dubbo RmiProtocol 的实现复制过来的，当做是自定义的 Protocol 实现\n```java\npackage com.oyr.dubbo.protocol;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;\nimport org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation;\nimport org.apache.dubbo.rpc.service.GenericService;\nimport org.apache.dubbo.rpc.support.ProtocolUtils;\nimport org.springframework.remoting.RemoteAccessException;\nimport org.springframework.remoting.rmi.RmiProxyFactoryBean;\nimport org.springframework.remoting.rmi.RmiServiceExporter;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.rmi.RemoteException;\n\nimport static org.apache.dubbo.common.Version.isRelease263OrHigher;\nimport static org.apache.dubbo.common.Version.isRelease270OrHigher;\nimport static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;\nimport static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n\npublic class MyProtocol extends AbstractProxyProtocol {\n\n    public static final int DEFAULT_PORT = 1099;\n\n    public MyProtocol() {\n        super(RemoteAccessException.class, RemoteException.class);\n        System.out.println(\"MyProtocol Init\");\n    }\n\n    @Override\n    public int getDefaultPort() {\n        return DEFAULT_PORT;\n    }\n\n    @Override\n    protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {\n        RmiServiceExporter rmiServiceExporter = createExporter(impl, type, url, false);\n        RmiServiceExporter genericServiceExporter = createExporter(impl, GenericService.class, url, true);\n        return new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    rmiServiceExporter.destroy();\n                    genericServiceExporter.destroy();\n                } catch (Throwable e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {\n        final RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();\n        final String generic = url.getParameter(GENERIC_KEY);\n        final boolean isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class);\n        /*\n          RMI needs extra parameter since it uses customized remote invocation object\n\n          The customized RemoteInvocation was firstly introduced in v2.6.3; The package was renamed to 'org.apache.*' since v2.7.0\n          Considering the above two conditions, we need to check before sending customized RemoteInvocation:\n          1. if the provider version is v2.7.0 or higher, send 'org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation'.\n          2. if the provider version is v2.6.3 or higher, send 'com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation'.\n          3. if the provider version is lower than v2.6.3, does not use customized RemoteInvocation.\n         */\n        if (isRelease270OrHigher(url.getParameter(RELEASE_KEY))) {\n            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                RemoteInvocation invocation = new RmiRemoteInvocation(methodInvocation);\n                if (isGeneric) {\n                    invocation.addAttribute(GENERIC_KEY, generic);\n                }\n                return invocation;\n            });\n        } else if (isRelease263OrHigher(url.getParameter(DUBBO_VERSION_KEY))) {\n            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                RemoteInvocation invocation = new com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation(methodInvocation);\n                if (isGeneric) {\n                    invocation.addAttribute(GENERIC_KEY, generic);\n                }\n                return invocation;\n            });\n        }\n        String serviceUrl = url.toIdentityString();\n        if (isGeneric) {\n            serviceUrl = serviceUrl + \"/\" + GENERIC_KEY;\n        }\n        rmiProxyFactoryBean.setServiceUrl(serviceUrl);\n        rmiProxyFactoryBean.setServiceInterface(serviceType);\n        rmiProxyFactoryBean.setCacheStub(true);\n        rmiProxyFactoryBean.setLookupStubOnStartup(true);\n        rmiProxyFactoryBean.setRefreshStubOnConnectFailure(true);\n        rmiProxyFactoryBean.afterPropertiesSet();\n        return (T) rmiProxyFactoryBean.getObject();\n    }\n\n    @Override\n    protected int getErrorCode(Throwable e) {\n        if (e instanceof RemoteAccessException) {\n            e = e.getCause();\n        }\n        if (e != null && e.getCause() != null) {\n            Class<?> cls = e.getCause().getClass();\n            if (SocketTimeoutException.class.equals(cls)) {\n                return RpcException.TIMEOUT_EXCEPTION;\n            } else if (IOException.class.isAssignableFrom(cls)) {\n                return RpcException.NETWORK_EXCEPTION;\n            } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {\n                return RpcException.SERIALIZATION_EXCEPTION;\n            }\n        }\n        return super.getErrorCode(e);\n    }\n\n    private <T> RmiServiceExporter createExporter(T impl, Class<?> type, URL url, boolean isGeneric) {\n        final RmiServiceExporter rmiServiceExporter = new RmiServiceExporter();\n        rmiServiceExporter.setRegistryPort(url.getPort());\n        if (isGeneric) {\n            rmiServiceExporter.setServiceName(url.getPath() + \"/\" + GENERIC_KEY);\n        } else {\n            rmiServiceExporter.setServiceName(url.getPath());\n        }\n        rmiServiceExporter.setServiceInterface(type);\n        rmiServiceExporter.setService(impl);\n        try {\n            rmiServiceExporter.afterPropertiesSet();\n        } catch (RemoteException e) {\n            throw new RpcException(e.getMessage(), e);\n        }\n        return rmiServiceExporter;\n    }\n\n}\n```\n\n#### Dubbo规定目录下配置\n\n1）在工程 resources 目录下新建 ETA-INF/services 目录；  \n2）在 ETA-INF/services 目录下，新建一个 com.alibaba.dubbo.rpc.Protocol 文件；  \n3）指定 com.alibaba.dubbo.rpc.Protocol 文件内容：  \n```\nmy=com.oyr.dubbo.protocol.MyProtocol\n```\n\n#### 修改服务提供者，使用自定义的 Protocol 实现\n\n1）把自定义实现的jar依赖到服务提供者中\n\n```xml\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>protocol-demo</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n```\n\n2）修改配置，协议使用自定义实现\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\n# 使用自定义实现的协议\ndubbo.protocol.name=my\ndubbo.protocol.port=20888\n```\n\n3）启动服务提供者，查看效果；\n启动服务提供者，控制台应该打印出：MyProtocol Init；  \n这既代表已经使用了自定义实现的协议；\n\n#### 总结\n\n服务提供者启动的时候，就会加载 my=com.bingo.MyProtocol 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了；\n\ndubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。\n然后对于对应的组件，类似 <dubbo:protocol> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。\n\n## 参考博客\n\nhttps://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi\n\nhttps://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162808615116780262585211&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&utm_term=spi&spm=1018.2226.3001.4450\n\n# Dubbo Container（服务容器）\n\n## Dubbo Container 简介\n\nDubbo Container 是一个独立的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。\n\n服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。\n\n## Dubbo 内置了几种服务容器\n\n### 服务容器分类\n\ndubbo 内置了 spring, jetty, log4j 等服务容器；\n当然也可以自己扩展服务容器进行加载；\n\n### Spring Container\n\n- 自动加载 META-INF/spring 目录下的所有 Spring 配置。（这个已在源码中写死）\n- 配置 spring 配置加载位置：(dubbo.spring.config=classpath*:META-INF/spring/*.xml)\n\n### Jetty Container\n\n- 启动一个内嵌 Jetty，用于汇报状态。\n- 配置：\n    - dubbo.jetty.port=8080：配置 jetty 启动端口\n    - dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件\n    - dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面\n\n### Log4j Container\n\n- 自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。\n- 配置：\n    - dubbo.log4j.file=/foo/bar.log：配置日志文件路径\n    - dubbo.log4j.level=WARN：配置日志级别\n    - dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突\n\n## 容器启动\n\nSPI 容器扩展类：`org.apache.dubbo.container.Container`\n![SPI 容器扩展类](https://rong0624.gitee.io/images/Dubbo/1628502633574.jpg)\n\n`org.apache.dubbo.container.Main` 是服务启动的主类，在服务启动时会调用容器的 start() 方法，在服务停止时会调用 stop() 方法；\n\n那么默认到底是调用那个容器呢？注意 `org.apache.dubbo.container.Container` 接口有一个注解 `@SPI(\"spring\")`；  \n通过对 Dubbo SPI 的了解，容器应该有内嵌对应的文件：org.apache.dubbo.container.Container；  \norg.apache.dubbo.container.Container内容：\n```\nspring=org.apache.dubbo.container.spring.SpringContainer\nlog4j=org.apache.dubbo.container.log4j.Log4jContainer\nlogback=org.apache.dubbo.container.logback.LogbackContainer\n```\n通过以上分析，可以知道默认调用的是org.apache.dubbo.container.spring.SpringContainer；\n\n\n## 容器停止\n\ndubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用\"kill -9    PID\"等强制关闭指令，是不会执行优雅停机的，只有通过\"kill PID\"时，才会执行。\n\n停止源码（在Main方法里面）：\n```java\nif (\"true\".equals(System.getProperty(SHUTDOWN_HOOK_KEY))) {\n    Runtime.getRuntime().addShutdownHook(new Thread(\"dubbo-container-shutdown-hook\") {\n        @Override\n        public void run() {\n            for (Container container : containers) {\n                try {\n                    container.stop();\n                    logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\");\n                } catch (Throwable t) {\n                    logger.error(t.getMessage(), t);\n                }\n                try {\n                    LOCK.lock();\n                    STOP.signal();\n                } finally {\n                    LOCK.unlock();\n                }\n            }\n        }\n    });\n}\n```\n\n1）服务提供方  \n停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。  \n然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。\n\n2）服务消费方  \n停止时，不再发起新的调用请求，所有新的调用在客户端即报错。  \n然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。\n\n# RPC\n\n## 什么是RPC\n\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。  \n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n## RPC模型\n\n![rpc模型](https://rong0624.gitee.io/images/Dubbo/rpc通讯.png)  \n\n1. Client：客户端；服务调用方。\n2. Client Stub：客户端存根；存放服务端地址信息，将客户端的请求信息进行编码，再通过网络传输给发送端 or 接受服务端的响应数据，进行解码。\n3. Server：服务端；服务提供方。\n4. Server Stub：服务端存根；接收客户端发送的请求信息并解码，然后调用本地服务进行处理，并将处理结果进行编码后返回。\n\n**RPC两个核心模块：通讯（网络传输），序列化（编码，解码）。**\n\n## RPC调用过程\n\n![rpc序列化](https://rong0624.gitee.io/images/Dubbo/rpc序列化.png)\n\n```\n一次完整的RPC调用流程（同步调用，异步另说）如下： \n1）服务消费方以本地调用方式调用服务；（client）\n2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；\n3）client stub找到服务地址，并将消息发送到服务端；\n4）server stub收到消息后进行解码； \n5）server stub根据解码结果调用本地的服务； \n6）server本地服务执行并将结果返回给server stub；\n7）server stub将返回结果打包成消息并发送至消费方； \n8）client stub接收到消息，并进行解码； \n9）服务消费方得到最终结果。\nRPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。\n```\n\n# Dubbo 底层解析\n\n## Dubbo-架构设计\n\n![dubbo框架设计](https://rong0624.gitee.io/images/Dubbo/1627979178965.jpg)\n\n### 分类\n\n- Business 实现层\n- RPC 远程调用层\n- Remoting 网络通讯层\n\n### 各层说明\n\n- service 接口层：给服务提供者和服务消费者来实现的（留给开发人员来实现）\n- config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\n- proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\n- registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\n- cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\n- monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\n- protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\n- exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\n- transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\n- serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\n\n## Dubbo-启动解析，加载配置\n\n![启动解析](https://rong0624.gitee.io/images/Dubbo/1627981581425.jpg)\n\n## Dubbo-服务暴露\n\n![服务暴露](https://rong0624.gitee.io/images/Dubbo/1627981689580.jpg)\n\n## Dubbo-服务引用\n\n![服务引用](https://rong0624.gitee.io/images/Dubbo/1627981770108.jpg)\n\n## Dubbo-服务调用\n\n![服务调用](https://rong0624.gitee.io/images/Dubbo/1627981894490.jpg)","source":"_posts/oyr/Dubbo/Dubbo-高级.md","raw":"---\ntitle: Dubbo-高级\ndate: 2021-07-8 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Dubbo\ntags: \n    - Dubbo\n    - 分布式\n---\n\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的```dubbo.application.name```相同，Dubbo则会认为是同一集群。\n\n<!-- more -->\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群容错配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 服务降级\n\n### 服务降级概念\n\n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n### Dubbo 服务降级机制\n\nDubbo的服务降级采用的是mock机制；即当服务提供者出错时（抛出 RpcException），进行 mock 调用；  \n同时也可以用于本地测试，用服务消费者端配置的 mock 服务替代要调用的远程服务，亦或者是对某个服务消费者屏蔽服务提供者，不让其进行远程调用。\n\n其具有两种策略方式：\n- fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n- force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n\n### fail 策略\n\n当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n\n#### mock=“true”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"true\" />\n\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:true\" />\n```\n解释：指定 mock 策略为布尔类型，且为 true，此时需要消费端提供服务接口的 mock 实现类，该类的包名需要与服务接口一致，且类名格式为 [接口名 + Mock], 即 com.oyr.user.service.UserServiceMock, 当调用远程服务失败后, 就会执行 UserServiceMock的相同方法（远程调用是hello方法，那么即会调用mock的hello方法）, 如果不提供此 mock 类，dubbo 消费端会启动失败。\n\n#### mock=“具体的mock实现类”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"com.oyr.user.service.mock.UserServiceMock\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:com.oyr.user.service.mock.UserServiceMock\" />\n```\n\n解释：指定 mock 策略为具体的 mock 实现类, 当调用远程服务失败时, 就会执行 mock 实现类的相同方法.\n\n#### mock=“抛出自定义异常”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"throw org.apache.dubbo.demo.consumer.exception.CustomException\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:throw org.apache.dubbo.demo.consumer.exception.CustomException\" />\n```\n\n解释：指定 mock 策略为抛出自定义异常, 当远程服务调用失败后, 会给服务消费者抛出自定义异常.\n\n#### mock=“返回 mock 数据”\n\n```xml\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"return null\" />\nor\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" mock=\"fail:return null\" />\n```\n\n解释：指定 mock 属性值为返回 mock 数据，当远程服务调用失败后，就会给服务消费者返回null。\n\n### force 策略\n\n当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n具体的策略跟 fail 策略一致，此处不再详细说明。\n\n#### mock=“force:true”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"“force:true\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n#### mock=“force: 执行Mock实现类”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:com.apache.dubbo.demo.DemoServiceMock2\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n#### mock=“force:抛出自定义异常”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:throw com.apache.dubbo.demo.XXXException\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n#### mock=“force:返回mock数据”\n\n```xml\n<dubbo:reference id=\"demoService\" mock=\"force:return xxx\" interface=\"org.apache.dubbo.demo.DemoService\"/>\n```\n\n# Dubbo SPI 机制\n\n## SPI 是什么？\n\nSPI（service provider interface）。  \nSPI 就是通过动态加载机制实现面向接口编程;  \nSPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;\n\nSPI 一般用在哪儿？  \n主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。\n\n举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。\n\n## API 和 SPI 的区别\n\nAPI （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。\n\nSPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。\n\n## Java SPI\n\n### Java SPI 简介\n\nSPI 经典的思想体现，大家平时都在用，比如说 jdbc。\nJava 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。\n但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如 mysql，你就将 mysql-jdbc-connector.jar 引入进来；oracle，你就将 oracle-jdbc-connector.jar 引入进来。\n在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。\n\n### Java SPI 实现细节\n\nJava SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个**以服务接口命名的文件**，然后**文件里面记录的是此 jar 包提供的具体实现类的全限定名。**  \n这样当我们引用了某个jar包的时候，就可以去找这个jar包的META-INF/services/目录，再根据接口名找到文件，然后读取文件里面的内容去进行实现类的加载与实例化。\n\n看个案例：看下MySql是怎么做的：  \n![MySql SPI实现1](https://rong0624.gitee.io/images/Dubbo/MySql_SPI实现1.png)\n再看下文件里的内容：  \n![MySql SPI实现2](https://rong0624.gitee.io/images/Dubbo/MySql_SPI实现2.png)\n\n### Java SPI 缺点\n\nJava SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。\n\n所以说 Java SPI 无法按需加载实现类。\n\n## Dubbo SPI\n\n### Dubbo SPI 简介\n\nDubbo 也用了 SPI 思想，不过没有用 jdk 的 SPI 机制，是自己实现的一套 SPI 机制。\nDubbo SPI：是按需加载实现类的，按需加载的话首先你得给个名字，通过名字去文件里面找到对应的实现类全限定名然后加载实例化即可。Dubbo 就是这样设计的，配置文件里面存放的是键值对。\n\n我们先来看一下 Dubbo 对配置文件目录的约定，不同于 Java SPI ，Dubbo 分为了三类目录：\n- META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。\n- META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。\n- META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。\n\n注意：Dubbo SPI 除了可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有个自适应扩展机制。\n\n### Dubbo SPI 实现细节\n\n注意：当前拿 Dubbo Protocol 来演示。\n\nProtocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。\n它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。\n```java\n@SPI(\"dubbo\")  \npublic interface Protocol {  \n      \n    int getDefaultPort();  \n  \n    @Adaptive  \n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;  \n  \n    @Adaptive  \n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;  \n\n    void destroy();  \n  \n}  \n```\n\n在 dubbo 自己的 jar 里，在/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件中：\n```\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol\ninjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol\nhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol\nrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol\norg.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol\nnative-thrift=org.apache.dubbo.rpc.protocol.nativethrift.ThriftProtocol\nmemcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol\nrest=org.apache.dubbo.rpc.protocol.rest.RestProtocol\nxmlrpc=org.apache.dubbo.xml.rpc.protocol.xmlrpc.XmlRpcProtocol\ngrpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol\n```\n\n所以说，这就看到了 dubbo 的 SPI 机制默认是怎么玩儿的了，其实就是 Protocol 接口，@SPI(\"dubbo\") 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。\n\n如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口，Protocol 接口中，有两个方法加了 @Adaptive 注解，就是说那俩接口会被代理实现。\n比如这个 Protocol 接口搞了俩 @Adaptive 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。\n\n### Dubbo 自定义扩展组件\n\n这里展示一下，如何去扩展 Dubbo Protocol 的组件；\n\n#### 新开一个maven工程（protocol-demo），打包方式为jar；\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.oyr</groupId>\n    <artifactId>protocol-demo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <dependencies>\n        <!-- dubbo -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n            <version>2.7.7</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n#### Protocol 自定义实现\n\n以下代码，是将 Dubbo RmiProtocol 的实现复制过来的，当做是自定义的 Protocol 实现\n```java\npackage com.oyr.dubbo.protocol;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;\nimport org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation;\nimport org.apache.dubbo.rpc.service.GenericService;\nimport org.apache.dubbo.rpc.support.ProtocolUtils;\nimport org.springframework.remoting.RemoteAccessException;\nimport org.springframework.remoting.rmi.RmiProxyFactoryBean;\nimport org.springframework.remoting.rmi.RmiServiceExporter;\nimport org.springframework.remoting.support.RemoteInvocation;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.rmi.RemoteException;\n\nimport static org.apache.dubbo.common.Version.isRelease263OrHigher;\nimport static org.apache.dubbo.common.Version.isRelease270OrHigher;\nimport static org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;\nimport static org.apache.dubbo.rpc.Constants.GENERIC_KEY;\n\npublic class MyProtocol extends AbstractProxyProtocol {\n\n    public static final int DEFAULT_PORT = 1099;\n\n    public MyProtocol() {\n        super(RemoteAccessException.class, RemoteException.class);\n        System.out.println(\"MyProtocol Init\");\n    }\n\n    @Override\n    public int getDefaultPort() {\n        return DEFAULT_PORT;\n    }\n\n    @Override\n    protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {\n        RmiServiceExporter rmiServiceExporter = createExporter(impl, type, url, false);\n        RmiServiceExporter genericServiceExporter = createExporter(impl, GenericService.class, url, true);\n        return new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    rmiServiceExporter.destroy();\n                    genericServiceExporter.destroy();\n                } catch (Throwable e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {\n        final RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();\n        final String generic = url.getParameter(GENERIC_KEY);\n        final boolean isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class);\n        /*\n          RMI needs extra parameter since it uses customized remote invocation object\n\n          The customized RemoteInvocation was firstly introduced in v2.6.3; The package was renamed to 'org.apache.*' since v2.7.0\n          Considering the above two conditions, we need to check before sending customized RemoteInvocation:\n          1. if the provider version is v2.7.0 or higher, send 'org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation'.\n          2. if the provider version is v2.6.3 or higher, send 'com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation'.\n          3. if the provider version is lower than v2.6.3, does not use customized RemoteInvocation.\n         */\n        if (isRelease270OrHigher(url.getParameter(RELEASE_KEY))) {\n            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                RemoteInvocation invocation = new RmiRemoteInvocation(methodInvocation);\n                if (isGeneric) {\n                    invocation.addAttribute(GENERIC_KEY, generic);\n                }\n                return invocation;\n            });\n        } else if (isRelease263OrHigher(url.getParameter(DUBBO_VERSION_KEY))) {\n            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -> {\n                RemoteInvocation invocation = new com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation(methodInvocation);\n                if (isGeneric) {\n                    invocation.addAttribute(GENERIC_KEY, generic);\n                }\n                return invocation;\n            });\n        }\n        String serviceUrl = url.toIdentityString();\n        if (isGeneric) {\n            serviceUrl = serviceUrl + \"/\" + GENERIC_KEY;\n        }\n        rmiProxyFactoryBean.setServiceUrl(serviceUrl);\n        rmiProxyFactoryBean.setServiceInterface(serviceType);\n        rmiProxyFactoryBean.setCacheStub(true);\n        rmiProxyFactoryBean.setLookupStubOnStartup(true);\n        rmiProxyFactoryBean.setRefreshStubOnConnectFailure(true);\n        rmiProxyFactoryBean.afterPropertiesSet();\n        return (T) rmiProxyFactoryBean.getObject();\n    }\n\n    @Override\n    protected int getErrorCode(Throwable e) {\n        if (e instanceof RemoteAccessException) {\n            e = e.getCause();\n        }\n        if (e != null && e.getCause() != null) {\n            Class<?> cls = e.getCause().getClass();\n            if (SocketTimeoutException.class.equals(cls)) {\n                return RpcException.TIMEOUT_EXCEPTION;\n            } else if (IOException.class.isAssignableFrom(cls)) {\n                return RpcException.NETWORK_EXCEPTION;\n            } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {\n                return RpcException.SERIALIZATION_EXCEPTION;\n            }\n        }\n        return super.getErrorCode(e);\n    }\n\n    private <T> RmiServiceExporter createExporter(T impl, Class<?> type, URL url, boolean isGeneric) {\n        final RmiServiceExporter rmiServiceExporter = new RmiServiceExporter();\n        rmiServiceExporter.setRegistryPort(url.getPort());\n        if (isGeneric) {\n            rmiServiceExporter.setServiceName(url.getPath() + \"/\" + GENERIC_KEY);\n        } else {\n            rmiServiceExporter.setServiceName(url.getPath());\n        }\n        rmiServiceExporter.setServiceInterface(type);\n        rmiServiceExporter.setService(impl);\n        try {\n            rmiServiceExporter.afterPropertiesSet();\n        } catch (RemoteException e) {\n            throw new RpcException(e.getMessage(), e);\n        }\n        return rmiServiceExporter;\n    }\n\n}\n```\n\n#### Dubbo规定目录下配置\n\n1）在工程 resources 目录下新建 ETA-INF/services 目录；  \n2）在 ETA-INF/services 目录下，新建一个 com.alibaba.dubbo.rpc.Protocol 文件；  \n3）指定 com.alibaba.dubbo.rpc.Protocol 文件内容：  \n```\nmy=com.oyr.dubbo.protocol.MyProtocol\n```\n\n#### 修改服务提供者，使用自定义的 Protocol 实现\n\n1）把自定义实现的jar依赖到服务提供者中\n\n```xml\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>protocol-demo</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n```\n\n2）修改配置，协议使用自定义实现\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\n# 使用自定义实现的协议\ndubbo.protocol.name=my\ndubbo.protocol.port=20888\n```\n\n3）启动服务提供者，查看效果；\n启动服务提供者，控制台应该打印出：MyProtocol Init；  \n这既代表已经使用了自定义实现的协议；\n\n#### 总结\n\n服务提供者启动的时候，就会加载 my=com.bingo.MyProtocol 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了；\n\ndubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。\n然后对于对应的组件，类似 <dubbo:protocol> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。\n\n## 参考博客\n\nhttps://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi\n\nhttps://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162808615116780262585211&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&utm_term=spi&spm=1018.2226.3001.4450\n\n# Dubbo Container（服务容器）\n\n## Dubbo Container 简介\n\nDubbo Container 是一个独立的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。\n\n服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。\n\n## Dubbo 内置了几种服务容器\n\n### 服务容器分类\n\ndubbo 内置了 spring, jetty, log4j 等服务容器；\n当然也可以自己扩展服务容器进行加载；\n\n### Spring Container\n\n- 自动加载 META-INF/spring 目录下的所有 Spring 配置。（这个已在源码中写死）\n- 配置 spring 配置加载位置：(dubbo.spring.config=classpath*:META-INF/spring/*.xml)\n\n### Jetty Container\n\n- 启动一个内嵌 Jetty，用于汇报状态。\n- 配置：\n    - dubbo.jetty.port=8080：配置 jetty 启动端口\n    - dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件\n    - dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面\n\n### Log4j Container\n\n- 自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。\n- 配置：\n    - dubbo.log4j.file=/foo/bar.log：配置日志文件路径\n    - dubbo.log4j.level=WARN：配置日志级别\n    - dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突\n\n## 容器启动\n\nSPI 容器扩展类：`org.apache.dubbo.container.Container`\n![SPI 容器扩展类](https://rong0624.gitee.io/images/Dubbo/1628502633574.jpg)\n\n`org.apache.dubbo.container.Main` 是服务启动的主类，在服务启动时会调用容器的 start() 方法，在服务停止时会调用 stop() 方法；\n\n那么默认到底是调用那个容器呢？注意 `org.apache.dubbo.container.Container` 接口有一个注解 `@SPI(\"spring\")`；  \n通过对 Dubbo SPI 的了解，容器应该有内嵌对应的文件：org.apache.dubbo.container.Container；  \norg.apache.dubbo.container.Container内容：\n```\nspring=org.apache.dubbo.container.spring.SpringContainer\nlog4j=org.apache.dubbo.container.log4j.Log4jContainer\nlogback=org.apache.dubbo.container.logback.LogbackContainer\n```\n通过以上分析，可以知道默认调用的是org.apache.dubbo.container.spring.SpringContainer；\n\n\n## 容器停止\n\ndubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用\"kill -9    PID\"等强制关闭指令，是不会执行优雅停机的，只有通过\"kill PID\"时，才会执行。\n\n停止源码（在Main方法里面）：\n```java\nif (\"true\".equals(System.getProperty(SHUTDOWN_HOOK_KEY))) {\n    Runtime.getRuntime().addShutdownHook(new Thread(\"dubbo-container-shutdown-hook\") {\n        @Override\n        public void run() {\n            for (Container container : containers) {\n                try {\n                    container.stop();\n                    logger.info(\"Dubbo \" + container.getClass().getSimpleName() + \" stopped!\");\n                } catch (Throwable t) {\n                    logger.error(t.getMessage(), t);\n                }\n                try {\n                    LOCK.lock();\n                    STOP.signal();\n                } finally {\n                    LOCK.unlock();\n                }\n            }\n        }\n    });\n}\n```\n\n1）服务提供方  \n停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。  \n然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。\n\n2）服务消费方  \n停止时，不再发起新的调用请求，所有新的调用在客户端即报错。  \n然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。\n\n# RPC\n\n## 什么是RPC\n\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。  \n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n## RPC模型\n\n![rpc模型](https://rong0624.gitee.io/images/Dubbo/rpc通讯.png)  \n\n1. Client：客户端；服务调用方。\n2. Client Stub：客户端存根；存放服务端地址信息，将客户端的请求信息进行编码，再通过网络传输给发送端 or 接受服务端的响应数据，进行解码。\n3. Server：服务端；服务提供方。\n4. Server Stub：服务端存根；接收客户端发送的请求信息并解码，然后调用本地服务进行处理，并将处理结果进行编码后返回。\n\n**RPC两个核心模块：通讯（网络传输），序列化（编码，解码）。**\n\n## RPC调用过程\n\n![rpc序列化](https://rong0624.gitee.io/images/Dubbo/rpc序列化.png)\n\n```\n一次完整的RPC调用流程（同步调用，异步另说）如下： \n1）服务消费方以本地调用方式调用服务；（client）\n2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；\n3）client stub找到服务地址，并将消息发送到服务端；\n4）server stub收到消息后进行解码； \n5）server stub根据解码结果调用本地的服务； \n6）server本地服务执行并将结果返回给server stub；\n7）server stub将返回结果打包成消息并发送至消费方； \n8）client stub接收到消息，并进行解码； \n9）服务消费方得到最终结果。\nRPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。\n```\n\n# Dubbo 底层解析\n\n## Dubbo-架构设计\n\n![dubbo框架设计](https://rong0624.gitee.io/images/Dubbo/1627979178965.jpg)\n\n### 分类\n\n- Business 实现层\n- RPC 远程调用层\n- Remoting 网络通讯层\n\n### 各层说明\n\n- service 接口层：给服务提供者和服务消费者来实现的（留给开发人员来实现）\n- config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类\n- proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory\n- registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService\n- cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance\n- monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService\n- protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter\n- exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer\n- transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec\n- serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool\n\n## Dubbo-启动解析，加载配置\n\n![启动解析](https://rong0624.gitee.io/images/Dubbo/1627981581425.jpg)\n\n## Dubbo-服务暴露\n\n![服务暴露](https://rong0624.gitee.io/images/Dubbo/1627981689580.jpg)\n\n## Dubbo-服务引用\n\n![服务引用](https://rong0624.gitee.io/images/Dubbo/1627981770108.jpg)\n\n## Dubbo-服务调用\n\n![服务调用](https://rong0624.gitee.io/images/Dubbo/1627981894490.jpg)","slug":"oyr/Dubbo/Dubbo-高级","published":1,"updated":"2021-10-26T10:28:25.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86a000ucst7b34u7yrf","content":"<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的<code>dubbo.application.name</code>相同，Dubbo则会认为是同一集群。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群容错配置\"><a href=\"#集群容错配置\" class=\"headerlink\" title=\"集群容错配置\"></a>集群容错配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><h3 id=\"服务降级概念\"><a href=\"#服务降级概念\" class=\"headerlink\" title=\"服务降级概念\"></a>服务降级概念</h3><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h3 id=\"Dubbo-服务降级机制\"><a href=\"#Dubbo-服务降级机制\" class=\"headerlink\" title=\"Dubbo 服务降级机制\"></a>Dubbo 服务降级机制</h3><p>Dubbo的服务降级采用的是mock机制；即当服务提供者出错时（抛出 RpcException），进行 mock 调用；<br>同时也可以用于本地测试，用服务消费者端配置的 mock 服务替代要调用的远程服务，亦或者是对某个服务消费者屏蔽服务提供者，不让其进行远程调用。</p>\n<p>其具有两种策略方式：</p>\n<ul>\n<li>fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</li>\n<li>force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。</li>\n</ul>\n<h3 id=\"fail-策略\"><a href=\"#fail-策略\" class=\"headerlink\" title=\"fail 策略\"></a>fail 策略</h3><p>当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</p>\n<h4 id=\"mock-“true”\"><a href=\"#mock-“true”\" class=\"headerlink\" title=\"mock=“true”\"></a>mock=“true”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>解释：指定 mock 策略为布尔类型，且为 true，此时需要消费端提供服务接口的 mock 实现类，该类的包名需要与服务接口一致，且类名格式为 [接口名 + Mock], 即 com.oyr.user.service.UserServiceMock, 当调用远程服务失败后, 就会执行 UserServiceMock的相同方法（远程调用是hello方法，那么即会调用mock的hello方法）, 如果不提供此 mock 类，dubbo 消费端会启动失败。</p>\n<h4 id=\"mock-“具体的mock实现类”\"><a href=\"#mock-“具体的mock实现类”\" class=\"headerlink\" title=\"mock=“具体的mock实现类”\"></a>mock=“具体的mock实现类”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;com.oyr.user.service.mock.UserServiceMock&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:com.oyr.user.service.mock.UserServiceMock&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 策略为具体的 mock 实现类, 当调用远程服务失败时, 就会执行 mock 实现类的相同方法.</p>\n<h4 id=\"mock-“抛出自定义异常”\"><a href=\"#mock-“抛出自定义异常”\" class=\"headerlink\" title=\"mock=“抛出自定义异常”\"></a>mock=“抛出自定义异常”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;throw org.apache.dubbo.demo.consumer.exception.CustomException&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:throw org.apache.dubbo.demo.consumer.exception.CustomException&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 策略为抛出自定义异常, 当远程服务调用失败后, 会给服务消费者抛出自定义异常.</p>\n<h4 id=\"mock-“返回-mock-数据”\"><a href=\"#mock-“返回-mock-数据”\" class=\"headerlink\" title=\"mock=“返回 mock 数据”\"></a>mock=“返回 mock 数据”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;return null&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:return null&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 属性值为返回 mock 数据，当远程服务调用失败后，就会给服务消费者返回null。</p>\n<h3 id=\"force-策略\"><a href=\"#force-策略\" class=\"headerlink\" title=\"force 策略\"></a>force 策略</h3><p>当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。<br>具体的策略跟 fail 策略一致，此处不再详细说明。</p>\n<h4 id=\"mock-“force-true”\"><a href=\"#mock-“force-true”\" class=\"headerlink\" title=\"mock=“force:true”\"></a>mock=“force:true”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;“force:true&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"mock-“force-执行Mock实现类”\"><a href=\"#mock-“force-执行Mock实现类”\" class=\"headerlink\" title=\"mock=“force: 执行Mock实现类”\"></a>mock=“force: 执行Mock实现类”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:com.apache.dubbo.demo.DemoServiceMock2&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mock-“force-抛出自定义异常”\"><a href=\"#mock-“force-抛出自定义异常”\" class=\"headerlink\" title=\"mock=“force:抛出自定义异常”\"></a>mock=“force:抛出自定义异常”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:throw com.apache.dubbo.demo.XXXException&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mock-“force-返回mock数据”\"><a href=\"#mock-“force-返回mock数据”\" class=\"headerlink\" title=\"mock=“force:返回mock数据”\"></a>mock=“force:返回mock数据”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:return xxx&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dubbo-SPI-机制\"><a href=\"#Dubbo-SPI-机制\" class=\"headerlink\" title=\"Dubbo SPI 机制\"></a>Dubbo SPI 机制</h1><h2 id=\"SPI-是什么？\"><a href=\"#SPI-是什么？\" class=\"headerlink\" title=\"SPI 是什么？\"></a>SPI 是什么？</h2><p>SPI（service provider interface）。<br>SPI 就是通过动态加载机制实现面向接口编程;<br>SPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;</p>\n<p>SPI 一般用在哪儿？<br>主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。</p>\n<p>举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p>\n<h2 id=\"API-和-SPI-的区别\"><a href=\"#API-和-SPI-的区别\" class=\"headerlink\" title=\"API 和 SPI 的区别\"></a>API 和 SPI 的区别</h2><p>API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。</p>\n<p>SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。</p>\n<h2 id=\"Java-SPI\"><a href=\"#Java-SPI\" class=\"headerlink\" title=\"Java SPI\"></a>Java SPI</h2><h3 id=\"Java-SPI-简介\"><a href=\"#Java-SPI-简介\" class=\"headerlink\" title=\"Java SPI 简介\"></a>Java SPI 简介</h3><p>SPI 经典的思想体现，大家平时都在用，比如说 jdbc。<br>Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。<br>但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如 mysql，你就将 mysql-jdbc-connector.jar 引入进来；oracle，你就将 oracle-jdbc-connector.jar 引入进来。<br>在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。</p>\n<h3 id=\"Java-SPI-实现细节\"><a href=\"#Java-SPI-实现细节\" class=\"headerlink\" title=\"Java SPI 实现细节\"></a>Java SPI 实现细节</h3><p>Java SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个<strong>以服务接口命名的文件</strong>，然后<strong>文件里面记录的是此 jar 包提供的具体实现类的全限定名。</strong><br>这样当我们引用了某个jar包的时候，就可以去找这个jar包的META-INF/services/目录，再根据接口名找到文件，然后读取文件里面的内容去进行实现类的加载与实例化。</p>\n<p>看个案例：看下MySql是怎么做的：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/MySql_SPI%E5%AE%9E%E7%8E%B01.png\" alt=\"MySql SPI实现1\"><br>再看下文件里的内容：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/MySql_SPI%E5%AE%9E%E7%8E%B02.png\" alt=\"MySql SPI实现2\"></p>\n<h3 id=\"Java-SPI-缺点\"><a href=\"#Java-SPI-缺点\" class=\"headerlink\" title=\"Java SPI 缺点\"></a>Java SPI 缺点</h3><p>Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。</p>\n<p>所以说 Java SPI 无法按需加载实现类。</p>\n<h2 id=\"Dubbo-SPI\"><a href=\"#Dubbo-SPI\" class=\"headerlink\" title=\"Dubbo SPI\"></a>Dubbo SPI</h2><h3 id=\"Dubbo-SPI-简介\"><a href=\"#Dubbo-SPI-简介\" class=\"headerlink\" title=\"Dubbo SPI 简介\"></a>Dubbo SPI 简介</h3><p>Dubbo 也用了 SPI 思想，不过没有用 jdk 的 SPI 机制，是自己实现的一套 SPI 机制。<br>Dubbo SPI：是按需加载实现类的，按需加载的话首先你得给个名字，通过名字去文件里面找到对应的实现类全限定名然后加载实例化即可。Dubbo 就是这样设计的，配置文件里面存放的是键值对。</p>\n<p>我们先来看一下 Dubbo 对配置文件目录的约定，不同于 Java SPI ，Dubbo 分为了三类目录：</p>\n<ul>\n<li>META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。</li>\n<li>META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。</li>\n<li>META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。</li>\n</ul>\n<p>注意：Dubbo SPI 除了可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有个自适应扩展机制。</p>\n<h3 id=\"Dubbo-SPI-实现细节\"><a href=\"#Dubbo-SPI-实现细节\" class=\"headerlink\" title=\"Dubbo SPI 实现细节\"></a>Dubbo SPI 实现细节</h3><p>注意：当前拿 Dubbo Protocol 来演示。</p>\n<p>Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。<br>它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI(&quot;dubbo&quot;)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Protocol</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span>  </span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span>  </span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>在 dubbo 自己的 jar 里，在/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class=\"line\">injvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class=\"line\">http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class=\"line\">rmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class=\"line\">hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class=\"line\">org.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class=\"line\">thrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class=\"line\">native-thrift=org.apache.dubbo.rpc.protocol.nativethrift.ThriftProtocol</span><br><span class=\"line\">memcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class=\"line\">redis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class=\"line\">rest=org.apache.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class=\"line\">xmlrpc=org.apache.dubbo.xml.rpc.protocol.xmlrpc.XmlRpcProtocol</span><br><span class=\"line\">grpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol</span><br></pre></td></tr></table></figure>\n\n<p>所以说，这就看到了 dubbo 的 SPI 机制默认是怎么玩儿的了，其实就是 Protocol 接口，@SPI(“dubbo”) 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。</p>\n<p>如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口，Protocol 接口中，有两个方法加了 @Adaptive 注解，就是说那俩接口会被代理实现。<br>比如这个 Protocol 接口搞了俩 @Adaptive 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p>\n<h3 id=\"Dubbo-自定义扩展组件\"><a href=\"#Dubbo-自定义扩展组件\" class=\"headerlink\" title=\"Dubbo 自定义扩展组件\"></a>Dubbo 自定义扩展组件</h3><p>这里展示一下，如何去扩展 Dubbo Protocol 的组件；</p>\n<h4 id=\"新开一个maven工程（protocol-demo），打包方式为jar；\"><a href=\"#新开一个maven工程（protocol-demo），打包方式为jar；\" class=\"headerlink\" title=\"新开一个maven工程（protocol-demo），打包方式为jar；\"></a>新开一个maven工程（protocol-demo），打包方式为jar；</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protocol-demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Protocol-自定义实现\"><a href=\"#Protocol-自定义实现\" class=\"headerlink\" title=\"Protocol 自定义实现\"></a>Protocol 自定义实现</h4><p>以下代码，是将 Dubbo RmiProtocol 的实现复制过来的，当做是自定义的 Protocol 实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.dubbo.protocol;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.RpcException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.service.GenericService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.support.ProtocolUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.RemoteAccessException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.rmi.RmiProxyFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.rmi.RmiServiceExporter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.support.RemoteInvocation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.SocketTimeoutException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.RemoteException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.Version.isRelease263OrHigher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.Version.isRelease270OrHigher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.rpc.Constants.GENERIC_KEY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProtocol</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProxyProtocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">1099</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyProtocol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(RemoteAccessException.class, RemoteException.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;MyProtocol Init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DEFAULT_PORT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Runnable <span class=\"title\">doExport</span><span class=\"params\">(<span class=\"keyword\">final</span> T impl, Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        RmiServiceExporter rmiServiceExporter = createExporter(impl, type, url, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        RmiServiceExporter genericServiceExporter = createExporter(impl, GenericService.class, url, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    rmiServiceExporter.destroy();</span><br><span class=\"line\">                    genericServiceExporter.destroy();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    logger.warn(e.getMessage(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">doRefer</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; serviceType, <span class=\"keyword\">final</span> URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RmiProxyFactoryBean rmiProxyFactoryBean = <span class=\"keyword\">new</span> RmiProxyFactoryBean();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String generic = url.getParameter(GENERIC_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          RMI needs extra parameter since it uses customized remote invocation object</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          The customized RemoteInvocation was firstly introduced in v2.6.3; The package was renamed to &#x27;org.apache.*&#x27; since v2.7.0</span></span><br><span class=\"line\"><span class=\"comment\">          Considering the above two conditions, we need to check before sending customized RemoteInvocation:</span></span><br><span class=\"line\"><span class=\"comment\">          1. if the provider version is v2.7.0 or higher, send &#x27;org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">          2. if the provider version is v2.6.3 or higher, send &#x27;com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">          3. if the provider version is lower than v2.6.3, does not use customized RemoteInvocation.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRelease270OrHigher(url.getParameter(RELEASE_KEY))) &#123;</span><br><span class=\"line\">            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -&gt; &#123;</span><br><span class=\"line\">                RemoteInvocation invocation = <span class=\"keyword\">new</span> RmiRemoteInvocation(methodInvocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">                    invocation.addAttribute(GENERIC_KEY, generic);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> invocation;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isRelease263OrHigher(url.getParameter(DUBBO_VERSION_KEY))) &#123;</span><br><span class=\"line\">            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -&gt; &#123;</span><br><span class=\"line\">                RemoteInvocation invocation = <span class=\"keyword\">new</span> com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation(methodInvocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">                    invocation.addAttribute(GENERIC_KEY, generic);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> invocation;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String serviceUrl = url.toIdentityString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">            serviceUrl = serviceUrl + <span class=\"string\">&quot;/&quot;</span> + GENERIC_KEY;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rmiProxyFactoryBean.setServiceUrl(serviceUrl);</span><br><span class=\"line\">        rmiProxyFactoryBean.setServiceInterface(serviceType);</span><br><span class=\"line\">        rmiProxyFactoryBean.setCacheStub(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.setLookupStubOnStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.setRefreshStubOnConnectFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) rmiProxyFactoryBean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getErrorCode</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> RemoteAccessException) &#123;</span><br><span class=\"line\">            e = e.getCause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.getCause() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; cls = e.getCause().getClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (SocketTimeoutException.class.equals(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.TIMEOUT_EXCEPTION;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (IOException.class.isAssignableFrom(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.NETWORK_EXCEPTION;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ClassNotFoundException.class.isAssignableFrom(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.SERIALIZATION_EXCEPTION;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getErrorCode(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">RmiServiceExporter <span class=\"title\">createExporter</span><span class=\"params\">(T impl, Class&lt;?&gt; type, URL url, <span class=\"keyword\">boolean</span> isGeneric)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RmiServiceExporter rmiServiceExporter = <span class=\"keyword\">new</span> RmiServiceExporter();</span><br><span class=\"line\">        rmiServiceExporter.setRegistryPort(url.getPort());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">            rmiServiceExporter.setServiceName(url.getPath() + <span class=\"string\">&quot;/&quot;</span> + GENERIC_KEY);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            rmiServiceExporter.setServiceName(url.getPath());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rmiServiceExporter.setServiceInterface(type);</span><br><span class=\"line\">        rmiServiceExporter.setService(impl);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rmiServiceExporter.afterPropertiesSet();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rmiServiceExporter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dubbo规定目录下配置\"><a href=\"#Dubbo规定目录下配置\" class=\"headerlink\" title=\"Dubbo规定目录下配置\"></a>Dubbo规定目录下配置</h4><p>1）在工程 resources 目录下新建 ETA-INF/services 目录；<br>2）在 ETA-INF/services 目录下，新建一个 com.alibaba.dubbo.rpc.Protocol 文件；<br>3）指定 com.alibaba.dubbo.rpc.Protocol 文件内容：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my=com.oyr.dubbo.protocol.MyProtocol</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改服务提供者，使用自定义的-Protocol-实现\"><a href=\"#修改服务提供者，使用自定义的-Protocol-实现\" class=\"headerlink\" title=\"修改服务提供者，使用自定义的 Protocol 实现\"></a>修改服务提供者，使用自定义的 Protocol 实现</h4><p>1）把自定义实现的jar依赖到服务提供者中</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protocol-demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>2）修改配置，协议使用自定义实现</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 使用自定义实现的协议</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">my</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>3）启动服务提供者，查看效果；<br>启动服务提供者，控制台应该打印出：MyProtocol Init；<br>这既代表已经使用了自定义实现的协议；</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>服务提供者启动的时候，就会加载 my=com.bingo.MyProtocol 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了；</p>\n<p>dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。<br>然后对于对应的组件，类似 <a href=\"dubbo:protocol\">dubbo:protocol</a> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。</p>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><p><a href=\"https://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi\">https://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162808615116780262585211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&amp;utm_term=spi&amp;spm=1018.2226.3001.4450\">https://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162808615116780262585211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&amp;utm_term=spi&amp;spm=1018.2226.3001.4450</a></p>\n<h1 id=\"Dubbo-Container（服务容器）\"><a href=\"#Dubbo-Container（服务容器）\" class=\"headerlink\" title=\"Dubbo Container（服务容器）\"></a>Dubbo Container（服务容器）</h1><h2 id=\"Dubbo-Container-简介\"><a href=\"#Dubbo-Container-简介\" class=\"headerlink\" title=\"Dubbo Container 简介\"></a>Dubbo Container 简介</h2><p>Dubbo Container 是一个独立的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。</p>\n<p>服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</p>\n<h2 id=\"Dubbo-内置了几种服务容器\"><a href=\"#Dubbo-内置了几种服务容器\" class=\"headerlink\" title=\"Dubbo 内置了几种服务容器\"></a>Dubbo 内置了几种服务容器</h2><h3 id=\"服务容器分类\"><a href=\"#服务容器分类\" class=\"headerlink\" title=\"服务容器分类\"></a>服务容器分类</h3><p>dubbo 内置了 spring, jetty, log4j 等服务容器；<br>当然也可以自己扩展服务容器进行加载；</p>\n<h3 id=\"Spring-Container\"><a href=\"#Spring-Container\" class=\"headerlink\" title=\"Spring Container\"></a>Spring Container</h3><ul>\n<li>自动加载 META-INF/spring 目录下的所有 Spring 配置。（这个已在源码中写死）</li>\n<li>配置 spring 配置加载位置：(dubbo.spring.config=classpath*:META-INF/spring/*.xml)</li>\n</ul>\n<h3 id=\"Jetty-Container\"><a href=\"#Jetty-Container\" class=\"headerlink\" title=\"Jetty Container\"></a>Jetty Container</h3><ul>\n<li>启动一个内嵌 Jetty，用于汇报状态。</li>\n<li>配置：<ul>\n<li>dubbo.jetty.port=8080：配置 jetty 启动端口</li>\n<li>dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件</li>\n<li>dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Log4j-Container\"><a href=\"#Log4j-Container\" class=\"headerlink\" title=\"Log4j Container\"></a>Log4j Container</h3><ul>\n<li>自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。</li>\n<li>配置：<ul>\n<li>dubbo.log4j.file=/foo/bar.log：配置日志文件路径</li>\n<li>dubbo.log4j.level=WARN：配置日志级别</li>\n<li>dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h2><p>SPI 容器扩展类：<code>org.apache.dubbo.container.Container</code><br><img src=\"https://rong0624.gitee.io/images/Dubbo/1628502633574.jpg\" alt=\"SPI 容器扩展类\"></p>\n<p><code>org.apache.dubbo.container.Main</code> 是服务启动的主类，在服务启动时会调用容器的 start() 方法，在服务停止时会调用 stop() 方法；</p>\n<p>那么默认到底是调用那个容器呢？注意 <code>org.apache.dubbo.container.Container</code> 接口有一个注解 <code>@SPI(&quot;spring&quot;)</code>；<br>通过对 Dubbo SPI 的了解，容器应该有内嵌对应的文件：org.apache.dubbo.container.Container；<br>org.apache.dubbo.container.Container内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring=org.apache.dubbo.container.spring.SpringContainer</span><br><span class=\"line\">log4j=org.apache.dubbo.container.log4j.Log4jContainer</span><br><span class=\"line\">logback=org.apache.dubbo.container.logback.LogbackContainer</span><br></pre></td></tr></table></figure>\n<p>通过以上分析，可以知道默认调用的是org.apache.dubbo.container.spring.SpringContainer；</p>\n<h2 id=\"容器停止\"><a href=\"#容器停止\" class=\"headerlink\" title=\"容器停止\"></a>容器停止</h2><p>dubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用”kill -9    PID”等强制关闭指令，是不会执行优雅停机的，只有通过”kill PID”时，才会执行。</p>\n<p>停止源码（在Main方法里面）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&quot;true&quot;</span>.equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123;</span><br><span class=\"line\">    Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> Thread(<span class=\"string\">&quot;dubbo-container-shutdown-hook&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Container container : containers) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    container.stop();</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;Dubbo &quot;</span> + container.getClass().getSimpleName() + <span class=\"string\">&quot; stopped!&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    logger.error(t.getMessage(), t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    LOCK.lock();</span><br><span class=\"line\">                    STOP.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    LOCK.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1）服务提供方<br>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。<br>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</p>\n<p>2）服务消费方<br>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。<br>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</p>\n<h1 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h1><h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。<br>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<h2 id=\"RPC模型\"><a href=\"#RPC模型\" class=\"headerlink\" title=\"RPC模型\"></a>RPC模型</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc模型\">  </p>\n<ol>\n<li>Client：客户端；服务调用方。</li>\n<li>Client Stub：客户端存根；存放服务端地址信息，将客户端的请求信息进行编码，再通过网络传输给发送端 or 接受服务端的响应数据，进行解码。</li>\n<li>Server：服务端；服务提供方。</li>\n<li>Server Stub：服务端存根；接收客户端发送的请求信息并解码，然后调用本地服务进行处理，并将处理结果进行编码后返回。</li>\n</ol>\n<p><strong>RPC两个核心模块：通讯（网络传输），序列化（编码，解码）。</strong></p>\n<h2 id=\"RPC调用过程\"><a href=\"#RPC调用过程\" class=\"headerlink\" title=\"RPC调用过程\"></a>RPC调用过程</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一次完整的RPC调用流程（同步调用，异步另说）如下： </span><br><span class=\"line\">1）服务消费方以本地调用方式调用服务；（client）</span><br><span class=\"line\">2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</span><br><span class=\"line\">3）client stub找到服务地址，并将消息发送到服务端；</span><br><span class=\"line\">4）server stub收到消息后进行解码； </span><br><span class=\"line\">5）server stub根据解码结果调用本地的服务； </span><br><span class=\"line\">6）server本地服务执行并将结果返回给server stub；</span><br><span class=\"line\">7）server stub将返回结果打包成消息并发送至消费方； </span><br><span class=\"line\">8）client stub接收到消息，并进行解码； </span><br><span class=\"line\">9）服务消费方得到最终结果。</span><br><span class=\"line\">RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dubbo-底层解析\"><a href=\"#Dubbo-底层解析\" class=\"headerlink\" title=\"Dubbo 底层解析\"></a>Dubbo 底层解析</h1><h2 id=\"Dubbo-架构设计\"><a href=\"#Dubbo-架构设计\" class=\"headerlink\" title=\"Dubbo-架构设计\"></a>Dubbo-架构设计</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627979178965.jpg\" alt=\"dubbo框架设计\"></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>Business 实现层</li>\n<li>RPC 远程调用层</li>\n<li>Remoting 网络通讯层</li>\n</ul>\n<h3 id=\"各层说明\"><a href=\"#各层说明\" class=\"headerlink\" title=\"各层说明\"></a>各层说明</h3><ul>\n<li>service 接口层：给服务提供者和服务消费者来实现的（留给开发人员来实现）</li>\n<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>\n<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>\n<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>\n<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>\n<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>\n<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>\n<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>\n<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>\n<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>\n</ul>\n<h2 id=\"Dubbo-启动解析，加载配置\"><a href=\"#Dubbo-启动解析，加载配置\" class=\"headerlink\" title=\"Dubbo-启动解析，加载配置\"></a>Dubbo-启动解析，加载配置</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981581425.jpg\" alt=\"启动解析\"></p>\n<h2 id=\"Dubbo-服务暴露\"><a href=\"#Dubbo-服务暴露\" class=\"headerlink\" title=\"Dubbo-服务暴露\"></a>Dubbo-服务暴露</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981689580.jpg\" alt=\"服务暴露\"></p>\n<h2 id=\"Dubbo-服务引用\"><a href=\"#Dubbo-服务引用\" class=\"headerlink\" title=\"Dubbo-服务引用\"></a>Dubbo-服务引用</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981770108.jpg\" alt=\"服务引用\"></p>\n<h2 id=\"Dubbo-服务调用\"><a href=\"#Dubbo-服务调用\" class=\"headerlink\" title=\"Dubbo-服务调用\"></a>Dubbo-服务调用</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981894490.jpg\" alt=\"服务调用\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的<code>dubbo.application.name</code>相同，Dubbo则会认为是同一集群。</p>","more":"<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群容错配置\"><a href=\"#集群容错配置\" class=\"headerlink\" title=\"集群容错配置\"></a>集群容错配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><h3 id=\"服务降级概念\"><a href=\"#服务降级概念\" class=\"headerlink\" title=\"服务降级概念\"></a>服务降级概念</h3><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h3 id=\"Dubbo-服务降级机制\"><a href=\"#Dubbo-服务降级机制\" class=\"headerlink\" title=\"Dubbo 服务降级机制\"></a>Dubbo 服务降级机制</h3><p>Dubbo的服务降级采用的是mock机制；即当服务提供者出错时（抛出 RpcException），进行 mock 调用；<br>同时也可以用于本地测试，用服务消费者端配置的 mock 服务替代要调用的远程服务，亦或者是对某个服务消费者屏蔽服务提供者，不让其进行远程调用。</p>\n<p>其具有两种策略方式：</p>\n<ul>\n<li>fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</li>\n<li>force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。</li>\n</ul>\n<h3 id=\"fail-策略\"><a href=\"#fail-策略\" class=\"headerlink\" title=\"fail 策略\"></a>fail 策略</h3><p>当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</p>\n<h4 id=\"mock-“true”\"><a href=\"#mock-“true”\" class=\"headerlink\" title=\"mock=“true”\"></a>mock=“true”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>解释：指定 mock 策略为布尔类型，且为 true，此时需要消费端提供服务接口的 mock 实现类，该类的包名需要与服务接口一致，且类名格式为 [接口名 + Mock], 即 com.oyr.user.service.UserServiceMock, 当调用远程服务失败后, 就会执行 UserServiceMock的相同方法（远程调用是hello方法，那么即会调用mock的hello方法）, 如果不提供此 mock 类，dubbo 消费端会启动失败。</p>\n<h4 id=\"mock-“具体的mock实现类”\"><a href=\"#mock-“具体的mock实现类”\" class=\"headerlink\" title=\"mock=“具体的mock实现类”\"></a>mock=“具体的mock实现类”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;com.oyr.user.service.mock.UserServiceMock&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:com.oyr.user.service.mock.UserServiceMock&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 策略为具体的 mock 实现类, 当调用远程服务失败时, 就会执行 mock 实现类的相同方法.</p>\n<h4 id=\"mock-“抛出自定义异常”\"><a href=\"#mock-“抛出自定义异常”\" class=\"headerlink\" title=\"mock=“抛出自定义异常”\"></a>mock=“抛出自定义异常”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;throw org.apache.dubbo.demo.consumer.exception.CustomException&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:throw org.apache.dubbo.demo.consumer.exception.CustomException&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 策略为抛出自定义异常, 当远程服务调用失败后, 会给服务消费者抛出自定义异常.</p>\n<h4 id=\"mock-“返回-mock-数据”\"><a href=\"#mock-“返回-mock-数据”\" class=\"headerlink\" title=\"mock=“返回 mock 数据”\"></a>mock=“返回 mock 数据”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;return null&quot;</span> /&gt;</span></span><br><span class=\"line\">or</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;fail:return null&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：指定 mock 属性值为返回 mock 数据，当远程服务调用失败后，就会给服务消费者返回null。</p>\n<h3 id=\"force-策略\"><a href=\"#force-策略\" class=\"headerlink\" title=\"force 策略\"></a>force 策略</h3><p>当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。<br>具体的策略跟 fail 策略一致，此处不再详细说明。</p>\n<h4 id=\"mock-“force-true”\"><a href=\"#mock-“force-true”\" class=\"headerlink\" title=\"mock=“force:true”\"></a>mock=“force:true”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;“force:true&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"mock-“force-执行Mock实现类”\"><a href=\"#mock-“force-执行Mock实现类”\" class=\"headerlink\" title=\"mock=“force: 执行Mock实现类”\"></a>mock=“force: 执行Mock实现类”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:com.apache.dubbo.demo.DemoServiceMock2&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mock-“force-抛出自定义异常”\"><a href=\"#mock-“force-抛出自定义异常”\" class=\"headerlink\" title=\"mock=“force:抛出自定义异常”\"></a>mock=“force:抛出自定义异常”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:throw com.apache.dubbo.demo.XXXException&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"mock-“force-返回mock数据”\"><a href=\"#mock-“force-返回mock数据”\" class=\"headerlink\" title=\"mock=“force:返回mock数据”\"></a>mock=“force:返回mock数据”</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;demoService&quot;</span> <span class=\"attr\">mock</span>=<span class=\"string\">&quot;force:return xxx&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dubbo-SPI-机制\"><a href=\"#Dubbo-SPI-机制\" class=\"headerlink\" title=\"Dubbo SPI 机制\"></a>Dubbo SPI 机制</h1><h2 id=\"SPI-是什么？\"><a href=\"#SPI-是什么？\" class=\"headerlink\" title=\"SPI 是什么？\"></a>SPI 是什么？</h2><p>SPI（service provider interface）。<br>SPI 就是通过动态加载机制实现面向接口编程;<br>SPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;</p>\n<p>SPI 一般用在哪儿？<br>主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。</p>\n<p>举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p>\n<h2 id=\"API-和-SPI-的区别\"><a href=\"#API-和-SPI-的区别\" class=\"headerlink\" title=\"API 和 SPI 的区别\"></a>API 和 SPI 的区别</h2><p>API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。</p>\n<p>SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。</p>\n<h2 id=\"Java-SPI\"><a href=\"#Java-SPI\" class=\"headerlink\" title=\"Java SPI\"></a>Java SPI</h2><h3 id=\"Java-SPI-简介\"><a href=\"#Java-SPI-简介\" class=\"headerlink\" title=\"Java SPI 简介\"></a>Java SPI 简介</h3><p>SPI 经典的思想体现，大家平时都在用，比如说 jdbc。<br>Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。<br>但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要根据自己使用的数据库，比如 mysql，你就将 mysql-jdbc-connector.jar 引入进来；oracle，你就将 oracle-jdbc-connector.jar 引入进来。<br>在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。</p>\n<h3 id=\"Java-SPI-实现细节\"><a href=\"#Java-SPI-实现细节\" class=\"headerlink\" title=\"Java SPI 实现细节\"></a>Java SPI 实现细节</h3><p>Java SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个<strong>以服务接口命名的文件</strong>，然后<strong>文件里面记录的是此 jar 包提供的具体实现类的全限定名。</strong><br>这样当我们引用了某个jar包的时候，就可以去找这个jar包的META-INF/services/目录，再根据接口名找到文件，然后读取文件里面的内容去进行实现类的加载与实例化。</p>\n<p>看个案例：看下MySql是怎么做的：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/MySql_SPI%E5%AE%9E%E7%8E%B01.png\" alt=\"MySql SPI实现1\"><br>再看下文件里的内容：<br><img src=\"https://rong0624.gitee.io/images/Dubbo/MySql_SPI%E5%AE%9E%E7%8E%B02.png\" alt=\"MySql SPI实现2\"></p>\n<h3 id=\"Java-SPI-缺点\"><a href=\"#Java-SPI-缺点\" class=\"headerlink\" title=\"Java SPI 缺点\"></a>Java SPI 缺点</h3><p>Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类全部实例化，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了资源的浪费。</p>\n<p>所以说 Java SPI 无法按需加载实现类。</p>\n<h2 id=\"Dubbo-SPI\"><a href=\"#Dubbo-SPI\" class=\"headerlink\" title=\"Dubbo SPI\"></a>Dubbo SPI</h2><h3 id=\"Dubbo-SPI-简介\"><a href=\"#Dubbo-SPI-简介\" class=\"headerlink\" title=\"Dubbo SPI 简介\"></a>Dubbo SPI 简介</h3><p>Dubbo 也用了 SPI 思想，不过没有用 jdk 的 SPI 机制，是自己实现的一套 SPI 机制。<br>Dubbo SPI：是按需加载实现类的，按需加载的话首先你得给个名字，通过名字去文件里面找到对应的实现类全限定名然后加载实例化即可。Dubbo 就是这样设计的，配置文件里面存放的是键值对。</p>\n<p>我们先来看一下 Dubbo 对配置文件目录的约定，不同于 Java SPI ，Dubbo 分为了三类目录：</p>\n<ul>\n<li>META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。</li>\n<li>META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。</li>\n<li>META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。</li>\n</ul>\n<p>注意：Dubbo SPI 除了可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有个自适应扩展机制。</p>\n<h3 id=\"Dubbo-SPI-实现细节\"><a href=\"#Dubbo-SPI-实现细节\" class=\"headerlink\" title=\"Dubbo SPI 实现细节\"></a>Dubbo SPI 实现细节</h3><p>注意：当前拿 Dubbo Protocol 来演示。</p>\n<p>Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。<br>它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI(&quot;dubbo&quot;)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Protocol</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span>  </span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span>  </span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>在 dubbo 自己的 jar 里，在/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class=\"line\">injvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class=\"line\">http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class=\"line\">rmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class=\"line\">hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class=\"line\">org.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class=\"line\">thrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class=\"line\">native-thrift=org.apache.dubbo.rpc.protocol.nativethrift.ThriftProtocol</span><br><span class=\"line\">memcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class=\"line\">redis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class=\"line\">rest=org.apache.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class=\"line\">xmlrpc=org.apache.dubbo.xml.rpc.protocol.xmlrpc.XmlRpcProtocol</span><br><span class=\"line\">grpc=org.apache.dubbo.rpc.protocol.grpc.GrpcProtocol</span><br></pre></td></tr></table></figure>\n\n<p>所以说，这就看到了 dubbo 的 SPI 机制默认是怎么玩儿的了，其实就是 Protocol 接口，@SPI(“dubbo”) 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。</p>\n<p>如果想要动态替换掉默认的实现类，需要使用 @Adaptive 接口，Protocol 接口中，有两个方法加了 @Adaptive 注解，就是说那俩接口会被代理实现。<br>比如这个 Protocol 接口搞了俩 @Adaptive 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p>\n<h3 id=\"Dubbo-自定义扩展组件\"><a href=\"#Dubbo-自定义扩展组件\" class=\"headerlink\" title=\"Dubbo 自定义扩展组件\"></a>Dubbo 自定义扩展组件</h3><p>这里展示一下，如何去扩展 Dubbo Protocol 的组件；</p>\n<h4 id=\"新开一个maven工程（protocol-demo），打包方式为jar；\"><a href=\"#新开一个maven工程（protocol-demo），打包方式为jar；\" class=\"headerlink\" title=\"新开一个maven工程（protocol-demo），打包方式为jar；\"></a>新开一个maven工程（protocol-demo），打包方式为jar；</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protocol-demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Protocol-自定义实现\"><a href=\"#Protocol-自定义实现\" class=\"headerlink\" title=\"Protocol 自定义实现\"></a>Protocol 自定义实现</h4><p>以下代码，是将 Dubbo RmiProtocol 的实现复制过来的，当做是自定义的 Protocol 实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.dubbo.protocol;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.RpcException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.protocol.AbstractProxyProtocol;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.service.GenericService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.rpc.support.ProtocolUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.RemoteAccessException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.rmi.RmiProxyFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.rmi.RmiServiceExporter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.remoting.support.RemoteInvocation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.SocketTimeoutException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.rmi.RemoteException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.Version.isRelease263OrHigher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.Version.isRelease270OrHigher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.constants.CommonConstants.DUBBO_VERSION_KEY;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.common.constants.CommonConstants.RELEASE_KEY;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.dubbo.rpc.Constants.GENERIC_KEY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProtocol</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProxyProtocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">1099</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyProtocol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(RemoteAccessException.class, RemoteException.class);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;MyProtocol Init&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DEFAULT_PORT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Runnable <span class=\"title\">doExport</span><span class=\"params\">(<span class=\"keyword\">final</span> T impl, Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        RmiServiceExporter rmiServiceExporter = createExporter(impl, type, url, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        RmiServiceExporter genericServiceExporter = createExporter(impl, GenericService.class, url, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    rmiServiceExporter.destroy();</span><br><span class=\"line\">                    genericServiceExporter.destroy();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                    logger.warn(e.getMessage(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">doRefer</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; serviceType, <span class=\"keyword\">final</span> URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RmiProxyFactoryBean rmiProxyFactoryBean = <span class=\"keyword\">new</span> RmiProxyFactoryBean();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String generic = url.getParameter(GENERIC_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService.class);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          RMI needs extra parameter since it uses customized remote invocation object</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">          The customized RemoteInvocation was firstly introduced in v2.6.3; The package was renamed to &#x27;org.apache.*&#x27; since v2.7.0</span></span><br><span class=\"line\"><span class=\"comment\">          Considering the above two conditions, we need to check before sending customized RemoteInvocation:</span></span><br><span class=\"line\"><span class=\"comment\">          1. if the provider version is v2.7.0 or higher, send &#x27;org.apache.dubbo.rpc.protocol.rmi.RmiRemoteInvocation&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">          2. if the provider version is v2.6.3 or higher, send &#x27;com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation&#x27;.</span></span><br><span class=\"line\"><span class=\"comment\">          3. if the provider version is lower than v2.6.3, does not use customized RemoteInvocation.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRelease270OrHigher(url.getParameter(RELEASE_KEY))) &#123;</span><br><span class=\"line\">            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -&gt; &#123;</span><br><span class=\"line\">                RemoteInvocation invocation = <span class=\"keyword\">new</span> RmiRemoteInvocation(methodInvocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">                    invocation.addAttribute(GENERIC_KEY, generic);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> invocation;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isRelease263OrHigher(url.getParameter(DUBBO_VERSION_KEY))) &#123;</span><br><span class=\"line\">            rmiProxyFactoryBean.setRemoteInvocationFactory(methodInvocation -&gt; &#123;</span><br><span class=\"line\">                RemoteInvocation invocation = <span class=\"keyword\">new</span> com.alibaba.dubbo.rpc.protocol.rmi.RmiRemoteInvocation(methodInvocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">                    invocation.addAttribute(GENERIC_KEY, generic);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> invocation;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String serviceUrl = url.toIdentityString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">            serviceUrl = serviceUrl + <span class=\"string\">&quot;/&quot;</span> + GENERIC_KEY;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rmiProxyFactoryBean.setServiceUrl(serviceUrl);</span><br><span class=\"line\">        rmiProxyFactoryBean.setServiceInterface(serviceType);</span><br><span class=\"line\">        rmiProxyFactoryBean.setCacheStub(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.setLookupStubOnStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.setRefreshStubOnConnectFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        rmiProxyFactoryBean.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) rmiProxyFactoryBean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getErrorCode</span><span class=\"params\">(Throwable e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> RemoteAccessException) &#123;</span><br><span class=\"line\">            e = e.getCause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.getCause() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; cls = e.getCause().getClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (SocketTimeoutException.class.equals(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.TIMEOUT_EXCEPTION;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (IOException.class.isAssignableFrom(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.NETWORK_EXCEPTION;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ClassNotFoundException.class.isAssignableFrom(cls)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> RpcException.SERIALIZATION_EXCEPTION;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getErrorCode(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">RmiServiceExporter <span class=\"title\">createExporter</span><span class=\"params\">(T impl, Class&lt;?&gt; type, URL url, <span class=\"keyword\">boolean</span> isGeneric)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RmiServiceExporter rmiServiceExporter = <span class=\"keyword\">new</span> RmiServiceExporter();</span><br><span class=\"line\">        rmiServiceExporter.setRegistryPort(url.getPort());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isGeneric) &#123;</span><br><span class=\"line\">            rmiServiceExporter.setServiceName(url.getPath() + <span class=\"string\">&quot;/&quot;</span> + GENERIC_KEY);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            rmiServiceExporter.setServiceName(url.getPath());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rmiServiceExporter.setServiceInterface(type);</span><br><span class=\"line\">        rmiServiceExporter.setService(impl);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            rmiServiceExporter.afterPropertiesSet();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rmiServiceExporter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dubbo规定目录下配置\"><a href=\"#Dubbo规定目录下配置\" class=\"headerlink\" title=\"Dubbo规定目录下配置\"></a>Dubbo规定目录下配置</h4><p>1）在工程 resources 目录下新建 ETA-INF/services 目录；<br>2）在 ETA-INF/services 目录下，新建一个 com.alibaba.dubbo.rpc.Protocol 文件；<br>3）指定 com.alibaba.dubbo.rpc.Protocol 文件内容：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my=com.oyr.dubbo.protocol.MyProtocol</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改服务提供者，使用自定义的-Protocol-实现\"><a href=\"#修改服务提供者，使用自定义的-Protocol-实现\" class=\"headerlink\" title=\"修改服务提供者，使用自定义的 Protocol 实现\"></a>修改服务提供者，使用自定义的 Protocol 实现</h4><p>1）把自定义实现的jar依赖到服务提供者中</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>protocol-demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>2）修改配置，协议使用自定义实现</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 使用自定义实现的协议</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">my</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>3）启动服务提供者，查看效果；<br>启动服务提供者，控制台应该打印出：MyProtocol Init；<br>这既代表已经使用了自定义实现的协议；</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>服务提供者启动的时候，就会加载 my=com.bingo.MyProtocol 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了；</p>\n<p>dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类。<br>然后对于对应的组件，类似 <a href=\"dubbo:protocol\">dubbo:protocol</a> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。</p>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><p><a href=\"https://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi\">https://shishan100.gitee.io/docs/#/./docs/distributed-system/dubbo-spi</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162808615116780262585211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&amp;utm_term=spi&amp;spm=1018.2226.3001.4450\">https://blog.csdn.net/qq_35190492/article/details/108256452?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162808615116780262585211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162808615116780262585211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-108256452.pc_v2_rank_blog_default&amp;utm_term=spi&amp;spm=1018.2226.3001.4450</a></p>\n<h1 id=\"Dubbo-Container（服务容器）\"><a href=\"#Dubbo-Container（服务容器）\" class=\"headerlink\" title=\"Dubbo Container（服务容器）\"></a>Dubbo Container（服务容器）</h1><h2 id=\"Dubbo-Container-简介\"><a href=\"#Dubbo-Container-简介\" class=\"headerlink\" title=\"Dubbo Container 简介\"></a>Dubbo Container 简介</h2><p>Dubbo Container 是一个独立的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。</p>\n<p>服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</p>\n<h2 id=\"Dubbo-内置了几种服务容器\"><a href=\"#Dubbo-内置了几种服务容器\" class=\"headerlink\" title=\"Dubbo 内置了几种服务容器\"></a>Dubbo 内置了几种服务容器</h2><h3 id=\"服务容器分类\"><a href=\"#服务容器分类\" class=\"headerlink\" title=\"服务容器分类\"></a>服务容器分类</h3><p>dubbo 内置了 spring, jetty, log4j 等服务容器；<br>当然也可以自己扩展服务容器进行加载；</p>\n<h3 id=\"Spring-Container\"><a href=\"#Spring-Container\" class=\"headerlink\" title=\"Spring Container\"></a>Spring Container</h3><ul>\n<li>自动加载 META-INF/spring 目录下的所有 Spring 配置。（这个已在源码中写死）</li>\n<li>配置 spring 配置加载位置：(dubbo.spring.config=classpath*:META-INF/spring/*.xml)</li>\n</ul>\n<h3 id=\"Jetty-Container\"><a href=\"#Jetty-Container\" class=\"headerlink\" title=\"Jetty Container\"></a>Jetty Container</h3><ul>\n<li>启动一个内嵌 Jetty，用于汇报状态。</li>\n<li>配置：<ul>\n<li>dubbo.jetty.port=8080：配置 jetty 启动端口</li>\n<li>dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件</li>\n<li>dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Log4j-Container\"><a href=\"#Log4j-Container\" class=\"headerlink\" title=\"Log4j Container\"></a>Log4j Container</h3><ul>\n<li>自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。</li>\n<li>配置：<ul>\n<li>dubbo.log4j.file=/foo/bar.log：配置日志文件路径</li>\n<li>dubbo.log4j.level=WARN：配置日志级别</li>\n<li>dubbo.log4j.subdirectory=20880：配置日志子目录，用于多进程启动，避免冲突</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器启动\"><a href=\"#容器启动\" class=\"headerlink\" title=\"容器启动\"></a>容器启动</h2><p>SPI 容器扩展类：<code>org.apache.dubbo.container.Container</code><br><img src=\"https://rong0624.gitee.io/images/Dubbo/1628502633574.jpg\" alt=\"SPI 容器扩展类\"></p>\n<p><code>org.apache.dubbo.container.Main</code> 是服务启动的主类，在服务启动时会调用容器的 start() 方法，在服务停止时会调用 stop() 方法；</p>\n<p>那么默认到底是调用那个容器呢？注意 <code>org.apache.dubbo.container.Container</code> 接口有一个注解 <code>@SPI(&quot;spring&quot;)</code>；<br>通过对 Dubbo SPI 的了解，容器应该有内嵌对应的文件：org.apache.dubbo.container.Container；<br>org.apache.dubbo.container.Container内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring=org.apache.dubbo.container.spring.SpringContainer</span><br><span class=\"line\">log4j=org.apache.dubbo.container.log4j.Log4jContainer</span><br><span class=\"line\">logback=org.apache.dubbo.container.logback.LogbackContainer</span><br></pre></td></tr></table></figure>\n<p>通过以上分析，可以知道默认调用的是org.apache.dubbo.container.spring.SpringContainer；</p>\n<h2 id=\"容器停止\"><a href=\"#容器停止\" class=\"headerlink\" title=\"容器停止\"></a>容器停止</h2><p>dubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用”kill -9    PID”等强制关闭指令，是不会执行优雅停机的，只有通过”kill PID”时，才会执行。</p>\n<p>停止源码（在Main方法里面）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">&quot;true&quot;</span>.equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123;</span><br><span class=\"line\">    Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> Thread(<span class=\"string\">&quot;dubbo-container-shutdown-hook&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Container container : containers) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    container.stop();</span><br><span class=\"line\">                    logger.info(<span class=\"string\">&quot;Dubbo &quot;</span> + container.getClass().getSimpleName() + <span class=\"string\">&quot; stopped!&quot;</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                    logger.error(t.getMessage(), t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    LOCK.lock();</span><br><span class=\"line\">                    STOP.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    LOCK.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1）服务提供方<br>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。<br>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</p>\n<p>2）服务消费方<br>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。<br>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</p>\n<h1 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h1><h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。<br>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<h2 id=\"RPC模型\"><a href=\"#RPC模型\" class=\"headerlink\" title=\"RPC模型\"></a>RPC模型</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc模型\">  </p>\n<ol>\n<li>Client：客户端；服务调用方。</li>\n<li>Client Stub：客户端存根；存放服务端地址信息，将客户端的请求信息进行编码，再通过网络传输给发送端 or 接受服务端的响应数据，进行解码。</li>\n<li>Server：服务端；服务提供方。</li>\n<li>Server Stub：服务端存根；接收客户端发送的请求信息并解码，然后调用本地服务进行处理，并将处理结果进行编码后返回。</li>\n</ol>\n<p><strong>RPC两个核心模块：通讯（网络传输），序列化（编码，解码）。</strong></p>\n<h2 id=\"RPC调用过程\"><a href=\"#RPC调用过程\" class=\"headerlink\" title=\"RPC调用过程\"></a>RPC调用过程</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一次完整的RPC调用流程（同步调用，异步另说）如下： </span><br><span class=\"line\">1）服务消费方以本地调用方式调用服务；（client）</span><br><span class=\"line\">2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</span><br><span class=\"line\">3）client stub找到服务地址，并将消息发送到服务端；</span><br><span class=\"line\">4）server stub收到消息后进行解码； </span><br><span class=\"line\">5）server stub根据解码结果调用本地的服务； </span><br><span class=\"line\">6）server本地服务执行并将结果返回给server stub；</span><br><span class=\"line\">7）server stub将返回结果打包成消息并发送至消费方； </span><br><span class=\"line\">8）client stub接收到消息，并进行解码； </span><br><span class=\"line\">9）服务消费方得到最终结果。</span><br><span class=\"line\">RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Dubbo-底层解析\"><a href=\"#Dubbo-底层解析\" class=\"headerlink\" title=\"Dubbo 底层解析\"></a>Dubbo 底层解析</h1><h2 id=\"Dubbo-架构设计\"><a href=\"#Dubbo-架构设计\" class=\"headerlink\" title=\"Dubbo-架构设计\"></a>Dubbo-架构设计</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627979178965.jpg\" alt=\"dubbo框架设计\"></p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>Business 实现层</li>\n<li>RPC 远程调用层</li>\n<li>Remoting 网络通讯层</li>\n</ul>\n<h3 id=\"各层说明\"><a href=\"#各层说明\" class=\"headerlink\" title=\"各层说明\"></a>各层说明</h3><ul>\n<li>service 接口层：给服务提供者和服务消费者来实现的（留给开发人员来实现）</li>\n<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>\n<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>\n<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>\n<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>\n<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>\n<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>\n<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>\n<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>\n<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>\n</ul>\n<h2 id=\"Dubbo-启动解析，加载配置\"><a href=\"#Dubbo-启动解析，加载配置\" class=\"headerlink\" title=\"Dubbo-启动解析，加载配置\"></a>Dubbo-启动解析，加载配置</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981581425.jpg\" alt=\"启动解析\"></p>\n<h2 id=\"Dubbo-服务暴露\"><a href=\"#Dubbo-服务暴露\" class=\"headerlink\" title=\"Dubbo-服务暴露\"></a>Dubbo-服务暴露</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981689580.jpg\" alt=\"服务暴露\"></p>\n<h2 id=\"Dubbo-服务引用\"><a href=\"#Dubbo-服务引用\" class=\"headerlink\" title=\"Dubbo-服务引用\"></a>Dubbo-服务引用</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981770108.jpg\" alt=\"服务引用\"></p>\n<h2 id=\"Dubbo-服务调用\"><a href=\"#Dubbo-服务调用\" class=\"headerlink\" title=\"Dubbo-服务调用\"></a>Dubbo-服务调用</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627981894490.jpg\" alt=\"服务调用\"></p>"},{"title":"Dubbo-面试题","date":"2021-08-03T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 配置\n\n## Dubbo 核心配置有哪些\n\n| 标签 | 用途 | 解释 |\n| ---- | ---- | ----  |\n| dubbo:service     | 服务配置      | 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 |\n| dubbo:reference   | 引用配置\t    | 用于创建一个远程服务代理，一个引用可以指向多个注册中心\n| dubbo:protocol    | 协议配置\t    | 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受\n| dubbo:application | 应用配置\t    | 用于配置当前应用信息，不管该应用是提供者还是消费者\n| dubbo:module      | 模块配置      | 用于配置当前模块信息，可选\n| dubbo:registry    | 注册中心配置  | 用于配置连接注册中心相关信息\n| dubbo:monitor     | 监控中心配置  | 用于配置连接监控中心相关信息，可选\n| dubbo:provider    | 提供方配置    | 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选\n| dubbo:consumer    | 消费方配置    | 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选\n| dubbo:method\t    | 方法配置\t    | 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息\n| dubbo:argument\t| 参数配置\t    | 用于指定方法参数配置\n\n## Dubbo 配置原则\n\nDubbo 推荐在 Provider 上尽量多配置 Consumer 端属性。\n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等\n2）在Provider配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的\n\n## Dubbo 属性配置优先级\n\n![属性配置优先级](https://rong0624.gitee.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## Dubbo 配置文件优先级\n\n![配置文件优先级](https://rong0624.gitee.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# 通讯协议\n\n## Dubbo 支持哪些通讯协议？\n\n### Dubbo 官方文档\n\n支持4种，分别是：Dubbo，Hessian，RMI，HTTP；\n\n### Dubbo 2.7.7\n\n通过分析 dubbo 2.7.7版本协议实现，支持11种；\n分别是：Dubbo，Hessian，RMI，HTTP，WebService，Thrift，Memcached，Redis，Rest，XmlRpc，Grpc；\n\n## Dubbo 通讯协议的特点\n\n### Dubbo协议\n\nDubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\nDubbo默认使用Dubbo协议；\n\n基于Dubbo的远程调用协议：\n连接个数：单连接\n连接方式：长连接  \n传输协议：TCP  \n传输方式：NIO异步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。  \n适用场景：常规远程服务方法调用\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。  \nHessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### RMI协议\n\nJava标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多连接  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化(JSON)  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### Thrift协议\n\n基于Thrift实现PRC协议\n\n### Redis协议\n\n基于redis实现RPC协议\n\n### Memcached协议\n\n基于Memcached实现RPC协议\n\n## Dubbo支持服务多协议吗？\n\nDubbo 支持多协议；  \nDubbo 在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。\n\n# 序列化\n\n## Dubbo 支持哪些序列化\n\n![支持的序列化](https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg)\nDubbo 支持 Hession，Dubbo，Json、Java自带序列化 多种序列化方式。但是 Hessian 是其默认的序列化方式。\n\n## Dubbo 序列化特点\n\n### Hession\n\n是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。\n\n### Dubbo\n\n是阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。\n\n### Json\n\n目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。\n\n### Java自带序列化\n\n主要是采用JDK自带的Java序列化实现，性能很不理想。\n\n## Hessian 的数据结构\n\nHessian 的对象序列化机制有 8 种原始类型：\n- 原始二进制数据\n- boolean\n- 64-bit date（64 位毫秒值的日期）\n- 64-bit double\n- 32-bit int\n- 64-bit long\n- null\n- UTF-8 编码的 string\n\n另外还包括 3 种递归类型：\n- list for lists and arrays\n- map for maps and dictionaries\n- object for objects\n\n还有一种特殊的类型：\n- ref：用来表示对共享对象的引用。\n\n## 什么是 BP？\n\n可能有一些同学比较习惯于 JSON or XML 数据存储格式，对于 Protocol Buffer 还比较陌生。  \nProtocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。\n\n其实 PB 之所以性能如此好；主要得益于两个；  \n第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；  \n第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。\n\n# 通讯框架\n\n## Dubbo 正常哪些通信框架，推荐使用什么？\n\n![支持的通讯框架](https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg)  \nDubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo 推荐并默认使用 Netty。\n\n# 注册中心\n\n## Dubbo 支持哪些注册中心？\n\n![支持的注册中心](https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg)  \nZookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。\n\n## Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\n\n可以通讯。启动 Dubbo 时，消费者会从注册中心拉取生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。\n\n```\n健壮性\n监控中心宕掉不影响使用，只是丢失部分采样数据\n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\n注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\n服务提供者无状态，任意一台宕掉后，不影响使用\n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n```\n\n## Dubbo 直连模式\n\nDubbo 的直连模式，可以完全跳过注册中心，直接指定服务提供者的地址进行通讯；\n\n配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n## Dubbo 支持多注册中心吗？\n\nDubbo 支持多注册中心；  \nDubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  \n\n# 服务容器\n\n## Dubbo内置了哪几种服务容器？\n\n### Dubbo 官方文档\n\ndubbo 内置了 spring, jetty, log4j 等服务容器；\n支持自己扩展服务容器进行加载；\n\n### 2.7.7 版本\n\ndubbo 内置了 spring, log4j, logback 等服务容器；\n```\nspring=org.apache.dubbo.container.spring.SpringContainer\nlog4j=org.apache.dubbo.container.log4j.Log4jContainer\nlogback=org.apache.dubbo.container.logback.LogbackContainer\n```\n\n## 服务启动\n\nDubbo 服务启动只是一个简单的 Main 方法，加载一个简单的 Spring 容器，用于暴露服务。\n在服务启动时，调用容器的 start() 方法，在服务停止时调用 stop() 方法。\n\n# 高可用\n\n## Dubbo 负债均衡\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash 均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n## Dubbo 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n## Dubbo 服务降级\n\ndubbo 服务降级是 mock 机制，即当服务提供者出错时（抛出 RpcException），进行 mock 调用；\n\n有两种策略方式：\n- fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n- force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n\n# 运维管理\n\n## Dubbo 如何优雅停机？\n\nDubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。\n\n## Dubbo telnet 命令能做什么？\n\ndubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令。\n\n## 服务上线怎么兼容旧版本？\n\n可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。\n\n# SPI\n\n## SPI 是什么\n\nSPI 全称：Service Provider Interface;  \nSPI 就是通过动态加载机制实现面向接口编程;  \nSPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;\n\nSPI 一般用在哪儿？  \n主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。\n\n举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。\n\n## Dubbo SPI 和 Java SPI 区别？\n\nJava SPI\n- JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了\n\nDubbo SPI：\n- 对 Dubbo 进行扩展，不需要改动 Dubbo 的源码\n- 延迟加载，可以一次只加载自己想要加载的扩展实现。\n- 增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。\n- Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。\n\n# RPC 架构\n\n详情看 Dubbo-高级（RPC模块）\n\n# Dubbo 架构\n\n详情看 Dubbo-高级（Dubbo 底层解析模块）\n\n# 其他\n\n## Dubbo 支持服务降级吗？\n\ndubbo 自己有提供服务降级，但兼容性不是很好。  \n可以自己整合服务熔断框架，列如：Hystrix。\n\n## Dubbo 支持链路追踪吗？\n\ndubbo 目前暂时不支持链路追踪。  \n可以自己整合链路追踪框架，列如：Skywalking。\n\n## Dubbo 支持分布式事务吗？\n\ndubbo 目前暂时不支持分布式事务。  \n可以自己整合分布式事务框架，列如：Seata。","source":"_posts/oyr/Dubbo/Dubbo-面试题.md","raw":"---\ntitle: Dubbo-面试题\ndate: 2021-08-04 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Dubbo\ntags: \n    - Dubbo\n    - 分布式\n    - 面试\n---\n\n# 配置\n\n## Dubbo 核心配置有哪些\n\n| 标签 | 用途 | 解释 |\n| ---- | ---- | ----  |\n| dubbo:service     | 服务配置      | 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心 |\n| dubbo:reference   | 引用配置\t    | 用于创建一个远程服务代理，一个引用可以指向多个注册中心\n| dubbo:protocol    | 协议配置\t    | 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受\n| dubbo:application | 应用配置\t    | 用于配置当前应用信息，不管该应用是提供者还是消费者\n| dubbo:module      | 模块配置      | 用于配置当前模块信息，可选\n| dubbo:registry    | 注册中心配置  | 用于配置连接注册中心相关信息\n| dubbo:monitor     | 监控中心配置  | 用于配置连接监控中心相关信息，可选\n| dubbo:provider    | 提供方配置    | 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选\n| dubbo:consumer    | 消费方配置    | 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选\n| dubbo:method\t    | 方法配置\t    | 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息\n| dubbo:argument\t| 参数配置\t    | 用于指定方法参数配置\n\n## Dubbo 配置原则\n\nDubbo 推荐在 Provider 上尽量多配置 Consumer 端属性。\n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等\n2）在Provider配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的\n\n## Dubbo 属性配置优先级\n\n![属性配置优先级](https://rong0624.gitee.io/images/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## Dubbo 配置文件优先级\n\n![配置文件优先级](https://rong0624.gitee.io/images/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# 通讯协议\n\n## Dubbo 支持哪些通讯协议？\n\n### Dubbo 官方文档\n\n支持4种，分别是：Dubbo，Hessian，RMI，HTTP；\n\n### Dubbo 2.7.7\n\n通过分析 dubbo 2.7.7版本协议实现，支持11种；\n分别是：Dubbo，Hessian，RMI，HTTP，WebService，Thrift，Memcached，Redis，Rest，XmlRpc，Grpc；\n\n## Dubbo 通讯协议的特点\n\n### Dubbo协议\n\nDubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\nDubbo默认使用Dubbo协议；\n\n基于Dubbo的远程调用协议：\n连接个数：单连接\n连接方式：长连接  \n传输协议：TCP  \n传输方式：NIO异步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。  \n适用场景：常规远程服务方法调用\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。  \nHessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### RMI协议\n\nJava标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多连接  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化(JSON)  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### Thrift协议\n\n基于Thrift实现PRC协议\n\n### Redis协议\n\n基于redis实现RPC协议\n\n### Memcached协议\n\n基于Memcached实现RPC协议\n\n## Dubbo支持服务多协议吗？\n\nDubbo 支持多协议；  \nDubbo 在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。\n\n# 序列化\n\n## Dubbo 支持哪些序列化\n\n![支持的序列化](https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg)\nDubbo 支持 Hession，Dubbo，Json、Java自带序列化 多种序列化方式。但是 Hessian 是其默认的序列化方式。\n\n## Dubbo 序列化特点\n\n### Hession\n\n是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。\n\n### Dubbo\n\n是阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。\n\n### Json\n\n目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。\n\n### Java自带序列化\n\n主要是采用JDK自带的Java序列化实现，性能很不理想。\n\n## Hessian 的数据结构\n\nHessian 的对象序列化机制有 8 种原始类型：\n- 原始二进制数据\n- boolean\n- 64-bit date（64 位毫秒值的日期）\n- 64-bit double\n- 32-bit int\n- 64-bit long\n- null\n- UTF-8 编码的 string\n\n另外还包括 3 种递归类型：\n- list for lists and arrays\n- map for maps and dictionaries\n- object for objects\n\n还有一种特殊的类型：\n- ref：用来表示对共享对象的引用。\n\n## 什么是 BP？\n\n可能有一些同学比较习惯于 JSON or XML 数据存储格式，对于 Protocol Buffer 还比较陌生。  \nProtocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。\n\n其实 PB 之所以性能如此好；主要得益于两个；  \n第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；  \n第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。\n\n# 通讯框架\n\n## Dubbo 正常哪些通信框架，推荐使用什么？\n\n![支持的通讯框架](https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg)  \nDubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo 推荐并默认使用 Netty。\n\n# 注册中心\n\n## Dubbo 支持哪些注册中心？\n\n![支持的注册中心](https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg)  \nZookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。\n\n## Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\n\n可以通讯。启动 Dubbo 时，消费者会从注册中心拉取生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。\n\n```\n健壮性\n监控中心宕掉不影响使用，只是丢失部分采样数据\n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务\n注册中心对等集群，任意一台宕掉后，将自动切换到另一台\n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯\n服务提供者无状态，任意一台宕掉后，不影响使用\n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n```\n\n## Dubbo 直连模式\n\nDubbo 的直连模式，可以完全跳过注册中心，直接指定服务提供者的地址进行通讯；\n\n配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n## Dubbo 支持多注册中心吗？\n\nDubbo 支持多注册中心；  \nDubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  \n\n# 服务容器\n\n## Dubbo内置了哪几种服务容器？\n\n### Dubbo 官方文档\n\ndubbo 内置了 spring, jetty, log4j 等服务容器；\n支持自己扩展服务容器进行加载；\n\n### 2.7.7 版本\n\ndubbo 内置了 spring, log4j, logback 等服务容器；\n```\nspring=org.apache.dubbo.container.spring.SpringContainer\nlog4j=org.apache.dubbo.container.log4j.Log4jContainer\nlogback=org.apache.dubbo.container.logback.LogbackContainer\n```\n\n## 服务启动\n\nDubbo 服务启动只是一个简单的 Main 方法，加载一个简单的 Spring 容器，用于暴露服务。\n在服务启动时，调用容器的 start() 方法，在服务停止时调用 stop() 方法。\n\n# 高可用\n\n## Dubbo 负债均衡\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash 均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n## Dubbo 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n## Dubbo 服务降级\n\ndubbo 服务降级是 mock 机制，即当服务提供者出错时（抛出 RpcException），进行 mock 调用；\n\n有两种策略方式：\n- fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。\n- force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。\n\n# 运维管理\n\n## Dubbo 如何优雅停机？\n\nDubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。\n\n## Dubbo telnet 命令能做什么？\n\ndubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令。\n\n## 服务上线怎么兼容旧版本？\n\n可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。\n\n# SPI\n\n## SPI 是什么\n\nSPI 全称：Service Provider Interface;  \nSPI 就是通过动态加载机制实现面向接口编程;  \nSPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;\n\nSPI 一般用在哪儿？  \n主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。\n\n举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。\n\n## Dubbo SPI 和 Java SPI 区别？\n\nJava SPI\n- JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了\n\nDubbo SPI：\n- 对 Dubbo 进行扩展，不需要改动 Dubbo 的源码\n- 延迟加载，可以一次只加载自己想要加载的扩展实现。\n- 增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。\n- Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。\n\n# RPC 架构\n\n详情看 Dubbo-高级（RPC模块）\n\n# Dubbo 架构\n\n详情看 Dubbo-高级（Dubbo 底层解析模块）\n\n# 其他\n\n## Dubbo 支持服务降级吗？\n\ndubbo 自己有提供服务降级，但兼容性不是很好。  \n可以自己整合服务熔断框架，列如：Hystrix。\n\n## Dubbo 支持链路追踪吗？\n\ndubbo 目前暂时不支持链路追踪。  \n可以自己整合链路追踪框架，列如：Skywalking。\n\n## Dubbo 支持分布式事务吗？\n\ndubbo 目前暂时不支持分布式事务。  \n可以自己整合分布式事务框架，列如：Seata。","slug":"oyr/Dubbo/Dubbo-面试题","published":1,"updated":"2021-10-26T10:28:25.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86a000wcst7d5a010c2","content":"<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"Dubbo-核心配置有哪些\"><a href=\"#Dubbo-核心配置有哪些\" class=\"headerlink\" title=\"Dubbo 核心配置有哪些\"></a>Dubbo 核心配置有哪些</h2><table>\n<thead>\n<tr>\n<th>标签</th>\n<th>用途</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dubbo:service</td>\n<td>服务配置</td>\n<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>\n</tr>\n<tr>\n<td>dubbo:reference</td>\n<td>引用配置</td>\n<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>\n</tr>\n<tr>\n<td>dubbo:protocol</td>\n<td>协议配置</td>\n<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>\n</tr>\n<tr>\n<td>dubbo:application</td>\n<td>应用配置</td>\n<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>\n</tr>\n<tr>\n<td>dubbo:module</td>\n<td>模块配置</td>\n<td>用于配置当前模块信息，可选</td>\n</tr>\n<tr>\n<td>dubbo:registry</td>\n<td>注册中心配置</td>\n<td>用于配置连接注册中心相关信息</td>\n</tr>\n<tr>\n<td>dubbo:monitor</td>\n<td>监控中心配置</td>\n<td>用于配置连接监控中心相关信息，可选</td>\n</tr>\n<tr>\n<td>dubbo:provider</td>\n<td>提供方配置</td>\n<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>dubbo:consumer</td>\n<td>消费方配置</td>\n<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>dubbo:method</td>\n<td>方法配置</td>\n<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>\n</tr>\n<tr>\n<td>dubbo:argument</td>\n<td>参数配置</td>\n<td>用于指定方法参数配置</td>\n</tr>\n</tbody></table>\n<h2 id=\"Dubbo-配置原则\"><a href=\"#Dubbo-配置原则\" class=\"headerlink\" title=\"Dubbo 配置原则\"></a>Dubbo 配置原则</h2><p>Dubbo 推荐在 Provider 上尽量多配置 Consumer 端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的</p>\n<h2 id=\"Dubbo-属性配置优先级\"><a href=\"#Dubbo-属性配置优先级\" class=\"headerlink\" title=\"Dubbo 属性配置优先级\"></a>Dubbo 属性配置优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置优先级\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"Dubbo-配置文件优先级\"><a href=\"#Dubbo-配置文件优先级\" class=\"headerlink\" title=\"Dubbo 配置文件优先级\"></a>Dubbo 配置文件优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件优先级\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h1><h2 id=\"Dubbo-支持哪些通讯协议？\"><a href=\"#Dubbo-支持哪些通讯协议？\" class=\"headerlink\" title=\"Dubbo 支持哪些通讯协议？\"></a>Dubbo 支持哪些通讯协议？</h2><h3 id=\"Dubbo-官方文档\"><a href=\"#Dubbo-官方文档\" class=\"headerlink\" title=\"Dubbo 官方文档\"></a>Dubbo 官方文档</h3><p>支持4种，分别是：Dubbo，Hessian，RMI，HTTP；</p>\n<h3 id=\"Dubbo-2-7-7\"><a href=\"#Dubbo-2-7-7\" class=\"headerlink\" title=\"Dubbo 2.7.7\"></a>Dubbo 2.7.7</h3><p>通过分析 dubbo 2.7.7版本协议实现，支持11种；<br>分别是：Dubbo，Hessian，RMI，HTTP，WebService，Thrift，Memcached，Redis，Rest，XmlRpc，Grpc；</p>\n<h2 id=\"Dubbo-通讯协议的特点\"><a href=\"#Dubbo-通讯协议的特点\" class=\"headerlink\" title=\"Dubbo 通讯协议的特点\"></a>Dubbo 通讯协议的特点</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br>Dubbo默认使用Dubbo协议；</p>\n<p>基于Dubbo的远程调用协议：<br>连接个数：单连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO异步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<br>适用场景：常规远程服务方法调用</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。<br>Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>Java标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多连接<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化(JSON)<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"Thrift协议\"><a href=\"#Thrift协议\" class=\"headerlink\" title=\"Thrift协议\"></a>Thrift协议</h3><p>基于Thrift实现PRC协议</p>\n<h3 id=\"Redis协议\"><a href=\"#Redis协议\" class=\"headerlink\" title=\"Redis协议\"></a>Redis协议</h3><p>基于redis实现RPC协议</p>\n<h3 id=\"Memcached协议\"><a href=\"#Memcached协议\" class=\"headerlink\" title=\"Memcached协议\"></a>Memcached协议</h3><p>基于Memcached实现RPC协议</p>\n<h2 id=\"Dubbo支持服务多协议吗？\"><a href=\"#Dubbo支持服务多协议吗？\" class=\"headerlink\" title=\"Dubbo支持服务多协议吗？\"></a>Dubbo支持服务多协议吗？</h2><p>Dubbo 支持多协议；<br>Dubbo 在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。</p>\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><h2 id=\"Dubbo-支持哪些序列化\"><a href=\"#Dubbo-支持哪些序列化\" class=\"headerlink\" title=\"Dubbo 支持哪些序列化\"></a>Dubbo 支持哪些序列化</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg\" alt=\"支持的序列化\"><br>Dubbo 支持 Hession，Dubbo，Json、Java自带序列化 多种序列化方式。但是 Hessian 是其默认的序列化方式。</p>\n<h2 id=\"Dubbo-序列化特点\"><a href=\"#Dubbo-序列化特点\" class=\"headerlink\" title=\"Dubbo 序列化特点\"></a>Dubbo 序列化特点</h2><h3 id=\"Hession\"><a href=\"#Hession\" class=\"headerlink\" title=\"Hession\"></a>Hession</h3><p>是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。</p>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><p>是阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。</p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。</p>\n<h3 id=\"Java自带序列化\"><a href=\"#Java自带序列化\" class=\"headerlink\" title=\"Java自带序列化\"></a>Java自带序列化</h3><p>主要是采用JDK自带的Java序列化实现，性能很不理想。</p>\n<h2 id=\"Hessian-的数据结构\"><a href=\"#Hessian-的数据结构\" class=\"headerlink\" title=\"Hessian 的数据结构\"></a>Hessian 的数据结构</h2><p>Hessian 的对象序列化机制有 8 种原始类型：</p>\n<ul>\n<li>原始二进制数据</li>\n<li>boolean</li>\n<li>64-bit date（64 位毫秒值的日期）</li>\n<li>64-bit double</li>\n<li>32-bit int</li>\n<li>64-bit long</li>\n<li>null</li>\n<li>UTF-8 编码的 string</li>\n</ul>\n<p>另外还包括 3 种递归类型：</p>\n<ul>\n<li>list for lists and arrays</li>\n<li>map for maps and dictionaries</li>\n<li>object for objects</li>\n</ul>\n<p>还有一种特殊的类型：</p>\n<ul>\n<li>ref：用来表示对共享对象的引用。</li>\n</ul>\n<h2 id=\"什么是-BP？\"><a href=\"#什么是-BP？\" class=\"headerlink\" title=\"什么是 BP？\"></a>什么是 BP？</h2><p>可能有一些同学比较习惯于 JSON or XML 数据存储格式，对于 Protocol Buffer 还比较陌生。<br>Protocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。</p>\n<p>其实 PB 之所以性能如此好；主要得益于两个；<br>第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；<br>第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p>\n<h1 id=\"通讯框架\"><a href=\"#通讯框架\" class=\"headerlink\" title=\"通讯框架\"></a>通讯框架</h1><h2 id=\"Dubbo-正常哪些通信框架，推荐使用什么？\"><a href=\"#Dubbo-正常哪些通信框架，推荐使用什么？\" class=\"headerlink\" title=\"Dubbo 正常哪些通信框架，推荐使用什么？\"></a>Dubbo 正常哪些通信框架，推荐使用什么？</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg\" alt=\"支持的通讯框架\"><br>Dubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo 推荐并默认使用 Netty。</p>\n<h1 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h1><h2 id=\"Dubbo-支持哪些注册中心？\"><a href=\"#Dubbo-支持哪些注册中心？\" class=\"headerlink\" title=\"Dubbo 支持哪些注册中心？\"></a>Dubbo 支持哪些注册中心？</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg\" alt=\"支持的注册中心\"><br>Zookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。</p>\n<h2 id=\"Dubbo-的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\"><a href=\"#Dubbo-的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\" class=\"headerlink\" title=\"Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\"></a>Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？</h2><p>可以通讯。启动 Dubbo 时，消费者会从注册中心拉取生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">健壮性</span><br><span class=\"line\">监控中心宕掉不影响使用，只是丢失部分采样数据</span><br><span class=\"line\">数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</span><br><span class=\"line\">注册中心对等集群，任意一台宕掉后，将自动切换到另一台</span><br><span class=\"line\">注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</span><br><span class=\"line\">服务提供者无状态，任意一台宕掉后，不影响使用</span><br><span class=\"line\">服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-直连模式\"><a href=\"#Dubbo-直连模式\" class=\"headerlink\" title=\"Dubbo 直连模式\"></a>Dubbo 直连模式</h2><p>Dubbo 的直连模式，可以完全跳过注册中心，直接指定服务提供者的地址进行通讯；</p>\n<p>配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-支持多注册中心吗？\"><a href=\"#Dubbo-支持多注册中心吗？\" class=\"headerlink\" title=\"Dubbo 支持多注册中心吗？\"></a>Dubbo 支持多注册中心吗？</h2><p>Dubbo 支持多注册中心；<br>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  </p>\n<h1 id=\"服务容器\"><a href=\"#服务容器\" class=\"headerlink\" title=\"服务容器\"></a>服务容器</h1><h2 id=\"Dubbo内置了哪几种服务容器？\"><a href=\"#Dubbo内置了哪几种服务容器？\" class=\"headerlink\" title=\"Dubbo内置了哪几种服务容器？\"></a>Dubbo内置了哪几种服务容器？</h2><h3 id=\"Dubbo-官方文档-1\"><a href=\"#Dubbo-官方文档-1\" class=\"headerlink\" title=\"Dubbo 官方文档\"></a>Dubbo 官方文档</h3><p>dubbo 内置了 spring, jetty, log4j 等服务容器；<br>支持自己扩展服务容器进行加载；</p>\n<h3 id=\"2-7-7-版本\"><a href=\"#2-7-7-版本\" class=\"headerlink\" title=\"2.7.7 版本\"></a>2.7.7 版本</h3><p>dubbo 内置了 spring, log4j, logback 等服务容器；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring=org.apache.dubbo.container.spring.SpringContainer</span><br><span class=\"line\">log4j=org.apache.dubbo.container.log4j.Log4jContainer</span><br><span class=\"line\">logback=org.apache.dubbo.container.logback.LogbackContainer</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务启动\"><a href=\"#服务启动\" class=\"headerlink\" title=\"服务启动\"></a>服务启动</h2><p>Dubbo 服务启动只是一个简单的 Main 方法，加载一个简单的 Spring 容器，用于暴露服务。<br>在服务启动时，调用容器的 start() 方法，在服务停止时调用 stop() 方法。</p>\n<h1 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h1><h2 id=\"Dubbo-负债均衡\"><a href=\"#Dubbo-负债均衡\" class=\"headerlink\" title=\"Dubbo 负债均衡\"></a>Dubbo 负债均衡</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash 均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-集群容错\"><a href=\"#Dubbo-集群容错\" class=\"headerlink\" title=\"Dubbo 集群容错\"></a>Dubbo 集群容错</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-服务降级\"><a href=\"#Dubbo-服务降级\" class=\"headerlink\" title=\"Dubbo 服务降级\"></a>Dubbo 服务降级</h2><p>dubbo 服务降级是 mock 机制，即当服务提供者出错时（抛出 RpcException），进行 mock 调用；</p>\n<p>有两种策略方式：</p>\n<ul>\n<li>fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</li>\n<li>force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。</li>\n</ul>\n<h1 id=\"运维管理\"><a href=\"#运维管理\" class=\"headerlink\" title=\"运维管理\"></a>运维管理</h1><h2 id=\"Dubbo-如何优雅停机？\"><a href=\"#Dubbo-如何优雅停机？\" class=\"headerlink\" title=\"Dubbo 如何优雅停机？\"></a>Dubbo 如何优雅停机？</h2><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p>\n<h2 id=\"Dubbo-telnet-命令能做什么？\"><a href=\"#Dubbo-telnet-命令能做什么？\" class=\"headerlink\" title=\"Dubbo telnet 命令能做什么？\"></a>Dubbo telnet 命令能做什么？</h2><p>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令。</p>\n<h2 id=\"服务上线怎么兼容旧版本？\"><a href=\"#服务上线怎么兼容旧版本？\" class=\"headerlink\" title=\"服务上线怎么兼容旧版本？\"></a>服务上线怎么兼容旧版本？</h2><p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p>\n<h1 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h1><h2 id=\"SPI-是什么\"><a href=\"#SPI-是什么\" class=\"headerlink\" title=\"SPI 是什么\"></a>SPI 是什么</h2><p>SPI 全称：Service Provider Interface;<br>SPI 就是通过动态加载机制实现面向接口编程;<br>SPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;</p>\n<p>SPI 一般用在哪儿？<br>主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。</p>\n<p>举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p>\n<h2 id=\"Dubbo-SPI-和-Java-SPI-区别？\"><a href=\"#Dubbo-SPI-和-Java-SPI-区别？\" class=\"headerlink\" title=\"Dubbo SPI 和 Java SPI 区别？\"></a>Dubbo SPI 和 Java SPI 区别？</h2><p>Java SPI</p>\n<ul>\n<li>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</li>\n</ul>\n<p>Dubbo SPI：</p>\n<ul>\n<li>对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</li>\n<li>延迟加载，可以一次只加载自己想要加载的扩展实现。</li>\n<li>增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>\n<li>Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</li>\n</ul>\n<h1 id=\"RPC-架构\"><a href=\"#RPC-架构\" class=\"headerlink\" title=\"RPC 架构\"></a>RPC 架构</h1><p>详情看 Dubbo-高级（RPC模块）</p>\n<h1 id=\"Dubbo-架构\"><a href=\"#Dubbo-架构\" class=\"headerlink\" title=\"Dubbo 架构\"></a>Dubbo 架构</h1><p>详情看 Dubbo-高级（Dubbo 底层解析模块）</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"Dubbo-支持服务降级吗？\"><a href=\"#Dubbo-支持服务降级吗？\" class=\"headerlink\" title=\"Dubbo 支持服务降级吗？\"></a>Dubbo 支持服务降级吗？</h2><p>dubbo 自己有提供服务降级，但兼容性不是很好。<br>可以自己整合服务熔断框架，列如：Hystrix。</p>\n<h2 id=\"Dubbo-支持链路追踪吗？\"><a href=\"#Dubbo-支持链路追踪吗？\" class=\"headerlink\" title=\"Dubbo 支持链路追踪吗？\"></a>Dubbo 支持链路追踪吗？</h2><p>dubbo 目前暂时不支持链路追踪。<br>可以自己整合链路追踪框架，列如：Skywalking。</p>\n<h2 id=\"Dubbo-支持分布式事务吗？\"><a href=\"#Dubbo-支持分布式事务吗？\" class=\"headerlink\" title=\"Dubbo 支持分布式事务吗？\"></a>Dubbo 支持分布式事务吗？</h2><p>dubbo 目前暂时不支持分布式事务。<br>可以自己整合分布式事务框架，列如：Seata。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h2 id=\"Dubbo-核心配置有哪些\"><a href=\"#Dubbo-核心配置有哪些\" class=\"headerlink\" title=\"Dubbo 核心配置有哪些\"></a>Dubbo 核心配置有哪些</h2><table>\n<thead>\n<tr>\n<th>标签</th>\n<th>用途</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>dubbo:service</td>\n<td>服务配置</td>\n<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>\n</tr>\n<tr>\n<td>dubbo:reference</td>\n<td>引用配置</td>\n<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>\n</tr>\n<tr>\n<td>dubbo:protocol</td>\n<td>协议配置</td>\n<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>\n</tr>\n<tr>\n<td>dubbo:application</td>\n<td>应用配置</td>\n<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>\n</tr>\n<tr>\n<td>dubbo:module</td>\n<td>模块配置</td>\n<td>用于配置当前模块信息，可选</td>\n</tr>\n<tr>\n<td>dubbo:registry</td>\n<td>注册中心配置</td>\n<td>用于配置连接注册中心相关信息</td>\n</tr>\n<tr>\n<td>dubbo:monitor</td>\n<td>监控中心配置</td>\n<td>用于配置连接监控中心相关信息，可选</td>\n</tr>\n<tr>\n<td>dubbo:provider</td>\n<td>提供方配置</td>\n<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>dubbo:consumer</td>\n<td>消费方配置</td>\n<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>\n</tr>\n<tr>\n<td>dubbo:method</td>\n<td>方法配置</td>\n<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>\n</tr>\n<tr>\n<td>dubbo:argument</td>\n<td>参数配置</td>\n<td>用于指定方法参数配置</td>\n</tr>\n</tbody></table>\n<h2 id=\"Dubbo-配置原则\"><a href=\"#Dubbo-配置原则\" class=\"headerlink\" title=\"Dubbo 配置原则\"></a>Dubbo 配置原则</h2><p>Dubbo 推荐在 Provider 上尽量多配置 Consumer 端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的</p>\n<h2 id=\"Dubbo-属性配置优先级\"><a href=\"#Dubbo-属性配置优先级\" class=\"headerlink\" title=\"Dubbo 属性配置优先级\"></a>Dubbo 属性配置优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置优先级\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"Dubbo-配置文件优先级\"><a href=\"#Dubbo-配置文件优先级\" class=\"headerlink\" title=\"Dubbo 配置文件优先级\"></a>Dubbo 配置文件优先级</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件优先级\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h1><h2 id=\"Dubbo-支持哪些通讯协议？\"><a href=\"#Dubbo-支持哪些通讯协议？\" class=\"headerlink\" title=\"Dubbo 支持哪些通讯协议？\"></a>Dubbo 支持哪些通讯协议？</h2><h3 id=\"Dubbo-官方文档\"><a href=\"#Dubbo-官方文档\" class=\"headerlink\" title=\"Dubbo 官方文档\"></a>Dubbo 官方文档</h3><p>支持4种，分别是：Dubbo，Hessian，RMI，HTTP；</p>\n<h3 id=\"Dubbo-2-7-7\"><a href=\"#Dubbo-2-7-7\" class=\"headerlink\" title=\"Dubbo 2.7.7\"></a>Dubbo 2.7.7</h3><p>通过分析 dubbo 2.7.7版本协议实现，支持11种；<br>分别是：Dubbo，Hessian，RMI，HTTP，WebService，Thrift，Memcached，Redis，Rest，XmlRpc，Grpc；</p>\n<h2 id=\"Dubbo-通讯协议的特点\"><a href=\"#Dubbo-通讯协议的特点\" class=\"headerlink\" title=\"Dubbo 通讯协议的特点\"></a>Dubbo 通讯协议的特点</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<br>Dubbo默认使用Dubbo协议；</p>\n<p>基于Dubbo的远程调用协议：<br>连接个数：单连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO异步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<br>适用场景：常规远程服务方法调用</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。<br>Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>Java标准的远程调用协议，采用JDK标准的java.rmi.*实现，阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多连接<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化(JSON)<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"Thrift协议\"><a href=\"#Thrift协议\" class=\"headerlink\" title=\"Thrift协议\"></a>Thrift协议</h3><p>基于Thrift实现PRC协议</p>\n<h3 id=\"Redis协议\"><a href=\"#Redis协议\" class=\"headerlink\" title=\"Redis协议\"></a>Redis协议</h3><p>基于redis实现RPC协议</p>\n<h3 id=\"Memcached协议\"><a href=\"#Memcached协议\" class=\"headerlink\" title=\"Memcached协议\"></a>Memcached协议</h3><p>基于Memcached实现RPC协议</p>\n<h2 id=\"Dubbo支持服务多协议吗？\"><a href=\"#Dubbo支持服务多协议吗？\" class=\"headerlink\" title=\"Dubbo支持服务多协议吗？\"></a>Dubbo支持服务多协议吗？</h2><p>Dubbo 支持多协议；<br>Dubbo 在不同服务上支持不同协议 或者 同一服务上同时支持多种协议。</p>\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><h2 id=\"Dubbo-支持哪些序列化\"><a href=\"#Dubbo-支持哪些序列化\" class=\"headerlink\" title=\"Dubbo 支持哪些序列化\"></a>Dubbo 支持哪些序列化</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627984641381.jpg\" alt=\"支持的序列化\"><br>Dubbo 支持 Hession，Dubbo，Json、Java自带序列化 多种序列化方式。但是 Hessian 是其默认的序列化方式。</p>\n<h2 id=\"Dubbo-序列化特点\"><a href=\"#Dubbo-序列化特点\" class=\"headerlink\" title=\"Dubbo 序列化特点\"></a>Dubbo 序列化特点</h2><h3 id=\"Hession\"><a href=\"#Hession\" class=\"headerlink\" title=\"Hession\"></a>Hession</h3><p>是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。</p>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><p>是阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。</p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。</p>\n<h3 id=\"Java自带序列化\"><a href=\"#Java自带序列化\" class=\"headerlink\" title=\"Java自带序列化\"></a>Java自带序列化</h3><p>主要是采用JDK自带的Java序列化实现，性能很不理想。</p>\n<h2 id=\"Hessian-的数据结构\"><a href=\"#Hessian-的数据结构\" class=\"headerlink\" title=\"Hessian 的数据结构\"></a>Hessian 的数据结构</h2><p>Hessian 的对象序列化机制有 8 种原始类型：</p>\n<ul>\n<li>原始二进制数据</li>\n<li>boolean</li>\n<li>64-bit date（64 位毫秒值的日期）</li>\n<li>64-bit double</li>\n<li>32-bit int</li>\n<li>64-bit long</li>\n<li>null</li>\n<li>UTF-8 编码的 string</li>\n</ul>\n<p>另外还包括 3 种递归类型：</p>\n<ul>\n<li>list for lists and arrays</li>\n<li>map for maps and dictionaries</li>\n<li>object for objects</li>\n</ul>\n<p>还有一种特殊的类型：</p>\n<ul>\n<li>ref：用来表示对共享对象的引用。</li>\n</ul>\n<h2 id=\"什么是-BP？\"><a href=\"#什么是-BP？\" class=\"headerlink\" title=\"什么是 BP？\"></a>什么是 BP？</h2><p>可能有一些同学比较习惯于 JSON or XML 数据存储格式，对于 Protocol Buffer 还比较陌生。<br>Protocol Buffer 其实是 Google 出品的一种轻量并且高效的结构化数据存储格式，性能比 JSON、XML 要高很多。</p>\n<p>其实 PB 之所以性能如此好；主要得益于两个；<br>第一，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 XML 和 JSON 快上了 20~100 倍；<br>第二，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p>\n<h1 id=\"通讯框架\"><a href=\"#通讯框架\" class=\"headerlink\" title=\"通讯框架\"></a>通讯框架</h1><h2 id=\"Dubbo-正常哪些通信框架，推荐使用什么？\"><a href=\"#Dubbo-正常哪些通信框架，推荐使用什么？\" class=\"headerlink\" title=\"Dubbo 正常哪些通信框架，推荐使用什么？\"></a>Dubbo 正常哪些通信框架，推荐使用什么？</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983850471.jpg\" alt=\"支持的通讯框架\"><br>Dubbo 支持 Netty、Mina、Grizzly 多种通讯框架，Dubbo 推荐并默认使用 Netty。</p>\n<h1 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h1><h2 id=\"Dubbo-支持哪些注册中心？\"><a href=\"#Dubbo-支持哪些注册中心？\" class=\"headerlink\" title=\"Dubbo 支持哪些注册中心？\"></a>Dubbo 支持哪些注册中心？</h2><p><img src=\"https://rong0624.gitee.io/images/Dubbo/1627983532373.jpg\" alt=\"支持的注册中心\"><br>Zookeeper、Redis、Multicast、Simple 都可以作为Dubbo的注册中心，Dubbo官方推荐使用 Zookeeper。</p>\n<h2 id=\"Dubbo-的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\"><a href=\"#Dubbo-的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\" class=\"headerlink\" title=\"Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？\"></a>Dubbo 的注册中心挂掉，服务提供者和服务消费者之间还能通信么？</h2><p>可以通讯。启动 Dubbo 时，消费者会从注册中心拉取生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">健壮性</span><br><span class=\"line\">监控中心宕掉不影响使用，只是丢失部分采样数据</span><br><span class=\"line\">数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</span><br><span class=\"line\">注册中心对等集群，任意一台宕掉后，将自动切换到另一台</span><br><span class=\"line\">注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</span><br><span class=\"line\">服务提供者无状态，任意一台宕掉后，不影响使用</span><br><span class=\"line\">服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-直连模式\"><a href=\"#Dubbo-直连模式\" class=\"headerlink\" title=\"Dubbo 直连模式\"></a>Dubbo 直连模式</h2><p>Dubbo 的直连模式，可以完全跳过注册中心，直接指定服务提供者的地址进行通讯；</p>\n<p>配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-支持多注册中心吗？\"><a href=\"#Dubbo-支持多注册中心吗？\" class=\"headerlink\" title=\"Dubbo 支持多注册中心吗？\"></a>Dubbo 支持多注册中心吗？</h2><p>Dubbo 支持多注册中心；<br>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。  </p>\n<h1 id=\"服务容器\"><a href=\"#服务容器\" class=\"headerlink\" title=\"服务容器\"></a>服务容器</h1><h2 id=\"Dubbo内置了哪几种服务容器？\"><a href=\"#Dubbo内置了哪几种服务容器？\" class=\"headerlink\" title=\"Dubbo内置了哪几种服务容器？\"></a>Dubbo内置了哪几种服务容器？</h2><h3 id=\"Dubbo-官方文档-1\"><a href=\"#Dubbo-官方文档-1\" class=\"headerlink\" title=\"Dubbo 官方文档\"></a>Dubbo 官方文档</h3><p>dubbo 内置了 spring, jetty, log4j 等服务容器；<br>支持自己扩展服务容器进行加载；</p>\n<h3 id=\"2-7-7-版本\"><a href=\"#2-7-7-版本\" class=\"headerlink\" title=\"2.7.7 版本\"></a>2.7.7 版本</h3><p>dubbo 内置了 spring, log4j, logback 等服务容器；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring=org.apache.dubbo.container.spring.SpringContainer</span><br><span class=\"line\">log4j=org.apache.dubbo.container.log4j.Log4jContainer</span><br><span class=\"line\">logback=org.apache.dubbo.container.logback.LogbackContainer</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务启动\"><a href=\"#服务启动\" class=\"headerlink\" title=\"服务启动\"></a>服务启动</h2><p>Dubbo 服务启动只是一个简单的 Main 方法，加载一个简单的 Spring 容器，用于暴露服务。<br>在服务启动时，调用容器的 start() 方法，在服务停止时调用 stop() 方法。</p>\n<h1 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h1><h2 id=\"Dubbo-负债均衡\"><a href=\"#Dubbo-负债均衡\" class=\"headerlink\" title=\"Dubbo 负债均衡\"></a>Dubbo 负债均衡</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash 均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-集群容错\"><a href=\"#Dubbo-集群容错\" class=\"headerlink\" title=\"Dubbo 集群容错\"></a>Dubbo 集群容错</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dubbo-服务降级\"><a href=\"#Dubbo-服务降级\" class=\"headerlink\" title=\"Dubbo 服务降级\"></a>Dubbo 服务降级</h2><p>dubbo 服务降级是 mock 机制，即当服务提供者出错时（抛出 RpcException），进行 mock 调用；</p>\n<p>有两种策略方式：</p>\n<ul>\n<li>fail：当服务消费者调用服务提供者失败后，会去执行配置的 mock 策略。 配置方式为 mock=“fail:策略” 或者 mock=“策略”。</li>\n<li>force：当服务消费者调用服务提供者时，会直接执行 mock 配置的策略，不会进行服务调用。</li>\n</ul>\n<h1 id=\"运维管理\"><a href=\"#运维管理\" class=\"headerlink\" title=\"运维管理\"></a>运维管理</h1><h2 id=\"Dubbo-如何优雅停机？\"><a href=\"#Dubbo-如何优雅停机？\" class=\"headerlink\" title=\"Dubbo 如何优雅停机？\"></a>Dubbo 如何优雅停机？</h2><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p>\n<h2 id=\"Dubbo-telnet-命令能做什么？\"><a href=\"#Dubbo-telnet-命令能做什么？\" class=\"headerlink\" title=\"Dubbo telnet 命令能做什么？\"></a>Dubbo telnet 命令能做什么？</h2><p>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令。</p>\n<h2 id=\"服务上线怎么兼容旧版本？\"><a href=\"#服务上线怎么兼容旧版本？\" class=\"headerlink\" title=\"服务上线怎么兼容旧版本？\"></a>服务上线怎么兼容旧版本？</h2><p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p>\n<h1 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h1><h2 id=\"SPI-是什么\"><a href=\"#SPI-是什么\" class=\"headerlink\" title=\"SPI 是什么\"></a>SPI 是什么</h2><p>SPI 全称：Service Provider Interface;<br>SPI 就是通过动态加载机制实现面向接口编程;<br>SPI 是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件;</p>\n<p>SPI 一般用在哪儿？<br>主要在框架中使用，用于插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 SPI 思想就用上了。</p>\n<p>举个例子：你有一个接口 A。A1/A2/A3 分别是接口A的不同实现。你通过配置 接口 A = 实现 A2，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p>\n<h2 id=\"Dubbo-SPI-和-Java-SPI-区别？\"><a href=\"#Dubbo-SPI-和-Java-SPI-区别？\" class=\"headerlink\" title=\"Dubbo SPI 和 Java SPI 区别？\"></a>Dubbo SPI 和 Java SPI 区别？</h2><p>Java SPI</p>\n<ul>\n<li>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</li>\n</ul>\n<p>Dubbo SPI：</p>\n<ul>\n<li>对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</li>\n<li>延迟加载，可以一次只加载自己想要加载的扩展实现。</li>\n<li>增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>\n<li>Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</li>\n</ul>\n<h1 id=\"RPC-架构\"><a href=\"#RPC-架构\" class=\"headerlink\" title=\"RPC 架构\"></a>RPC 架构</h1><p>详情看 Dubbo-高级（RPC模块）</p>\n<h1 id=\"Dubbo-架构\"><a href=\"#Dubbo-架构\" class=\"headerlink\" title=\"Dubbo 架构\"></a>Dubbo 架构</h1><p>详情看 Dubbo-高级（Dubbo 底层解析模块）</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"Dubbo-支持服务降级吗？\"><a href=\"#Dubbo-支持服务降级吗？\" class=\"headerlink\" title=\"Dubbo 支持服务降级吗？\"></a>Dubbo 支持服务降级吗？</h2><p>dubbo 自己有提供服务降级，但兼容性不是很好。<br>可以自己整合服务熔断框架，列如：Hystrix。</p>\n<h2 id=\"Dubbo-支持链路追踪吗？\"><a href=\"#Dubbo-支持链路追踪吗？\" class=\"headerlink\" title=\"Dubbo 支持链路追踪吗？\"></a>Dubbo 支持链路追踪吗？</h2><p>dubbo 目前暂时不支持链路追踪。<br>可以自己整合链路追踪框架，列如：Skywalking。</p>\n<h2 id=\"Dubbo-支持分布式事务吗？\"><a href=\"#Dubbo-支持分布式事务吗？\" class=\"headerlink\" title=\"Dubbo 支持分布式事务吗？\"></a>Dubbo 支持分布式事务吗？</h2><p>dubbo 目前暂时不支持分布式事务。<br>可以自己整合分布式事务框架，列如：Seata。</p>\n"},{"title":"AQS","date":"2021-08-26T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是AQS\n    AQS Abstract Queued Synchronizer 抽象队列同步器\n    \n    AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n    \n    AQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\n    AQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n    \n![](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_1.jpg)\n\n## java并发与AQS的关系\n\njava 并发api的使用 简单如 \n\n```java\nReentrantLock lock = new ReentrantLock();\n\nlock.lock(); //加锁\n\n//...业务逻辑\n\nlock.unlock();//释放锁\n\n//以上代码：初始化一个lock 对象，然后加锁 和释放锁\n```\n\n    以reentrantLock为例， 与AQS的关系主要是因为：\n    java并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\n    AQS 是java并发包的基础类。\n\n\n## ReentrantLock-重入锁\n    可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n    也就是可以对一个锁加锁解锁多次\n\n每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。\n\n## ReentrantLock的加锁和释放锁的底层原理\n    当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n\n1. 线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。\n    如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功\n    \n    线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己\n    \n![线程1尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_2.jpg)  \n\n    从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n    内核中实现的锁机制都是用来的AQS实现的。\n\n2. 线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败\n\n![线程2尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_3.jpg)  \n\n    接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n    当线程1是否锁后，可以再次尝试去加锁\n\n![AQS加锁失败等待队列](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_4.jpg)  \n\n线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null\n![线程1释放锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_5.jpg)\n\n\n3. 接下来就是从等待队列中唤醒线程2尝试重新加锁。\n    线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己\n\n![线程2唤醒后尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_6.jpg)\n\n# 总结\n    本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\n    AQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n    它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n\n[来源参考]：https://shishan100.gitee.io/docs/#/./docs/page/page3","source":"_posts/lh/并发编程/AQS.md","raw":"---\ntitle: AQS\ndate: 2021-08-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是AQS\n    AQS Abstract Queued Synchronizer 抽象队列同步器\n    \n    AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n    \n    AQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\n    AQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n    \n![](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_1.jpg)\n\n## java并发与AQS的关系\n\njava 并发api的使用 简单如 \n\n```java\nReentrantLock lock = new ReentrantLock();\n\nlock.lock(); //加锁\n\n//...业务逻辑\n\nlock.unlock();//释放锁\n\n//以上代码：初始化一个lock 对象，然后加锁 和释放锁\n```\n\n    以reentrantLock为例， 与AQS的关系主要是因为：\n    java并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\n    AQS 是java并发包的基础类。\n\n\n## ReentrantLock-重入锁\n    可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n    也就是可以对一个锁加锁解锁多次\n\n每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。\n\n## ReentrantLock的加锁和释放锁的底层原理\n    当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n\n1. 线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。\n    如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功\n    \n    线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己\n    \n![线程1尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_2.jpg)  \n\n    从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n    内核中实现的锁机制都是用来的AQS实现的。\n\n2. 线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败\n\n![线程2尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_3.jpg)  \n\n    接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n    当线程1是否锁后，可以再次尝试去加锁\n\n![AQS加锁失败等待队列](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_4.jpg)  \n\n线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null\n![线程1释放锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_5.jpg)\n\n\n3. 接下来就是从等待队列中唤醒线程2尝试重新加锁。\n    线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己\n\n![线程2唤醒后尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_6.jpg)\n\n# 总结\n    本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\n    AQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n    它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n\n[来源参考]：https://shishan100.gitee.io/docs/#/./docs/page/page3","slug":"lh/并发编程/AQS","published":1,"updated":"2021-09-01T02:45:26.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86b0010cst75pqa3wh9","content":"<h1 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h1><pre><code>AQS Abstract Queued Synchronizer 抽象队列同步器\n\nAQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n\nAQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\nAQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_1.jpg\"></p>\n<h2 id=\"java并发与AQS的关系\"><a href=\"#java并发与AQS的关系\" class=\"headerlink\" title=\"java并发与AQS的关系\"></a>java并发与AQS的关系</h2><p>java 并发api的使用 简单如 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">//加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">lock.unlock();<span class=\"comment\">//释放锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以上代码：初始化一个lock 对象，然后加锁 和释放锁</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>以reentrantLock为例， 与AQS的关系主要是因为：\njava并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\nAQS 是java并发包的基础类。\n</code></pre>\n<h2 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock-重入锁\"></a>ReentrantLock-重入锁</h2><pre><code>可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n也就是可以对一个锁加锁解锁多次\n</code></pre>\n<p>每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。</p>\n<h2 id=\"ReentrantLock的加锁和释放锁的底层原理\"><a href=\"#ReentrantLock的加锁和释放锁的底层原理\" class=\"headerlink\" title=\"ReentrantLock的加锁和释放锁的底层原理\"></a>ReentrantLock的加锁和释放锁的底层原理</h2><pre><code>当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n</code></pre>\n<ol>\n<li>线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。<br> 如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功 线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_2.jpg\" alt=\"线程1尝试加锁\">  </p>\n<pre><code>从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n内核中实现的锁机制都是用来的AQS实现的。\n</code></pre>\n<ol start=\"2\">\n<li>线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_3.jpg\" alt=\"线程2尝试加锁\">  </p>\n<pre><code>接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n当线程1是否锁后，可以再次尝试去加锁\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_4.jpg\" alt=\"AQS加锁失败等待队列\">  </p>\n<p>线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_5.jpg\" alt=\"线程1释放锁\"></p>\n<ol start=\"3\">\n<li>接下来就是从等待队列中唤醒线程2尝试重新加锁。<br> 线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_6.jpg\" alt=\"线程2唤醒后尝试加锁\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\nAQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n</code></pre>\n<p>[来源参考]：<a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page3\">https://shishan100.gitee.io/docs/#/./docs/page/page3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h1><pre><code>AQS Abstract Queued Synchronizer 抽象队列同步器\n\nAQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n\nAQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\nAQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_1.jpg\"></p>\n<h2 id=\"java并发与AQS的关系\"><a href=\"#java并发与AQS的关系\" class=\"headerlink\" title=\"java并发与AQS的关系\"></a>java并发与AQS的关系</h2><p>java 并发api的使用 简单如 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">//加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">lock.unlock();<span class=\"comment\">//释放锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以上代码：初始化一个lock 对象，然后加锁 和释放锁</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>以reentrantLock为例， 与AQS的关系主要是因为：\njava并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\nAQS 是java并发包的基础类。\n</code></pre>\n<h2 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock-重入锁\"></a>ReentrantLock-重入锁</h2><pre><code>可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n也就是可以对一个锁加锁解锁多次\n</code></pre>\n<p>每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。</p>\n<h2 id=\"ReentrantLock的加锁和释放锁的底层原理\"><a href=\"#ReentrantLock的加锁和释放锁的底层原理\" class=\"headerlink\" title=\"ReentrantLock的加锁和释放锁的底层原理\"></a>ReentrantLock的加锁和释放锁的底层原理</h2><pre><code>当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n</code></pre>\n<ol>\n<li>线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。<br> 如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功 线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_2.jpg\" alt=\"线程1尝试加锁\">  </p>\n<pre><code>从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n内核中实现的锁机制都是用来的AQS实现的。\n</code></pre>\n<ol start=\"2\">\n<li>线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_3.jpg\" alt=\"线程2尝试加锁\">  </p>\n<pre><code>接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n当线程1是否锁后，可以再次尝试去加锁\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_4.jpg\" alt=\"AQS加锁失败等待队列\">  </p>\n<p>线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_5.jpg\" alt=\"线程1释放锁\"></p>\n<ol start=\"3\">\n<li>接下来就是从等待队列中唤醒线程2尝试重新加锁。<br> 线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_6.jpg\" alt=\"线程2唤醒后尝试加锁\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\nAQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n</code></pre>\n<p>[来源参考]：<a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page3\">https://shishan100.gitee.io/docs/#/./docs/page/page3</a></p>\n"},{"title":"CAS","date":"2021-08-10T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是CAS \n    CAS compare and swap的缩写，中文翻译成 比较并替换\n    \n    CAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n    如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n    无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\n    CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n\n## CAS的目的\n    利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n    其他院子操作都是利用类似的特性完成的。\n    而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n\n## CAS 存在的问题\n    CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n* ABA问题  \n    因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。  \n    但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。  \n    ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一  \n    那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。\n\n* 循环时间长开销大  \n    自选CAS如果长时间不成功，会给CPU带来很大的开销。\n    如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。  \n    pause 指令的作用\n    * 它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零\n    * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   \n\n* 只能保证一个共享变量的原子操作  \n    当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。  \n    解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作\n``` java\npublic class HelloWorld{\n    private int data = 0;\n\n    public synchronized void increment(){\n        data++;\n    }\n\n    // 多个线程同时调用方法：increment（）;\n}\n```\n\n## atmoic原子类及其底层原理\n    对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n    他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n```java\npublic class HelloWorld {\n    \n    private AtomicInteger data = new AtomicInteger(0);\n\n    //多个线程并发的执行：data.incrementAndGet()\n}\n```\n多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。\n\n    Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-1.jpg)\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-2.png)\n\n    上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n    先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n\n## java8 如何对CAS 进行了优化\n    atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n    如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n    于是JAVA 8 推出了一个新的类 LongAdder.  \n    LongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\n    LongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n    竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n    这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\n    LongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n    但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \n    LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \n    LongAdder 在保证高效的同时，也需要消耗更多的空间\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/LongAdder-1.jpg) \n\n```java\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.LongAdder;\n\n/**\n * <pre>\n * 程序目的：和 AtomicLong 进行性能对比\n * </pre>\n * created at 2020/8/11 06:25\n * @author lerry\n */\npublic class LongAdderDemo {\n /**\n  * 线程池内线程数\n  */\n final static int POOL_SIZE = 1000;\n\n public static void main(String[] args) throws InterruptedException {\n    long start = System.currentTimeMillis();\n\n    LongAdder counter = new LongAdder();\n    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);\n\n    ArrayList<Future> futures = new ArrayList<>(POOL_SIZE);\n    for (int i = 0; i < POOL_SIZE * 100; i++) {\n    futures.add(service.submit(new LongAdderDemo.Task(counter)));\n    }\n\n    // 等待所有线程执行完\n    for (Future future : futures) {\n    try {\n        future.get();\n    }\n    catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n    }\n\n    NumberFormat numberFormat = NumberFormat.getInstance();\n    System.out.printf(\"统计结果为：[%s]\\n\", numberFormat.format(counter.sum()));\n    System.out.printf(\"耗时：[%d]毫秒\", (System.currentTimeMillis() - start));\n    // 关闭线程池\n    service.shutdown();\n }\n\n /**\n  * 有一个 LongAdder 成员变量，每次执行N次+1操作\n  */\n static class Task implements Runnable {\n\n  private final LongAdder counter;\n\n  public Task(LongAdder counter) {\n   this.counter = counter;\n  }\n\n  /**\n   * 每个线程执行N次+1操作\n   */\n  @Override\n  public void run() {\n    for (int i = 0; i < 100; i++) {\n        counter.increment();\n    }\n  }// end run\n }// end class\n}\n```\n\n[来源参考] https://shishan100.gitee.io/docs/#/./docs/page/page2\n[微信参考链接] https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\n[LongAdder实践](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect)\n\n","source":"_posts/lh/并发编程/CAS.md","raw":"---\ntitle: CAS\ndate: 2021-08-11 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是CAS \n    CAS compare and swap的缩写，中文翻译成 比较并替换\n    \n    CAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n    如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n    无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\n    CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n\n## CAS的目的\n    利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n    其他院子操作都是利用类似的特性完成的。\n    而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n\n## CAS 存在的问题\n    CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n* ABA问题  \n    因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。  \n    但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。  \n    ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一  \n    那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。\n\n* 循环时间长开销大  \n    自选CAS如果长时间不成功，会给CPU带来很大的开销。\n    如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。  \n    pause 指令的作用\n    * 它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零\n    * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   \n\n* 只能保证一个共享变量的原子操作  \n    当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。  \n    解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作\n``` java\npublic class HelloWorld{\n    private int data = 0;\n\n    public synchronized void increment(){\n        data++;\n    }\n\n    // 多个线程同时调用方法：increment（）;\n}\n```\n\n## atmoic原子类及其底层原理\n    对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n    他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n```java\npublic class HelloWorld {\n    \n    private AtomicInteger data = new AtomicInteger(0);\n\n    //多个线程并发的执行：data.incrementAndGet()\n}\n```\n多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。\n\n    Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-1.jpg)\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-2.png)\n\n    上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n    先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n\n## java8 如何对CAS 进行了优化\n    atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n    如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n    于是JAVA 8 推出了一个新的类 LongAdder.  \n    LongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\n    LongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n    竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n    这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\n    LongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n    但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \n    LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \n    LongAdder 在保证高效的同时，也需要消耗更多的空间\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/LongAdder-1.jpg) \n\n```java\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.LongAdder;\n\n/**\n * <pre>\n * 程序目的：和 AtomicLong 进行性能对比\n * </pre>\n * created at 2020/8/11 06:25\n * @author lerry\n */\npublic class LongAdderDemo {\n /**\n  * 线程池内线程数\n  */\n final static int POOL_SIZE = 1000;\n\n public static void main(String[] args) throws InterruptedException {\n    long start = System.currentTimeMillis();\n\n    LongAdder counter = new LongAdder();\n    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);\n\n    ArrayList<Future> futures = new ArrayList<>(POOL_SIZE);\n    for (int i = 0; i < POOL_SIZE * 100; i++) {\n    futures.add(service.submit(new LongAdderDemo.Task(counter)));\n    }\n\n    // 等待所有线程执行完\n    for (Future future : futures) {\n    try {\n        future.get();\n    }\n    catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n    }\n\n    NumberFormat numberFormat = NumberFormat.getInstance();\n    System.out.printf(\"统计结果为：[%s]\\n\", numberFormat.format(counter.sum()));\n    System.out.printf(\"耗时：[%d]毫秒\", (System.currentTimeMillis() - start));\n    // 关闭线程池\n    service.shutdown();\n }\n\n /**\n  * 有一个 LongAdder 成员变量，每次执行N次+1操作\n  */\n static class Task implements Runnable {\n\n  private final LongAdder counter;\n\n  public Task(LongAdder counter) {\n   this.counter = counter;\n  }\n\n  /**\n   * 每个线程执行N次+1操作\n   */\n  @Override\n  public void run() {\n    for (int i = 0; i < 100; i++) {\n        counter.increment();\n    }\n  }// end run\n }// end class\n}\n```\n\n[来源参考] https://shishan100.gitee.io/docs/#/./docs/page/page2\n[微信参考链接] https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\n[LongAdder实践](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect)\n\n","slug":"lh/并发编程/CAS","published":1,"updated":"2021-09-01T02:45:39.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86c0012cst7e2e7fz49","content":"<h1 id=\"什么是CAS\"><a href=\"#什么是CAS\" class=\"headerlink\" title=\"什么是CAS\"></a>什么是CAS</h1><pre><code>CAS compare and swap的缩写，中文翻译成 比较并替换\n\nCAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\nCAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n</code></pre>\n<h2 id=\"CAS的目的\"><a href=\"#CAS的目的\" class=\"headerlink\" title=\"CAS的目的\"></a>CAS的目的</h2><pre><code>利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n其他院子操作都是利用类似的特性完成的。\n而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n</code></pre>\n<h2 id=\"CAS-存在的问题\"><a href=\"#CAS-存在的问题\" class=\"headerlink\" title=\"CAS 存在的问题\"></a>CAS 存在的问题</h2><pre><code>CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n</code></pre>\n<ul>\n<li><p>ABA问题<br>  因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。<br>  但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。<br>  ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一<br>  那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。</p>\n</li>\n<li><p>循环时间长开销大<br>  自选CAS如果长时间不成功，会给CPU带来很大的开销。<br>  如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。<br>  pause 指令的作用</p>\n<ul>\n<li>它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   </li>\n</ul>\n</li>\n<li><p>只能保证一个共享变量的原子操作<br>  当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。<br>  解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        data++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个线程同时调用方法：increment（）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"atmoic原子类及其底层原理\"><a href=\"#atmoic原子类及其底层原理\" class=\"headerlink\" title=\"atmoic原子类及其底层原理\"></a>atmoic原子类及其底层原理</h2><pre><code>对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger data = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//多个线程并发的执行：data.incrementAndGet()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。</p>\n<pre><code>Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-1.jpg\"></p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-2.png\"></p>\n<pre><code>上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n</code></pre>\n<h2 id=\"java8-如何对CAS-进行了优化\"><a href=\"#java8-如何对CAS-进行了优化\" class=\"headerlink\" title=\"java8 如何对CAS 进行了优化\"></a>java8 如何对CAS 进行了优化</h2><pre><code>atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n于是JAVA 8 推出了一个新的类 LongAdder.  \nLongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\nLongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\nLongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \nLongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \nLongAdder 在保证高效的同时，也需要消耗更多的空间\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/LongAdder-1.jpg\"> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.NumberFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 程序目的：和 AtomicLong 进行性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * created at 2020/8/11 06:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lerry</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongAdderDemo</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 线程池内线程数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> POOL_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    LongAdder counter = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;Future&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(POOL_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; POOL_SIZE * <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    futures.add(service.submit(<span class=\"keyword\">new</span> LongAdderDemo.Task(counter)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有线程执行完</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Future future : futures) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        future.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NumberFormat numberFormat = NumberFormat.getInstance();</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;统计结果为：[%s]\\n&quot;</span>, numberFormat.format(counter.sum()));</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;耗时：[%d]毫秒&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class=\"line\">    <span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    service.shutdown();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 有一个 LongAdder 成员变量，每次执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LongAdder counter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(LongAdder counter)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.counter = counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 每个线程执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        counter.increment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;<span class=\"comment\">// end run</span></span><br><span class=\"line\"> &#125;<span class=\"comment\">// end class</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[来源参考] <a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page2\">https://shishan100.gitee.io/docs/#/./docs/page/page2</a><br>[微信参考链接] <a href=\"https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\">https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect\">LongAdder实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是CAS\"><a href=\"#什么是CAS\" class=\"headerlink\" title=\"什么是CAS\"></a>什么是CAS</h1><pre><code>CAS compare and swap的缩写，中文翻译成 比较并替换\n\nCAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\nCAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n</code></pre>\n<h2 id=\"CAS的目的\"><a href=\"#CAS的目的\" class=\"headerlink\" title=\"CAS的目的\"></a>CAS的目的</h2><pre><code>利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n其他院子操作都是利用类似的特性完成的。\n而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n</code></pre>\n<h2 id=\"CAS-存在的问题\"><a href=\"#CAS-存在的问题\" class=\"headerlink\" title=\"CAS 存在的问题\"></a>CAS 存在的问题</h2><pre><code>CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n</code></pre>\n<ul>\n<li><p>ABA问题<br>  因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。<br>  但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。<br>  ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一<br>  那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。</p>\n</li>\n<li><p>循环时间长开销大<br>  自选CAS如果长时间不成功，会给CPU带来很大的开销。<br>  如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。<br>  pause 指令的作用</p>\n<ul>\n<li>它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   </li>\n</ul>\n</li>\n<li><p>只能保证一个共享变量的原子操作<br>  当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。<br>  解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        data++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个线程同时调用方法：increment（）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"atmoic原子类及其底层原理\"><a href=\"#atmoic原子类及其底层原理\" class=\"headerlink\" title=\"atmoic原子类及其底层原理\"></a>atmoic原子类及其底层原理</h2><pre><code>对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger data = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//多个线程并发的执行：data.incrementAndGet()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。</p>\n<pre><code>Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-1.jpg\"></p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-2.png\"></p>\n<pre><code>上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n</code></pre>\n<h2 id=\"java8-如何对CAS-进行了优化\"><a href=\"#java8-如何对CAS-进行了优化\" class=\"headerlink\" title=\"java8 如何对CAS 进行了优化\"></a>java8 如何对CAS 进行了优化</h2><pre><code>atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n于是JAVA 8 推出了一个新的类 LongAdder.  \nLongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\nLongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\nLongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \nLongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \nLongAdder 在保证高效的同时，也需要消耗更多的空间\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/LongAdder-1.jpg\"> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.NumberFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 程序目的：和 AtomicLong 进行性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * created at 2020/8/11 06:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lerry</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongAdderDemo</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 线程池内线程数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> POOL_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    LongAdder counter = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;Future&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(POOL_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; POOL_SIZE * <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    futures.add(service.submit(<span class=\"keyword\">new</span> LongAdderDemo.Task(counter)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有线程执行完</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Future future : futures) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        future.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NumberFormat numberFormat = NumberFormat.getInstance();</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;统计结果为：[%s]\\n&quot;</span>, numberFormat.format(counter.sum()));</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;耗时：[%d]毫秒&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class=\"line\">    <span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    service.shutdown();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 有一个 LongAdder 成员变量，每次执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LongAdder counter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(LongAdder counter)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.counter = counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 每个线程执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        counter.increment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;<span class=\"comment\">// end run</span></span><br><span class=\"line\"> &#125;<span class=\"comment\">// end class</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[来源参考] <a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page2\">https://shishan100.gitee.io/docs/#/./docs/page/page2</a><br>[微信参考链接] <a href=\"https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\">https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect\">LongAdder实践</a></p>\n"},{"title":"并发编程初讲","date":"2021-08-09T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 基础概念\n\n## 什么是线程和进程\n    在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n\n* 进程：是程序的一次执行过程，系统运行程序的基本单位。\n    * 系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n\n* 线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。\n    * 多个线程共享进程的堆和方法区。\n    * 每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。\n\n## 什么是并发和并行 \n* 并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）\n\n* 并行：单位时间内，多个任务同时执行。\n\n\n## 说说线程的生命周期\n    线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n\n* 初始状态（NEW）：线程被构建，但是没有调用start方法。\n\n* 运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。\n\n* 阻塞状态(BLOCKED): 线程被锁阻塞了。\n\n* 等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。\n\n* 超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。\n\n* 终止状态（TERMIATEB）: 线程执行结束。\n\n    线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/并发状态流程图.png)\n \n    线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n    当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n    而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n    线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n\n## 线程的结束\n1. 设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。\n\n2. 使用interrupt()方法中断线程\n\n3. 使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）\n\n\n## 并发编程的三大特性\n    并发编程的三大特性只要是：原子性、可见性、有序性\n\n* 原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。\n\n* 可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。\n\n* 有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。\n\n\n## java的内存模型 JMM\n用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。\n\n    用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\n    JMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n    本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n![](https://kubpang.gitee.io/sourceFile/Java/并发/JMM-1.png)\n\n\n## JAVA 变量的读写\n我们在看Volatile关键字的时候先了解一下java变量的读写：  \n（1）lock：作用于主内存，把变量标识为线程独占状态。\n\n（2）unlock：作用于主内存，解除独占状态。\n\n（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。\n\n（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。\n\n（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。\n\n（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。\n\n（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。\n\n（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。\n\n## 重排序\n在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n\n* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n* 内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 \n\n    这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。\n\n## happens-before原则\n* 程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。\n* 锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。\n* volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。\n* 传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。\n* 线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。\n* 线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。\n* 线程终结原则：同一个线程所有的操作都优先于线程的终止检测。\n* 对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。\n\n\n## 说说 sleep() 和 wait() 的区别？\n* sleep() 和 wait() 都可以暂停线程的执行。\n* sleep() 不释放锁，wait() 释放锁。\n* sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。\n* sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。\n* sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。\n* wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 \n\n##  为什么不能直接调用 run() 方法？\n* 调用 run() 方法，会被当做普通方法去执行，不是多线程工作。\n\n* 调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作\n\n## 说说 Runnable 和 Callable 的区别？\nRunnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:\n* Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。\n* Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。\n\n    对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。\n    \n    FutureTask 表示一个异步运算的任务。\n    FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。\n    只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。\n \n## volatile 于 synchronized 区别\n    volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\n    synchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\n    volatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\n    n 不仅保证了可见性，也保证了原子性。\n    因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n    多个线程争抢n变量时，会出现阻塞情况\n\n    volatile是轻量级的，因为只能修饰变量。\n    n是重量级的，可以修饰变量、代码块、方法。\n    ","source":"_posts/lh/并发编程/并发编程初讲.md","raw":"---\ntitle: 并发编程初讲\ndate: 2021-08-10 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 基础概念\n\n## 什么是线程和进程\n    在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n\n* 进程：是程序的一次执行过程，系统运行程序的基本单位。\n    * 系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n\n* 线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。\n    * 多个线程共享进程的堆和方法区。\n    * 每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。\n\n## 什么是并发和并行 \n* 并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）\n\n* 并行：单位时间内，多个任务同时执行。\n\n\n## 说说线程的生命周期\n    线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n\n* 初始状态（NEW）：线程被构建，但是没有调用start方法。\n\n* 运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。\n\n* 阻塞状态(BLOCKED): 线程被锁阻塞了。\n\n* 等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。\n\n* 超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。\n\n* 终止状态（TERMIATEB）: 线程执行结束。\n\n    线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/并发状态流程图.png)\n \n    线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n    当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n    而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n    线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n\n## 线程的结束\n1. 设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。\n\n2. 使用interrupt()方法中断线程\n\n3. 使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）\n\n\n## 并发编程的三大特性\n    并发编程的三大特性只要是：原子性、可见性、有序性\n\n* 原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。\n\n* 可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。\n\n* 有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。\n\n\n## java的内存模型 JMM\n用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。\n\n    用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\n    JMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n    本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n![](https://kubpang.gitee.io/sourceFile/Java/并发/JMM-1.png)\n\n\n## JAVA 变量的读写\n我们在看Volatile关键字的时候先了解一下java变量的读写：  \n（1）lock：作用于主内存，把变量标识为线程独占状态。\n\n（2）unlock：作用于主内存，解除独占状态。\n\n（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。\n\n（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。\n\n（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。\n\n（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。\n\n（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。\n\n（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。\n\n## 重排序\n在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n\n* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n* 内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 \n\n    这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。\n\n## happens-before原则\n* 程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。\n* 锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。\n* volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。\n* 传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。\n* 线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。\n* 线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。\n* 线程终结原则：同一个线程所有的操作都优先于线程的终止检测。\n* 对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。\n\n\n## 说说 sleep() 和 wait() 的区别？\n* sleep() 和 wait() 都可以暂停线程的执行。\n* sleep() 不释放锁，wait() 释放锁。\n* sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。\n* sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。\n* sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。\n* wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 \n\n##  为什么不能直接调用 run() 方法？\n* 调用 run() 方法，会被当做普通方法去执行，不是多线程工作。\n\n* 调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作\n\n## 说说 Runnable 和 Callable 的区别？\nRunnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:\n* Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。\n* Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。\n\n    对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。\n    \n    FutureTask 表示一个异步运算的任务。\n    FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。\n    只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。\n \n## volatile 于 synchronized 区别\n    volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\n    synchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\n    volatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\n    n 不仅保证了可见性，也保证了原子性。\n    因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n    多个线程争抢n变量时，会出现阻塞情况\n\n    volatile是轻量级的，因为只能修饰变量。\n    n是重量级的，可以修饰变量、代码块、方法。\n    ","slug":"lh/并发编程/并发编程初讲","published":1,"updated":"2021-09-01T02:45:02.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86e0016cst77ndk71bt","content":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程\"></a>什么是线程和进程</h2><pre><code>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n</code></pre>\n<ul>\n<li><p>进程：是程序的一次执行过程，系统运行程序的基本单位。</p>\n<ul>\n<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>\n</ul>\n</li>\n<li><p>线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。</p>\n<ul>\n<li>多个线程共享进程的堆和方法区。</li>\n<li>每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是并发和并行\"><a href=\"#什么是并发和并行\" class=\"headerlink\" title=\"什么是并发和并行\"></a>什么是并发和并行</h2><ul>\n<li><p>并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）</p>\n</li>\n<li><p>并行：单位时间内，多个任务同时执行。</p>\n</li>\n</ul>\n<h2 id=\"说说线程的生命周期\"><a href=\"#说说线程的生命周期\" class=\"headerlink\" title=\"说说线程的生命周期\"></a>说说线程的生命周期</h2><pre><code>线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n</code></pre>\n<ul>\n<li><p>初始状态（NEW）：线程被构建，但是没有调用start方法。</p>\n</li>\n<li><p>运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。</p>\n</li>\n<li><p>阻塞状态(BLOCKED): 线程被锁阻塞了。</p>\n</li>\n<li><p>等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。</p>\n</li>\n<li><p>超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。</p>\n</li>\n<li><p>终止状态（TERMIATEB）: 线程执行结束。</p>\n<p>  线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。</p>\n</li>\n</ul>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<pre><code>线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n</code></pre>\n<h2 id=\"线程的结束\"><a href=\"#线程的结束\" class=\"headerlink\" title=\"线程的结束\"></a>线程的结束</h2><ol>\n<li><p>设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。</p>\n</li>\n<li><p>使用interrupt()方法中断线程</p>\n</li>\n<li><p>使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）</p>\n</li>\n</ol>\n<h2 id=\"并发编程的三大特性\"><a href=\"#并发编程的三大特性\" class=\"headerlink\" title=\"并发编程的三大特性\"></a>并发编程的三大特性</h2><pre><code>并发编程的三大特性只要是：原子性、可见性、有序性\n</code></pre>\n<ul>\n<li><p>原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。</p>\n</li>\n<li><p>可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。</p>\n</li>\n<li><p>有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。</p>\n</li>\n</ul>\n<h2 id=\"java的内存模型-JMM\"><a href=\"#java的内存模型-JMM\" class=\"headerlink\" title=\"java的内存模型 JMM\"></a>java的内存模型 JMM</h2><p>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>\n<pre><code>用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\nJMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/JMM-1.png\"></p>\n<h2 id=\"JAVA-变量的读写\"><a href=\"#JAVA-变量的读写\" class=\"headerlink\" title=\"JAVA 变量的读写\"></a>JAVA 变量的读写</h2><p>我们在看Volatile关键字的时候先了解一下java变量的读写：<br>（1）lock：作用于主内存，把变量标识为线程独占状态。</p>\n<p>（2）unlock：作用于主内存，解除独占状态。</p>\n<p>（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>\n<p>（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>\n<p>（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>\n<p>（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</p>\n<p>（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</p>\n<p>（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：</p>\n<ul>\n<li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>\n</li>\n<li><p>指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n</li>\n<li><p>内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 </p>\n<p>  这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。</p>\n</li>\n</ul>\n<h2 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h2><ul>\n<li>程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。</li>\n<li>锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。</li>\n<li>volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。</li>\n<li>传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。</li>\n<li>线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。</li>\n<li>线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。</li>\n<li>线程终结原则：同一个线程所有的操作都优先于线程的终止检测。</li>\n<li>对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。</li>\n</ul>\n<h2 id=\"说说-sleep-和-wait-的区别？\"><a href=\"#说说-sleep-和-wait-的区别？\" class=\"headerlink\" title=\"说说 sleep() 和 wait() 的区别？\"></a>说说 sleep() 和 wait() 的区别？</h2><ul>\n<li>sleep() 和 wait() 都可以暂停线程的执行。</li>\n<li>sleep() 不释放锁，wait() 释放锁。</li>\n<li>sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。</li>\n<li>sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。</li>\n<li>sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。</li>\n<li>wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 </li>\n</ul>\n<h2 id=\"为什么不能直接调用-run-方法？\"><a href=\"#为什么不能直接调用-run-方法？\" class=\"headerlink\" title=\"为什么不能直接调用 run() 方法？\"></a>为什么不能直接调用 run() 方法？</h2><ul>\n<li><p>调用 run() 方法，会被当做普通方法去执行，不是多线程工作。</p>\n</li>\n<li><p>调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作</p>\n</li>\n</ul>\n<h2 id=\"说说-Runnable-和-Callable-的区别？\"><a href=\"#说说-Runnable-和-Callable-的区别？\" class=\"headerlink\" title=\"说说 Runnable 和 Callable 的区别？\"></a>说说 Runnable 和 Callable 的区别？</h2><p>Runnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:</p>\n<ul>\n<li><p>Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。</p>\n</li>\n<li><p>Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。</p>\n<p>  对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。</p>\n<p>  FutureTask 表示一个异步运算的任务。<br>  FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。<br>  只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>\n</li>\n</ul>\n<h2 id=\"volatile-于-synchronized-区别\"><a href=\"#volatile-于-synchronized-区别\" class=\"headerlink\" title=\"volatile 于 synchronized 区别\"></a>volatile 于 synchronized 区别</h2><pre><code>volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\nsynchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\nvolatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\nn 不仅保证了可见性，也保证了原子性。\n因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n多个线程争抢n变量时，会出现阻塞情况\n\nvolatile是轻量级的，因为只能修饰变量。\nn是重量级的，可以修饰变量、代码块、方法。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程\"></a>什么是线程和进程</h2><pre><code>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n</code></pre>\n<ul>\n<li><p>进程：是程序的一次执行过程，系统运行程序的基本单位。</p>\n<ul>\n<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>\n</ul>\n</li>\n<li><p>线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。</p>\n<ul>\n<li>多个线程共享进程的堆和方法区。</li>\n<li>每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是并发和并行\"><a href=\"#什么是并发和并行\" class=\"headerlink\" title=\"什么是并发和并行\"></a>什么是并发和并行</h2><ul>\n<li><p>并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）</p>\n</li>\n<li><p>并行：单位时间内，多个任务同时执行。</p>\n</li>\n</ul>\n<h2 id=\"说说线程的生命周期\"><a href=\"#说说线程的生命周期\" class=\"headerlink\" title=\"说说线程的生命周期\"></a>说说线程的生命周期</h2><pre><code>线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n</code></pre>\n<ul>\n<li><p>初始状态（NEW）：线程被构建，但是没有调用start方法。</p>\n</li>\n<li><p>运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。</p>\n</li>\n<li><p>阻塞状态(BLOCKED): 线程被锁阻塞了。</p>\n</li>\n<li><p>等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。</p>\n</li>\n<li><p>超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。</p>\n</li>\n<li><p>终止状态（TERMIATEB）: 线程执行结束。</p>\n<p>  线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。</p>\n</li>\n</ul>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<pre><code>线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n</code></pre>\n<h2 id=\"线程的结束\"><a href=\"#线程的结束\" class=\"headerlink\" title=\"线程的结束\"></a>线程的结束</h2><ol>\n<li><p>设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。</p>\n</li>\n<li><p>使用interrupt()方法中断线程</p>\n</li>\n<li><p>使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）</p>\n</li>\n</ol>\n<h2 id=\"并发编程的三大特性\"><a href=\"#并发编程的三大特性\" class=\"headerlink\" title=\"并发编程的三大特性\"></a>并发编程的三大特性</h2><pre><code>并发编程的三大特性只要是：原子性、可见性、有序性\n</code></pre>\n<ul>\n<li><p>原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。</p>\n</li>\n<li><p>可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。</p>\n</li>\n<li><p>有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。</p>\n</li>\n</ul>\n<h2 id=\"java的内存模型-JMM\"><a href=\"#java的内存模型-JMM\" class=\"headerlink\" title=\"java的内存模型 JMM\"></a>java的内存模型 JMM</h2><p>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>\n<pre><code>用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\nJMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/JMM-1.png\"></p>\n<h2 id=\"JAVA-变量的读写\"><a href=\"#JAVA-变量的读写\" class=\"headerlink\" title=\"JAVA 变量的读写\"></a>JAVA 变量的读写</h2><p>我们在看Volatile关键字的时候先了解一下java变量的读写：<br>（1）lock：作用于主内存，把变量标识为线程独占状态。</p>\n<p>（2）unlock：作用于主内存，解除独占状态。</p>\n<p>（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>\n<p>（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>\n<p>（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>\n<p>（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</p>\n<p>（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</p>\n<p>（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：</p>\n<ul>\n<li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>\n</li>\n<li><p>指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n</li>\n<li><p>内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 </p>\n<p>  这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。</p>\n</li>\n</ul>\n<h2 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h2><ul>\n<li>程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。</li>\n<li>锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。</li>\n<li>volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。</li>\n<li>传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。</li>\n<li>线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。</li>\n<li>线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。</li>\n<li>线程终结原则：同一个线程所有的操作都优先于线程的终止检测。</li>\n<li>对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。</li>\n</ul>\n<h2 id=\"说说-sleep-和-wait-的区别？\"><a href=\"#说说-sleep-和-wait-的区别？\" class=\"headerlink\" title=\"说说 sleep() 和 wait() 的区别？\"></a>说说 sleep() 和 wait() 的区别？</h2><ul>\n<li>sleep() 和 wait() 都可以暂停线程的执行。</li>\n<li>sleep() 不释放锁，wait() 释放锁。</li>\n<li>sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。</li>\n<li>sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。</li>\n<li>sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。</li>\n<li>wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 </li>\n</ul>\n<h2 id=\"为什么不能直接调用-run-方法？\"><a href=\"#为什么不能直接调用-run-方法？\" class=\"headerlink\" title=\"为什么不能直接调用 run() 方法？\"></a>为什么不能直接调用 run() 方法？</h2><ul>\n<li><p>调用 run() 方法，会被当做普通方法去执行，不是多线程工作。</p>\n</li>\n<li><p>调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作</p>\n</li>\n</ul>\n<h2 id=\"说说-Runnable-和-Callable-的区别？\"><a href=\"#说说-Runnable-和-Callable-的区别？\" class=\"headerlink\" title=\"说说 Runnable 和 Callable 的区别？\"></a>说说 Runnable 和 Callable 的区别？</h2><p>Runnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:</p>\n<ul>\n<li><p>Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。</p>\n</li>\n<li><p>Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。</p>\n<p>  对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。</p>\n<p>  FutureTask 表示一个异步运算的任务。<br>  FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。<br>  只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>\n</li>\n</ul>\n<h2 id=\"volatile-于-synchronized-区别\"><a href=\"#volatile-于-synchronized-区别\" class=\"headerlink\" title=\"volatile 于 synchronized 区别\"></a>volatile 于 synchronized 区别</h2><pre><code>volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\nsynchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\nvolatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\nn 不仅保证了可见性，也保证了原子性。\n因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n多个线程争抢n变量时，会出现阻塞情况\n\nvolatile是轻量级的，因为只能修饰变量。\nn是重量级的，可以修饰变量、代码块、方法。\n</code></pre>\n"},{"title":"线程池","date":"2021-08-29T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 线程池作用\njava中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处\n1. 降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗\n\n2. 提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n\n3. 提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。\n\n# Executor 框架\nExecutor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。\n\n![Executor框架](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-1.png)  \n\nExecutor 结构主要包含任务、任务的执行和异步结果的计算\n1. 任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。\n    * Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。\n\n2. 任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。\n    * Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。\n\n3. 异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。\n\n在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  \n\n如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。  \n由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 \n\n# ThreadPoolExecutor\n## 核心参数\n* corePoolSize: 核心线程数。\n    * 定义了最小可以同时运行的线程数据\n* maximumPoolSize: 最大线程数\n    * 当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。\n* wordQueue: 任务队列\n    * 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。\n\n## 常见参数\n* keepAliveTime: 多余线程存活时间\n    * 当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁\n* unit: 时间单位\n    * keepAliveTime参数的时间单位\n* threadFactory: 线程工厂\n    * executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。\n* handler: 饱和策略\n![ThreadPoolExecutor饱和策略](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-2.png)  \n\n如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：\n* ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。\n* ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。\n* ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。\n* ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。\n\n阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  \n1. <font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。\n2. <font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  \n\n![线程池执行原理](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-3.png)","source":"_posts/lh/并发编程/线程池.md","raw":"---\ntitle: 线程池\ndate: 2021-08-30 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 线程池作用\njava中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处\n1. 降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗\n\n2. 提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n\n3. 提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。\n\n# Executor 框架\nExecutor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。\n\n![Executor框架](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-1.png)  \n\nExecutor 结构主要包含任务、任务的执行和异步结果的计算\n1. 任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。\n    * Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。\n\n2. 任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。\n    * Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。\n\n3. 异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。\n\n在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  \n\n如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。  \n由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 \n\n# ThreadPoolExecutor\n## 核心参数\n* corePoolSize: 核心线程数。\n    * 定义了最小可以同时运行的线程数据\n* maximumPoolSize: 最大线程数\n    * 当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。\n* wordQueue: 任务队列\n    * 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。\n\n## 常见参数\n* keepAliveTime: 多余线程存活时间\n    * 当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁\n* unit: 时间单位\n    * keepAliveTime参数的时间单位\n* threadFactory: 线程工厂\n    * executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。\n* handler: 饱和策略\n![ThreadPoolExecutor饱和策略](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-2.png)  \n\n如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：\n* ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。\n* ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。\n* ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。\n* ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。\n\n阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  \n1. <font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。\n2. <font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  \n\n![线程池执行原理](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-3.png)","slug":"lh/并发编程/线程池","published":1,"updated":"2021-09-01T02:45:13.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86e0018cst7h5k3fc94","content":"<h1 id=\"线程池作用\"><a href=\"#线程池作用\" class=\"headerlink\" title=\"线程池作用\"></a>线程池作用</h1><p>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处</p>\n<ol>\n<li><p>降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗</p>\n</li>\n<li><p>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>\n</li>\n<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</p>\n</li>\n</ol>\n<h1 id=\"Executor-框架\"><a href=\"#Executor-框架\" class=\"headerlink\" title=\"Executor 框架\"></a>Executor 框架</h1><p>Executor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-1.png\" alt=\"Executor框架\">  </p>\n<p>Executor 结构主要包含任务、任务的执行和异步结果的计算</p>\n<ol>\n<li><p>任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。</p>\n<ul>\n<li>Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。</li>\n</ul>\n</li>\n<li><p>任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。</p>\n<ul>\n<li>Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。</li>\n</ul>\n</li>\n<li><p>异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。</p>\n</li>\n</ol>\n<p>在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  </p>\n<p>如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。<br>由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 </p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li>corePoolSize: 核心线程数。<ul>\n<li>定义了最小可以同时运行的线程数据</li>\n</ul>\n</li>\n<li>maximumPoolSize: 最大线程数<ul>\n<li>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。</li>\n</ul>\n</li>\n<li>wordQueue: 任务队列<ul>\n<li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见参数\"><a href=\"#常见参数\" class=\"headerlink\" title=\"常见参数\"></a>常见参数</h2><ul>\n<li>keepAliveTime: 多余线程存活时间<ul>\n<li>当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁</li>\n</ul>\n</li>\n<li>unit: 时间单位<ul>\n<li>keepAliveTime参数的时间单位</li>\n</ul>\n</li>\n<li>threadFactory: 线程工厂<ul>\n<li>executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。</li>\n</ul>\n</li>\n<li>handler: 饱和策略<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-2.png\" alt=\"ThreadPoolExecutor饱和策略\">  </li>\n</ul>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  </p>\n<ol>\n<li><font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</li>\n<li><font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  </li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-3.png\" alt=\"线程池执行原理\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程池作用\"><a href=\"#线程池作用\" class=\"headerlink\" title=\"线程池作用\"></a>线程池作用</h1><p>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处</p>\n<ol>\n<li><p>降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗</p>\n</li>\n<li><p>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>\n</li>\n<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</p>\n</li>\n</ol>\n<h1 id=\"Executor-框架\"><a href=\"#Executor-框架\" class=\"headerlink\" title=\"Executor 框架\"></a>Executor 框架</h1><p>Executor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-1.png\" alt=\"Executor框架\">  </p>\n<p>Executor 结构主要包含任务、任务的执行和异步结果的计算</p>\n<ol>\n<li><p>任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。</p>\n<ul>\n<li>Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。</li>\n</ul>\n</li>\n<li><p>任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。</p>\n<ul>\n<li>Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。</li>\n</ul>\n</li>\n<li><p>异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。</p>\n</li>\n</ol>\n<p>在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  </p>\n<p>如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。<br>由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 </p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li>corePoolSize: 核心线程数。<ul>\n<li>定义了最小可以同时运行的线程数据</li>\n</ul>\n</li>\n<li>maximumPoolSize: 最大线程数<ul>\n<li>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。</li>\n</ul>\n</li>\n<li>wordQueue: 任务队列<ul>\n<li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见参数\"><a href=\"#常见参数\" class=\"headerlink\" title=\"常见参数\"></a>常见参数</h2><ul>\n<li>keepAliveTime: 多余线程存活时间<ul>\n<li>当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁</li>\n</ul>\n</li>\n<li>unit: 时间单位<ul>\n<li>keepAliveTime参数的时间单位</li>\n</ul>\n</li>\n<li>threadFactory: 线程工厂<ul>\n<li>executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。</li>\n</ul>\n</li>\n<li>handler: 饱和策略<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-2.png\" alt=\"ThreadPoolExecutor饱和策略\">  </li>\n</ul>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  </p>\n<ol>\n<li><font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</li>\n<li><font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  </li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-3.png\" alt=\"线程池执行原理\"></p>\n"},{"title":"volatile","date":"2021-08-09T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 为什么用volatile\n    假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n    那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n\n   ![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-1.jpg)\n\n    这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n    这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n    一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n    这就是所谓的 java 并发编程中的可见性问题:\n    多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n\n# volatile的作用及背后原理\n    要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？\n```java\npublic class HelloWorld {\n    private volatile int data = 0;\n\n    //线程1会读取和修改data变量值\n\n    //线程2会读取data变量值\n\n}\n```\n\n## volatile的作用\n    1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n    让主内存里的data的值立马变成最新的值\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-3.jpg)\n\n    2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-4.jpg)\n\n    3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-5.jpg)\n\n## volatile的特殊规则\n    read、load、use动作必须连续出现。\n    assign、store、write动作必须连续出现。\n\n\n## 内存屏障\nJVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：\n* LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。\n\n* StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。\n\n* LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。\n\n* StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。\n    * StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。\n\n\n需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-6.png)\n\n\n# 总结\n    每次读取前必须先从主内存刷新到最新的值。\n    每次写入后必须立即同步回主内存当中。\n\n    最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n    有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n    也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n    但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\n    volatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n    原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n\n\n","source":"_posts/lh/并发编程/volatile.md","raw":"---\ntitle: volatile\ndate: 2021-08-10 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 为什么用volatile\n    假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n    那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n\n   ![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-1.jpg)\n\n    这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n    这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n    一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n    这就是所谓的 java 并发编程中的可见性问题:\n    多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n\n# volatile的作用及背后原理\n    要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？\n```java\npublic class HelloWorld {\n    private volatile int data = 0;\n\n    //线程1会读取和修改data变量值\n\n    //线程2会读取data变量值\n\n}\n```\n\n## volatile的作用\n    1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n    让主内存里的data的值立马变成最新的值\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-3.jpg)\n\n    2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-4.jpg)\n\n    3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-5.jpg)\n\n## volatile的特殊规则\n    read、load、use动作必须连续出现。\n    assign、store、write动作必须连续出现。\n\n\n## 内存屏障\nJVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：\n* LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。\n\n* StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。\n\n* LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。\n\n* StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。\n    * StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。\n\n\n需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-6.png)\n\n\n# 总结\n    每次读取前必须先从主内存刷新到最新的值。\n    每次写入后必须立即同步回主内存当中。\n\n    最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n    有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n    也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n    但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\n    volatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n    原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n\n\n","slug":"lh/并发编程/volatile","published":1,"updated":"2021-09-02T07:08:46.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86f001ccst75mh9fsji","content":"<h1 id=\"为什么用volatile\"><a href=\"#为什么用volatile\" class=\"headerlink\" title=\"为什么用volatile\"></a>为什么用volatile</h1><pre><code>假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n</code></pre>\n<p>   <img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-1.jpg\"></p>\n<pre><code>这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n这就是所谓的 java 并发编程中的可见性问题:\n多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n</code></pre>\n<h1 id=\"volatile的作用及背后原理\"><a href=\"#volatile的作用及背后原理\" class=\"headerlink\" title=\"volatile的作用及背后原理\"></a>volatile的作用及背后原理</h1><pre><code>要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n</code></pre>\n<p>比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程1会读取和修改data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程2会读取data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"volatile的作用\"><a href=\"#volatile的作用\" class=\"headerlink\" title=\"volatile的作用\"></a>volatile的作用</h2><pre><code>1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n让主内存里的data的值立马变成最新的值\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-3.jpg\"></p>\n<pre><code>2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-4.jpg\"></p>\n<pre><code>3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-5.jpg\"></p>\n<h2 id=\"volatile的特殊规则\"><a href=\"#volatile的特殊规则\" class=\"headerlink\" title=\"volatile的特殊规则\"></a>volatile的特殊规则</h2><pre><code>read、load、use动作必须连续出现。\nassign、store、write动作必须连续出现。\n</code></pre>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>JVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：</p>\n<ul>\n<li><p>LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。</p>\n</li>\n<li><p>LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。</p>\n<ul>\n<li>StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-6.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>每次读取前必须先从主内存刷新到最新的值。\n每次写入后必须立即同步回主内存当中。\n\n最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\nvolatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么用volatile\"><a href=\"#为什么用volatile\" class=\"headerlink\" title=\"为什么用volatile\"></a>为什么用volatile</h1><pre><code>假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n</code></pre>\n<p>   <img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-1.jpg\"></p>\n<pre><code>这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n这就是所谓的 java 并发编程中的可见性问题:\n多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n</code></pre>\n<h1 id=\"volatile的作用及背后原理\"><a href=\"#volatile的作用及背后原理\" class=\"headerlink\" title=\"volatile的作用及背后原理\"></a>volatile的作用及背后原理</h1><pre><code>要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n</code></pre>\n<p>比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程1会读取和修改data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程2会读取data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"volatile的作用\"><a href=\"#volatile的作用\" class=\"headerlink\" title=\"volatile的作用\"></a>volatile的作用</h2><pre><code>1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n让主内存里的data的值立马变成最新的值\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-3.jpg\"></p>\n<pre><code>2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-4.jpg\"></p>\n<pre><code>3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-5.jpg\"></p>\n<h2 id=\"volatile的特殊规则\"><a href=\"#volatile的特殊规则\" class=\"headerlink\" title=\"volatile的特殊规则\"></a>volatile的特殊规则</h2><pre><code>read、load、use动作必须连续出现。\nassign、store、write动作必须连续出现。\n</code></pre>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>JVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：</p>\n<ul>\n<li><p>LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。</p>\n</li>\n<li><p>LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。</p>\n<ul>\n<li>StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-6.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>每次读取前必须先从主内存刷新到最新的值。\n每次写入后必须立即同步回主内存当中。\n\n最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\nvolatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n</code></pre>\n"},{"title":"锁相关","date":"2021-08-29T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是锁\n在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n\n# 锁的三个概念\n1. <font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。\n\n2. <font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁\n\n3. <font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。  \n死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。  \n![死锁图解](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-4.jpg)\n\n# Monitor 原理（核心） \njava中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。\n\n在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:\n\n![Monitor的数据结构](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-2.png)  \n* 进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  \n    * 如果对象未被锁住，则成为拥有者。\n    * 否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font>\n* 等待区（Wait Set）: 存放等待状态的线程。  \n    * 表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。\n* 拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。\n\n当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。\n\n# MarkWord 原理（核心） \n注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。\n\n前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：\n* MarkWord: 保存对象当前锁机制的记录信息。\n* klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。\n* 数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。\n\n当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：  \n![MarkWord 32位JVM中存储的内容](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-3.png)  \n\n其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。\n\n# 锁的种类\n![java 主流锁](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-5.png)\n\n1. <font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  \n* 偏向锁  \n自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font>\n\n* 轻量级锁  \n如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font>\n\n* 重量级锁\n重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font>\n\n\n* 锁的升级：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\n\n2. <font color=#0099FF>可重入锁/非可重入锁</font>  \n* 可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。\n    * 可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类\n* 不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  \n\n3. <font color=#0099FF>共享锁/独占锁</font>  \n* 共享锁: 一个对象的锁，能被多个线程同时获取。\n    * 读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有\n* 独占锁: 一个对象的锁，同一时间只能被一个线程使用。\n    * 读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。\n\n4. <font color=#0099FF>公平锁/非公平锁</font> \n* 公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。  \n[AQS中线程2进入等待队列 则提现了公平锁](https://blog.quanlinmen.cn/2021/08/27/lh/并发编程/AQS/)\n![线程2的公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/公平锁.jpg)\n\n* 非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。\n![线程2的不公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/非公平锁.jpg)\n\n* 如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略\n```java\n//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略\nReentrantLock lock = new ReentrantLock(true);\n```\n5. <font color=#0099FF>悲观锁/乐观锁</font>\n* 悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。\n\n* 乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。\n\n6. <font color=#0099FF>自旋锁/非自旋锁</font>\n* 自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。\n\n* 非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。\n\n7. <font color=#0099FF>可中断锁/不可中断锁</font>\n* 可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理\n\n* 不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开\n\n\n\n","source":"_posts/lh/并发编程/锁相关.md","raw":"---\ntitle: 锁相关\ndate: 2021-08-30 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是锁\n在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n\n# 锁的三个概念\n1. <font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。\n\n2. <font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁\n\n3. <font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。  \n死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。  \n![死锁图解](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-4.jpg)\n\n# Monitor 原理（核心） \njava中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。\n\n在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:\n\n![Monitor的数据结构](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-2.png)  \n* 进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  \n    * 如果对象未被锁住，则成为拥有者。\n    * 否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font>\n* 等待区（Wait Set）: 存放等待状态的线程。  \n    * 表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。\n* 拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。\n\n当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。\n\n# MarkWord 原理（核心） \n注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。\n\n前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：\n* MarkWord: 保存对象当前锁机制的记录信息。\n* klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。\n* 数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。\n\n当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：  \n![MarkWord 32位JVM中存储的内容](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-3.png)  \n\n其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。\n\n# 锁的种类\n![java 主流锁](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-5.png)\n\n1. <font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  \n* 偏向锁  \n自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font>\n\n* 轻量级锁  \n如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font>\n\n* 重量级锁\n重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font>\n\n\n* 锁的升级：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\n\n2. <font color=#0099FF>可重入锁/非可重入锁</font>  \n* 可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。\n    * 可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类\n* 不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  \n\n3. <font color=#0099FF>共享锁/独占锁</font>  \n* 共享锁: 一个对象的锁，能被多个线程同时获取。\n    * 读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有\n* 独占锁: 一个对象的锁，同一时间只能被一个线程使用。\n    * 读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。\n\n4. <font color=#0099FF>公平锁/非公平锁</font> \n* 公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。  \n[AQS中线程2进入等待队列 则提现了公平锁](https://blog.quanlinmen.cn/2021/08/27/lh/并发编程/AQS/)\n![线程2的公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/公平锁.jpg)\n\n* 非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。\n![线程2的不公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/非公平锁.jpg)\n\n* 如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略\n```java\n//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略\nReentrantLock lock = new ReentrantLock(true);\n```\n5. <font color=#0099FF>悲观锁/乐观锁</font>\n* 悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。\n\n* 乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。\n\n6. <font color=#0099FF>自旋锁/非自旋锁</font>\n* 自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。\n\n* 非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。\n\n7. <font color=#0099FF>可中断锁/不可中断锁</font>\n* 可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理\n\n* 不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开\n\n\n\n","slug":"lh/并发编程/锁相关","published":1,"updated":"2021-09-01T02:44:49.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86g001ecst7basi2e9u","content":"<h1 id=\"什么是锁\"><a href=\"#什么是锁\" class=\"headerlink\" title=\"什么是锁\"></a>什么是锁</h1><p>在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。</p>\n<h1 id=\"锁的三个概念\"><a href=\"#锁的三个概念\" class=\"headerlink\" title=\"锁的三个概念\"></a>锁的三个概念</h1><ol>\n<li><p><font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。</p>\n</li>\n<li><p><font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁</p>\n</li>\n<li><p><font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。<br>死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-4.jpg\" alt=\"死锁图解\"></p>\n</li>\n</ol>\n<h1 id=\"Monitor-原理（核心）\"><a href=\"#Monitor-原理（核心）\" class=\"headerlink\" title=\"Monitor 原理（核心）\"></a>Monitor 原理（核心）</h1><p>java中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>\n<p>在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-2.png\" alt=\"Monitor的数据结构\">  </p>\n<ul>\n<li>进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  <ul>\n<li>如果对象未被锁住，则成为拥有者。</li>\n<li>否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font></li>\n</ul>\n</li>\n<li>等待区（Wait Set）: 存放等待状态的线程。  <ul>\n<li>表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。</li>\n</ul>\n</li>\n<li>拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。</li>\n</ul>\n<p>当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。</p>\n<h1 id=\"MarkWord-原理（核心）\"><a href=\"#MarkWord-原理（核心）\" class=\"headerlink\" title=\"MarkWord 原理（核心）\"></a>MarkWord 原理（核心）</h1><p>注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。</p>\n<p>前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：</p>\n<ul>\n<li>MarkWord: 保存对象当前锁机制的记录信息。</li>\n<li>klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。</li>\n<li>数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。</li>\n</ul>\n<p>当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-3.png\" alt=\"MarkWord 32位JVM中存储的内容\">  </p>\n<p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。</p>\n<h1 id=\"锁的种类\"><a href=\"#锁的种类\" class=\"headerlink\" title=\"锁的种类\"></a>锁的种类</h1><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-5.png\" alt=\"java 主流锁\"></p>\n<ol>\n<li><font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  </li>\n</ol>\n<ul>\n<li><p>偏向锁<br>自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font></p>\n</li>\n<li><p>轻量级锁<br>如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font></p>\n</li>\n<li><p>重量级锁<br>重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font></p>\n</li>\n</ul>\n<ul>\n<li>锁的升级：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li>\n</ul>\n<ol start=\"2\">\n<li><font color=#0099FF>可重入锁/非可重入锁</font>  </li>\n</ol>\n<ul>\n<li>可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。<ul>\n<li>可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类</li>\n</ul>\n</li>\n<li>不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  </li>\n</ul>\n<ol start=\"3\">\n<li><font color=#0099FF>共享锁/独占锁</font>  </li>\n</ol>\n<ul>\n<li>共享锁: 一个对象的锁，能被多个线程同时获取。<ul>\n<li>读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有</li>\n</ul>\n</li>\n<li>独占锁: 一个对象的锁，同一时间只能被一个线程使用。<ul>\n<li>读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><font color=#0099FF>公平锁/非公平锁</font> </li>\n</ol>\n<ul>\n<li><p>公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。<br><a href=\"https://blog.quanlinmen.cn/2021/08/27/lh/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/\">AQS中线程2进入等待队列 则提现了公平锁</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的公平锁\"></p>\n</li>\n<li><p>非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的不公平锁\"></p>\n</li>\n<li><p>如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"5\">\n<li><font color=#0099FF>悲观锁/乐观锁</font></li>\n</ol>\n<ul>\n<li><p>悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。</p>\n</li>\n<li><p>乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><font color=#0099FF>自旋锁/非自旋锁</font></li>\n</ol>\n<ul>\n<li><p>自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。</p>\n</li>\n<li><p>非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><font color=#0099FF>可中断锁/不可中断锁</font></li>\n</ol>\n<ul>\n<li><p>可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理</p>\n</li>\n<li><p>不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是锁\"><a href=\"#什么是锁\" class=\"headerlink\" title=\"什么是锁\"></a>什么是锁</h1><p>在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。</p>\n<h1 id=\"锁的三个概念\"><a href=\"#锁的三个概念\" class=\"headerlink\" title=\"锁的三个概念\"></a>锁的三个概念</h1><ol>\n<li><p><font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。</p>\n</li>\n<li><p><font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁</p>\n</li>\n<li><p><font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。<br>死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-4.jpg\" alt=\"死锁图解\"></p>\n</li>\n</ol>\n<h1 id=\"Monitor-原理（核心）\"><a href=\"#Monitor-原理（核心）\" class=\"headerlink\" title=\"Monitor 原理（核心）\"></a>Monitor 原理（核心）</h1><p>java中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>\n<p>在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-2.png\" alt=\"Monitor的数据结构\">  </p>\n<ul>\n<li>进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  <ul>\n<li>如果对象未被锁住，则成为拥有者。</li>\n<li>否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font></li>\n</ul>\n</li>\n<li>等待区（Wait Set）: 存放等待状态的线程。  <ul>\n<li>表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。</li>\n</ul>\n</li>\n<li>拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。</li>\n</ul>\n<p>当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。</p>\n<h1 id=\"MarkWord-原理（核心）\"><a href=\"#MarkWord-原理（核心）\" class=\"headerlink\" title=\"MarkWord 原理（核心）\"></a>MarkWord 原理（核心）</h1><p>注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。</p>\n<p>前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：</p>\n<ul>\n<li>MarkWord: 保存对象当前锁机制的记录信息。</li>\n<li>klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。</li>\n<li>数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。</li>\n</ul>\n<p>当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-3.png\" alt=\"MarkWord 32位JVM中存储的内容\">  </p>\n<p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。</p>\n<h1 id=\"锁的种类\"><a href=\"#锁的种类\" class=\"headerlink\" title=\"锁的种类\"></a>锁的种类</h1><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-5.png\" alt=\"java 主流锁\"></p>\n<ol>\n<li><font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  </li>\n</ol>\n<ul>\n<li><p>偏向锁<br>自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font></p>\n</li>\n<li><p>轻量级锁<br>如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font></p>\n</li>\n<li><p>重量级锁<br>重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font></p>\n</li>\n</ul>\n<ul>\n<li>锁的升级：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li>\n</ul>\n<ol start=\"2\">\n<li><font color=#0099FF>可重入锁/非可重入锁</font>  </li>\n</ol>\n<ul>\n<li>可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。<ul>\n<li>可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类</li>\n</ul>\n</li>\n<li>不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  </li>\n</ul>\n<ol start=\"3\">\n<li><font color=#0099FF>共享锁/独占锁</font>  </li>\n</ol>\n<ul>\n<li>共享锁: 一个对象的锁，能被多个线程同时获取。<ul>\n<li>读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有</li>\n</ul>\n</li>\n<li>独占锁: 一个对象的锁，同一时间只能被一个线程使用。<ul>\n<li>读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><font color=#0099FF>公平锁/非公平锁</font> </li>\n</ol>\n<ul>\n<li><p>公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。<br><a href=\"https://blog.quanlinmen.cn/2021/08/27/lh/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/\">AQS中线程2进入等待队列 则提现了公平锁</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的公平锁\"></p>\n</li>\n<li><p>非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的不公平锁\"></p>\n</li>\n<li><p>如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"5\">\n<li><font color=#0099FF>悲观锁/乐观锁</font></li>\n</ol>\n<ul>\n<li><p>悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。</p>\n</li>\n<li><p>乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><font color=#0099FF>自旋锁/非自旋锁</font></li>\n</ol>\n<ul>\n<li><p>自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。</p>\n</li>\n<li><p>非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><font color=#0099FF>可中断锁/不可中断锁</font></li>\n</ol>\n<ul>\n<li><p>可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理</p>\n</li>\n<li><p>不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开</p>\n</li>\n</ul>\n"},{"title":"Hexo常用命令.md","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/oyr/Hexo/Hexo常用命令.md","raw":"---\ntitle: Hexo常用命令.md\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: Hexo\ncategories: ory-Hexo\n---\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"oyr/Hexo/Hexo常用命令","published":1,"updated":"2021-10-26T10:30:26.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86g001gcst740670ypo","content":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"Feign","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 简介\n\nFeign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。  \nFeign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。  \nFeign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。\n\n## 为什么选择Feign?\n\n你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。  \n你也可以直接使用 Apache HttpClient 来实现。  \n但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。\n\n## Feign工作机制\n\nFeign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。  \n然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。\n\n## 版本兼容性\n\nFeign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。\n对于需要兼容 JDK 6 的用户，请使用 Feign 9.x\n\n## 功能概述\n\n这是一张包含 feign 提供的当前关键功能的地图：  \n![feign功能概述](https://rong0624.gitee.io/images/Feign/)\n\n# Feign使用简介\n\n## ","source":"_posts/oyr/Feign/Feign.md","raw":"---\ntitle: Feign\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-HTTP 客户端\ntags: Feign\n---\n\n# 简介\n\nFeign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。  \nFeign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。  \nFeign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。\n\n## 为什么选择Feign?\n\n你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。  \n你也可以直接使用 Apache HttpClient 来实现。  \n但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。\n\n## Feign工作机制\n\nFeign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。  \n然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。\n\n## 版本兼容性\n\nFeign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。\n对于需要兼容 JDK 6 的用户，请使用 Feign 9.x\n\n## 功能概述\n\n这是一张包含 feign 提供的当前关键功能的地图：  \n![feign功能概述](https://rong0624.gitee.io/images/Feign/)\n\n# Feign使用简介\n\n## ","slug":"oyr/Feign/Feign","published":1,"updated":"2021-10-26T10:28:31.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86h001kcst7dosj8z1p","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。<br>Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。<br>Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。</p>\n<h2 id=\"为什么选择Feign\"><a href=\"#为什么选择Feign\" class=\"headerlink\" title=\"为什么选择Feign?\"></a>为什么选择Feign?</h2><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。<br>你也可以直接使用 Apache HttpClient 来实现。<br>但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p>\n<h2 id=\"Feign工作机制\"><a href=\"#Feign工作机制\" class=\"headerlink\" title=\"Feign工作机制\"></a>Feign工作机制</h2><p>Feign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。<br>然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p>\n<h2 id=\"版本兼容性\"><a href=\"#版本兼容性\" class=\"headerlink\" title=\"版本兼容性\"></a>版本兼容性</h2><p>Feign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。<br>对于需要兼容 JDK 6 的用户，请使用 Feign 9.x</p>\n<h2 id=\"功能概述\"><a href=\"#功能概述\" class=\"headerlink\" title=\"功能概述\"></a>功能概述</h2><p>这是一张包含 feign 提供的当前关键功能的地图：<br><img src=\"https://rong0624.gitee.io/images/Feign/\" alt=\"feign功能概述\"></p>\n<h1 id=\"Feign使用简介\"><a href=\"#Feign使用简介\" class=\"headerlink\" title=\"Feign使用简介\"></a>Feign使用简介</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。<br>Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。<br>Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。</p>\n<h2 id=\"为什么选择Feign\"><a href=\"#为什么选择Feign\" class=\"headerlink\" title=\"为什么选择Feign?\"></a>为什么选择Feign?</h2><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。<br>你也可以直接使用 Apache HttpClient 来实现。<br>但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p>\n<h2 id=\"Feign工作机制\"><a href=\"#Feign工作机制\" class=\"headerlink\" title=\"Feign工作机制\"></a>Feign工作机制</h2><p>Feign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。<br>然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p>\n<h2 id=\"版本兼容性\"><a href=\"#版本兼容性\" class=\"headerlink\" title=\"版本兼容性\"></a>版本兼容性</h2><p>Feign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。<br>对于需要兼容 JDK 6 的用户，请使用 Feign 9.x</p>\n<h2 id=\"功能概述\"><a href=\"#功能概述\" class=\"headerlink\" title=\"功能概述\"></a>功能概述</h2><p>这是一张包含 feign 提供的当前关键功能的地图：<br><img src=\"https://rong0624.gitee.io/images/Feign/\" alt=\"feign功能概述\"></p>\n<h1 id=\"Feign使用简介\"><a href=\"#Feign使用简介\" class=\"headerlink\" title=\"Feign使用简介\"></a>Feign使用简介</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"Elastic-Job","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Job/Elastic-Job.md","raw":"---\ntitle: Elastic-Job\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Elastic-Job\ntags: \n    - java\n---","slug":"oyr/Job/Elastic-Job","published":1,"updated":"2021-10-27T02:53:21.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86h001lcst799x7axeu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java8新特性","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Java8新特性简介\n\n1）速度更快  \n2）代码更少（增加了新的语法Lambda表达式）  \n3）强大的Stream API  \n4）便于并行  \n5）最大化减少空指针异常 Optional\n\n**其中 Lambda 表达式与 Stream API 最为核心的。**\n\n<!-- more -->\n\n# Lambda表达式\n\n## 什么是Lambda 表达式\n\nLambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。  \nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。  \n使用 Lambda 表达式可以使代码变的更加简洁紧凑。\n\n## Lambda 表达式\n\nLambda 表达式的基础语法：  \nJava8中引入了一个新操作符：“->”该操作符被称为剪头操作符或 Lambda 操作符。\n\n箭头操作符将 Lambda 表达式拆分成两部分：  \n左侧：指定了 Lambda 表达式需要的所有参数。  \n右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。  \n列如：(parameters) -> expression 或 (parameters) ->{ statements; }\n\n特征：  \n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。  \n可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。  \n可选的大括号：如果主体包含了一个语句，就不需要使用大括号。  \n可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n上联：左右遇一括号省  \n下联：左侧推断类型省  \n横批：能省则省\n\n## 语法\n\n1）语法格式一：无参，无返回值\n```java\nRunnable runnable = () -> System.out.println(\"hello lambda!!!\");\n```\n\n2）语法格式二：有一个参数，并且无返回值\n```java\nConsumer<String> consumer = (x) -> System.out.println(x);\n```\n\n3）语法格式三：若只有一个参数，小括号可以省略不写\n```java\nConsumer<String> consumer = x -> System.out.println(x);\n```\n\n4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"开始比较\");\n    return Integer.compare(x, y);\n};\n```\n\n5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n\n（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’\n```java\nComparator<Integer> comparator = (Integer x, Integer y) -> Integer.compare(x, y);\n```\n\n## Lambda表达式需要“函数式接口”的支持\n\n详情看：函数式接口\n\n# 函数式接口\n\n## 什么是函数式接口？\n\n函数式接口：  \n接口中只有一个抽象方法的接口，称为函数式接口。  \n可以使用注解 @FunctionalInterface 修饰。\n\n```java\n@FunctionalInterface    // 表示这是函数式接口\npublic interface MyFun {\n\n    String getValue(String str);\n\n    String test();多一个方法就报错\n\n}\n```\n\n## Java8 内置的四大核心函数式接口\n\n1）Consumer<T>：消费型接口  \nVoid accept(T t)\n\n2）Supplier<T>：供给型接口  \nT get();\n\n3）Function<T, R>：函数型接口  \nR apply(T t);\n\n4）Predicate<T>：断言型接口  \nBoolean test(T t);\n\n## 其他接口\n\n![其他函数式接口](https://rong0624.gitee.io/images/Java/JDK/其他函数式接口.png)\n\n# 方法引用与构造函数引用\n\n## 方法引用\n\n方法引用：  \n若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”  \n（可以理解为方法引用是Lambda表达式的另外一种表现方式）  \n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n\n### 语法\n\n方法引用三种语法格式：  \n```\n第一种：实例对象::实例方法名  \n\n第二种：类::静态方法名  \n\n第三种：类::实例方法名\n```\n\n注意：  \n（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。  \n（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。\n\n### 案例\n\n```java\n// 方法引用：对象::方法名\npublic void test1() {\n    Consumer<String> con1 = x -> System.out.println(x);\n    Consumer<String> con2 = System.out::print;\n\n    User user = new User();\n    Supplier<String> sup1 = () -> user.getName();\n    Supplier<String> sup2 = user::getName;\n}\n\n// 方法引用：类名::静态方法名\npublic void test2() {\n    Comparator<Integer> com1 = (x, y) -> Integer.compare(x, y);\n    Comparator<Integer> com2 = Integer::compare;\n}\n\n// 方法引用：类名：实例方法名\npublic void test3() {\n    BiPredicate<String, String> bp1 = (x, y) -> x.equals(y);\n    BiPredicate<String, String> bp2 = String::equals;\n}\n```\n\n## 构造器引用\n\n### 语法\n\n语法格式：Class :: method\n\n注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。\n\n### 案例\n\n```java\n// 构造器引用：类名::new\npublic void test4() {\n    // 对应函数式接口的抽象方法，当前调用无参构造\n    Supplier<User> su1 = () -> new User();\n    Supplier<User> su2 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器\n    Function<Integer, User> fun1 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器\n    BiFunction<String, Integer, User> fun2 = User::new;\n}\n```\n\n# Stream API\n\n## 了解Stream API\n\nJava8中有两大最为重要的改变：   \n第一个是Lambda表达式；  \n第二个则是Stream API（java.util.stream.*）；  \n\nStream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。  \n使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。\n\n## 什么是Stream\n\n流（Stream）到底是什么呢？  \n是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。  \n“集合讲的是数据，流讲的是计算！！！”\n\n注意：  \n1）Stream 自己不会存储元素  \n2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream  \n3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）\n\n## Stream的三个操作步骤\n\n1）创建Stream  \n一个数据源（如：集合，数组），获取一个流\n\n2）中间操作  \n一个中间操作链，对数据源的数据进行处理（过滤，映射）\n\n3）终止操作（终端操作，返回结果）  \n一个终止操作，执行中间操作链，并且产生结果\n\n流程图：  \n![Stream操作流程图](https://rong0624.gitee.io/images/Java/JDK/Stream操作流程图.png)\n\n## 创建Stream\n\n### 集合创建Stream\n\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：  \ndefault Stream<E> stream() : 返回一个顺序流  \ndefault Stream<E> parallelStream() : 返回一个并行流\n\n案例：\n```java\n@Test\npublic void test1() {\n    // List Set 继承至 Collection\n    all.stream().forEach(System.out::println);\n    all.parallelStream().forEach(System.out::println);\n    map.values().stream().forEach(System.out::println);\n}\n```\n\n### 数组创建Stream\n\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流：  \nstatic <T> Stream<T> stream(T[] array): 返回一个流。\n\n重载形式，能够处理对应基本类型的数组： \npublic static IntStream stream(int[] array) \npublic static LongStream stream(long[] array)\npublic static DoubleStream stream(double[] array)\n\n案例：\n```java\n@Test\npublic void test2() {\n    int[] intArr = {1, 2, 3, 4};\n    String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n    Arrays.stream(intArr).forEach(System.out::println);\n    Arrays.stream(strArr).forEach(System.out::println);\n}\n```\n\n### 值创建Stream\n\n可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：  \npublic static<T> Stream<T> of(T... values) : 返回一个流\n\n案例：\n```java\npublic void test3() {\n    Stream.of(\"a\", \"b\", \"c\", \"d\").forEach(System.out::println);\n    Stream.of(\"a\", \"b\", \"c\", \"d\").parallel().forEach(System.out::println);\n    Stream.of(new User(50, \"张三\"),\n            new User(60, \"李四\"),\n            new User(11, \"王五\")).forEach(System.out::println);\n}\n```\n\n### 函数创建Stream（无限流）\n\n可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 \n迭代：  \npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);\n\n生成：  \npublic static<T> Stream<T> generate(Supplier<T> s);\n\n## Stream的中间操作\n\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!  \n而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。\n\n### 筛选与切片\n\nfilter(Predicate p)：接收Lambda，从Stream流中排除某些元素。\n\ndistinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。\n\nlimit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。\n\nskip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。\n\n案例：\n```java\n@Test\npublic void test1() {\n    all.stream().filter(user -> user.getAge() > 10).forEach(System.out::println);\n    all.stream().distinct().forEach(System.out::println);\n    all.stream().limit(10).forEach(System.out::println);\n    all.stream().skip(10).forEach(System.out::println);\n    all.stream().distinct()\n            .filter(user -> user.getAge() > 10)\n            .limit(10)\n            .skip(5)\n            .forEach(System.out::println);\n}\n```\n\n### 映射\n\nmap(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nflatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。\n\n```java\npublic void test2() {\n    all.stream().map(user -> user.getName())\n                .forEach(System.out::println);\n    all.stream().flatMap(user -> Stream.of(user.getName()))\n            .forEach(System.out::println);\n}\n```\n\n### 排序\n\nsorted()：自然排序，使用Comparable默认排序。\n\nsorted(Comparator comparator)：定制排序，使用Comparator。\n\n```java\npublic void test3() {\n    List<String> strings = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"zzz\");\n    strings.stream()\n            .sorted()\n            .forEach(System.out::println);\n\n    all.stream().sorted((x, y) -> {\n        if (x.getAge().equals(y.getAge())) {\n            return x.getName().compareTo(y.getName());\n        }\n        return x.getAge().compareTo(y.getAge());\n    }).forEach(System.out::println);\n}\n```\n\n## Stream的终止操作\n\n### 查找与匹配\n\nFind查找：  \nfindFirst() ：返回第一个元素   \nfindAny() ：返回当前流中的任意元素  \ncount() ：返回流中元素总个数  \nmax(Comparator c) ：返回流中最大值  \nmin(Comparator c) ：返回流中最小值  \n\nMatch匹配：  \nallMatch(Predicate p) ：检查是否匹配所有元素   \nanyMatch(Predicate p) ：检查是否至少匹配一个元素   \nnoneMatch(Predicate p) ：检查是否没有匹配所有元素\n\nFinal 查找案例：\n```java\n@Test\npublic void test2() {\n    Optional<User> firstOptional = all.stream().findFirst();\n    Optional<User> anyOptional = all.stream().findAny();\n    long count = all.stream().count();\n    Optional<User> maxOptional = all.stream().max(Comparator.comparing(User::getAge));\n    Optional<Integer> minOptional = all.stream().map(User::getAge).min(Integer::compareTo);\n    System.out.println(firstOptional.get());\n    System.out.println(anyOptional.get());\n    System.out.println(count);\n    System.out.println(maxOptional.get());\n    System.out.println(minOptional.get());\n}\n```\n\nMatch 匹配Demo：\n```java\n@Test\npublic void test3() {\n    boolean allMatch = all.stream().allMatch(x -> UserStatus.A == x.getStatus());\n    boolean anyMatch = all.stream().anyMatch(x -> UserStatus.B == (x.getStatus()));\n    boolean noneMatch = all.stream().noneMatch(x -> UserStatus.A == x.getStatus());\n    System.out.println(allMatch);\n    System.out.println(anyMatch);\n    System.out.println(noneMatch);\n}\n```\n\n### 规约\n\nreduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。\n\nreduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。\n\n```java\n@Test\npublic void reduceTest() {\n    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -> {\n        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);\n        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);\n        return o.add(n);\n    });\n    System.out.println(reduce);\n}\n```\n\n### 收集\n\ncollect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。\n\nCollector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：  \n![常见收集器方法](https://rong0624.gitee.io/images/Java/JDK/常见收集器方法.png)\n\n案例：\n```java\npublic void test1() {\n    // 转collection\n    Set<User> set = all.stream().collect(Collectors.toSet());\n    List<Integer> list = all.stream().map(User::getId).collect(Collectors.toList());\n    // 转map\n    Map<String, User> map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));\n    // 转map，处理key相同的元素\n    Map<String, User> map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -> x));\n    // 根据属性分组\n    Map<String, List<User>> sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));\n}\n```\n\n# 并行流 与 串行流\n\n# 新时间日期API\n\n在旧版的java中，日期时间API存在诸多问题，其中有：  \n1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一  \n2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。  \n3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。\n\n**因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。**\n\nJava8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：  \nLocal（本地）  简化了日期的处理，没有时区的问题。  \nZoned（时区）  通过制定的时区处理日期时间。  \n新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n\n## 常用类简介\n\nInstat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\nPeriod：用于计算日期间隔  \nDuration：用于计算时间间隔  \n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime\n\nZoneld：时区  \nZonedDateTime：表示日期+时间+时区值\n\nDateTimeFormatter：用于日期时间的格式化\n\n## 本地化日期时间API\n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime\n\n公共API：  \nnow()：静态方法，根据当前时间创建对象。  \nof()：静态方法，根据指定的日期/时间创建对象。\n\nLocalDate 与 LocalDateTime公共API：  \ngetYear()：获取年份  \ngetMonth()：获取月份，返回一个Month的枚举  \ngetMonthValue()：获取月份  \ngetDayOfMonth()：获取当前月份天数【1-31】  \ngetDayOfYear()：获取当前年份天数【1-366】  \ngetDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举  \nplus()：添加一个 Duration 或 Period  \nminus()：删除一个 Duration 或 Period\nplusDays(); plusWeeks(); plusMonths(); plusYears()：  \n向当前对象，新增几天，几周，几月，几年。\nminusDays(); minusWeeks(); minusMonths(); minusYears()：  \n向当前对象，减去几天，几周，几月，几年。\nwithDayOfMonth()：修改当前月的天数  \nwithDayOfYear()：修改当前年的天数\n\nLocalTime 与 LocalDateTime公共API：  \ngetHour()：获取小时  \ngetMinute()：获取分钟  \ngetSecond()：获取秒\n\n## 时区日期时间API\n\n## Instant 时间戳\n\nJava8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\n如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。\n\n用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n\nInstant API方法：  \ngetEpochSecond()：获取秒数  \ntoEpochMilli()：获取毫秒数  \ngetNano()：获取纳秒数  \nSystem.currentTimeMillis()：获取时间戳，毫秒级别。\n\n```java\nInstant instant = Instant.now();\n// 获取秒数\nlong currentSecond = instant.getEpochSecond();\n// 获取毫秒数\nlong currentMilli = instant.toEpochMilli();\n// 时间戳\nlong currentTimeMilli = System.currentTimeMillis();\nSystem.out.println(currentSecond);\nSystem.out.println(currentMilli);\nSystem.out.println(instant);\nSystem.out.println(currentTimeMilli);\n```\n\n## Period 日期间隔\n\nJava8新提供Period来表示一个日期段，日期间隔。\n\nPeriod API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Period实例  \ngetYears();\t\t\t获取这段日期的相隔年数  \ngetMonths(); \t\t获取单纯月份比较，相隔几月  \ngetDays(); \t\t\t获取单纯天数比较，相隔几天\n\n```java\n// 1999-06-24\nLocalDate from = LocalDate.of(1999, Month.MAY, 24);\n// 2020-08-20\nLocalDate to = LocalDate.of(2020, Month.JULY, 20);\n\nPeriod period = Period.between(from, to);\nint years = period.getYears(); // 这段日期的相隔年数\nint months = period.getMonths(); // 单纯月份比较，相隔几月\nint days = period.getDays(); // 单纯天数比较，相隔几天\n```\n\n## Duration 时间间隔\n\nJava8新提供Duration来表示一个时间段，时间间隔。\n\nDuration API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Duration实例  \ntoDays()：\t\t获取这段时间的天数  \ntoHours()：\t\t获取这段时间的小时  \ntoMinutes()：\t\t获取这段时间的分钟数  \ngetSeconds()：\t获取这段时间的秒数  \ntoMillis()：\t\t获取这段时间的毫秒数  \ntoNanos()：\t\t获取这段时间的纳秒数\n\n```java\n@Test\npublic void durationTest() {\n    // 1999-06-24 00:00:00\n    LocalDateTime from = LocalDateTime.of(1999, Month.MAY, 24, 0, 0, 0);\n    // 2020-08-20 00:00:00\n    LocalDateTime to = LocalDateTime.of(2020, Month.JULY, 20, 0, 0, 0);\n\n    Duration duration = Duration.between(from, to);\n\n    long days = duration.toDays();// 这段时间的天数\n    long hours = duration.toHours();// 这段时间的小时\n    long minutes  = duration.toMinutes();// 这段时间的分钟数\n    long seconds = duration.getSeconds();// 这段时间的秒数\n    long milliSeconds = duration.toMillis();// 这段时间的毫秒数\n    long nanos = duration.toNanos();// 这段时间的纳秒数\n\n    System.out.println(days);\n    System.out.println(hours);\n    System.out.println(minutes);\n    System.out.println(seconds);\n    System.out.println(milliSeconds);\n    System.out.println(nanos);\n}\n```\n\n## 解析与格式化\n\n格式化时间：  \nJava8新提供DateTimeFormatter来格式化时间。\n\n解析时间：  \n使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。\n\n格式化时间demo：\n```java\nLocalDateTime now = LocalDateTime.now();\nString s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);\nString s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = formatter.format(now);\n```\n\n解析时间Demo：\n```java\nLocalDate localDate = LocalDate.parse(\"2020-10-01\");\nLocalDateTime localDateTime = LocalDateTime.parse(\"2020-10-01T15:15:15\");\nLocalDateTime copyLocalDateTime = LocalDateTime.parse(\"2020-10-01 15:15:15\", DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));\n```\n\n# 接口中的默认方法 与 静态方法\n\n## 默认方法\n\nJava8新增了接口的默认方法。  \n简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n\n为什么要有这个特性：  \n首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。  \n然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。\n\n接口默认方法语法格式：\n```java\npublic interface MyInterface {\n\n    default String getStr() {\n        return \"hello interface default method\";\n    }\n\n}\n```\n\n## 默认方法的问题\n\n如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：\n\n接口冲突：\n如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。\n\n类优先原则：\n如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。\n\n接口冲突案例：\n```java\npublic interface Dog {\n\n    default void call() {\n        System.out.println(\"我是狗，汪汪汪\");\n    }\n\n}\n\npublic interface Cat {\n\n    default void call() {\n        System.out.println(\"我是猫，喵喵喵\");\n    }\n\n}\n\npublic class Demo implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n\n    @Override\n    public void call() {\n        Dog.super.call();\n        Cat.super.call();\n        System.out.println(\"我是demo\");\n    }\n}\n```\n\n类优先原则：\n```java\npublic abstract class BaseClass {\n\n    public void call() {\n        System.out.println(\"我是baseClass\");\n    }\n\n}\n\npublic class Demo extends BaseClass implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n    \n}\n```\n\n## 静态方法\n\nJava8的另一个特性是接口可以声明（并且可以提供实现）静态方法。\n\n接口静态方法语法格式：\n```java\npublic interface MyInterface {\n\n    static String getStr() {\n        return \"hello interface static method\";\n    }\n\n}\n```\n\n# Optional 类\n\n## Optional 类简介\n\nOptional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。\n\nOptional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。\n\nOptional 类的引入，可以很好的解决空指针异常。\nOptional 类可以很好的判断一个值存在或者不存在。\n\n## 常用方法\n\n```\nOptional.get()               获取Optional容器包含的值，如果值为null，抛出异常\n\nOptional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常\nOptional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例\nOptional .empty()\t\t\t创建一个空的Optional 实例\n\nOptional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false\nOrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t\nOrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值\nMap(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()\nflatMap(function f)\t\t\t与map类型，要求返回Optional\n```\n\n案例：\n```java\n    @Test\n    public void methodDemo() {\n        // optional.of创建optional实例，t不能为空，为null，抛出异常\n        Optional<Integer> integerOptional = Optional.of(1);\n        // optional.ofNullable创建optional实例，t如果为空，返回一个空的optional\n        Optional<User> userOptional = Optional.ofNullable(null);\n        // optional.empty创建一个空值得optional实例\n        Optional<Object> empty = Optional.empty();\n\n\n    //        // get，optional如果值为空，抛出异常\n    //        integerOptional.get();\n    //        userOptional.get();\n    //        empty.get();\n\n        System.out.println(userOptional.isPresent());\n\n        // 如果值不为空，则返回，如果为空，则返回给定的值\n        Integer integer = integerOptional.orElse(3);\n        User user = userOptional.orElse(new User());\n        Object o = empty.orElse(new BigDecimal(\"100\"));\n\n        System.out.println(integer);\n        System.out.println(user);\n        System.out.println(o);\n    }\n```","source":"_posts/oyr/Java/Java8新特性.md","raw":"---\ntitle: Java8新特性\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Java\ntags: \n    - java\n---\n\n# Java8新特性简介\n\n1）速度更快  \n2）代码更少（增加了新的语法Lambda表达式）  \n3）强大的Stream API  \n4）便于并行  \n5）最大化减少空指针异常 Optional\n\n**其中 Lambda 表达式与 Stream API 最为核心的。**\n\n<!-- more -->\n\n# Lambda表达式\n\n## 什么是Lambda 表达式\n\nLambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。  \nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。  \n使用 Lambda 表达式可以使代码变的更加简洁紧凑。\n\n## Lambda 表达式\n\nLambda 表达式的基础语法：  \nJava8中引入了一个新操作符：“->”该操作符被称为剪头操作符或 Lambda 操作符。\n\n箭头操作符将 Lambda 表达式拆分成两部分：  \n左侧：指定了 Lambda 表达式需要的所有参数。  \n右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。  \n列如：(parameters) -> expression 或 (parameters) ->{ statements; }\n\n特征：  \n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。  \n可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。  \n可选的大括号：如果主体包含了一个语句，就不需要使用大括号。  \n可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n上联：左右遇一括号省  \n下联：左侧推断类型省  \n横批：能省则省\n\n## 语法\n\n1）语法格式一：无参，无返回值\n```java\nRunnable runnable = () -> System.out.println(\"hello lambda!!!\");\n```\n\n2）语法格式二：有一个参数，并且无返回值\n```java\nConsumer<String> consumer = (x) -> System.out.println(x);\n```\n\n3）语法格式三：若只有一个参数，小括号可以省略不写\n```java\nConsumer<String> consumer = x -> System.out.println(x);\n```\n\n4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"开始比较\");\n    return Integer.compare(x, y);\n};\n```\n\n5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n\n（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’\n```java\nComparator<Integer> comparator = (Integer x, Integer y) -> Integer.compare(x, y);\n```\n\n## Lambda表达式需要“函数式接口”的支持\n\n详情看：函数式接口\n\n# 函数式接口\n\n## 什么是函数式接口？\n\n函数式接口：  \n接口中只有一个抽象方法的接口，称为函数式接口。  \n可以使用注解 @FunctionalInterface 修饰。\n\n```java\n@FunctionalInterface    // 表示这是函数式接口\npublic interface MyFun {\n\n    String getValue(String str);\n\n    String test();多一个方法就报错\n\n}\n```\n\n## Java8 内置的四大核心函数式接口\n\n1）Consumer<T>：消费型接口  \nVoid accept(T t)\n\n2）Supplier<T>：供给型接口  \nT get();\n\n3）Function<T, R>：函数型接口  \nR apply(T t);\n\n4）Predicate<T>：断言型接口  \nBoolean test(T t);\n\n## 其他接口\n\n![其他函数式接口](https://rong0624.gitee.io/images/Java/JDK/其他函数式接口.png)\n\n# 方法引用与构造函数引用\n\n## 方法引用\n\n方法引用：  \n若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”  \n（可以理解为方法引用是Lambda表达式的另外一种表现方式）  \n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n\n### 语法\n\n方法引用三种语法格式：  \n```\n第一种：实例对象::实例方法名  \n\n第二种：类::静态方法名  \n\n第三种：类::实例方法名\n```\n\n注意：  \n（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。  \n（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。\n\n### 案例\n\n```java\n// 方法引用：对象::方法名\npublic void test1() {\n    Consumer<String> con1 = x -> System.out.println(x);\n    Consumer<String> con2 = System.out::print;\n\n    User user = new User();\n    Supplier<String> sup1 = () -> user.getName();\n    Supplier<String> sup2 = user::getName;\n}\n\n// 方法引用：类名::静态方法名\npublic void test2() {\n    Comparator<Integer> com1 = (x, y) -> Integer.compare(x, y);\n    Comparator<Integer> com2 = Integer::compare;\n}\n\n// 方法引用：类名：实例方法名\npublic void test3() {\n    BiPredicate<String, String> bp1 = (x, y) -> x.equals(y);\n    BiPredicate<String, String> bp2 = String::equals;\n}\n```\n\n## 构造器引用\n\n### 语法\n\n语法格式：Class :: method\n\n注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。\n\n### 案例\n\n```java\n// 构造器引用：类名::new\npublic void test4() {\n    // 对应函数式接口的抽象方法，当前调用无参构造\n    Supplier<User> su1 = () -> new User();\n    Supplier<User> su2 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器\n    Function<Integer, User> fun1 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器\n    BiFunction<String, Integer, User> fun2 = User::new;\n}\n```\n\n# Stream API\n\n## 了解Stream API\n\nJava8中有两大最为重要的改变：   \n第一个是Lambda表达式；  \n第二个则是Stream API（java.util.stream.*）；  \n\nStream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。  \n使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。\n\n## 什么是Stream\n\n流（Stream）到底是什么呢？  \n是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。  \n“集合讲的是数据，流讲的是计算！！！”\n\n注意：  \n1）Stream 自己不会存储元素  \n2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream  \n3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）\n\n## Stream的三个操作步骤\n\n1）创建Stream  \n一个数据源（如：集合，数组），获取一个流\n\n2）中间操作  \n一个中间操作链，对数据源的数据进行处理（过滤，映射）\n\n3）终止操作（终端操作，返回结果）  \n一个终止操作，执行中间操作链，并且产生结果\n\n流程图：  \n![Stream操作流程图](https://rong0624.gitee.io/images/Java/JDK/Stream操作流程图.png)\n\n## 创建Stream\n\n### 集合创建Stream\n\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：  \ndefault Stream<E> stream() : 返回一个顺序流  \ndefault Stream<E> parallelStream() : 返回一个并行流\n\n案例：\n```java\n@Test\npublic void test1() {\n    // List Set 继承至 Collection\n    all.stream().forEach(System.out::println);\n    all.parallelStream().forEach(System.out::println);\n    map.values().stream().forEach(System.out::println);\n}\n```\n\n### 数组创建Stream\n\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流：  \nstatic <T> Stream<T> stream(T[] array): 返回一个流。\n\n重载形式，能够处理对应基本类型的数组： \npublic static IntStream stream(int[] array) \npublic static LongStream stream(long[] array)\npublic static DoubleStream stream(double[] array)\n\n案例：\n```java\n@Test\npublic void test2() {\n    int[] intArr = {1, 2, 3, 4};\n    String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n    Arrays.stream(intArr).forEach(System.out::println);\n    Arrays.stream(strArr).forEach(System.out::println);\n}\n```\n\n### 值创建Stream\n\n可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：  \npublic static<T> Stream<T> of(T... values) : 返回一个流\n\n案例：\n```java\npublic void test3() {\n    Stream.of(\"a\", \"b\", \"c\", \"d\").forEach(System.out::println);\n    Stream.of(\"a\", \"b\", \"c\", \"d\").parallel().forEach(System.out::println);\n    Stream.of(new User(50, \"张三\"),\n            new User(60, \"李四\"),\n            new User(11, \"王五\")).forEach(System.out::println);\n}\n```\n\n### 函数创建Stream（无限流）\n\n可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 \n迭代：  \npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);\n\n生成：  \npublic static<T> Stream<T> generate(Supplier<T> s);\n\n## Stream的中间操作\n\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!  \n而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。\n\n### 筛选与切片\n\nfilter(Predicate p)：接收Lambda，从Stream流中排除某些元素。\n\ndistinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。\n\nlimit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。\n\nskip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。\n\n案例：\n```java\n@Test\npublic void test1() {\n    all.stream().filter(user -> user.getAge() > 10).forEach(System.out::println);\n    all.stream().distinct().forEach(System.out::println);\n    all.stream().limit(10).forEach(System.out::println);\n    all.stream().skip(10).forEach(System.out::println);\n    all.stream().distinct()\n            .filter(user -> user.getAge() > 10)\n            .limit(10)\n            .skip(5)\n            .forEach(System.out::println);\n}\n```\n\n### 映射\n\nmap(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nflatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。\n\n```java\npublic void test2() {\n    all.stream().map(user -> user.getName())\n                .forEach(System.out::println);\n    all.stream().flatMap(user -> Stream.of(user.getName()))\n            .forEach(System.out::println);\n}\n```\n\n### 排序\n\nsorted()：自然排序，使用Comparable默认排序。\n\nsorted(Comparator comparator)：定制排序，使用Comparator。\n\n```java\npublic void test3() {\n    List<String> strings = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"zzz\");\n    strings.stream()\n            .sorted()\n            .forEach(System.out::println);\n\n    all.stream().sorted((x, y) -> {\n        if (x.getAge().equals(y.getAge())) {\n            return x.getName().compareTo(y.getName());\n        }\n        return x.getAge().compareTo(y.getAge());\n    }).forEach(System.out::println);\n}\n```\n\n## Stream的终止操作\n\n### 查找与匹配\n\nFind查找：  \nfindFirst() ：返回第一个元素   \nfindAny() ：返回当前流中的任意元素  \ncount() ：返回流中元素总个数  \nmax(Comparator c) ：返回流中最大值  \nmin(Comparator c) ：返回流中最小值  \n\nMatch匹配：  \nallMatch(Predicate p) ：检查是否匹配所有元素   \nanyMatch(Predicate p) ：检查是否至少匹配一个元素   \nnoneMatch(Predicate p) ：检查是否没有匹配所有元素\n\nFinal 查找案例：\n```java\n@Test\npublic void test2() {\n    Optional<User> firstOptional = all.stream().findFirst();\n    Optional<User> anyOptional = all.stream().findAny();\n    long count = all.stream().count();\n    Optional<User> maxOptional = all.stream().max(Comparator.comparing(User::getAge));\n    Optional<Integer> minOptional = all.stream().map(User::getAge).min(Integer::compareTo);\n    System.out.println(firstOptional.get());\n    System.out.println(anyOptional.get());\n    System.out.println(count);\n    System.out.println(maxOptional.get());\n    System.out.println(minOptional.get());\n}\n```\n\nMatch 匹配Demo：\n```java\n@Test\npublic void test3() {\n    boolean allMatch = all.stream().allMatch(x -> UserStatus.A == x.getStatus());\n    boolean anyMatch = all.stream().anyMatch(x -> UserStatus.B == (x.getStatus()));\n    boolean noneMatch = all.stream().noneMatch(x -> UserStatus.A == x.getStatus());\n    System.out.println(allMatch);\n    System.out.println(anyMatch);\n    System.out.println(noneMatch);\n}\n```\n\n### 规约\n\nreduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。\n\nreduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。\n\n```java\n@Test\npublic void reduceTest() {\n    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -> {\n        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);\n        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);\n        return o.add(n);\n    });\n    System.out.println(reduce);\n}\n```\n\n### 收集\n\ncollect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。\n\nCollector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：  \n![常见收集器方法](https://rong0624.gitee.io/images/Java/JDK/常见收集器方法.png)\n\n案例：\n```java\npublic void test1() {\n    // 转collection\n    Set<User> set = all.stream().collect(Collectors.toSet());\n    List<Integer> list = all.stream().map(User::getId).collect(Collectors.toList());\n    // 转map\n    Map<String, User> map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));\n    // 转map，处理key相同的元素\n    Map<String, User> map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -> x));\n    // 根据属性分组\n    Map<String, List<User>> sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));\n}\n```\n\n# 并行流 与 串行流\n\n# 新时间日期API\n\n在旧版的java中，日期时间API存在诸多问题，其中有：  \n1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一  \n2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。  \n3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。\n\n**因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。**\n\nJava8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：  \nLocal（本地）  简化了日期的处理，没有时区的问题。  \nZoned（时区）  通过制定的时区处理日期时间。  \n新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n\n## 常用类简介\n\nInstat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\nPeriod：用于计算日期间隔  \nDuration：用于计算时间间隔  \n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime\n\nZoneld：时区  \nZonedDateTime：表示日期+时间+时区值\n\nDateTimeFormatter：用于日期时间的格式化\n\n## 本地化日期时间API\n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime\n\n公共API：  \nnow()：静态方法，根据当前时间创建对象。  \nof()：静态方法，根据指定的日期/时间创建对象。\n\nLocalDate 与 LocalDateTime公共API：  \ngetYear()：获取年份  \ngetMonth()：获取月份，返回一个Month的枚举  \ngetMonthValue()：获取月份  \ngetDayOfMonth()：获取当前月份天数【1-31】  \ngetDayOfYear()：获取当前年份天数【1-366】  \ngetDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举  \nplus()：添加一个 Duration 或 Period  \nminus()：删除一个 Duration 或 Period\nplusDays(); plusWeeks(); plusMonths(); plusYears()：  \n向当前对象，新增几天，几周，几月，几年。\nminusDays(); minusWeeks(); minusMonths(); minusYears()：  \n向当前对象，减去几天，几周，几月，几年。\nwithDayOfMonth()：修改当前月的天数  \nwithDayOfYear()：修改当前年的天数\n\nLocalTime 与 LocalDateTime公共API：  \ngetHour()：获取小时  \ngetMinute()：获取分钟  \ngetSecond()：获取秒\n\n## 时区日期时间API\n\n## Instant 时间戳\n\nJava8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\n如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。\n\n用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n\nInstant API方法：  \ngetEpochSecond()：获取秒数  \ntoEpochMilli()：获取毫秒数  \ngetNano()：获取纳秒数  \nSystem.currentTimeMillis()：获取时间戳，毫秒级别。\n\n```java\nInstant instant = Instant.now();\n// 获取秒数\nlong currentSecond = instant.getEpochSecond();\n// 获取毫秒数\nlong currentMilli = instant.toEpochMilli();\n// 时间戳\nlong currentTimeMilli = System.currentTimeMillis();\nSystem.out.println(currentSecond);\nSystem.out.println(currentMilli);\nSystem.out.println(instant);\nSystem.out.println(currentTimeMilli);\n```\n\n## Period 日期间隔\n\nJava8新提供Period来表示一个日期段，日期间隔。\n\nPeriod API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Period实例  \ngetYears();\t\t\t获取这段日期的相隔年数  \ngetMonths(); \t\t获取单纯月份比较，相隔几月  \ngetDays(); \t\t\t获取单纯天数比较，相隔几天\n\n```java\n// 1999-06-24\nLocalDate from = LocalDate.of(1999, Month.MAY, 24);\n// 2020-08-20\nLocalDate to = LocalDate.of(2020, Month.JULY, 20);\n\nPeriod period = Period.between(from, to);\nint years = period.getYears(); // 这段日期的相隔年数\nint months = period.getMonths(); // 单纯月份比较，相隔几月\nint days = period.getDays(); // 单纯天数比较，相隔几天\n```\n\n## Duration 时间间隔\n\nJava8新提供Duration来表示一个时间段，时间间隔。\n\nDuration API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Duration实例  \ntoDays()：\t\t获取这段时间的天数  \ntoHours()：\t\t获取这段时间的小时  \ntoMinutes()：\t\t获取这段时间的分钟数  \ngetSeconds()：\t获取这段时间的秒数  \ntoMillis()：\t\t获取这段时间的毫秒数  \ntoNanos()：\t\t获取这段时间的纳秒数\n\n```java\n@Test\npublic void durationTest() {\n    // 1999-06-24 00:00:00\n    LocalDateTime from = LocalDateTime.of(1999, Month.MAY, 24, 0, 0, 0);\n    // 2020-08-20 00:00:00\n    LocalDateTime to = LocalDateTime.of(2020, Month.JULY, 20, 0, 0, 0);\n\n    Duration duration = Duration.between(from, to);\n\n    long days = duration.toDays();// 这段时间的天数\n    long hours = duration.toHours();// 这段时间的小时\n    long minutes  = duration.toMinutes();// 这段时间的分钟数\n    long seconds = duration.getSeconds();// 这段时间的秒数\n    long milliSeconds = duration.toMillis();// 这段时间的毫秒数\n    long nanos = duration.toNanos();// 这段时间的纳秒数\n\n    System.out.println(days);\n    System.out.println(hours);\n    System.out.println(minutes);\n    System.out.println(seconds);\n    System.out.println(milliSeconds);\n    System.out.println(nanos);\n}\n```\n\n## 解析与格式化\n\n格式化时间：  \nJava8新提供DateTimeFormatter来格式化时间。\n\n解析时间：  \n使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。\n\n格式化时间demo：\n```java\nLocalDateTime now = LocalDateTime.now();\nString s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);\nString s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = formatter.format(now);\n```\n\n解析时间Demo：\n```java\nLocalDate localDate = LocalDate.parse(\"2020-10-01\");\nLocalDateTime localDateTime = LocalDateTime.parse(\"2020-10-01T15:15:15\");\nLocalDateTime copyLocalDateTime = LocalDateTime.parse(\"2020-10-01 15:15:15\", DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));\n```\n\n# 接口中的默认方法 与 静态方法\n\n## 默认方法\n\nJava8新增了接口的默认方法。  \n简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n\n为什么要有这个特性：  \n首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。  \n然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。\n\n接口默认方法语法格式：\n```java\npublic interface MyInterface {\n\n    default String getStr() {\n        return \"hello interface default method\";\n    }\n\n}\n```\n\n## 默认方法的问题\n\n如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：\n\n接口冲突：\n如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。\n\n类优先原则：\n如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。\n\n接口冲突案例：\n```java\npublic interface Dog {\n\n    default void call() {\n        System.out.println(\"我是狗，汪汪汪\");\n    }\n\n}\n\npublic interface Cat {\n\n    default void call() {\n        System.out.println(\"我是猫，喵喵喵\");\n    }\n\n}\n\npublic class Demo implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n\n    @Override\n    public void call() {\n        Dog.super.call();\n        Cat.super.call();\n        System.out.println(\"我是demo\");\n    }\n}\n```\n\n类优先原则：\n```java\npublic abstract class BaseClass {\n\n    public void call() {\n        System.out.println(\"我是baseClass\");\n    }\n\n}\n\npublic class Demo extends BaseClass implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n    \n}\n```\n\n## 静态方法\n\nJava8的另一个特性是接口可以声明（并且可以提供实现）静态方法。\n\n接口静态方法语法格式：\n```java\npublic interface MyInterface {\n\n    static String getStr() {\n        return \"hello interface static method\";\n    }\n\n}\n```\n\n# Optional 类\n\n## Optional 类简介\n\nOptional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。\n\nOptional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。\n\nOptional 类的引入，可以很好的解决空指针异常。\nOptional 类可以很好的判断一个值存在或者不存在。\n\n## 常用方法\n\n```\nOptional.get()               获取Optional容器包含的值，如果值为null，抛出异常\n\nOptional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常\nOptional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例\nOptional .empty()\t\t\t创建一个空的Optional 实例\n\nOptional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false\nOrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t\nOrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值\nMap(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()\nflatMap(function f)\t\t\t与map类型，要求返回Optional\n```\n\n案例：\n```java\n    @Test\n    public void methodDemo() {\n        // optional.of创建optional实例，t不能为空，为null，抛出异常\n        Optional<Integer> integerOptional = Optional.of(1);\n        // optional.ofNullable创建optional实例，t如果为空，返回一个空的optional\n        Optional<User> userOptional = Optional.ofNullable(null);\n        // optional.empty创建一个空值得optional实例\n        Optional<Object> empty = Optional.empty();\n\n\n    //        // get，optional如果值为空，抛出异常\n    //        integerOptional.get();\n    //        userOptional.get();\n    //        empty.get();\n\n        System.out.println(userOptional.isPresent());\n\n        // 如果值不为空，则返回，如果为空，则返回给定的值\n        Integer integer = integerOptional.orElse(3);\n        User user = userOptional.orElse(new User());\n        Object o = empty.orElse(new BigDecimal(\"100\"));\n\n        System.out.println(integer);\n        System.out.println(user);\n        System.out.println(o);\n    }\n```","slug":"oyr/Java/Java8新特性","published":1,"updated":"2021-10-26T10:30:26.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86i001pcst7cepu56nn","content":"<h1 id=\"Java8新特性简介\"><a href=\"#Java8新特性简介\" class=\"headerlink\" title=\"Java8新特性简介\"></a>Java8新特性简介</h1><p>1）速度更快<br>2）代码更少（增加了新的语法Lambda表达式）<br>3）强大的Stream API<br>4）便于并行<br>5）最大化减少空指针异常 Optional</p>\n<p><strong>其中 Lambda 表达式与 Stream API 最为核心的。</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"什么是Lambda-表达式\"><a href=\"#什么是Lambda-表达式\" class=\"headerlink\" title=\"什么是Lambda 表达式\"></a>什么是Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>Lambda 表达式的基础语法：<br>Java8中引入了一个新操作符：“-&gt;”该操作符被称为剪头操作符或 Lambda 操作符。</p>\n<p>箭头操作符将 Lambda 表达式拆分成两部分：<br>左侧：指定了 Lambda 表达式需要的所有参数。<br>右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。<br>列如：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<p>特征：<br>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>\n<p>上联：左右遇一括号省<br>下联：左侧推断类型省<br>横批：能省则省</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>1）语法格式一：无参，无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable runnable = () -&gt; System.out.println(<span class=\"string\">&quot;hello lambda!!!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>2）语法格式二：有一个参数，并且无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>3）语法格式三：若只有一个参数，小括号可以省略不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;开始比较&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda表达式需要“函数式接口”的支持\"><a href=\"#Lambda表达式需要“函数式接口”的支持\" class=\"headerlink\" title=\"Lambda表达式需要“函数式接口”的支持\"></a>Lambda表达式需要“函数式接口”的支持</h2><p>详情看：函数式接口</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式接口？\"><a href=\"#什么是函数式接口？\" class=\"headerlink\" title=\"什么是函数式接口？\"></a>什么是函数式接口？</h2><p>函数式接口：<br>接口中只有一个抽象方法的接口，称为函数式接口。<br>可以使用注解 @FunctionalInterface 修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span>    <span class=\"comment\">// 表示这是函数式接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFun</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getValue</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;多一个方法就报错</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java8-内置的四大核心函数式接口\"><a href=\"#Java8-内置的四大核心函数式接口\" class=\"headerlink\" title=\"Java8 内置的四大核心函数式接口\"></a>Java8 内置的四大核心函数式接口</h2><p>1）Consumer<T>：消费型接口<br>Void accept(T t)</p>\n<p>2）Supplier<T>：供给型接口<br>T get();</p>\n<p>3）Function&lt;T, R&gt;：函数型接口<br>R apply(T t);</p>\n<p>4）Predicate<T>：断言型接口<br>Boolean test(T t);</p>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><p><img src=\"https://rong0624.gitee.io/images/Java/JDK/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png\" alt=\"其他函数式接口\"></p>\n<h1 id=\"方法引用与构造函数引用\"><a href=\"#方法引用与构造函数引用\" class=\"headerlink\" title=\"方法引用与构造函数引用\"></a>方法引用与构造函数引用</h1><h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用：<br>若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”<br>（可以理解为方法引用是Lambda表达式的另外一种表现方式）<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>方法引用三种语法格式：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：实例对象::实例方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第二种：类::静态方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第三种：类::实例方法名</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。<br>（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法引用：对象::方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);</span><br><span class=\"line\">    Consumer&lt;String&gt; con2 = System.out::print;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup1 = () -&gt; user.getName();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup2 = user::getName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名::静态方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名：实例方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y);</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>语法格式：Class :: method</p>\n<p>注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造器引用：类名::new</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用无参构造</span></span><br><span class=\"line\">    Supplier&lt;User&gt; su1 = () -&gt; <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;User&gt; su2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器</span></span><br><span class=\"line\">    Function&lt;Integer, User&gt; fun1 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器</span></span><br><span class=\"line\">    BiFunction&lt;String, Integer, User&gt; fun2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><h2 id=\"了解Stream-API\"><a href=\"#了解Stream-API\" class=\"headerlink\" title=\"了解Stream API\"></a>了解Stream API</h2><p>Java8中有两大最为重要的改变：<br>第一个是Lambda表达式；<br>第二个则是Stream API（java.util.stream.*）；  </p>\n<p>Stream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。<br>使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。</p>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>流（Stream）到底是什么呢？<br>是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！！！”</p>\n<p>注意：<br>1）Stream 自己不会存储元素<br>2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream<br>3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）</p>\n<h2 id=\"Stream的三个操作步骤\"><a href=\"#Stream的三个操作步骤\" class=\"headerlink\" title=\"Stream的三个操作步骤\"></a>Stream的三个操作步骤</h2><p>1）创建Stream<br>一个数据源（如：集合，数组），获取一个流</p>\n<p>2）中间操作<br>一个中间操作链，对数据源的数据进行处理（过滤，映射）</p>\n<p>3）终止操作（终端操作，返回结果）<br>一个终止操作，执行中间操作链，并且产生结果</p>\n<p>流程图：<br><img src=\"https://rong0624.gitee.io/images/Java/JDK/Stream%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"Stream操作流程图\"></p>\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><h3 id=\"集合创建Stream\"><a href=\"#集合创建Stream\" class=\"headerlink\" title=\"集合创建Stream\"></a>集合创建Stream</h3><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：<br>default Stream<E> stream() : 返回一个顺序流<br>default Stream<E> parallelStream() : 返回一个并行流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// List Set 继承至 Collection</span></span><br><span class=\"line\">    all.stream().forEach(System.out::println);</span><br><span class=\"line\">    all.parallelStream().forEach(System.out::println);</span><br><span class=\"line\">    map.values().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组创建Stream\"><a href=\"#数组创建Stream\" class=\"headerlink\" title=\"数组创建Stream\"></a>数组创建Stream</h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<br>static <T> Stream<T> stream(T[] array): 返回一个流。</p>\n<p>重载形式，能够处理对应基本类型的数组：<br>public static IntStream stream(int[] array)<br>public static LongStream stream(long[] array)<br>public static DoubleStream stream(double[] array)</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] intArr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    String[] strArr = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>&#125;;</span><br><span class=\"line\">    Arrays.stream(intArr).forEach(System.out::println);</span><br><span class=\"line\">    Arrays.stream(strArr).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值创建Stream\"><a href=\"#值创建Stream\" class=\"headerlink\" title=\"值创建Stream\"></a>值创建Stream</h3><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：<br>public static<T> Stream<T> of(T… values) : 返回一个流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).parallel().forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"keyword\">new</span> User(<span class=\"number\">50</span>, <span class=\"string\">&quot;张三&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">60</span>, <span class=\"string\">&quot;李四&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">11</span>, <span class=\"string\">&quot;王五&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数创建Stream（无限流）\"><a href=\"#函数创建Stream（无限流）\" class=\"headerlink\" title=\"函数创建Stream（无限流）\"></a>函数创建Stream（无限流）</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。<br>迭代：<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);</p>\n<p>生成：<br>public static<T> Stream<T> generate(Supplier<T> s);</p>\n<h2 id=\"Stream的中间操作\"><a href=\"#Stream的中间操作\" class=\"headerlink\" title=\"Stream的中间操作\"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!<br>而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。</p>\n<h3 id=\"筛选与切片\"><a href=\"#筛选与切片\" class=\"headerlink\" title=\"筛选与切片\"></a>筛选与切片</h3><p>filter(Predicate p)：接收Lambda，从Stream流中排除某些元素。</p>\n<p>distinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。</p>\n<p>limit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。</p>\n<p>skip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    all.stream().limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().skip(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct()</span><br><span class=\"line\">            .filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .skip(<span class=\"number\">5</span>)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>map(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>\n<p>flatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().map(user -&gt; user.getName())</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    all.stream().flatMap(user -&gt; Stream.of(user.getName()))</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>sorted()：自然排序，使用Comparable默认排序。</p>\n<p>sorted(Comparator comparator)：定制排序，使用Comparator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;ddd&quot;</span>, <span class=\"string\">&quot;zzz&quot;</span>);</span><br><span class=\"line\">    strings.stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    all.stream().sorted((x, y) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.getAge().equals(y.getAge())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x.getName().compareTo(y.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.getAge().compareTo(y.getAge());</span><br><span class=\"line\">    &#125;).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的终止操作\"><a href=\"#Stream的终止操作\" class=\"headerlink\" title=\"Stream的终止操作\"></a>Stream的终止操作</h2><h3 id=\"查找与匹配\"><a href=\"#查找与匹配\" class=\"headerlink\" title=\"查找与匹配\"></a>查找与匹配</h3><p>Find查找：<br>findFirst() ：返回第一个元素<br>findAny() ：返回当前流中的任意元素<br>count() ：返回流中元素总个数<br>max(Comparator c) ：返回流中最大值<br>min(Comparator c) ：返回流中最小值  </p>\n<p>Match匹配：<br>allMatch(Predicate p) ：检查是否匹配所有元素<br>anyMatch(Predicate p) ：检查是否至少匹配一个元素<br>noneMatch(Predicate p) ：检查是否没有匹配所有元素</p>\n<p>Final 查找案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Optional&lt;User&gt; firstOptional = all.stream().findFirst();</span><br><span class=\"line\">    Optional&lt;User&gt; anyOptional = all.stream().findAny();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> count = all.stream().count();</span><br><span class=\"line\">    Optional&lt;User&gt; maxOptional = all.stream().max(Comparator.comparing(User::getAge));</span><br><span class=\"line\">    Optional&lt;Integer&gt; minOptional = all.stream().map(User::getAge).min(Integer::compareTo);</span><br><span class=\"line\">    System.out.println(firstOptional.get());</span><br><span class=\"line\">    System.out.println(anyOptional.get());</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\">    System.out.println(maxOptional.get());</span><br><span class=\"line\">    System.out.println(minOptional.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Match 匹配Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> allMatch = all.stream().allMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> anyMatch = all.stream().anyMatch(x -&gt; UserStatus.B == (x.getStatus()));</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> noneMatch = all.stream().noneMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"规约\"><a href=\"#规约\" class=\"headerlink\" title=\"规约\"></a>规约</h3><p>reduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。</p>\n<p>reduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reduceTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -&gt; &#123;</span><br><span class=\"line\">        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.add(n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h3><p>collect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。</p>\n<p>Collector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：<br><img src=\"https://rong0624.gitee.io/images/Java/JDK/%E5%B8%B8%E8%A7%81%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B9%E6%B3%95.png\" alt=\"常见收集器方法\"></p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 转collection</span></span><br><span class=\"line\">    Set&lt;User&gt; set = all.stream().collect(Collectors.toSet());</span><br><span class=\"line\">    List&lt;Integer&gt; list = all.stream().map(User::getId).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// 转map</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));</span><br><span class=\"line\">    <span class=\"comment\">// 转map，处理key相同的元素</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -&gt; x));</span><br><span class=\"line\">    <span class=\"comment\">// 根据属性分组</span></span><br><span class=\"line\">    Map&lt;String, List&lt;User&gt;&gt; sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"并行流-与-串行流\"><a href=\"#并行流-与-串行流\" class=\"headerlink\" title=\"并行流 与 串行流\"></a>并行流 与 串行流</h1><h1 id=\"新时间日期API\"><a href=\"#新时间日期API\" class=\"headerlink\" title=\"新时间日期API\"></a>新时间日期API</h1><p>在旧版的java中，日期时间API存在诸多问题，其中有：<br>1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一<br>2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。<br>3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</p>\n<p><strong>因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。</strong></p>\n<p>Java8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：<br>Local（本地）  简化了日期的处理，没有时区的问题。<br>Zoned（时区）  通过制定的时区处理日期时间。<br>新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>\n<h2 id=\"常用类简介\"><a href=\"#常用类简介\" class=\"headerlink\" title=\"常用类简介\"></a>常用类简介</h2><p>Instat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>Period：用于计算日期间隔<br>Duration：用于计算时间间隔  </p>\n<p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime</p>\n<p>Zoneld：时区<br>ZonedDateTime：表示日期+时间+时区值</p>\n<p>DateTimeFormatter：用于日期时间的格式化</p>\n<h2 id=\"本地化日期时间API\"><a href=\"#本地化日期时间API\" class=\"headerlink\" title=\"本地化日期时间API\"></a>本地化日期时间API</h2><p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime</p>\n<p>公共API：<br>now()：静态方法，根据当前时间创建对象。<br>of()：静态方法，根据指定的日期/时间创建对象。</p>\n<p>LocalDate 与 LocalDateTime公共API：<br>getYear()：获取年份<br>getMonth()：获取月份，返回一个Month的枚举<br>getMonthValue()：获取月份<br>getDayOfMonth()：获取当前月份天数【1-31】<br>getDayOfYear()：获取当前年份天数【1-366】<br>getDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举<br>plus()：添加一个 Duration 或 Period<br>minus()：删除一个 Duration 或 Period<br>plusDays(); plusWeeks(); plusMonths(); plusYears()：<br>向当前对象，新增几天，几周，几月，几年。<br>minusDays(); minusWeeks(); minusMonths(); minusYears()：<br>向当前对象，减去几天，几周，几月，几年。<br>withDayOfMonth()：修改当前月的天数<br>withDayOfYear()：修改当前年的天数</p>\n<p>LocalTime 与 LocalDateTime公共API：<br>getHour()：获取小时<br>getMinute()：获取分钟<br>getSecond()：获取秒</p>\n<h2 id=\"时区日期时间API\"><a href=\"#时区日期时间API\" class=\"headerlink\" title=\"时区日期时间API\"></a>时区日期时间API</h2><h2 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h2><p>Java8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。</p>\n<p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。</p>\n<p>Instant API方法：<br>getEpochSecond()：获取秒数<br>toEpochMilli()：获取毫秒数<br>getNano()：获取纳秒数<br>System.currentTimeMillis()：获取时间戳，毫秒级别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant instant = Instant.now();</span><br><span class=\"line\"><span class=\"comment\">// 获取秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentSecond = instant.getEpochSecond();</span><br><span class=\"line\"><span class=\"comment\">// 获取毫秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentMilli = instant.toEpochMilli();</span><br><span class=\"line\"><span class=\"comment\">// 时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentTimeMilli = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(currentSecond);</span><br><span class=\"line\">System.out.println(currentMilli);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\">System.out.println(currentTimeMilli);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Period-日期间隔\"><a href=\"#Period-日期间隔\" class=\"headerlink\" title=\"Period 日期间隔\"></a>Period 日期间隔</h2><p>Java8新提供Period来表示一个日期段，日期间隔。</p>\n<p>Period API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Period实例<br>getYears();            获取这段日期的相隔年数<br>getMonths();         获取单纯月份比较，相隔几月<br>getDays();             获取单纯天数比较，相隔几天</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1999-06-24</span></span><br><span class=\"line\">LocalDate from = LocalDate.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2020-08-20</span></span><br><span class=\"line\">LocalDate to = LocalDate.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Period period = Period.between(from, to);</span><br><span class=\"line\"><span class=\"keyword\">int</span> years = period.getYears(); <span class=\"comment\">// 这段日期的相隔年数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> months = period.getMonths(); <span class=\"comment\">// 单纯月份比较，相隔几月</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> days = period.getDays(); <span class=\"comment\">// 单纯天数比较，相隔几天</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Duration-时间间隔\"><a href=\"#Duration-时间间隔\" class=\"headerlink\" title=\"Duration 时间间隔\"></a>Duration 时间间隔</h2><p>Java8新提供Duration来表示一个时间段，时间间隔。</p>\n<p>Duration API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Duration实例<br>toDays()：        获取这段时间的天数<br>toHours()：        获取这段时间的小时<br>toMinutes()：        获取这段时间的分钟数<br>getSeconds()：    获取这段时间的秒数<br>toMillis()：        获取这段时间的毫秒数<br>toNanos()：        获取这段时间的纳秒数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">durationTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1999-06-24 00:00:00</span></span><br><span class=\"line\">    LocalDateTime from = LocalDateTime.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2020-08-20 00:00:00</span></span><br><span class=\"line\">    LocalDateTime to = LocalDateTime.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Duration duration = Duration.between(from, to);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> days = duration.toDays();<span class=\"comment\">// 这段时间的天数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> hours = duration.toHours();<span class=\"comment\">// 这段时间的小时</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> minutes  = duration.toMinutes();<span class=\"comment\">// 这段时间的分钟数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> seconds = duration.getSeconds();<span class=\"comment\">// 这段时间的秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> milliSeconds = duration.toMillis();<span class=\"comment\">// 这段时间的毫秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = duration.toNanos();<span class=\"comment\">// 这段时间的纳秒数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(days);</span><br><span class=\"line\">    System.out.println(hours);</span><br><span class=\"line\">    System.out.println(minutes);</span><br><span class=\"line\">    System.out.println(seconds);</span><br><span class=\"line\">    System.out.println(milliSeconds);</span><br><span class=\"line\">    System.out.println(nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析与格式化\"><a href=\"#解析与格式化\" class=\"headerlink\" title=\"解析与格式化\"></a>解析与格式化</h2><p>格式化时间：<br>Java8新提供DateTimeFormatter来格式化时间。</p>\n<p>解析时间：<br>使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。</p>\n<p>格式化时间demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">String s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);</span><br><span class=\"line\">String s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);</span><br><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">String format = formatter.format(now);</span><br></pre></td></tr></table></figure>\n\n<p>解析时间Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate localDate = LocalDate.parse(<span class=\"string\">&quot;2020-10-01&quot;</span>);</span><br><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01T15:15:15&quot;</span>);</span><br><span class=\"line\">LocalDateTime copyLocalDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01 15:15:15&quot;</span>, DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"接口中的默认方法-与-静态方法\"><a href=\"#接口中的默认方法-与-静态方法\" class=\"headerlink\" title=\"接口中的默认方法 与 静态方法\"></a>接口中的默认方法 与 静态方法</h1><h2 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h2><p>Java8新增了接口的默认方法。<br>简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>\n<p>为什么要有这个特性：<br>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。<br>然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。</p>\n<p>接口默认方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface default method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认方法的问题\"><a href=\"#默认方法的问题\" class=\"headerlink\" title=\"默认方法的问题\"></a>默认方法的问题</h2><p>如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p>\n<p>接口冲突：<br>如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。</p>\n<p>类优先原则：<br>如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。</p>\n<p>接口冲突案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是狗，汪汪汪&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是猫，喵喵喵&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dog.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        Cat.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是demo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类优先原则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是baseClass&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>Java8的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>\n<p>接口静态方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface static method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Optional-类\"><a href=\"#Optional-类\" class=\"headerlink\" title=\"Optional 类\"></a>Optional 类</h1><h2 id=\"Optional-类简介\"><a href=\"#Optional-类简介\" class=\"headerlink\" title=\"Optional 类简介\"></a>Optional 类简介</h2><p>Optional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。</p>\n<p>Optional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。</p>\n<p>Optional 类的引入，可以很好的解决空指针异常。<br>Optional 类可以很好的判断一个值存在或者不存在。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional.get()               获取Optional容器包含的值，如果值为null，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常</span><br><span class=\"line\">Optional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例</span><br><span class=\"line\">Optional .empty()\t\t\t创建一个空的Optional 实例</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false</span><br><span class=\"line\">OrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t</span><br><span class=\"line\">OrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值</span><br><span class=\"line\">Map(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()</span><br><span class=\"line\">flatMap(function f)\t\t\t与map类型，要求返回Optional</span><br></pre></td></tr></table></figure>\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// optional.of创建optional实例，t不能为空，为null，抛出异常</span></span><br><span class=\"line\">    Optional&lt;Integer&gt; integerOptional = Optional.of(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.ofNullable创建optional实例，t如果为空，返回一个空的optional</span></span><br><span class=\"line\">    Optional&lt;User&gt; userOptional = Optional.ofNullable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.empty创建一个空值得optional实例</span></span><br><span class=\"line\">    Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        // get，optional如果值为空，抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//        integerOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        userOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        empty.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(userOptional.isPresent());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果值不为空，则返回，如果为空，则返回给定的值</span></span><br><span class=\"line\">    Integer integer = integerOptional.orElse(<span class=\"number\">3</span>);</span><br><span class=\"line\">    User user = userOptional.orElse(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">    Object o = empty.orElse(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;100&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(integer);</span><br><span class=\"line\">    System.out.println(user);</span><br><span class=\"line\">    System.out.println(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Java8新特性简介\"><a href=\"#Java8新特性简介\" class=\"headerlink\" title=\"Java8新特性简介\"></a>Java8新特性简介</h1><p>1）速度更快<br>2）代码更少（增加了新的语法Lambda表达式）<br>3）强大的Stream API<br>4）便于并行<br>5）最大化减少空指针异常 Optional</p>\n<p><strong>其中 Lambda 表达式与 Stream API 最为核心的。</strong></p>","more":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"什么是Lambda-表达式\"><a href=\"#什么是Lambda-表达式\" class=\"headerlink\" title=\"什么是Lambda 表达式\"></a>什么是Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>Lambda 表达式的基础语法：<br>Java8中引入了一个新操作符：“-&gt;”该操作符被称为剪头操作符或 Lambda 操作符。</p>\n<p>箭头操作符将 Lambda 表达式拆分成两部分：<br>左侧：指定了 Lambda 表达式需要的所有参数。<br>右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。<br>列如：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<p>特征：<br>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>\n<p>上联：左右遇一括号省<br>下联：左侧推断类型省<br>横批：能省则省</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>1）语法格式一：无参，无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable runnable = () -&gt; System.out.println(<span class=\"string\">&quot;hello lambda!!!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>2）语法格式二：有一个参数，并且无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>3）语法格式三：若只有一个参数，小括号可以省略不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;开始比较&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda表达式需要“函数式接口”的支持\"><a href=\"#Lambda表达式需要“函数式接口”的支持\" class=\"headerlink\" title=\"Lambda表达式需要“函数式接口”的支持\"></a>Lambda表达式需要“函数式接口”的支持</h2><p>详情看：函数式接口</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式接口？\"><a href=\"#什么是函数式接口？\" class=\"headerlink\" title=\"什么是函数式接口？\"></a>什么是函数式接口？</h2><p>函数式接口：<br>接口中只有一个抽象方法的接口，称为函数式接口。<br>可以使用注解 @FunctionalInterface 修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span>    <span class=\"comment\">// 表示这是函数式接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFun</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getValue</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;多一个方法就报错</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java8-内置的四大核心函数式接口\"><a href=\"#Java8-内置的四大核心函数式接口\" class=\"headerlink\" title=\"Java8 内置的四大核心函数式接口\"></a>Java8 内置的四大核心函数式接口</h2><p>1）Consumer<T>：消费型接口<br>Void accept(T t)</p>\n<p>2）Supplier<T>：供给型接口<br>T get();</p>\n<p>3）Function&lt;T, R&gt;：函数型接口<br>R apply(T t);</p>\n<p>4）Predicate<T>：断言型接口<br>Boolean test(T t);</p>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><p><img src=\"https://rong0624.gitee.io/images/Java/JDK/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png\" alt=\"其他函数式接口\"></p>\n<h1 id=\"方法引用与构造函数引用\"><a href=\"#方法引用与构造函数引用\" class=\"headerlink\" title=\"方法引用与构造函数引用\"></a>方法引用与构造函数引用</h1><h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用：<br>若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”<br>（可以理解为方法引用是Lambda表达式的另外一种表现方式）<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>方法引用三种语法格式：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：实例对象::实例方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第二种：类::静态方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第三种：类::实例方法名</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。<br>（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法引用：对象::方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);</span><br><span class=\"line\">    Consumer&lt;String&gt; con2 = System.out::print;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup1 = () -&gt; user.getName();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup2 = user::getName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名::静态方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名：实例方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y);</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>语法格式：Class :: method</p>\n<p>注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造器引用：类名::new</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用无参构造</span></span><br><span class=\"line\">    Supplier&lt;User&gt; su1 = () -&gt; <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;User&gt; su2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器</span></span><br><span class=\"line\">    Function&lt;Integer, User&gt; fun1 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器</span></span><br><span class=\"line\">    BiFunction&lt;String, Integer, User&gt; fun2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><h2 id=\"了解Stream-API\"><a href=\"#了解Stream-API\" class=\"headerlink\" title=\"了解Stream API\"></a>了解Stream API</h2><p>Java8中有两大最为重要的改变：<br>第一个是Lambda表达式；<br>第二个则是Stream API（java.util.stream.*）；  </p>\n<p>Stream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。<br>使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。</p>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>流（Stream）到底是什么呢？<br>是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！！！”</p>\n<p>注意：<br>1）Stream 自己不会存储元素<br>2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream<br>3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）</p>\n<h2 id=\"Stream的三个操作步骤\"><a href=\"#Stream的三个操作步骤\" class=\"headerlink\" title=\"Stream的三个操作步骤\"></a>Stream的三个操作步骤</h2><p>1）创建Stream<br>一个数据源（如：集合，数组），获取一个流</p>\n<p>2）中间操作<br>一个中间操作链，对数据源的数据进行处理（过滤，映射）</p>\n<p>3）终止操作（终端操作，返回结果）<br>一个终止操作，执行中间操作链，并且产生结果</p>\n<p>流程图：<br><img src=\"https://rong0624.gitee.io/images/Java/JDK/Stream%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"Stream操作流程图\"></p>\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><h3 id=\"集合创建Stream\"><a href=\"#集合创建Stream\" class=\"headerlink\" title=\"集合创建Stream\"></a>集合创建Stream</h3><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：<br>default Stream<E> stream() : 返回一个顺序流<br>default Stream<E> parallelStream() : 返回一个并行流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// List Set 继承至 Collection</span></span><br><span class=\"line\">    all.stream().forEach(System.out::println);</span><br><span class=\"line\">    all.parallelStream().forEach(System.out::println);</span><br><span class=\"line\">    map.values().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组创建Stream\"><a href=\"#数组创建Stream\" class=\"headerlink\" title=\"数组创建Stream\"></a>数组创建Stream</h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<br>static <T> Stream<T> stream(T[] array): 返回一个流。</p>\n<p>重载形式，能够处理对应基本类型的数组：<br>public static IntStream stream(int[] array)<br>public static LongStream stream(long[] array)<br>public static DoubleStream stream(double[] array)</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] intArr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    String[] strArr = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>&#125;;</span><br><span class=\"line\">    Arrays.stream(intArr).forEach(System.out::println);</span><br><span class=\"line\">    Arrays.stream(strArr).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值创建Stream\"><a href=\"#值创建Stream\" class=\"headerlink\" title=\"值创建Stream\"></a>值创建Stream</h3><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：<br>public static<T> Stream<T> of(T… values) : 返回一个流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).parallel().forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"keyword\">new</span> User(<span class=\"number\">50</span>, <span class=\"string\">&quot;张三&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">60</span>, <span class=\"string\">&quot;李四&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">11</span>, <span class=\"string\">&quot;王五&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数创建Stream（无限流）\"><a href=\"#函数创建Stream（无限流）\" class=\"headerlink\" title=\"函数创建Stream（无限流）\"></a>函数创建Stream（无限流）</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。<br>迭代：<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);</p>\n<p>生成：<br>public static<T> Stream<T> generate(Supplier<T> s);</p>\n<h2 id=\"Stream的中间操作\"><a href=\"#Stream的中间操作\" class=\"headerlink\" title=\"Stream的中间操作\"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!<br>而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。</p>\n<h3 id=\"筛选与切片\"><a href=\"#筛选与切片\" class=\"headerlink\" title=\"筛选与切片\"></a>筛选与切片</h3><p>filter(Predicate p)：接收Lambda，从Stream流中排除某些元素。</p>\n<p>distinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。</p>\n<p>limit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。</p>\n<p>skip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    all.stream().limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().skip(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct()</span><br><span class=\"line\">            .filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .skip(<span class=\"number\">5</span>)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>map(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>\n<p>flatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().map(user -&gt; user.getName())</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    all.stream().flatMap(user -&gt; Stream.of(user.getName()))</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>sorted()：自然排序，使用Comparable默认排序。</p>\n<p>sorted(Comparator comparator)：定制排序，使用Comparator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;ddd&quot;</span>, <span class=\"string\">&quot;zzz&quot;</span>);</span><br><span class=\"line\">    strings.stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    all.stream().sorted((x, y) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.getAge().equals(y.getAge())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x.getName().compareTo(y.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.getAge().compareTo(y.getAge());</span><br><span class=\"line\">    &#125;).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的终止操作\"><a href=\"#Stream的终止操作\" class=\"headerlink\" title=\"Stream的终止操作\"></a>Stream的终止操作</h2><h3 id=\"查找与匹配\"><a href=\"#查找与匹配\" class=\"headerlink\" title=\"查找与匹配\"></a>查找与匹配</h3><p>Find查找：<br>findFirst() ：返回第一个元素<br>findAny() ：返回当前流中的任意元素<br>count() ：返回流中元素总个数<br>max(Comparator c) ：返回流中最大值<br>min(Comparator c) ：返回流中最小值  </p>\n<p>Match匹配：<br>allMatch(Predicate p) ：检查是否匹配所有元素<br>anyMatch(Predicate p) ：检查是否至少匹配一个元素<br>noneMatch(Predicate p) ：检查是否没有匹配所有元素</p>\n<p>Final 查找案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Optional&lt;User&gt; firstOptional = all.stream().findFirst();</span><br><span class=\"line\">    Optional&lt;User&gt; anyOptional = all.stream().findAny();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> count = all.stream().count();</span><br><span class=\"line\">    Optional&lt;User&gt; maxOptional = all.stream().max(Comparator.comparing(User::getAge));</span><br><span class=\"line\">    Optional&lt;Integer&gt; minOptional = all.stream().map(User::getAge).min(Integer::compareTo);</span><br><span class=\"line\">    System.out.println(firstOptional.get());</span><br><span class=\"line\">    System.out.println(anyOptional.get());</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\">    System.out.println(maxOptional.get());</span><br><span class=\"line\">    System.out.println(minOptional.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Match 匹配Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> allMatch = all.stream().allMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> anyMatch = all.stream().anyMatch(x -&gt; UserStatus.B == (x.getStatus()));</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> noneMatch = all.stream().noneMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"规约\"><a href=\"#规约\" class=\"headerlink\" title=\"规约\"></a>规约</h3><p>reduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。</p>\n<p>reduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reduceTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -&gt; &#123;</span><br><span class=\"line\">        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.add(n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h3><p>collect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。</p>\n<p>Collector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：<br><img src=\"https://rong0624.gitee.io/images/Java/JDK/%E5%B8%B8%E8%A7%81%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B9%E6%B3%95.png\" alt=\"常见收集器方法\"></p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 转collection</span></span><br><span class=\"line\">    Set&lt;User&gt; set = all.stream().collect(Collectors.toSet());</span><br><span class=\"line\">    List&lt;Integer&gt; list = all.stream().map(User::getId).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// 转map</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));</span><br><span class=\"line\">    <span class=\"comment\">// 转map，处理key相同的元素</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -&gt; x));</span><br><span class=\"line\">    <span class=\"comment\">// 根据属性分组</span></span><br><span class=\"line\">    Map&lt;String, List&lt;User&gt;&gt; sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"并行流-与-串行流\"><a href=\"#并行流-与-串行流\" class=\"headerlink\" title=\"并行流 与 串行流\"></a>并行流 与 串行流</h1><h1 id=\"新时间日期API\"><a href=\"#新时间日期API\" class=\"headerlink\" title=\"新时间日期API\"></a>新时间日期API</h1><p>在旧版的java中，日期时间API存在诸多问题，其中有：<br>1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一<br>2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。<br>3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</p>\n<p><strong>因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。</strong></p>\n<p>Java8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：<br>Local（本地）  简化了日期的处理，没有时区的问题。<br>Zoned（时区）  通过制定的时区处理日期时间。<br>新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>\n<h2 id=\"常用类简介\"><a href=\"#常用类简介\" class=\"headerlink\" title=\"常用类简介\"></a>常用类简介</h2><p>Instat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>Period：用于计算日期间隔<br>Duration：用于计算时间间隔  </p>\n<p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime</p>\n<p>Zoneld：时区<br>ZonedDateTime：表示日期+时间+时区值</p>\n<p>DateTimeFormatter：用于日期时间的格式化</p>\n<h2 id=\"本地化日期时间API\"><a href=\"#本地化日期时间API\" class=\"headerlink\" title=\"本地化日期时间API\"></a>本地化日期时间API</h2><p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime</p>\n<p>公共API：<br>now()：静态方法，根据当前时间创建对象。<br>of()：静态方法，根据指定的日期/时间创建对象。</p>\n<p>LocalDate 与 LocalDateTime公共API：<br>getYear()：获取年份<br>getMonth()：获取月份，返回一个Month的枚举<br>getMonthValue()：获取月份<br>getDayOfMonth()：获取当前月份天数【1-31】<br>getDayOfYear()：获取当前年份天数【1-366】<br>getDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举<br>plus()：添加一个 Duration 或 Period<br>minus()：删除一个 Duration 或 Period<br>plusDays(); plusWeeks(); plusMonths(); plusYears()：<br>向当前对象，新增几天，几周，几月，几年。<br>minusDays(); minusWeeks(); minusMonths(); minusYears()：<br>向当前对象，减去几天，几周，几月，几年。<br>withDayOfMonth()：修改当前月的天数<br>withDayOfYear()：修改当前年的天数</p>\n<p>LocalTime 与 LocalDateTime公共API：<br>getHour()：获取小时<br>getMinute()：获取分钟<br>getSecond()：获取秒</p>\n<h2 id=\"时区日期时间API\"><a href=\"#时区日期时间API\" class=\"headerlink\" title=\"时区日期时间API\"></a>时区日期时间API</h2><h2 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h2><p>Java8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。</p>\n<p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。</p>\n<p>Instant API方法：<br>getEpochSecond()：获取秒数<br>toEpochMilli()：获取毫秒数<br>getNano()：获取纳秒数<br>System.currentTimeMillis()：获取时间戳，毫秒级别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant instant = Instant.now();</span><br><span class=\"line\"><span class=\"comment\">// 获取秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentSecond = instant.getEpochSecond();</span><br><span class=\"line\"><span class=\"comment\">// 获取毫秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentMilli = instant.toEpochMilli();</span><br><span class=\"line\"><span class=\"comment\">// 时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentTimeMilli = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(currentSecond);</span><br><span class=\"line\">System.out.println(currentMilli);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\">System.out.println(currentTimeMilli);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Period-日期间隔\"><a href=\"#Period-日期间隔\" class=\"headerlink\" title=\"Period 日期间隔\"></a>Period 日期间隔</h2><p>Java8新提供Period来表示一个日期段，日期间隔。</p>\n<p>Period API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Period实例<br>getYears();            获取这段日期的相隔年数<br>getMonths();         获取单纯月份比较，相隔几月<br>getDays();             获取单纯天数比较，相隔几天</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1999-06-24</span></span><br><span class=\"line\">LocalDate from = LocalDate.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2020-08-20</span></span><br><span class=\"line\">LocalDate to = LocalDate.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Period period = Period.between(from, to);</span><br><span class=\"line\"><span class=\"keyword\">int</span> years = period.getYears(); <span class=\"comment\">// 这段日期的相隔年数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> months = period.getMonths(); <span class=\"comment\">// 单纯月份比较，相隔几月</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> days = period.getDays(); <span class=\"comment\">// 单纯天数比较，相隔几天</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Duration-时间间隔\"><a href=\"#Duration-时间间隔\" class=\"headerlink\" title=\"Duration 时间间隔\"></a>Duration 时间间隔</h2><p>Java8新提供Duration来表示一个时间段，时间间隔。</p>\n<p>Duration API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Duration实例<br>toDays()：        获取这段时间的天数<br>toHours()：        获取这段时间的小时<br>toMinutes()：        获取这段时间的分钟数<br>getSeconds()：    获取这段时间的秒数<br>toMillis()：        获取这段时间的毫秒数<br>toNanos()：        获取这段时间的纳秒数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">durationTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1999-06-24 00:00:00</span></span><br><span class=\"line\">    LocalDateTime from = LocalDateTime.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2020-08-20 00:00:00</span></span><br><span class=\"line\">    LocalDateTime to = LocalDateTime.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Duration duration = Duration.between(from, to);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> days = duration.toDays();<span class=\"comment\">// 这段时间的天数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> hours = duration.toHours();<span class=\"comment\">// 这段时间的小时</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> minutes  = duration.toMinutes();<span class=\"comment\">// 这段时间的分钟数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> seconds = duration.getSeconds();<span class=\"comment\">// 这段时间的秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> milliSeconds = duration.toMillis();<span class=\"comment\">// 这段时间的毫秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = duration.toNanos();<span class=\"comment\">// 这段时间的纳秒数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(days);</span><br><span class=\"line\">    System.out.println(hours);</span><br><span class=\"line\">    System.out.println(minutes);</span><br><span class=\"line\">    System.out.println(seconds);</span><br><span class=\"line\">    System.out.println(milliSeconds);</span><br><span class=\"line\">    System.out.println(nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析与格式化\"><a href=\"#解析与格式化\" class=\"headerlink\" title=\"解析与格式化\"></a>解析与格式化</h2><p>格式化时间：<br>Java8新提供DateTimeFormatter来格式化时间。</p>\n<p>解析时间：<br>使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。</p>\n<p>格式化时间demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">String s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);</span><br><span class=\"line\">String s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);</span><br><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">String format = formatter.format(now);</span><br></pre></td></tr></table></figure>\n\n<p>解析时间Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate localDate = LocalDate.parse(<span class=\"string\">&quot;2020-10-01&quot;</span>);</span><br><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01T15:15:15&quot;</span>);</span><br><span class=\"line\">LocalDateTime copyLocalDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01 15:15:15&quot;</span>, DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"接口中的默认方法-与-静态方法\"><a href=\"#接口中的默认方法-与-静态方法\" class=\"headerlink\" title=\"接口中的默认方法 与 静态方法\"></a>接口中的默认方法 与 静态方法</h1><h2 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h2><p>Java8新增了接口的默认方法。<br>简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>\n<p>为什么要有这个特性：<br>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。<br>然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。</p>\n<p>接口默认方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface default method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认方法的问题\"><a href=\"#默认方法的问题\" class=\"headerlink\" title=\"默认方法的问题\"></a>默认方法的问题</h2><p>如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p>\n<p>接口冲突：<br>如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。</p>\n<p>类优先原则：<br>如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。</p>\n<p>接口冲突案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是狗，汪汪汪&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是猫，喵喵喵&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dog.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        Cat.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是demo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类优先原则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是baseClass&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>Java8的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>\n<p>接口静态方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface static method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Optional-类\"><a href=\"#Optional-类\" class=\"headerlink\" title=\"Optional 类\"></a>Optional 类</h1><h2 id=\"Optional-类简介\"><a href=\"#Optional-类简介\" class=\"headerlink\" title=\"Optional 类简介\"></a>Optional 类简介</h2><p>Optional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。</p>\n<p>Optional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。</p>\n<p>Optional 类的引入，可以很好的解决空指针异常。<br>Optional 类可以很好的判断一个值存在或者不存在。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional.get()               获取Optional容器包含的值，如果值为null，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常</span><br><span class=\"line\">Optional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例</span><br><span class=\"line\">Optional .empty()\t\t\t创建一个空的Optional 实例</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false</span><br><span class=\"line\">OrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t</span><br><span class=\"line\">OrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值</span><br><span class=\"line\">Map(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()</span><br><span class=\"line\">flatMap(function f)\t\t\t与map类型，要求返回Optional</span><br></pre></td></tr></table></figure>\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// optional.of创建optional实例，t不能为空，为null，抛出异常</span></span><br><span class=\"line\">    Optional&lt;Integer&gt; integerOptional = Optional.of(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.ofNullable创建optional实例，t如果为空，返回一个空的optional</span></span><br><span class=\"line\">    Optional&lt;User&gt; userOptional = Optional.ofNullable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.empty创建一个空值得optional实例</span></span><br><span class=\"line\">    Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        // get，optional如果值为空，抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//        integerOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        userOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        empty.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(userOptional.isPresent());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果值不为空，则返回，如果为空，则返回给定的值</span></span><br><span class=\"line\">    Integer integer = integerOptional.orElse(<span class=\"number\">3</span>);</span><br><span class=\"line\">    User user = userOptional.orElse(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">    Object o = empty.orElse(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;100&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(integer);</span><br><span class=\"line\">    System.out.println(user);</span><br><span class=\"line\">    System.out.println(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"AMQP","date":"2021-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# AMQP模型\n\n## AMQP模型\n\n![AMQP模型](https://rong0624.gitee.io/images/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 工作流程\n\n### 生产者工作流程\n\n![生产者工作流程](https://rong0624.gitee.io/images/MQ/1626761231258.jpg)\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n### 消费者工作流程\n\n![消费者工作流程](https://rong0624.gitee.io/images/MQ/1626761231333.jpg)\n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n# Exchange交换机\n\n交换机是用来发送消息的AMQP实体。\n交换机拿到一个消息之后将它路由给一个或零个队列。\n它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。\n\nAMQP 0-9-1的代理提供了四种交换机：  \n![交换机类型](https://rong0624.gitee.io/images/MQ/交换机类型.png)  \n\n除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  \nName  \nDurability（消息代理重启后，交换机是否还存在）  \nAuto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  \nArguments（依赖代理本身）  \n\n交换机可以有两个状态：持久（durable），暂存（transient）。  \n持久化的交换机会在消息代理（broker）重启后依旧存在。  \n暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。  \n并不是所有的应用场景都需要持久化的交换机。\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：  \n当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.gitee.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件  \n2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端  \n3）分发系统使用它来广播各种状态和配置更新  \n4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.gitee.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.gitee.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。  \n头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。  \n路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。\n如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# Message消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息消费\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","source":"_posts/oyr/MQ/AMQP.md","raw":"---\ntitle: AMQP\ndate: 2021-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n---\n\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# AMQP模型\n\n## AMQP模型\n\n![AMQP模型](https://rong0624.gitee.io/images/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 工作流程\n\n### 生产者工作流程\n\n![生产者工作流程](https://rong0624.gitee.io/images/MQ/1626761231258.jpg)\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n### 消费者工作流程\n\n![消费者工作流程](https://rong0624.gitee.io/images/MQ/1626761231333.jpg)\n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n# Exchange交换机\n\n交换机是用来发送消息的AMQP实体。\n交换机拿到一个消息之后将它路由给一个或零个队列。\n它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。\n\nAMQP 0-9-1的代理提供了四种交换机：  \n![交换机类型](https://rong0624.gitee.io/images/MQ/交换机类型.png)  \n\n除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  \nName  \nDurability（消息代理重启后，交换机是否还存在）  \nAuto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  \nArguments（依赖代理本身）  \n\n交换机可以有两个状态：持久（durable），暂存（transient）。  \n持久化的交换机会在消息代理（broker）重启后依旧存在。  \n暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。  \n并不是所有的应用场景都需要持久化的交换机。\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：  \n当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.gitee.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件  \n2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端  \n3）分发系统使用它来广播各种状态和配置更新  \n4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.gitee.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.gitee.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。  \n头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。  \n路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。\n如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# Message消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息消费\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","slug":"oyr/MQ/AMQP","published":1,"updated":"2021-10-26T10:30:26.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86i001qcst75ugrf9ul","content":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h1 id=\"AMQP模型\"><a href=\"#AMQP模型\" class=\"headerlink\" title=\"AMQP模型\"></a>AMQP模型</h1><h2 id=\"AMQP模型-1\"><a href=\"#AMQP模型-1\" class=\"headerlink\" title=\"AMQP模型\"></a>AMQP模型</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"生产者工作流程\"><a href=\"#生产者工作流程\" class=\"headerlink\" title=\"生产者工作流程\"></a>生产者工作流程</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/1626761231258.jpg\" alt=\"生产者工作流程\"></p>\n<p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<h3 id=\"消费者工作流程\"><a href=\"#消费者工作流程\" class=\"headerlink\" title=\"消费者工作流程\"></a>消费者工作流程</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/1626761231333.jpg\" alt=\"消费者工作流程\"></p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><p>交换机是用来发送消息的AMQP实体。<br>交换机拿到一个消息之后将它路由给一个或零个队列。<br>它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。</p>\n<p>AMQP 0-9-1的代理提供了四种交换机：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B.png\" alt=\"交换机类型\">  </p>\n<p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：<br>Name<br>Durability（消息代理重启后，交换机是否还存在）<br>Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）<br>Arguments（依赖代理本身）  </p>\n<p>交换机可以有两个状态：持久（durable），暂存（transient）。<br>持久化的交换机会在消息代理（broker）重启后依旧存在。<br>暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。<br>并不是所有的应用场景都需要持久化的交换机。</p>\n<h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：<br>当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：<br>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件<br>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端<br>3）分发系统使用它来广播各种状态和配置更新<br>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</p>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。<br>头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。<br>路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。<br>如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"Message消息机制\"><a href=\"#Message消息机制\" class=\"headerlink\" title=\"Message消息机制\"></a>Message消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h2><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>","more":"<h1 id=\"AMQP模型\"><a href=\"#AMQP模型\" class=\"headerlink\" title=\"AMQP模型\"></a>AMQP模型</h1><h2 id=\"AMQP模型-1\"><a href=\"#AMQP模型-1\" class=\"headerlink\" title=\"AMQP模型\"></a>AMQP模型</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"生产者工作流程\"><a href=\"#生产者工作流程\" class=\"headerlink\" title=\"生产者工作流程\"></a>生产者工作流程</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/1626761231258.jpg\" alt=\"生产者工作流程\"></p>\n<p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<h3 id=\"消费者工作流程\"><a href=\"#消费者工作流程\" class=\"headerlink\" title=\"消费者工作流程\"></a>消费者工作流程</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/1626761231333.jpg\" alt=\"消费者工作流程\"></p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><p>交换机是用来发送消息的AMQP实体。<br>交换机拿到一个消息之后将它路由给一个或零个队列。<br>它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。</p>\n<p>AMQP 0-9-1的代理提供了四种交换机：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B.png\" alt=\"交换机类型\">  </p>\n<p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：<br>Name<br>Durability（消息代理重启后，交换机是否还存在）<br>Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）<br>Arguments（依赖代理本身）  </p>\n<p>交换机可以有两个状态：持久（durable），暂存（transient）。<br>持久化的交换机会在消息代理（broker）重启后依旧存在。<br>暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。<br>并不是所有的应用场景都需要持久化的交换机。</p>\n<h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：<br>当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：<br>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件<br>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端<br>3）分发系统使用它来广播各种状态和配置更新<br>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</p>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。<br>头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。<br>路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。<br>如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"Message消息机制\"><a href=\"#Message消息机制\" class=\"headerlink\" title=\"Message消息机制\"></a>Message消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h2><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>"},{"title":"ActiveMQ","date":"2021-06-15T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# ActiveMQ基础\n\n## 简介\n\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。  \nActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。  \n尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。\n\n## 特点\n\n1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议  \n2）完全支持JMS客户端和Message Broker中的企业集成模式  \n3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标  \n4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息  \n5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置  \n6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计  \n7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递  \n8）可以用作内存JMS提供程序，非常适合单元测试JMS  \n9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输  \n10）使用JDBC和高性能日志支持非常快速的持久性\n\n# ActiveMQ的安装\n\n# ActiveMQ的消息形式\n\n对于消息的传递有两种类型：  \n1）点对点（p2p），即一个生产者和一个消费者一一对应；  \n2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；  \n如图所示：  \n![ActiveMQ的消息类型](https://rong0624.gitee.io/images/MQ/ActiveMQ/ActiveMQ的消息类型.png)\n\nJMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。\n* StreamMessage -- Java原始值的数据流\n* MapMessage -- 一套名称-值对\n* TextMessage -- 一个字符串对象\n* ObjectMessage -- 一个序列化的 Java对象\n* BytesMessage -- 一个字节的数据流\n\n# ActiveMQ的使用\n\n导入maven依赖：\n```xml\n<!-- activemq依赖的jar -->\n<dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-all</artifactId>\n    <version>5.11.2</version>\n</dependency>\n```\n\n## Queue\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testQueueProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t//brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。\n\t\t//参数：队列的名称。\n\t\tQueue queue = session.createQueue(\"test-queue\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(queue);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*TextMessage message = new ActiveMQTextMessage();\n\t\tmessage.setText(\"hello activeMq,this is my first test.\");*/\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my first test.\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n## Topic\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testTopicProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t// brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。\n\t\t// 参数：话题的名称。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(topic);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*\n\t\t * TextMessage message = new ActiveMQTextMessage(); message.setText(\n\t\t * \"hello activeMq,this is my first test.\");\n\t\t */\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my topic test\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n消费者：接收消息。\n\n使用步骤：\n第一步：创建一个ConnectionFactory对象。  \n第二步：从ConnectionFactory对象中获得一个Connection对象。  \n第三步：开启连接。调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。  \n第六步：使用Session对象创建一个Consumer对象。  \n第七步：接收消息。  \n第八步：打印消息。  \n第九步：关闭资源\n\n```java\n    @Test\n\tpublic void testTopicConsumer() throws Exception {\n\t\t// 第一步：创建一个ConnectionFactory对象。\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：从ConnectionFactory对象中获得一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接。调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Consumer对象。\n\t\tMessageConsumer consumer = session.createConsumer(topic);\n\t\t// 第七步：接收消息。\n\t\tconsumer.setMessageListener(new MessageListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onMessage(Message message) {\n\t\t\t\ttry {\n\t\t\t\t\tTextMessage textMessage = (TextMessage) message;\n\t\t\t\t\tString text = null;\n\t\t\t\t\t// 取消息的内容\n\t\t\t\t\ttext = textMessage.getText();\n\t\t\t\t\t// 第八步：打印消息。\n\t\t\t\t\tSystem.out.println(text);\n\t\t\t\t} catch (JMSException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"topic的消费端03。。。。。\");\n\t\t// 等待键盘输入\n\t\tSystem.in.read();\n\t\t// 第九步：关闭资源\n\t\tconsumer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n# ActiveMQ消息数据持久化\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\n两种选择：非持久性模式/持久性模式  \n1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。  \n2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\nPERSISTENT：\n指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\n\nNON_PERSISTENT:\n不要求JMS provider持久保存消息\n\n在消息提供者设置消息持久化：`producer.setDeliveryMode(DeliveryMode.PERSISTENT);`\n\n# JMS可靠消息机制\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了。   \n消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。  \n改参数有三个可选值：\n1. Session.AUTO_ACKNOWLEDGE：自动签收  \n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n2. Session.CLIENT_ACKNOWLEDGE：手动签收  \n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n3. Session.DUPS_ACKNOWLEDGE：  \n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n4. 带事物的session：  \n完成操作后需要手动的commit\n\n","source":"_posts/oyr/MQ/ActiveMQ.md","raw":"---\ntitle: ActiveMQ\ndate: 2021-06-16 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n\t- MQ\n\t- 中间件\n---\n\n# ActiveMQ基础\n\n## 简介\n\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。  \nActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。  \n尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。\n\n## 特点\n\n1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议  \n2）完全支持JMS客户端和Message Broker中的企业集成模式  \n3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标  \n4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息  \n5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置  \n6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计  \n7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递  \n8）可以用作内存JMS提供程序，非常适合单元测试JMS  \n9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输  \n10）使用JDBC和高性能日志支持非常快速的持久性\n\n# ActiveMQ的安装\n\n# ActiveMQ的消息形式\n\n对于消息的传递有两种类型：  \n1）点对点（p2p），即一个生产者和一个消费者一一对应；  \n2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；  \n如图所示：  \n![ActiveMQ的消息类型](https://rong0624.gitee.io/images/MQ/ActiveMQ/ActiveMQ的消息类型.png)\n\nJMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。\n* StreamMessage -- Java原始值的数据流\n* MapMessage -- 一套名称-值对\n* TextMessage -- 一个字符串对象\n* ObjectMessage -- 一个序列化的 Java对象\n* BytesMessage -- 一个字节的数据流\n\n# ActiveMQ的使用\n\n导入maven依赖：\n```xml\n<!-- activemq依赖的jar -->\n<dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-all</artifactId>\n    <version>5.11.2</version>\n</dependency>\n```\n\n## Queue\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testQueueProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t//brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。\n\t\t//参数：队列的名称。\n\t\tQueue queue = session.createQueue(\"test-queue\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(queue);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*TextMessage message = new ActiveMQTextMessage();\n\t\tmessage.setText(\"hello activeMq,this is my first test.\");*/\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my first test.\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n## Topic\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testTopicProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t// brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。\n\t\t// 参数：话题的名称。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(topic);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*\n\t\t * TextMessage message = new ActiveMQTextMessage(); message.setText(\n\t\t * \"hello activeMq,this is my first test.\");\n\t\t */\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my topic test\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n消费者：接收消息。\n\n使用步骤：\n第一步：创建一个ConnectionFactory对象。  \n第二步：从ConnectionFactory对象中获得一个Connection对象。  \n第三步：开启连接。调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。  \n第六步：使用Session对象创建一个Consumer对象。  \n第七步：接收消息。  \n第八步：打印消息。  \n第九步：关闭资源\n\n```java\n    @Test\n\tpublic void testTopicConsumer() throws Exception {\n\t\t// 第一步：创建一个ConnectionFactory对象。\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：从ConnectionFactory对象中获得一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接。调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Consumer对象。\n\t\tMessageConsumer consumer = session.createConsumer(topic);\n\t\t// 第七步：接收消息。\n\t\tconsumer.setMessageListener(new MessageListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onMessage(Message message) {\n\t\t\t\ttry {\n\t\t\t\t\tTextMessage textMessage = (TextMessage) message;\n\t\t\t\t\tString text = null;\n\t\t\t\t\t// 取消息的内容\n\t\t\t\t\ttext = textMessage.getText();\n\t\t\t\t\t// 第八步：打印消息。\n\t\t\t\t\tSystem.out.println(text);\n\t\t\t\t} catch (JMSException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"topic的消费端03。。。。。\");\n\t\t// 等待键盘输入\n\t\tSystem.in.read();\n\t\t// 第九步：关闭资源\n\t\tconsumer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n# ActiveMQ消息数据持久化\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\n两种选择：非持久性模式/持久性模式  \n1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。  \n2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\nPERSISTENT：\n指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\n\nNON_PERSISTENT:\n不要求JMS provider持久保存消息\n\n在消息提供者设置消息持久化：`producer.setDeliveryMode(DeliveryMode.PERSISTENT);`\n\n# JMS可靠消息机制\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了。   \n消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。  \n改参数有三个可选值：\n1. Session.AUTO_ACKNOWLEDGE：自动签收  \n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n2. Session.CLIENT_ACKNOWLEDGE：手动签收  \n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n3. Session.DUPS_ACKNOWLEDGE：  \n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n4. 带事物的session：  \n完成操作后需要手动的commit\n\n","slug":"oyr/MQ/ActiveMQ","published":1,"updated":"2021-10-26T10:30:26.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86j001ucst7a5q32ijx","content":"<h1 id=\"ActiveMQ基础\"><a href=\"#ActiveMQ基础\" class=\"headerlink\" title=\"ActiveMQ基础\"></a>ActiveMQ基础</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。<br>ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。<br>尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议<br>2）完全支持JMS客户端和Message Broker中的企业集成模式<br>3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标<br>4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息<br>5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置<br>6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计<br>7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递<br>8）可以用作内存JMS提供程序，非常适合单元测试JMS<br>9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输<br>10）使用JDBC和高性能日志支持非常快速的持久性</p>\n<h1 id=\"ActiveMQ的安装\"><a href=\"#ActiveMQ的安装\" class=\"headerlink\" title=\"ActiveMQ的安装\"></a>ActiveMQ的安装</h1><h1 id=\"ActiveMQ的消息形式\"><a href=\"#ActiveMQ的消息形式\" class=\"headerlink\" title=\"ActiveMQ的消息形式\"></a>ActiveMQ的消息形式</h1><p>对于消息的传递有两种类型：<br>1）点对点（p2p），即一个生产者和一个消费者一一对应；<br>2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；<br>如图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/ActiveMQ/ActiveMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.png\" alt=\"ActiveMQ的消息类型\"></p>\n<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>\n<ul>\n<li>StreamMessage – Java原始值的数据流</li>\n<li>MapMessage – 一套名称-值对</li>\n<li>TextMessage – 一个字符串对象</li>\n<li>ObjectMessage – 一个序列化的 Java对象</li>\n<li>BytesMessage – 一个字节的数据流</li>\n</ul>\n<h1 id=\"ActiveMQ的使用\"><a href=\"#ActiveMQ的使用\" class=\"headerlink\" title=\"ActiveMQ的使用\"></a>ActiveMQ的使用</h1><p>导入maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- activemq依赖的jar --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.activemq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activemq-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.11.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><h3 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testQueueProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">//brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：队列的名称。</span></span><br><span class=\"line\">\tQueue queue = session.createQueue(<span class=\"string\">&quot;test-queue&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(queue);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*TextMessage message = new ActiveMQTextMessage();</span></span><br><span class=\"line\"><span class=\"comment\">\tmessage.setText(&quot;hello activeMq,this is my first test.&quot;);*/</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my first test.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h3 id=\"Producer-1\"><a href=\"#Producer-1\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">// brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 参数：话题的名称。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * TextMessage message = new ActiveMQTextMessage(); message.setText(</span></span><br><span class=\"line\"><span class=\"comment\">\t * &quot;hello activeMq,this is my first test.&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my topic test&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p>消费者：接收消息。</p>\n<p>使用步骤：<br>第一步：创建一个ConnectionFactory对象。<br>第二步：从ConnectionFactory对象中获得一个Connection对象。<br>第三步：开启连接。调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。<br>第六步：使用Session对象创建一个Consumer对象。<br>第七步：接收消息。<br>第八步：打印消息。<br>第九步：关闭资源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicConsumer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建一个ConnectionFactory对象。</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：从ConnectionFactory对象中获得一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接。调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Consumer对象。</span></span><br><span class=\"line\">\tMessageConsumer consumer = session.createConsumer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：接收消息。</span></span><br><span class=\"line\">\tconsumer.setMessageListener(<span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTextMessage textMessage = (TextMessage) message;</span><br><span class=\"line\">\t\t\t\tString text = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 取消息的内容</span></span><br><span class=\"line\">\t\t\t\ttext = textMessage.getText();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 第八步：打印消息。</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(text);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (JMSException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;topic的消费端03。。。。。&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待键盘输入</span></span><br><span class=\"line\">\tSystem.in.read();</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源</span></span><br><span class=\"line\">\tconsumer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ActiveMQ消息数据持久化\"><a href=\"#ActiveMQ消息数据持久化\" class=\"headerlink\" title=\"ActiveMQ消息数据持久化\"></a>ActiveMQ消息数据持久化</h1><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>两种选择：非持久性模式/持久性模式<br>1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。<br>2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</p>\n<p>PERSISTENT：<br>指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</p>\n<p>NON_PERSISTENT:<br>不要求JMS provider持久保存消息</p>\n<p>在消息提供者设置消息持久化：<code>producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></p>\n<h1 id=\"JMS可靠消息机制\"><a href=\"#JMS可靠消息机制\" class=\"headerlink\" title=\"JMS可靠消息机制\"></a>JMS可靠消息机制</h1><p>JMS消息只有在被确认之后，才认为已经被成功的消费了。<br>消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。<br>改参数有三个可选值：</p>\n<ol>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n<li>带事物的session：<br>完成操作后需要手动的commit</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ActiveMQ基础\"><a href=\"#ActiveMQ基础\" class=\"headerlink\" title=\"ActiveMQ基础\"></a>ActiveMQ基础</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。<br>ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。<br>尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议<br>2）完全支持JMS客户端和Message Broker中的企业集成模式<br>3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标<br>4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息<br>5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置<br>6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计<br>7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递<br>8）可以用作内存JMS提供程序，非常适合单元测试JMS<br>9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输<br>10）使用JDBC和高性能日志支持非常快速的持久性</p>\n<h1 id=\"ActiveMQ的安装\"><a href=\"#ActiveMQ的安装\" class=\"headerlink\" title=\"ActiveMQ的安装\"></a>ActiveMQ的安装</h1><h1 id=\"ActiveMQ的消息形式\"><a href=\"#ActiveMQ的消息形式\" class=\"headerlink\" title=\"ActiveMQ的消息形式\"></a>ActiveMQ的消息形式</h1><p>对于消息的传递有两种类型：<br>1）点对点（p2p），即一个生产者和一个消费者一一对应；<br>2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；<br>如图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/ActiveMQ/ActiveMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.png\" alt=\"ActiveMQ的消息类型\"></p>\n<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>\n<ul>\n<li>StreamMessage – Java原始值的数据流</li>\n<li>MapMessage – 一套名称-值对</li>\n<li>TextMessage – 一个字符串对象</li>\n<li>ObjectMessage – 一个序列化的 Java对象</li>\n<li>BytesMessage – 一个字节的数据流</li>\n</ul>\n<h1 id=\"ActiveMQ的使用\"><a href=\"#ActiveMQ的使用\" class=\"headerlink\" title=\"ActiveMQ的使用\"></a>ActiveMQ的使用</h1><p>导入maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- activemq依赖的jar --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.activemq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activemq-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.11.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><h3 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testQueueProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">//brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：队列的名称。</span></span><br><span class=\"line\">\tQueue queue = session.createQueue(<span class=\"string\">&quot;test-queue&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(queue);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*TextMessage message = new ActiveMQTextMessage();</span></span><br><span class=\"line\"><span class=\"comment\">\tmessage.setText(&quot;hello activeMq,this is my first test.&quot;);*/</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my first test.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h3 id=\"Producer-1\"><a href=\"#Producer-1\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">// brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 参数：话题的名称。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * TextMessage message = new ActiveMQTextMessage(); message.setText(</span></span><br><span class=\"line\"><span class=\"comment\">\t * &quot;hello activeMq,this is my first test.&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my topic test&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p>消费者：接收消息。</p>\n<p>使用步骤：<br>第一步：创建一个ConnectionFactory对象。<br>第二步：从ConnectionFactory对象中获得一个Connection对象。<br>第三步：开启连接。调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。<br>第六步：使用Session对象创建一个Consumer对象。<br>第七步：接收消息。<br>第八步：打印消息。<br>第九步：关闭资源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicConsumer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建一个ConnectionFactory对象。</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：从ConnectionFactory对象中获得一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接。调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Consumer对象。</span></span><br><span class=\"line\">\tMessageConsumer consumer = session.createConsumer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：接收消息。</span></span><br><span class=\"line\">\tconsumer.setMessageListener(<span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTextMessage textMessage = (TextMessage) message;</span><br><span class=\"line\">\t\t\t\tString text = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 取消息的内容</span></span><br><span class=\"line\">\t\t\t\ttext = textMessage.getText();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 第八步：打印消息。</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(text);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (JMSException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;topic的消费端03。。。。。&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待键盘输入</span></span><br><span class=\"line\">\tSystem.in.read();</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源</span></span><br><span class=\"line\">\tconsumer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ActiveMQ消息数据持久化\"><a href=\"#ActiveMQ消息数据持久化\" class=\"headerlink\" title=\"ActiveMQ消息数据持久化\"></a>ActiveMQ消息数据持久化</h1><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>两种选择：非持久性模式/持久性模式<br>1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。<br>2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</p>\n<p>PERSISTENT：<br>指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</p>\n<p>NON_PERSISTENT:<br>不要求JMS provider持久保存消息</p>\n<p>在消息提供者设置消息持久化：<code>producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></p>\n<h1 id=\"JMS可靠消息机制\"><a href=\"#JMS可靠消息机制\" class=\"headerlink\" title=\"JMS可靠消息机制\"></a>JMS可靠消息机制</h1><p>JMS消息只有在被确认之后，才认为已经被成功的消费了。<br>消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。<br>改参数有三个可选值：</p>\n<ol>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n<li>带事物的session：<br>完成操作后需要手动的commit</li>\n</ol>\n"},{"title":"Kafka","date":"2021-08-12T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/MQ/Kafka.md","raw":"---\ntitle: Kafka\ndate: 2021-08-13 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n---\n","slug":"oyr/MQ/Kafka","published":1,"updated":"2021-10-27T02:47:25.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86k001wcst75c5e29ar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JMS","date":"2021-06-14T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# JMS简介\n\n## JMS是什么\n\nJMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。  \nJava消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。\n\nJMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n<!-- more -->\n\n## 为什么需要JMS\n\n在JAVA中，如果两个应用程序之间对各自都不了解，甚至这两个程序可能部署在不同的大洲上，那么它们之间如何发送消息呢？举个例子，一个应用程序A部署在印度，另一个应用程序部署在美国，然后每当A触发某件事后，B想从A获取一些更新信息。\n当然，也有可能不止一个B对A的更新信息感兴趣，可能会有N个类似B的应用程序想从A中获取更新的信息。\n\n在这种情况下，JAVA提供了最佳的解决方案-JMS，完美解决了上面讨论的问题。\n\nJMS同样适用于基于事件的应用程序，如聊天服务，它需要一种发布事件机制向所有与服务器连接的客户端发送消息。JMS与RMI不同，发送消息的时候，接收者不需要在线。服务器发送了消息，然后就不管了；\n等到客户端上线的时候，能保证接收到服务器发送的消息。这是一个很强大的解决方案，能处理当今世界很多普遍问题。\n\n## JMS的优势\n\n1）异步：JMS天生就是异步的，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端。\n2）可靠：JMS保证消息只会递送一次。大家都遇到过重复创建消息问题，而JMS能帮你避免该问题，只是避免而不是杜绝，所以在一些糟糕的环境下还是有可能会出现重复。\n\n# JMS体系架构\n\nJMS由以下元素组成。\n\n1）JMS提供者   \n连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。\n\n2）JMS客户   \n生产或消费消息的基于Java的应用程序或对象。\n\n3）JMS生产者   \n创建并发送消息的JMS客户。\n\n4）JMS消费者   \n接收消息的JMS客户。\n\n5）JMS消息   \n包括可以在JMS客户之间传递的数据的对象\n\n6）JMS队列   \n一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。\n\n7）JMS主题 \n一种支持发送消息给多个订阅者的机制。\n\n# JMS消息模型\n\n## JMS消息模型\n\n1）Point-to-Point(P2P)  \n2）Publish/Subscribe(Pub/Sub)\n\n在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。\n任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。\n\n## P2P（点对点）\n\n![P2P模式](https://rong0624.gitee.io/images/MQ/JMS/397872-20170315231815541-1387998695.jpeg)\n\n### 涉及的概念\n\n1）消息队列(Queue)    \n2）提供者(Sender)  \n3）消费者(Receiver)  \n4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\n### P2P的特点\n\n1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)  \n2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列  \n3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。  \n4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。  \n5）消费者在成功接收消息之后需向队列应答成功  \n\n**注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。**\n\n## Pub/Sub（发布/订阅模式）\n\n![Pub/Sub模式](https://rong0624.gitee.io/images/MQ/JMS/397872-20170315232442979-934776600.jpeg)\n\n### 涉及的概念\n\n1）主题（Topic）  \n2）发布者（Publisher）  \n3）订阅者（Subscriber）  \n4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\n### Pub/Sub的特点\n\n1）每个消息可以有多个消费者。  \n2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。  \n3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。  \n4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。  \n5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。  \n6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。\n\n**如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型**\n\n# JMS消息\n\n## JMS消息结构\n\nJMS客户端使用JMS消息与系统通讯，JMS消息虽然格式简单但是非常灵活。\nJMS消息由三部分组成：消息头，消息属性，消息体;\n\n### 消息头\n\n设置消息的通用属性,类似http消息头,可以设置消息的过期时间,是否持久化,投递的目的地(队列名/topic名),最主要的设置消息的唯一标识messageId来标识消息的唯一性(JMS会模认生成,你也可以使用自己的id格式来生成唯一标识)。\n\nJMS消息头预定义了若干字段用于客户端与JMS提供者之间识别和发送消息，预编译头如下：  \n- JMSDestination：消息发送的目的地，主要是指Queue和Topic，由session创建而由生产者的send方法设置。\n- JMSDeliveryMode：传送模式:有两种即久模式和非持久模式。一条持久性的消息应该被传输\"一次仅仅一次\"，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。一条非持久的消息最多会传递一次，这意味着服务器出现故障，该消息将永远丢失。由session穿件由消息生产者的send方法设置。\n- JMSMessageID：唯一识别每个消息的标识，由JMS消息生产者产生。由send方法设置。\n- JMSTimestamp：一个JMS Provider在调用send()方法时自动设置，它是消息被发送和消费者实际接收的时间差。由客户端设置。\n- JMSCorrelationID：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。由客户端设置\n- JMSReplyTo：提供本消息回复消息的目的地址,由客户端设置\n- JMSRedelivered：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收(acknowledged)。如果该消息被重新传送，JMSRedelivered=true 否则 JMSRedelivered=flase 。由JMS Provider设置\n- JMSType：消息类型的标识符，由客户端设置\n- JMSExpiration：消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT的时间值。如果timeToLive值等于零，则JMSExpiration被设置为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。由send方法设置\n- JMSPriority：消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息。JMS不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达，默认是4级。由send方法设置\n一个消息的消息头有这些属性，我们可以按照需要对这个消息的消息进行设计，在将这个消息使用消息生产者的send（）方法发送到消息服务上。\n\n### 消息体\n\n在消息体中，JMS API定义了五种类型的消息格式，让我们可以以不同的形式发送和接受消息，并提供了对已有消息格式的兼容。\n\n不同的消息类型如下：\n- Text message : javax.jms.TextMessage，表示一个文本对象。\n- Object message : javax.jms.ObjectMessage，表示一个JAVA对象。\n- Bytes message : javax.jms.BytesMessage，表示字节数据。\n- Stream message :javax.jms.StreamMessage，表示java原始值数据流。\n- Map message : javax.jms.MapMessage，表示键值对。\n\n### 消息属性\n\n我们可以给消息设置自定义属性，这些属性主要是提供给应用程序的。\n对于实现消息过滤功能，消息属性非常有用，JMS API定义了一些标准属性，JMS服务提供者可以选择性的提供部分标准属性。\n\n## 消息消费\n\n在JMS中，消息的产生和消息是异步的。  \n对于消费来说，JMS的消息者可以通过两种方式来消费消息：\n- 同步：订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞\n- 异步：订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。\n\n## 消息持久化（可靠性）\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\nJMS提供两种选择：（非持久性模式/持久性模式）\n- 非持久性模式： 服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。\n- 持久性模式： 服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\n设置方式：\n```\nPERSISTENT: 指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\nNON_PERSISTENT: 不要求JMS provider持久保存消息\n```\n\n注意：topic持久化时,消费者需要在MQ注册一个自己的身份id标识,在消费者宕机时,生产者会为对应的id保留数据。\n\n## 消息确认机制（可靠性）\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了，消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认.\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。\n在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。改参数有三个可选值:\n- Session.AUTO_ACKNOWLEDGE：自动签收\n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n- Session.CLIENT_ACKNOWLEDGE：手动签收\n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n- Session.DUPS_ACKNOWLEDGE：\n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n\n## 消息过期\n\n可以设置消息在一定时间后过期，默认是永不过期。\n\n## 消息优先级\n\n可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0(最低)到9(最高)。如果不指定优先级，默认级别是4。需要注意的是，JMS Provider并不一定保证按照优先级的顺序提交消息。\n\n## 消息的临时目的地\n\n可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保存的时间。只有创建该临时的地方的连接上的消息消费者才能够从临时目的地中提取消息。\n\n# JMS应用程序接口\n\n1. ConnectionFactory 接口(连接工厂)\n    - 创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂\n    - 分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。\n2. Destination 接口(目标)\n    - Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。\n    - 是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;\n    - 对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。\n    - 所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。\n3. Connection 接口(连接)\n    - Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。\n    - Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。\n4. Session 接口(会话)\n    - Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。\n    - 由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。\n    - 可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。\n    - 同样，也分QueueSession和TopicSession。\n5. MessageProducer 接口(消息的生产者)\n    - 消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。\n    - 同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。\n6. MessageConsumer 接口(消息消费者)\n    - 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。\n    - 可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。\n    - 当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。\n7. Message 接口（消息）\n    - 是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。\n    - 一个消息有三个主要部分：\n        - 1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。\n        - 2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。\n        - 3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。\n    - 消息接口非常灵活，并提供了许多方式来定制消息的内容。\n8. MessageListener\n    - 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。\n    - EJB中的MDB（Message-Driven Bean）就是一种MessageListener。\n\n![JMS 应用程序接口](https://rong0624.gitee.io/images/MQ/JMS/20170215230025420.png)\n\n# JMS提供者实现\n\n要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。  \n开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等。\n\n# 参考资料\n\nhttps://www.cnblogs.com/molao-doing/articles/6557305.html\nhttps://blog.csdn.net/pengchenghui/article/details/80934723\nhttps://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw","source":"_posts/oyr/MQ/JMS.md","raw":"---\ntitle: JMS\ndate: 2021-06-15 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n---\n\n# JMS简介\n\n## JMS是什么\n\nJMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。  \nJava消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。\n\nJMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n<!-- more -->\n\n## 为什么需要JMS\n\n在JAVA中，如果两个应用程序之间对各自都不了解，甚至这两个程序可能部署在不同的大洲上，那么它们之间如何发送消息呢？举个例子，一个应用程序A部署在印度，另一个应用程序部署在美国，然后每当A触发某件事后，B想从A获取一些更新信息。\n当然，也有可能不止一个B对A的更新信息感兴趣，可能会有N个类似B的应用程序想从A中获取更新的信息。\n\n在这种情况下，JAVA提供了最佳的解决方案-JMS，完美解决了上面讨论的问题。\n\nJMS同样适用于基于事件的应用程序，如聊天服务，它需要一种发布事件机制向所有与服务器连接的客户端发送消息。JMS与RMI不同，发送消息的时候，接收者不需要在线。服务器发送了消息，然后就不管了；\n等到客户端上线的时候，能保证接收到服务器发送的消息。这是一个很强大的解决方案，能处理当今世界很多普遍问题。\n\n## JMS的优势\n\n1）异步：JMS天生就是异步的，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端。\n2）可靠：JMS保证消息只会递送一次。大家都遇到过重复创建消息问题，而JMS能帮你避免该问题，只是避免而不是杜绝，所以在一些糟糕的环境下还是有可能会出现重复。\n\n# JMS体系架构\n\nJMS由以下元素组成。\n\n1）JMS提供者   \n连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。\n\n2）JMS客户   \n生产或消费消息的基于Java的应用程序或对象。\n\n3）JMS生产者   \n创建并发送消息的JMS客户。\n\n4）JMS消费者   \n接收消息的JMS客户。\n\n5）JMS消息   \n包括可以在JMS客户之间传递的数据的对象\n\n6）JMS队列   \n一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。\n\n7）JMS主题 \n一种支持发送消息给多个订阅者的机制。\n\n# JMS消息模型\n\n## JMS消息模型\n\n1）Point-to-Point(P2P)  \n2）Publish/Subscribe(Pub/Sub)\n\n在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。\n任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。\n\n## P2P（点对点）\n\n![P2P模式](https://rong0624.gitee.io/images/MQ/JMS/397872-20170315231815541-1387998695.jpeg)\n\n### 涉及的概念\n\n1）消息队列(Queue)    \n2）提供者(Sender)  \n3）消费者(Receiver)  \n4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\n### P2P的特点\n\n1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)  \n2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列  \n3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。  \n4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。  \n5）消费者在成功接收消息之后需向队列应答成功  \n\n**注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。**\n\n## Pub/Sub（发布/订阅模式）\n\n![Pub/Sub模式](https://rong0624.gitee.io/images/MQ/JMS/397872-20170315232442979-934776600.jpeg)\n\n### 涉及的概念\n\n1）主题（Topic）  \n2）发布者（Publisher）  \n3）订阅者（Subscriber）  \n4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\n### Pub/Sub的特点\n\n1）每个消息可以有多个消费者。  \n2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。  \n3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。  \n4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。  \n5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。  \n6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。\n\n**如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型**\n\n# JMS消息\n\n## JMS消息结构\n\nJMS客户端使用JMS消息与系统通讯，JMS消息虽然格式简单但是非常灵活。\nJMS消息由三部分组成：消息头，消息属性，消息体;\n\n### 消息头\n\n设置消息的通用属性,类似http消息头,可以设置消息的过期时间,是否持久化,投递的目的地(队列名/topic名),最主要的设置消息的唯一标识messageId来标识消息的唯一性(JMS会模认生成,你也可以使用自己的id格式来生成唯一标识)。\n\nJMS消息头预定义了若干字段用于客户端与JMS提供者之间识别和发送消息，预编译头如下：  \n- JMSDestination：消息发送的目的地，主要是指Queue和Topic，由session创建而由生产者的send方法设置。\n- JMSDeliveryMode：传送模式:有两种即久模式和非持久模式。一条持久性的消息应该被传输\"一次仅仅一次\"，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。一条非持久的消息最多会传递一次，这意味着服务器出现故障，该消息将永远丢失。由session穿件由消息生产者的send方法设置。\n- JMSMessageID：唯一识别每个消息的标识，由JMS消息生产者产生。由send方法设置。\n- JMSTimestamp：一个JMS Provider在调用send()方法时自动设置，它是消息被发送和消费者实际接收的时间差。由客户端设置。\n- JMSCorrelationID：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。由客户端设置\n- JMSReplyTo：提供本消息回复消息的目的地址,由客户端设置\n- JMSRedelivered：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收(acknowledged)。如果该消息被重新传送，JMSRedelivered=true 否则 JMSRedelivered=flase 。由JMS Provider设置\n- JMSType：消息类型的标识符，由客户端设置\n- JMSExpiration：消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT的时间值。如果timeToLive值等于零，则JMSExpiration被设置为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。由send方法设置\n- JMSPriority：消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息。JMS不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达，默认是4级。由send方法设置\n一个消息的消息头有这些属性，我们可以按照需要对这个消息的消息进行设计，在将这个消息使用消息生产者的send（）方法发送到消息服务上。\n\n### 消息体\n\n在消息体中，JMS API定义了五种类型的消息格式，让我们可以以不同的形式发送和接受消息，并提供了对已有消息格式的兼容。\n\n不同的消息类型如下：\n- Text message : javax.jms.TextMessage，表示一个文本对象。\n- Object message : javax.jms.ObjectMessage，表示一个JAVA对象。\n- Bytes message : javax.jms.BytesMessage，表示字节数据。\n- Stream message :javax.jms.StreamMessage，表示java原始值数据流。\n- Map message : javax.jms.MapMessage，表示键值对。\n\n### 消息属性\n\n我们可以给消息设置自定义属性，这些属性主要是提供给应用程序的。\n对于实现消息过滤功能，消息属性非常有用，JMS API定义了一些标准属性，JMS服务提供者可以选择性的提供部分标准属性。\n\n## 消息消费\n\n在JMS中，消息的产生和消息是异步的。  \n对于消费来说，JMS的消息者可以通过两种方式来消费消息：\n- 同步：订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞\n- 异步：订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。\n\n## 消息持久化（可靠性）\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\nJMS提供两种选择：（非持久性模式/持久性模式）\n- 非持久性模式： 服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。\n- 持久性模式： 服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\n设置方式：\n```\nPERSISTENT: 指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\nNON_PERSISTENT: 不要求JMS provider持久保存消息\n```\n\n注意：topic持久化时,消费者需要在MQ注册一个自己的身份id标识,在消费者宕机时,生产者会为对应的id保留数据。\n\n## 消息确认机制（可靠性）\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了，消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认.\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。\n在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。改参数有三个可选值:\n- Session.AUTO_ACKNOWLEDGE：自动签收\n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n- Session.CLIENT_ACKNOWLEDGE：手动签收\n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n- Session.DUPS_ACKNOWLEDGE：\n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n\n## 消息过期\n\n可以设置消息在一定时间后过期，默认是永不过期。\n\n## 消息优先级\n\n可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0(最低)到9(最高)。如果不指定优先级，默认级别是4。需要注意的是，JMS Provider并不一定保证按照优先级的顺序提交消息。\n\n## 消息的临时目的地\n\n可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保存的时间。只有创建该临时的地方的连接上的消息消费者才能够从临时目的地中提取消息。\n\n# JMS应用程序接口\n\n1. ConnectionFactory 接口(连接工厂)\n    - 创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂\n    - 分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。\n2. Destination 接口(目标)\n    - Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。\n    - 是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;\n    - 对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。\n    - 所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。\n3. Connection 接口(连接)\n    - Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。\n    - Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。\n4. Session 接口(会话)\n    - Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。\n    - 由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。\n    - 可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。\n    - 同样，也分QueueSession和TopicSession。\n5. MessageProducer 接口(消息的生产者)\n    - 消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。\n    - 同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。\n6. MessageConsumer 接口(消息消费者)\n    - 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。\n    - 可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。\n    - 当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。\n7. Message 接口（消息）\n    - 是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。\n    - 一个消息有三个主要部分：\n        - 1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。\n        - 2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。\n        - 3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。\n    - 消息接口非常灵活，并提供了许多方式来定制消息的内容。\n8. MessageListener\n    - 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。\n    - EJB中的MDB（Message-Driven Bean）就是一种MessageListener。\n\n![JMS 应用程序接口](https://rong0624.gitee.io/images/MQ/JMS/20170215230025420.png)\n\n# JMS提供者实现\n\n要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。  \n开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等。\n\n# 参考资料\n\nhttps://www.cnblogs.com/molao-doing/articles/6557305.html\nhttps://blog.csdn.net/pengchenghui/article/details/80934723\nhttps://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw","slug":"oyr/MQ/JMS","published":1,"updated":"2021-10-26T10:30:26.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86l0021cst7bw2scdf5","content":"<h1 id=\"JMS简介\"><a href=\"#JMS简介\" class=\"headerlink\" title=\"JMS简介\"></a>JMS简介</h1><h2 id=\"JMS是什么\"><a href=\"#JMS是什么\" class=\"headerlink\" title=\"JMS是什么\"></a>JMS是什么</h2><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>\n<p>JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么需要JMS\"><a href=\"#为什么需要JMS\" class=\"headerlink\" title=\"为什么需要JMS\"></a>为什么需要JMS</h2><p>在JAVA中，如果两个应用程序之间对各自都不了解，甚至这两个程序可能部署在不同的大洲上，那么它们之间如何发送消息呢？举个例子，一个应用程序A部署在印度，另一个应用程序部署在美国，然后每当A触发某件事后，B想从A获取一些更新信息。<br>当然，也有可能不止一个B对A的更新信息感兴趣，可能会有N个类似B的应用程序想从A中获取更新的信息。</p>\n<p>在这种情况下，JAVA提供了最佳的解决方案-JMS，完美解决了上面讨论的问题。</p>\n<p>JMS同样适用于基于事件的应用程序，如聊天服务，它需要一种发布事件机制向所有与服务器连接的客户端发送消息。JMS与RMI不同，发送消息的时候，接收者不需要在线。服务器发送了消息，然后就不管了；<br>等到客户端上线的时候，能保证接收到服务器发送的消息。这是一个很强大的解决方案，能处理当今世界很多普遍问题。</p>\n<h2 id=\"JMS的优势\"><a href=\"#JMS的优势\" class=\"headerlink\" title=\"JMS的优势\"></a>JMS的优势</h2><p>1）异步：JMS天生就是异步的，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端。<br>2）可靠：JMS保证消息只会递送一次。大家都遇到过重复创建消息问题，而JMS能帮你避免该问题，只是避免而不是杜绝，所以在一些糟糕的环境下还是有可能会出现重复。</p>\n<h1 id=\"JMS体系架构\"><a href=\"#JMS体系架构\" class=\"headerlink\" title=\"JMS体系架构\"></a>JMS体系架构</h1><p>JMS由以下元素组成。</p>\n<p>1）JMS提供者<br>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p>\n<p>2）JMS客户<br>生产或消费消息的基于Java的应用程序或对象。</p>\n<p>3）JMS生产者<br>创建并发送消息的JMS客户。</p>\n<p>4）JMS消费者<br>接收消息的JMS客户。</p>\n<p>5）JMS消息<br>包括可以在JMS客户之间传递的数据的对象</p>\n<p>6）JMS队列<br>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p>\n<p>7）JMS主题<br>一种支持发送消息给多个订阅者的机制。</p>\n<h1 id=\"JMS消息模型\"><a href=\"#JMS消息模型\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h1><h2 id=\"JMS消息模型-1\"><a href=\"#JMS消息模型-1\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h2><p>1）Point-to-Point(P2P)<br>2）Publish/Subscribe(Pub/Sub)</p>\n<p>在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。<br>任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。</p>\n<h2 id=\"P2P（点对点）\"><a href=\"#P2P（点对点）\" class=\"headerlink\" title=\"P2P（点对点）\"></a>P2P（点对点）</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/397872-20170315231815541-1387998695.jpeg\" alt=\"P2P模式\"></p>\n<h3 id=\"涉及的概念\"><a href=\"#涉及的概念\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）消息队列(Queue)<br>2）提供者(Sender)<br>3）消费者(Receiver)<br>4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<h3 id=\"P2P的特点\"><a href=\"#P2P的特点\" class=\"headerlink\" title=\"P2P的特点\"></a>P2P的特点</h3><p>1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列<br>3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。<br>4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。<br>5）消费者在成功接收消息之后需向队列应答成功  </p>\n<p><strong>注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</strong></p>\n<h2 id=\"Pub-Sub（发布-订阅模式）\"><a href=\"#Pub-Sub（发布-订阅模式）\" class=\"headerlink\" title=\"Pub/Sub（发布/订阅模式）\"></a>Pub/Sub（发布/订阅模式）</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/397872-20170315232442979-934776600.jpeg\" alt=\"Pub/Sub模式\"></p>\n<h3 id=\"涉及的概念-1\"><a href=\"#涉及的概念-1\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）主题（Topic）<br>2）发布者（Publisher）<br>3）订阅者（Subscriber）<br>4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<h3 id=\"Pub-Sub的特点\"><a href=\"#Pub-Sub的特点\" class=\"headerlink\" title=\"Pub/Sub的特点\"></a>Pub/Sub的特点</h3><p>1）每个消息可以有多个消费者。<br>2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。<br>3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。<br>4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。<br>5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。<br>6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。</p>\n<p><strong>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</strong></p>\n<h1 id=\"JMS消息\"><a href=\"#JMS消息\" class=\"headerlink\" title=\"JMS消息\"></a>JMS消息</h1><h2 id=\"JMS消息结构\"><a href=\"#JMS消息结构\" class=\"headerlink\" title=\"JMS消息结构\"></a>JMS消息结构</h2><p>JMS客户端使用JMS消息与系统通讯，JMS消息虽然格式简单但是非常灵活。<br>JMS消息由三部分组成：消息头，消息属性，消息体;</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>设置消息的通用属性,类似http消息头,可以设置消息的过期时间,是否持久化,投递的目的地(队列名/topic名),最主要的设置消息的唯一标识messageId来标识消息的唯一性(JMS会模认生成,你也可以使用自己的id格式来生成唯一标识)。</p>\n<p>JMS消息头预定义了若干字段用于客户端与JMS提供者之间识别和发送消息，预编译头如下：  </p>\n<ul>\n<li>JMSDestination：消息发送的目的地，主要是指Queue和Topic，由session创建而由生产者的send方法设置。</li>\n<li>JMSDeliveryMode：传送模式:有两种即久模式和非持久模式。一条持久性的消息应该被传输”一次仅仅一次”，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。一条非持久的消息最多会传递一次，这意味着服务器出现故障，该消息将永远丢失。由session穿件由消息生产者的send方法设置。</li>\n<li>JMSMessageID：唯一识别每个消息的标识，由JMS消息生产者产生。由send方法设置。</li>\n<li>JMSTimestamp：一个JMS Provider在调用send()方法时自动设置，它是消息被发送和消费者实际接收的时间差。由客户端设置。</li>\n<li>JMSCorrelationID：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。由客户端设置</li>\n<li>JMSReplyTo：提供本消息回复消息的目的地址,由客户端设置</li>\n<li>JMSRedelivered：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收(acknowledged)。如果该消息被重新传送，JMSRedelivered=true 否则 JMSRedelivered=flase 。由JMS Provider设置</li>\n<li>JMSType：消息类型的标识符，由客户端设置</li>\n<li>JMSExpiration：消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT的时间值。如果timeToLive值等于零，则JMSExpiration被设置为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。由send方法设置</li>\n<li>JMSPriority：消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息。JMS不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达，默认是4级。由send方法设置<br>一个消息的消息头有这些属性，我们可以按照需要对这个消息的消息进行设计，在将这个消息使用消息生产者的send（）方法发送到消息服务上。</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>在消息体中，JMS API定义了五种类型的消息格式，让我们可以以不同的形式发送和接受消息，并提供了对已有消息格式的兼容。</p>\n<p>不同的消息类型如下：</p>\n<ul>\n<li>Text message : javax.jms.TextMessage，表示一个文本对象。</li>\n<li>Object message : javax.jms.ObjectMessage，表示一个JAVA对象。</li>\n<li>Bytes message : javax.jms.BytesMessage，表示字节数据。</li>\n<li>Stream message :javax.jms.StreamMessage，表示java原始值数据流。</li>\n<li>Map message : javax.jms.MapMessage，表示键值对。</li>\n</ul>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>我们可以给消息设置自定义属性，这些属性主要是提供给应用程序的。<br>对于实现消息过滤功能，消息属性非常有用，JMS API定义了一些标准属性，JMS服务提供者可以选择性的提供部分标准属性。</p>\n<h2 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h2><p>在JMS中，消息的产生和消息是异步的。<br>对于消费来说，JMS的消息者可以通过两种方式来消费消息：</p>\n<ul>\n<li>同步：订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞</li>\n<li>异步：订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</li>\n</ul>\n<h2 id=\"消息持久化（可靠性）\"><a href=\"#消息持久化（可靠性）\" class=\"headerlink\" title=\"消息持久化（可靠性）\"></a>消息持久化（可靠性）</h2><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>JMS提供两种选择：（非持久性模式/持久性模式）</p>\n<ul>\n<li>非持久性模式： 服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。</li>\n<li>持久性模式： 服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</li>\n</ul>\n<p>设置方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSISTENT: 指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</span><br><span class=\"line\">NON_PERSISTENT: 不要求JMS provider持久保存消息</span><br></pre></td></tr></table></figure>\n\n<p>注意：topic持久化时,消费者需要在MQ注册一个自己的身份id标识,在消费者宕机时,生产者会为对应的id保留数据。</p>\n<h2 id=\"消息确认机制（可靠性）\"><a href=\"#消息确认机制（可靠性）\" class=\"headerlink\" title=\"消息确认机制（可靠性）\"></a>消息确认机制（可靠性）</h2><p>JMS消息只有在被确认之后，才认为已经被成功的消费了，消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认.</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。<br>在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。改参数有三个可选值:</p>\n<ul>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n</ul>\n<h2 id=\"消息过期\"><a href=\"#消息过期\" class=\"headerlink\" title=\"消息过期\"></a>消息过期</h2><p>可以设置消息在一定时间后过期，默认是永不过期。</p>\n<h2 id=\"消息优先级\"><a href=\"#消息优先级\" class=\"headerlink\" title=\"消息优先级\"></a>消息优先级</h2><p>可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0(最低)到9(最高)。如果不指定优先级，默认级别是4。需要注意的是，JMS Provider并不一定保证按照优先级的顺序提交消息。</p>\n<h2 id=\"消息的临时目的地\"><a href=\"#消息的临时目的地\" class=\"headerlink\" title=\"消息的临时目的地\"></a>消息的临时目的地</h2><p>可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保存的时间。只有创建该临时的地方的连接上的消息消费者才能够从临时目的地中提取消息。</p>\n<h1 id=\"JMS应用程序接口\"><a href=\"#JMS应用程序接口\" class=\"headerlink\" title=\"JMS应用程序接口\"></a>JMS应用程序接口</h1><ol>\n<li>ConnectionFactory 接口(连接工厂)<ul>\n<li>创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂</li>\n<li>分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</li>\n</ul>\n</li>\n<li>Destination 接口(目标)<ul>\n<li>Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。</li>\n<li>是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;</li>\n<li>对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</li>\n<li>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</li>\n</ul>\n</li>\n<li>Connection 接口(连接)<ul>\n<li>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。</li>\n<li>Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</li>\n</ul>\n</li>\n<li>Session 接口(会话)<ul>\n<li>Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。</li>\n<li>由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。</li>\n<li>可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。</li>\n<li>同样，也分QueueSession和TopicSession。</li>\n</ul>\n</li>\n<li>MessageProducer 接口(消息的生产者)<ul>\n<li>消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。</li>\n<li>同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</li>\n</ul>\n</li>\n<li>MessageConsumer 接口(消息消费者)<ul>\n<li>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。</li>\n<li>可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。</li>\n<li>当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</li>\n</ul>\n</li>\n<li>Message 接口（消息）<ul>\n<li>是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。</li>\n<li>一个消息有三个主要部分：<ul>\n<li>1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。</li>\n<li>2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。</li>\n<li>3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>MessageListener<ul>\n<li>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。</li>\n<li>EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/20170215230025420.png\" alt=\"JMS 应用程序接口\"></p>\n<h1 id=\"JMS提供者实现\"><a href=\"#JMS提供者实现\" class=\"headerlink\" title=\"JMS提供者实现\"></a>JMS提供者实现</h1><p>要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。<br>开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/molao-doing/articles/6557305.html\">https://www.cnblogs.com/molao-doing/articles/6557305.html</a><br><a href=\"https://blog.csdn.net/pengchenghui/article/details/80934723\">https://blog.csdn.net/pengchenghui/article/details/80934723</a><br><a href=\"https://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw\">https://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JMS简介\"><a href=\"#JMS简介\" class=\"headerlink\" title=\"JMS简介\"></a>JMS简介</h1><h2 id=\"JMS是什么\"><a href=\"#JMS是什么\" class=\"headerlink\" title=\"JMS是什么\"></a>JMS是什么</h2><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>\n<p>JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>","more":"<h2 id=\"为什么需要JMS\"><a href=\"#为什么需要JMS\" class=\"headerlink\" title=\"为什么需要JMS\"></a>为什么需要JMS</h2><p>在JAVA中，如果两个应用程序之间对各自都不了解，甚至这两个程序可能部署在不同的大洲上，那么它们之间如何发送消息呢？举个例子，一个应用程序A部署在印度，另一个应用程序部署在美国，然后每当A触发某件事后，B想从A获取一些更新信息。<br>当然，也有可能不止一个B对A的更新信息感兴趣，可能会有N个类似B的应用程序想从A中获取更新的信息。</p>\n<p>在这种情况下，JAVA提供了最佳的解决方案-JMS，完美解决了上面讨论的问题。</p>\n<p>JMS同样适用于基于事件的应用程序，如聊天服务，它需要一种发布事件机制向所有与服务器连接的客户端发送消息。JMS与RMI不同，发送消息的时候，接收者不需要在线。服务器发送了消息，然后就不管了；<br>等到客户端上线的时候，能保证接收到服务器发送的消息。这是一个很强大的解决方案，能处理当今世界很多普遍问题。</p>\n<h2 id=\"JMS的优势\"><a href=\"#JMS的优势\" class=\"headerlink\" title=\"JMS的优势\"></a>JMS的优势</h2><p>1）异步：JMS天生就是异步的，客户端获取消息的时候，不需要主动发送请求，消息会自动发送给可用的客户端。<br>2）可靠：JMS保证消息只会递送一次。大家都遇到过重复创建消息问题，而JMS能帮你避免该问题，只是避免而不是杜绝，所以在一些糟糕的环境下还是有可能会出现重复。</p>\n<h1 id=\"JMS体系架构\"><a href=\"#JMS体系架构\" class=\"headerlink\" title=\"JMS体系架构\"></a>JMS体系架构</h1><p>JMS由以下元素组成。</p>\n<p>1）JMS提供者<br>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p>\n<p>2）JMS客户<br>生产或消费消息的基于Java的应用程序或对象。</p>\n<p>3）JMS生产者<br>创建并发送消息的JMS客户。</p>\n<p>4）JMS消费者<br>接收消息的JMS客户。</p>\n<p>5）JMS消息<br>包括可以在JMS客户之间传递的数据的对象</p>\n<p>6）JMS队列<br>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p>\n<p>7）JMS主题<br>一种支持发送消息给多个订阅者的机制。</p>\n<h1 id=\"JMS消息模型\"><a href=\"#JMS消息模型\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h1><h2 id=\"JMS消息模型-1\"><a href=\"#JMS消息模型-1\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h2><p>1）Point-to-Point(P2P)<br>2）Publish/Subscribe(Pub/Sub)</p>\n<p>在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。<br>任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。</p>\n<h2 id=\"P2P（点对点）\"><a href=\"#P2P（点对点）\" class=\"headerlink\" title=\"P2P（点对点）\"></a>P2P（点对点）</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/397872-20170315231815541-1387998695.jpeg\" alt=\"P2P模式\"></p>\n<h3 id=\"涉及的概念\"><a href=\"#涉及的概念\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）消息队列(Queue)<br>2）提供者(Sender)<br>3）消费者(Receiver)<br>4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<h3 id=\"P2P的特点\"><a href=\"#P2P的特点\" class=\"headerlink\" title=\"P2P的特点\"></a>P2P的特点</h3><p>1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列<br>3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。<br>4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。<br>5）消费者在成功接收消息之后需向队列应答成功  </p>\n<p><strong>注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</strong></p>\n<h2 id=\"Pub-Sub（发布-订阅模式）\"><a href=\"#Pub-Sub（发布-订阅模式）\" class=\"headerlink\" title=\"Pub/Sub（发布/订阅模式）\"></a>Pub/Sub（发布/订阅模式）</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/397872-20170315232442979-934776600.jpeg\" alt=\"Pub/Sub模式\"></p>\n<h3 id=\"涉及的概念-1\"><a href=\"#涉及的概念-1\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）主题（Topic）<br>2）发布者（Publisher）<br>3）订阅者（Subscriber）<br>4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<h3 id=\"Pub-Sub的特点\"><a href=\"#Pub-Sub的特点\" class=\"headerlink\" title=\"Pub/Sub的特点\"></a>Pub/Sub的特点</h3><p>1）每个消息可以有多个消费者。<br>2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。<br>3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。<br>4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。<br>5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。<br>6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。</p>\n<p><strong>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</strong></p>\n<h1 id=\"JMS消息\"><a href=\"#JMS消息\" class=\"headerlink\" title=\"JMS消息\"></a>JMS消息</h1><h2 id=\"JMS消息结构\"><a href=\"#JMS消息结构\" class=\"headerlink\" title=\"JMS消息结构\"></a>JMS消息结构</h2><p>JMS客户端使用JMS消息与系统通讯，JMS消息虽然格式简单但是非常灵活。<br>JMS消息由三部分组成：消息头，消息属性，消息体;</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>设置消息的通用属性,类似http消息头,可以设置消息的过期时间,是否持久化,投递的目的地(队列名/topic名),最主要的设置消息的唯一标识messageId来标识消息的唯一性(JMS会模认生成,你也可以使用自己的id格式来生成唯一标识)。</p>\n<p>JMS消息头预定义了若干字段用于客户端与JMS提供者之间识别和发送消息，预编译头如下：  </p>\n<ul>\n<li>JMSDestination：消息发送的目的地，主要是指Queue和Topic，由session创建而由生产者的send方法设置。</li>\n<li>JMSDeliveryMode：传送模式:有两种即久模式和非持久模式。一条持久性的消息应该被传输”一次仅仅一次”，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。一条非持久的消息最多会传递一次，这意味着服务器出现故障，该消息将永远丢失。由session穿件由消息生产者的send方法设置。</li>\n<li>JMSMessageID：唯一识别每个消息的标识，由JMS消息生产者产生。由send方法设置。</li>\n<li>JMSTimestamp：一个JMS Provider在调用send()方法时自动设置，它是消息被发送和消费者实际接收的时间差。由客户端设置。</li>\n<li>JMSCorrelationID：用来连接到另外一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。由客户端设置</li>\n<li>JMSReplyTo：提供本消息回复消息的目的地址,由客户端设置</li>\n<li>JMSRedelivered：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些时候收到过该消息，但并没有签收(acknowledged)。如果该消息被重新传送，JMSRedelivered=true 否则 JMSRedelivered=flase 。由JMS Provider设置</li>\n<li>JMSType：消息类型的标识符，由客户端设置</li>\n<li>JMSExpiration：消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT的时间值。如果timeToLive值等于零，则JMSExpiration被设置为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。由send方法设置</li>\n<li>JMSPriority：消息优先级，从0-9十个级别，0-4是普通消息，5-9是加急消息。JMS不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要先于普通消息到达，默认是4级。由send方法设置<br>一个消息的消息头有这些属性，我们可以按照需要对这个消息的消息进行设计，在将这个消息使用消息生产者的send（）方法发送到消息服务上。</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>在消息体中，JMS API定义了五种类型的消息格式，让我们可以以不同的形式发送和接受消息，并提供了对已有消息格式的兼容。</p>\n<p>不同的消息类型如下：</p>\n<ul>\n<li>Text message : javax.jms.TextMessage，表示一个文本对象。</li>\n<li>Object message : javax.jms.ObjectMessage，表示一个JAVA对象。</li>\n<li>Bytes message : javax.jms.BytesMessage，表示字节数据。</li>\n<li>Stream message :javax.jms.StreamMessage，表示java原始值数据流。</li>\n<li>Map message : javax.jms.MapMessage，表示键值对。</li>\n</ul>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>我们可以给消息设置自定义属性，这些属性主要是提供给应用程序的。<br>对于实现消息过滤功能，消息属性非常有用，JMS API定义了一些标准属性，JMS服务提供者可以选择性的提供部分标准属性。</p>\n<h2 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h2><p>在JMS中，消息的产生和消息是异步的。<br>对于消费来说，JMS的消息者可以通过两种方式来消费消息：</p>\n<ul>\n<li>同步：订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞</li>\n<li>异步：订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</li>\n</ul>\n<h2 id=\"消息持久化（可靠性）\"><a href=\"#消息持久化（可靠性）\" class=\"headerlink\" title=\"消息持久化（可靠性）\"></a>消息持久化（可靠性）</h2><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>JMS提供两种选择：（非持久性模式/持久性模式）</p>\n<ul>\n<li>非持久性模式： 服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。</li>\n<li>持久性模式： 服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</li>\n</ul>\n<p>设置方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PERSISTENT: 指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</span><br><span class=\"line\">NON_PERSISTENT: 不要求JMS provider持久保存消息</span><br></pre></td></tr></table></figure>\n\n<p>注意：topic持久化时,消费者需要在MQ注册一个自己的身份id标识,在消费者宕机时,生产者会为对应的id保留数据。</p>\n<h2 id=\"消息确认机制（可靠性）\"><a href=\"#消息确认机制（可靠性）\" class=\"headerlink\" title=\"消息确认机制（可靠性）\"></a>消息确认机制（可靠性）</h2><p>JMS消息只有在被确认之后，才认为已经被成功的消费了，消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认.</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。<br>在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。改参数有三个可选值:</p>\n<ul>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n</ul>\n<h2 id=\"消息过期\"><a href=\"#消息过期\" class=\"headerlink\" title=\"消息过期\"></a>消息过期</h2><p>可以设置消息在一定时间后过期，默认是永不过期。</p>\n<h2 id=\"消息优先级\"><a href=\"#消息优先级\" class=\"headerlink\" title=\"消息优先级\"></a>消息优先级</h2><p>可以使用消息优先级来指示JMS Provider首先提交紧急的消息。优先级分10个级别，从0(最低)到9(最高)。如果不指定优先级，默认级别是4。需要注意的是，JMS Provider并不一定保证按照优先级的顺序提交消息。</p>\n<h2 id=\"消息的临时目的地\"><a href=\"#消息的临时目的地\" class=\"headerlink\" title=\"消息的临时目的地\"></a>消息的临时目的地</h2><p>可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保存的时间。只有创建该临时的地方的连接上的消息消费者才能够从临时目的地中提取消息。</p>\n<h1 id=\"JMS应用程序接口\"><a href=\"#JMS应用程序接口\" class=\"headerlink\" title=\"JMS应用程序接口\"></a>JMS应用程序接口</h1><ol>\n<li>ConnectionFactory 接口(连接工厂)<ul>\n<li>创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂</li>\n<li>分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</li>\n</ul>\n</li>\n<li>Destination 接口(目标)<ul>\n<li>Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。</li>\n<li>是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;</li>\n<li>对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</li>\n<li>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</li>\n</ul>\n</li>\n<li>Connection 接口(连接)<ul>\n<li>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。</li>\n<li>Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</li>\n</ul>\n</li>\n<li>Session 接口(会话)<ul>\n<li>Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。</li>\n<li>由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。</li>\n<li>可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。</li>\n<li>同样，也分QueueSession和TopicSession。</li>\n</ul>\n</li>\n<li>MessageProducer 接口(消息的生产者)<ul>\n<li>消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。</li>\n<li>同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</li>\n</ul>\n</li>\n<li>MessageConsumer 接口(消息消费者)<ul>\n<li>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。</li>\n<li>可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。</li>\n<li>当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</li>\n</ul>\n</li>\n<li>Message 接口（消息）<ul>\n<li>是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。</li>\n<li>一个消息有三个主要部分：<ul>\n<li>1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。</li>\n<li>2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。</li>\n<li>3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>MessageListener<ul>\n<li>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。</li>\n<li>EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/JMS/20170215230025420.png\" alt=\"JMS 应用程序接口\"></p>\n<h1 id=\"JMS提供者实现\"><a href=\"#JMS提供者实现\" class=\"headerlink\" title=\"JMS提供者实现\"></a>JMS提供者实现</h1><p>要使用Java消息服务，你必须要有一个JMS提供者，管理会话和队列。现在既有开源的提供者也有专有的提供者。<br>开源的提供者包括：Apache ActiveMQ、Kafka、WebMethods、阿里的RocketMQ等。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/molao-doing/articles/6557305.html\">https://www.cnblogs.com/molao-doing/articles/6557305.html</a><br><a href=\"https://blog.csdn.net/pengchenghui/article/details/80934723\">https://blog.csdn.net/pengchenghui/article/details/80934723</a><br><a href=\"https://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw\">https://mp.weixin.qq.com/s/WCeYaDjK9dWQ95m3Wv3vPw</a></p>"},{"title":"消息中间件入门与简介","date":"2021-06-09T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://rong0624.gitee.io/images/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://rong0624.gitee.io/images/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://rong0624.gitee.io/images/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://rong0624.gitee.io/images/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://rong0624.gitee.io/images/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://rong0624.gitee.io/images/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://rong0624.gitee.io/images/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://rong0624.gitee.io/images/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://rong0624.gitee.io/images/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://rong0624.gitee.io/images/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","source":"_posts/oyr/MQ/消息中间件入门与简介.md","raw":"---\ntitle: 消息中间件入门与简介\ndate: 2021-06-10 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n---\n\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://rong0624.gitee.io/images/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://rong0624.gitee.io/images/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://rong0624.gitee.io/images/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://rong0624.gitee.io/images/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://rong0624.gitee.io/images/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://rong0624.gitee.io/images/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://rong0624.gitee.io/images/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://rong0624.gitee.io/images/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://rong0624.gitee.io/images/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://rong0624.gitee.io/images/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://rong0624.gitee.io/images/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","slug":"oyr/MQ/消息中间件入门与简介","published":1,"updated":"2021-10-26T10:30:26.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86l0022cst7efuf4lln","content":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://rong0624.gitee.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://rong0624.gitee.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://rong0624.gitee.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://rong0624.gitee.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>","more":"<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://rong0624.gitee.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://rong0624.gitee.io/images/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://rong0624.gitee.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://rong0624.gitee.io/images/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>"},{"title":"Markdown语法","date":"2021-04-30T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Markdown标题\n\n## 使用 = 和 - 表示一级和二级标题\n\n= 和 - 标记语法格式如下：\n```\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n---------------\n```\n\n<!-- more -->\n\n## 使用 # 号标记\n\n使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# Markdown 段落格式\n\n## 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg)\n\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg)\n\n## 字体\n\nMarkdown 可以使用以下几种字体：\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md3.gif)\n\n## 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n```\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg)\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n```\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg)\n\n## 下划线\n\n下划线可以通过 HTML 的 <u> 标签来实现：\n```\n<u>带下划线文本</u>\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg)\n\n## 脚注\n\n脚注是对文本的补充说明。  \nMarkdown 脚注的格式如下:\n```\n[^要注明的文本]\n```\n\n以下实例演示了脚注的用法：\n```\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n```\n\n演示效果如下：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md5.gif)\n\n# Markdown列表\n\nMarkdown 支持有序列表和无序列表。\n\n## 无序列表\n\n无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n```\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n显示结果如下：  \n![无序列表图](https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg)\n\n## 有序列表\n\n有序列表使用数字并加上 . 号来表示，如：\n```\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n![有序列表图](https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg)\n\n## 列表嵌套\n\n列表嵌套只需在子列表中的选项前面添加四个空格即可：\n```\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n显示结果如下：\n![列表嵌套图](https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg)\n\n# Markdown区块\n\n## 区块\n\nMarkdown 区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号：\n```\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n```\n\n显示结果如下：\n![区块图](https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg)\n\n另外区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推：\n```\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n显示结果如下：\n![区块嵌套图](https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg)\n\n## 区块中使用列表\n\n区块中使用列表实例如下：\n```\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n显示结果如下：\n![区块中使用列表图](https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg)\n\n## 列表中使用区块\n\n如果要在列表项目内放进区块，那么就需要在 > 前添加四个空格的缩进。\n\n列表中使用区块实例如下：\n```\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n显示结果如下：\n![列表中使用区块图](https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg)\n\n# Markdown图片\n\nMarkdown 图片语法格式如下：\n```\n![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 \"可选标题\")\n```\n* 开头一个感叹号 !\n* 接着一个方括号，里面放上图片的替代文字\n* 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n\n使用实例：\n```\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\n```\n显示结果如下：  \n![图片使用Demo图](https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg)\n\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n```html\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n```\n显示结果如下：\n![图片img使用Demo图](https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg)\n\n# Markdown代码\n\n## 代码片段\n\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：\n```\n`printf()` 函数\n```\n显示结果如下：\n![片段代码图](https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg)\n\n## 代码区块\n\n代码区块使用 4 个空格或者一个制表符（Tab 键）。（没效果）\n\n你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n```java\npublic void test1() {\n    System.out.println(\"你好~\");\n}\n```\n显示效果如下：\n![代码区块2](https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg)\n\n# Markdoun链接\n\n链接使用语法如下：\n```\n[链接名称](链接地址)\n\nor\n\n<链接地址>\n```\n\n列如：\n```\n(https://www.baidu.com/)\n\n[百度一下](https://www.baidu.com/)\n```\n显示效果：\n// TODO\n\n# Markdoun表格\n\n## 表格\n\nMarkdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n\n语法格式如下：\n```\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n以上代码显示结果如下：\n![表格](https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg)\n\n## 表格对齐\n\n我们可以设置表格的对齐方式：\n* -: 设置内容和标题栏居右对齐。\n* :- 设置内容和标题栏居左对齐。\n* :-: 设置内容和标题栏居中对齐。  \n\n实例如下：\n```\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n![表格对齐](https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg)\n\n# Markdoun高级技巧\n\n// TODO","source":"_posts/oyr/Markdown/Markdown语法.md","raw":"---\ntitle: Markdown语法\ndate: 2021-05-01 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: Markdown\ncategories: Markdown\n---\n\n# Markdown标题\n\n## 使用 = 和 - 表示一级和二级标题\n\n= 和 - 标记语法格式如下：\n```\n我展示的是一级标题\n=================\n\n我展示的是二级标题\n---------------\n```\n\n<!-- more -->\n\n## 使用 # 号标记\n\n使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n# Markdown 段落格式\n\n## 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg)\n\n当然也可以在段落后面使用一个空行来表示重新开始一个段落。  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg)\n\n## 字体\n\nMarkdown 可以使用以下几种字体：\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md3.gif)\n\n## 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n```\n***\n\n* * *\n\n*****\n\n- - -\n\n----------\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg)\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n```\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg)\n\n## 下划线\n\n下划线可以通过 HTML 的 <u> 标签来实现：\n```\n<u>带下划线文本</u>\n```\n\n显示效果如下所示：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg)\n\n## 脚注\n\n脚注是对文本的补充说明。  \nMarkdown 脚注的格式如下:\n```\n[^要注明的文本]\n```\n\n以下实例演示了脚注的用法：\n```\n创建脚注格式类似这样 [^RUNOOB]。\n\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\n```\n\n演示效果如下：  \n![效果图](https://www.runoob.com/wp-content/uploads/2019/03/md5.gif)\n\n# Markdown列表\n\nMarkdown 支持有序列表和无序列表。\n\n## 无序列表\n\n无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n```\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n显示结果如下：  \n![无序列表图](https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg)\n\n## 有序列表\n\n有序列表使用数字并加上 . 号来表示，如：\n```\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n![有序列表图](https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg)\n\n## 列表嵌套\n\n列表嵌套只需在子列表中的选项前面添加四个空格即可：\n```\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n显示结果如下：\n![列表嵌套图](https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg)\n\n# Markdown区块\n\n## 区块\n\nMarkdown 区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号：\n```\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n```\n\n显示结果如下：\n![区块图](https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg)\n\n另外区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推：\n```\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n显示结果如下：\n![区块嵌套图](https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg)\n\n## 区块中使用列表\n\n区块中使用列表实例如下：\n```\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n显示结果如下：\n![区块中使用列表图](https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg)\n\n## 列表中使用区块\n\n如果要在列表项目内放进区块，那么就需要在 > 前添加四个空格的缩进。\n\n列表中使用区块实例如下：\n```\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n显示结果如下：\n![列表中使用区块图](https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg)\n\n# Markdown图片\n\nMarkdown 图片语法格式如下：\n```\n![alt 属性文本](图片地址)\n\n![alt 属性文本](图片地址 \"可选标题\")\n```\n* 开头一个感叹号 !\n* 接着一个方括号，里面放上图片的替代文字\n* 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 属性的文字。\n\n使用实例：\n```\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\n```\n显示结果如下：  \n![图片使用Demo图](https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg)\n\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n```html\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n```\n显示结果如下：\n![图片img使用Demo图](https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg)\n\n# Markdown代码\n\n## 代码片段\n\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：\n```\n`printf()` 函数\n```\n显示结果如下：\n![片段代码图](https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg)\n\n## 代码区块\n\n代码区块使用 4 个空格或者一个制表符（Tab 键）。（没效果）\n\n你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n```java\npublic void test1() {\n    System.out.println(\"你好~\");\n}\n```\n显示效果如下：\n![代码区块2](https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg)\n\n# Markdoun链接\n\n链接使用语法如下：\n```\n[链接名称](链接地址)\n\nor\n\n<链接地址>\n```\n\n列如：\n```\n(https://www.baidu.com/)\n\n[百度一下](https://www.baidu.com/)\n```\n显示效果：\n// TODO\n\n# Markdoun表格\n\n## 表格\n\nMarkdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n\n语法格式如下：\n```\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n以上代码显示结果如下：\n![表格](https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg)\n\n## 表格对齐\n\n我们可以设置表格的对齐方式：\n* -: 设置内容和标题栏居右对齐。\n* :- 设置内容和标题栏居左对齐。\n* :-: 设置内容和标题栏居中对齐。  \n\n实例如下：\n```\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n![表格对齐](https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg)\n\n# Markdoun高级技巧\n\n// TODO","slug":"oyr/Markdown/Markdown语法","published":1,"updated":"2021-09-15T07:38:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86m0026cst71x9tdcxg","content":"<h1 id=\"Markdown标题\"><a href=\"#Markdown标题\" class=\"headerlink\" title=\"Markdown标题\"></a>Markdown标题</h1><h2 id=\"使用-和-表示一级和二级标题\"><a href=\"#使用-和-表示一级和二级标题\" class=\"headerlink\" title=\"使用 = 和 - 表示一级和二级标题\"></a>使用 = 和 - 表示一级和二级标题</h2><p>= 和 - 标记语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我展示的是一级标题</span><br><span class=\"line\">=================</span><br><span class=\"line\"></span><br><span class=\"line\">我展示的是二级标题</span><br><span class=\"line\">---------------</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"使用-号标记\"><a href=\"#使用-号标记\" class=\"headerlink\" title=\"使用 # 号标记\"></a>使用 # 号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Markdown-段落格式\"><a href=\"#Markdown-段落格式\" class=\"headerlink\" title=\"Markdown 段落格式\"></a>Markdown 段落格式</h1><h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg\" alt=\"效果图\"></p>\n<p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg\" alt=\"效果图\"></p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md3.gif\" alt=\"效果图\"></p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">----------</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg\" alt=\"效果图\"></p>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUNOOB.COM</span><br><span class=\"line\">GOOGLE.COM</span><br><span class=\"line\">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg\" alt=\"效果图\"></p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg\" alt=\"效果图\"></p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^要注明的文本]</span><br></pre></td></tr></table></figure>\n\n<p>以下实例演示了脚注的用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class=\"line\"></span><br><span class=\"line\">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure>\n\n<p>演示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md5.gif\" alt=\"效果图\"></p>\n<h1 id=\"Markdown列表\"><a href=\"#Markdown列表\" class=\"headerlink\" title=\"Markdown列表\"></a>Markdown列表</h1><p>Markdown 支持有序列表和无序列表。</p>\n<h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">* 第二项</span><br><span class=\"line\">* 第三项</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一项</span><br><span class=\"line\">+ 第二项</span><br><span class=\"line\">+ 第三项</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\">- 第三项</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg\" alt=\"无序列表图\"></p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项</span><br><span class=\"line\">2. 第二项</span><br><span class=\"line\">3. 第三项</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg\" alt=\"有序列表图\"></p>\n<h2 id=\"列表嵌套\"><a href=\"#列表嵌套\" class=\"headerlink\" title=\"列表嵌套\"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项：</span><br><span class=\"line\">    - 第一项嵌套的第一个元素</span><br><span class=\"line\">    - 第一项嵌套的第二个元素</span><br><span class=\"line\">2. 第二项：</span><br><span class=\"line\">    - 第二项嵌套的第一个元素</span><br><span class=\"line\">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg\" alt=\"列表嵌套图\"></p>\n<h1 id=\"Markdown区块\"><a href=\"#Markdown区块\" class=\"headerlink\" title=\"Markdown区块\"></a>Markdown区块</h1><h2 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 区块引用</span><br><span class=\"line\">&gt; 菜鸟教程</span><br><span class=\"line\">&gt; 学的不仅是技术更是梦想</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg\" alt=\"区块图\"></p>\n<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 最外层</span><br><span class=\"line\">&gt; &gt; 第一层嵌套</span><br><span class=\"line\">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg\" alt=\"区块嵌套图\"></p>\n<h2 id=\"区块中使用列表\"><a href=\"#区块中使用列表\" class=\"headerlink\" title=\"区块中使用列表\"></a>区块中使用列表</h2><p>区块中使用列表实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 区块中使用列表</span><br><span class=\"line\">&gt; 1. 第一项</span><br><span class=\"line\">&gt; 2. 第二项</span><br><span class=\"line\">&gt; + 第一项</span><br><span class=\"line\">&gt; + 第二项</span><br><span class=\"line\">&gt; + 第三项</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg\" alt=\"区块中使用列表图\"></p>\n<h2 id=\"列表中使用区块\"><a href=\"#列表中使用区块\" class=\"headerlink\" title=\"列表中使用区块\"></a>列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p>\n<p>列表中使用区块实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">    &gt; 菜鸟教程</span><br><span class=\"line\">    &gt; 学的不仅是技术更是梦想</span><br><span class=\"line\">* 第二项</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg\" alt=\"列表中使用区块图\"></p>\n<h1 id=\"Markdown图片\"><a href=\"#Markdown图片\" class=\"headerlink\" title=\"Markdown图片\"></a>Markdown图片</h1><p>Markdown 图片语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt 属性文本](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开头一个感叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li>\n</ul>\n<p>使用实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)</span><br><span class=\"line\"></span><br><span class=\"line\">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg\" alt=\"图片使用Demo图\"></p>\n<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;50%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg\" alt=\"图片img使用Demo图\"></p>\n<h1 id=\"Markdown代码\"><a href=\"#Markdown代码\" class=\"headerlink\" title=\"Markdown代码\"></a>Markdown代码</h1><h2 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`printf()` 函数</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg\" alt=\"片段代码图\"></p>\n<h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。（没效果）</p>\n<p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;你好~&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg\" alt=\"代码区块2\"></p>\n<h1 id=\"Markdoun链接\"><a href=\"#Markdoun链接\" class=\"headerlink\" title=\"Markdoun链接\"></a>Markdoun链接</h1><p>链接使用语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[链接名称](链接地址)</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>列如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(https://www.baidu.com/)</span><br><span class=\"line\"></span><br><span class=\"line\">[百度一下](https://www.baidu.com/)</span><br></pre></td></tr></table></figure>\n<p>显示效果：<br>// TODO</p>\n<h1 id=\"Markdoun表格\"><a href=\"#Markdoun表格\" class=\"headerlink\" title=\"Markdoun表格\"></a>Markdoun表格</h1><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>\n<p>语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|  表头   | 表头  |</span><br><span class=\"line\">|  ----  | ----  |</span><br><span class=\"line\">| 单元格  | 单元格 |</span><br><span class=\"line\">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>\n<p>以上代码显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg\" alt=\"表格\"></p>\n<h2 id=\"表格对齐\"><a href=\"#表格对齐\" class=\"headerlink\" title=\"表格对齐\"></a>表格对齐</h2><p>我们可以设置表格的对齐方式：</p>\n<ul>\n<li>-: 设置内容和标题栏居右对齐。</li>\n<li>:- 设置内容和标题栏居左对齐。</li>\n<li>:-: 设置内容和标题栏居中对齐。  </li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class=\"line\">| :-----| ----: | :----: |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg\" alt=\"表格对齐\"></p>\n<h1 id=\"Markdoun高级技巧\"><a href=\"#Markdoun高级技巧\" class=\"headerlink\" title=\"Markdoun高级技巧\"></a>Markdoun高级技巧</h1><p>// TODO</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Markdown标题\"><a href=\"#Markdown标题\" class=\"headerlink\" title=\"Markdown标题\"></a>Markdown标题</h1><h2 id=\"使用-和-表示一级和二级标题\"><a href=\"#使用-和-表示一级和二级标题\" class=\"headerlink\" title=\"使用 = 和 - 表示一级和二级标题\"></a>使用 = 和 - 表示一级和二级标题</h2><p>= 和 - 标记语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我展示的是一级标题</span><br><span class=\"line\">=================</span><br><span class=\"line\"></span><br><span class=\"line\">我展示的是二级标题</span><br><span class=\"line\">---------------</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"使用-号标记\"><a href=\"#使用-号标记\" class=\"headerlink\" title=\"使用 # 号标记\"></a>使用 # 号标记</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Markdown-段落格式\"><a href=\"#Markdown-段落格式\" class=\"headerlink\" title=\"Markdown 段落格式\"></a>Markdown 段落格式</h1><h2 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg\" alt=\"效果图\"></p>\n<p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg\" alt=\"效果图\"></p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*斜体文本*</span><br><span class=\"line\">_斜体文本_</span><br><span class=\"line\">**粗体文本**</span><br><span class=\"line\">__粗体文本__</span><br><span class=\"line\">***粗斜体文本***</span><br><span class=\"line\">___粗斜体文本___</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md3.gif\" alt=\"效果图\"></p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">***</span><br><span class=\"line\"></span><br><span class=\"line\">* * *</span><br><span class=\"line\"></span><br><span class=\"line\">*****</span><br><span class=\"line\"></span><br><span class=\"line\">- - -</span><br><span class=\"line\"></span><br><span class=\"line\">----------</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg\" alt=\"效果图\"></p>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUNOOB.COM</span><br><span class=\"line\">GOOGLE.COM</span><br><span class=\"line\">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg\" alt=\"效果图\"></p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>下划线可以通过 HTML 的 <u> 标签来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>\n\n<p>显示效果如下所示：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg\" alt=\"效果图\"></p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明。<br>Markdown 脚注的格式如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[^要注明的文本]</span><br></pre></td></tr></table></figure>\n\n<p>以下实例演示了脚注的用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class=\"line\"></span><br><span class=\"line\">[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span><br></pre></td></tr></table></figure>\n\n<p>演示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/md5.gif\" alt=\"效果图\"></p>\n<h1 id=\"Markdown列表\"><a href=\"#Markdown列表\" class=\"headerlink\" title=\"Markdown列表\"></a>Markdown列表</h1><p>Markdown 支持有序列表和无序列表。</p>\n<h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">* 第二项</span><br><span class=\"line\">* 第三项</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一项</span><br><span class=\"line\">+ 第二项</span><br><span class=\"line\">+ 第三项</span><br><span class=\"line\"></span><br><span class=\"line\">- 第一项</span><br><span class=\"line\">- 第二项</span><br><span class=\"line\">- 第三项</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg\" alt=\"无序列表图\"></p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项</span><br><span class=\"line\">2. 第二项</span><br><span class=\"line\">3. 第三项</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg\" alt=\"有序列表图\"></p>\n<h2 id=\"列表嵌套\"><a href=\"#列表嵌套\" class=\"headerlink\" title=\"列表嵌套\"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 第一项：</span><br><span class=\"line\">    - 第一项嵌套的第一个元素</span><br><span class=\"line\">    - 第一项嵌套的第二个元素</span><br><span class=\"line\">2. 第二项：</span><br><span class=\"line\">    - 第二项嵌套的第一个元素</span><br><span class=\"line\">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg\" alt=\"列表嵌套图\"></p>\n<h1 id=\"Markdown区块\"><a href=\"#Markdown区块\" class=\"headerlink\" title=\"Markdown区块\"></a>Markdown区块</h1><h2 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 区块引用</span><br><span class=\"line\">&gt; 菜鸟教程</span><br><span class=\"line\">&gt; 学的不仅是技术更是梦想</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg\" alt=\"区块图\"></p>\n<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 最外层</span><br><span class=\"line\">&gt; &gt; 第一层嵌套</span><br><span class=\"line\">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg\" alt=\"区块嵌套图\"></p>\n<h2 id=\"区块中使用列表\"><a href=\"#区块中使用列表\" class=\"headerlink\" title=\"区块中使用列表\"></a>区块中使用列表</h2><p>区块中使用列表实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 区块中使用列表</span><br><span class=\"line\">&gt; 1. 第一项</span><br><span class=\"line\">&gt; 2. 第二项</span><br><span class=\"line\">&gt; + 第一项</span><br><span class=\"line\">&gt; + 第二项</span><br><span class=\"line\">&gt; + 第三项</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg\" alt=\"区块中使用列表图\"></p>\n<h2 id=\"列表中使用区块\"><a href=\"#列表中使用区块\" class=\"headerlink\" title=\"列表中使用区块\"></a>列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p>\n<p>列表中使用区块实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 第一项</span><br><span class=\"line\">    &gt; 菜鸟教程</span><br><span class=\"line\">    &gt; 学的不仅是技术更是梦想</span><br><span class=\"line\">* 第二项</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg\" alt=\"列表中使用区块图\"></p>\n<h1 id=\"Markdown图片\"><a href=\"#Markdown图片\" class=\"headerlink\" title=\"Markdown图片\"></a>Markdown图片</h1><p>Markdown 图片语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![alt 属性文本](图片地址)</span><br><span class=\"line\"></span><br><span class=\"line\">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开头一个感叹号 !</li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li>\n</ul>\n<p>使用实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)</span><br><span class=\"line\"></span><br><span class=\"line\">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg\" alt=\"图片使用Demo图\"></p>\n<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://static.runoob.com/images/runoob-logo.png&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;50%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg\" alt=\"图片img使用Demo图\"></p>\n<h1 id=\"Markdown代码\"><a href=\"#Markdown代码\" class=\"headerlink\" title=\"Markdown代码\"></a>Markdown代码</h1><h2 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`printf()` 函数</span><br></pre></td></tr></table></figure>\n<p>显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg\" alt=\"片段代码图\"></p>\n<h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。（没效果）</p>\n<p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;你好~&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显示效果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg\" alt=\"代码区块2\"></p>\n<h1 id=\"Markdoun链接\"><a href=\"#Markdoun链接\" class=\"headerlink\" title=\"Markdoun链接\"></a>Markdoun链接</h1><p>链接使用语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[链接名称](链接地址)</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>列如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(https://www.baidu.com/)</span><br><span class=\"line\"></span><br><span class=\"line\">[百度一下](https://www.baidu.com/)</span><br></pre></td></tr></table></figure>\n<p>显示效果：<br>// TODO</p>\n<h1 id=\"Markdoun表格\"><a href=\"#Markdoun表格\" class=\"headerlink\" title=\"Markdoun表格\"></a>Markdoun表格</h1><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>\n<p>语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|  表头   | 表头  |</span><br><span class=\"line\">|  ----  | ----  |</span><br><span class=\"line\">| 单元格  | 单元格 |</span><br><span class=\"line\">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>\n<p>以上代码显示结果如下：<br><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg\" alt=\"表格\"></p>\n<h2 id=\"表格对齐\"><a href=\"#表格对齐\" class=\"headerlink\" title=\"表格对齐\"></a>表格对齐</h2><p>我们可以设置表格的对齐方式：</p>\n<ul>\n<li>-: 设置内容和标题栏居右对齐。</li>\n<li>:- 设置内容和标题栏居左对齐。</li>\n<li>:-: 设置内容和标题栏居中对齐。  </li>\n</ul>\n<p>实例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class=\"line\">| :-----| ----: | :----: |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br><span class=\"line\">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg\" alt=\"表格对齐\"></p>\n<h1 id=\"Markdoun高级技巧\"><a href=\"#Markdoun高级技巧\" class=\"headerlink\" title=\"Markdoun高级技巧\"></a>Markdoun高级技巧</h1><p>// TODO</p>"},{"title":"MySQL-主从复制","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 主从复制是什么\n\n主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。  \n主机（master）以写为主，备机（slave）以读为主。\n\n# 应用场景\n\n1）读写分离（提高性能，多从可以提高查询速度）  \n2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）\n\n# ","source":"_posts/oyr/MySQL/MySQL-主从复制.md","raw":"---\ntitle: MySQL-主从复制\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MySQL\ntags: \n\t- MySQL\n\t- 数据库\n---\n\n# 主从复制是什么\n\n主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。  \n主机（master）以写为主，备机（slave）以读为主。\n\n# 应用场景\n\n1）读写分离（提高性能，多从可以提高查询速度）  \n2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）\n\n# ","slug":"oyr/MySQL/MySQL-主从复制","published":1,"updated":"2021-10-26T10:30:44.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86n0028cst72g5pa9iu","content":"<h1 id=\"主从复制是什么\"><a href=\"#主从复制是什么\" class=\"headerlink\" title=\"主从复制是什么\"></a>主从复制是什么</h1><p>主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。<br>主机（master）以写为主，备机（slave）以读为主。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>1）读写分离（提高性能，多从可以提高查询速度）<br>2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"主从复制是什么\"><a href=\"#主从复制是什么\" class=\"headerlink\" title=\"主从复制是什么\"></a>主从复制是什么</h1><p>主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。<br>主机（master）以写为主，备机（slave）以读为主。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>1）读写分离（提高性能，多从可以提高查询速度）<br>2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"Nginx","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Nginx/Nginx.md","raw":"---\ntitle: Nginx\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Nginx\ntags: \n   - Nginx\n   - 中间件\n---","slug":"oyr/Nginx/Nginx","published":1,"updated":"2021-10-27T02:47:04.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86o002dcst7bqujczfr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL-事务日志","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# MySQL 事务日志（redolog & undolog）\n\nInnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\n\n1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。  \n2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。\n\n<!-- more -->\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。  \n用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n## redo log的基本概念\n\nredo log包含两部分：  \n一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；  \n二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；\n\n在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。\n\n## redo log（重做日志） vs bin log（二进制日志）\n\n// TODO\n\nredo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。\n\n### 产生的地方不一样\n\nbin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。  \nredo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。\n\n### 记录的内容不同\n\nbin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。  \nredo log是物理日志，记录该数据页更新的内容。\n\n### 写入的方式不同\n\nbin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。  \nredo log是循环写，日志空间大小固定。\n\n# undo log（回滚日志）\n\n## 定义\n\nredo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。    \n保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。  \n同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。\n\nundo log 和 redo log记录的物理日志不一样，它是逻辑日志。  \n可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。  \n有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。\n\n**undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。\n另外，undo log也会产生redo log，因为undo log也要实现持久性保护。**\n\n**保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。**\n\n***\n\n## \n\n\n","source":"_posts/oyr/MySQL/MySQL-事务日志.md","raw":"---\ntitle: MySQL-事务日志\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MySQL\ntags: \n\t- MySQL\n\t- 数据库\n---\n\n# MySQL 事务日志（redolog & undolog）\n\nInnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\n\n1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。  \n2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。\n\n<!-- more -->\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。  \n用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n## redo log的基本概念\n\nredo log包含两部分：  \n一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；  \n二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；\n\n在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。\n\n## redo log（重做日志） vs bin log（二进制日志）\n\n// TODO\n\nredo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。\n\n### 产生的地方不一样\n\nbin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。  \nredo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。\n\n### 记录的内容不同\n\nbin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。  \nredo log是物理日志，记录该数据页更新的内容。\n\n### 写入的方式不同\n\nbin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。  \nredo log是循环写，日志空间大小固定。\n\n# undo log（回滚日志）\n\n## 定义\n\nredo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。    \n保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。  \n同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。\n\nundo log 和 redo log记录的物理日志不一样，它是逻辑日志。  \n可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。  \n有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。\n\n**undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。\n另外，undo log也会产生redo log，因为undo log也要实现持久性保护。**\n\n**保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。**\n\n***\n\n## \n\n\n","slug":"oyr/MySQL/MySQL-事务日志","published":1,"updated":"2021-10-26T10:30:44.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86o002fcst70w229pnh","content":"<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>InnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。</p>\n<p>1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。<br>2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。<br>用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h2 id=\"redo-log的基本概念\"><a href=\"#redo-log的基本概念\" class=\"headerlink\" title=\"redo log的基本概念\"></a>redo log的基本概念</h2><p>redo log包含两部分：<br>一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；<br>二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；</p>\n<p>在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>\n<h2 id=\"redo-log（重做日志）-vs-bin-log（二进制日志）\"><a href=\"#redo-log（重做日志）-vs-bin-log（二进制日志）\" class=\"headerlink\" title=\"redo log（重做日志） vs bin log（二进制日志）\"></a>redo log（重做日志） vs bin log（二进制日志）</h2><p>// TODO</p>\n<p>redo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。</p>\n<h3 id=\"产生的地方不一样\"><a href=\"#产生的地方不一样\" class=\"headerlink\" title=\"产生的地方不一样\"></a>产生的地方不一样</h3><p>bin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。<br>redo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。</p>\n<h3 id=\"记录的内容不同\"><a href=\"#记录的内容不同\" class=\"headerlink\" title=\"记录的内容不同\"></a>记录的内容不同</h3><p>bin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。<br>redo log是物理日志，记录该数据页更新的内容。</p>\n<h3 id=\"写入的方式不同\"><a href=\"#写入的方式不同\" class=\"headerlink\" title=\"写入的方式不同\"></a>写入的方式不同</h3><p>bin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。<br>redo log是循环写，日志空间大小固定。</p>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。<br>保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。<br>同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>\n<p>undo log 和 redo log记录的物理日志不一样，它是逻辑日志。<br>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<p>当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。<br>有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>\n<p><strong>undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。<br>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</strong></p>\n<p><strong>保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</strong></p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>InnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。</p>\n<p>1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。<br>2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。</p>","more":"<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。<br>用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h2 id=\"redo-log的基本概念\"><a href=\"#redo-log的基本概念\" class=\"headerlink\" title=\"redo log的基本概念\"></a>redo log的基本概念</h2><p>redo log包含两部分：<br>一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；<br>二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；</p>\n<p>在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>\n<h2 id=\"redo-log（重做日志）-vs-bin-log（二进制日志）\"><a href=\"#redo-log（重做日志）-vs-bin-log（二进制日志）\" class=\"headerlink\" title=\"redo log（重做日志） vs bin log（二进制日志）\"></a>redo log（重做日志） vs bin log（二进制日志）</h2><p>// TODO</p>\n<p>redo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。</p>\n<h3 id=\"产生的地方不一样\"><a href=\"#产生的地方不一样\" class=\"headerlink\" title=\"产生的地方不一样\"></a>产生的地方不一样</h3><p>bin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。<br>redo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。</p>\n<h3 id=\"记录的内容不同\"><a href=\"#记录的内容不同\" class=\"headerlink\" title=\"记录的内容不同\"></a>记录的内容不同</h3><p>bin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。<br>redo log是物理日志，记录该数据页更新的内容。</p>\n<h3 id=\"写入的方式不同\"><a href=\"#写入的方式不同\" class=\"headerlink\" title=\"写入的方式不同\"></a>写入的方式不同</h3><p>bin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。<br>redo log是循环写，日志空间大小固定。</p>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。<br>保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。<br>同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>\n<p>undo log 和 redo log记录的物理日志不一样，它是逻辑日志。<br>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<p>当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。<br>有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>\n<p><strong>undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。<br>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</strong></p>\n<p><strong>保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</strong></p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"MySQL-日志系统","date":"2021-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# MySQL日志分类\n\n注意：  \n设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。  \n如果想要当前会话生效通过set sesison进行设置。\n\n## 日志分类\n\nMysql有7种日志文件，分别是：  \n1）errorlog（错误日志）  \n2）generallog（普通日志）  \n3）slow query log（慢查询日志）  \n4）binlog（二进制日志）  \n5）relaylog（中继日志）  \n6）redolog（重做日志）  \n7）undolog（回滚日志）\n\n***\n\n<!-- more -->\n\n## 重要日志\n\nslow query log：慢查询日志  \nundolog-redolog：事务日志（innoDB存储引擎日志）  \nbinlog：二进制日志（server层日志）  \nrelaylog：中继日志（主从复制）\n\n***\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://rong0624.gitee.io/images/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://rong0624.gitee.io/images/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\n\nbin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  \n\n**用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。**\n\n***\n\n## 应用场景\n\n1）数据恢复  \n做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。\n2）mysql主从复制  \n做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看是否启动bin log 日志\nshow variables like 'log_bin';\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n2）查看binlog的目录  \nshow global variables like \"%log_bin%\";\n\n\n3）查看主库的日志文件，以及position信息\nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       314 |\n| mysql-bin.000002 |       639 |\n+------------------+-----------+\n2 rows in set (0.00 sec)\n```\n\n4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000002 |      639 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;  \n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n6）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 开启bin log\n\n注意：mysql 8.0 版本之前，默认不开启，建议开启。\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://rong0624.gitee.io/images/MySQL/1624350274231.jpg)\n\n***\n\n## bin log 的写入时机\n\n对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。\n\nsync_binlog参数讲解：  \n1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；  \n2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。  \n3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。\n\n如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。\n\n在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。\n\n***\n\n## bin log 文件以及扩展\n\n二进制日志包含两种文件：  \n* 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n* 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\nbinlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  \n* 魔数：0xfe62696e对应的是0xfebin； \n* Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；\n* 第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；\n* 其余的Event按照第一个Event的格式版本写入；\n* 最后一个Event用于说明下一个binlog文件；\n* binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表\n\n当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：\n* MySQL服务器停止或重启时\n* 使用 flush logs 命令；\n* 当 binlog 文件大小超过 max_binlog_size 变量的值时；\n\nmax_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。\n\n注意：bin log与数据库文件在同目录中。  \n\n***\n\n## bin log 的日志格式\n\n记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：\n* STATEMENT：基于SQL语句的复制（statement-based replication, SBR）\n* ROW：基于行的复制（row-based replication, RBR）\n* MIXED：混合模式复制（mixed-based replication, MBR）\n\n**注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。**\n\n### Statement\n\n每一条会修改数据的sql都会记录在binlog中\n\n优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。\n\n缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。\n\n### Row\n\n5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。\n\n优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.\n\n缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。\n\n注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。\n\n### Mixed\n\n从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。  \n在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\n\n### bin log企业模式的选择\n\n互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；\n用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；\n用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；\n\n## 查看二进制日志文件\n\nbin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\nmysqlbinlog 使用语法：\n```bash\n# mysqlbinlog 的执行格式\nmysqlbinlog [options] log_file ...\n-s                          以精简的方式显示日志内容\n-v                          以详细的方式显示日志内容\n-d=数据库名                  只显示指定数据库的日志内容\n-o=n                        忽略日志中前n行MySQL命令\n-r=file                     将指定内容写入指定文件\n--start-datetime  \n                            显示指定时间范围内的日志内容\n--stop-datetime         \n\n--start-position        \n                            显示指定位置间隔内的日志内容\n--stop-position     \n\n# 查看bin-log二进制文件（shell方式）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003\n\n# 查看bin-log二进制文件（带查询条件）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\\n    --start-datetime=\"2019-03-01 00:00:00\"  \\\n    --stop-datetime=\"2019-03-10 00:00:00\"   \\\n    --start-position=\"5000\"    \\\n    --stop-position=\"20000\"\n```\n\n查看二进制日志文件：mysqlbinlog -v --base64-output=decode-rows mysql-bin.000002 \n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n```\n解释：  \n* position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始\n* timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）\n* server id: 服务器标识（1）\n* end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）\n* thread_id: 执行该事件的线程id （thread_id=2）\n* exec_time: 事件执行的花费时间\n* error_code: 错误码，0意味着没有发生错误\n* type：事件类型Query\n\n### 命令查看\n\nmysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\n// TODO\n\n# MySQL 事务日志（redolog & undolog）\n\n请看MySQL事务日志分析博客","source":"_posts/oyr/MySQL/MySQL-日志系统.md","raw":"---\ntitle: MySQL-日志系统\ndate: 2021-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MySQL\ntags: \n\t- MySQL\n\t- 数据库\n---\n\n# MySQL日志分类\n\n注意：  \n设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。  \n如果想要当前会话生效通过set sesison进行设置。\n\n## 日志分类\n\nMysql有7种日志文件，分别是：  \n1）errorlog（错误日志）  \n2）generallog（普通日志）  \n3）slow query log（慢查询日志）  \n4）binlog（二进制日志）  \n5）relaylog（中继日志）  \n6）redolog（重做日志）  \n7）undolog（回滚日志）\n\n***\n\n<!-- more -->\n\n## 重要日志\n\nslow query log：慢查询日志  \nundolog-redolog：事务日志（innoDB存储引擎日志）  \nbinlog：二进制日志（server层日志）  \nrelaylog：中继日志（主从复制）\n\n***\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://rong0624.gitee.io/images/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://rong0624.gitee.io/images/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\n\nbin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  \n\n**用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。**\n\n***\n\n## 应用场景\n\n1）数据恢复  \n做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。\n2）mysql主从复制  \n做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看是否启动bin log 日志\nshow variables like 'log_bin';\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n2）查看binlog的目录  \nshow global variables like \"%log_bin%\";\n\n\n3）查看主库的日志文件，以及position信息\nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       314 |\n| mysql-bin.000002 |       639 |\n+------------------+-----------+\n2 rows in set (0.00 sec)\n```\n\n4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000002 |      639 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;  \n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n6）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 开启bin log\n\n注意：mysql 8.0 版本之前，默认不开启，建议开启。\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://rong0624.gitee.io/images/MySQL/1624350274231.jpg)\n\n***\n\n## bin log 的写入时机\n\n对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。\n\nsync_binlog参数讲解：  \n1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；  \n2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。  \n3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。\n\n如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。\n\n在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。\n\n***\n\n## bin log 文件以及扩展\n\n二进制日志包含两种文件：  \n* 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n* 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\nbinlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  \n* 魔数：0xfe62696e对应的是0xfebin； \n* Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；\n* 第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；\n* 其余的Event按照第一个Event的格式版本写入；\n* 最后一个Event用于说明下一个binlog文件；\n* binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表\n\n当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：\n* MySQL服务器停止或重启时\n* 使用 flush logs 命令；\n* 当 binlog 文件大小超过 max_binlog_size 变量的值时；\n\nmax_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。\n\n注意：bin log与数据库文件在同目录中。  \n\n***\n\n## bin log 的日志格式\n\n记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：\n* STATEMENT：基于SQL语句的复制（statement-based replication, SBR）\n* ROW：基于行的复制（row-based replication, RBR）\n* MIXED：混合模式复制（mixed-based replication, MBR）\n\n**注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。**\n\n### Statement\n\n每一条会修改数据的sql都会记录在binlog中\n\n优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。\n\n缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。\n\n### Row\n\n5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。\n\n优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.\n\n缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。\n\n注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。\n\n### Mixed\n\n从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。  \n在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\n\n### bin log企业模式的选择\n\n互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；\n用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；\n用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；\n\n## 查看二进制日志文件\n\nbin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\nmysqlbinlog 使用语法：\n```bash\n# mysqlbinlog 的执行格式\nmysqlbinlog [options] log_file ...\n-s                          以精简的方式显示日志内容\n-v                          以详细的方式显示日志内容\n-d=数据库名                  只显示指定数据库的日志内容\n-o=n                        忽略日志中前n行MySQL命令\n-r=file                     将指定内容写入指定文件\n--start-datetime  \n                            显示指定时间范围内的日志内容\n--stop-datetime         \n\n--start-position        \n                            显示指定位置间隔内的日志内容\n--stop-position     \n\n# 查看bin-log二进制文件（shell方式）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003\n\n# 查看bin-log二进制文件（带查询条件）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\\n    --start-datetime=\"2019-03-01 00:00:00\"  \\\n    --stop-datetime=\"2019-03-10 00:00:00\"   \\\n    --start-position=\"5000\"    \\\n    --stop-position=\"20000\"\n```\n\n查看二进制日志文件：mysqlbinlog -v --base64-output=decode-rows mysql-bin.000002 \n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n```\n解释：  \n* position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始\n* timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）\n* server id: 服务器标识（1）\n* end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）\n* thread_id: 执行该事件的线程id （thread_id=2）\n* exec_time: 事件执行的花费时间\n* error_code: 错误码，0意味着没有发生错误\n* type：事件类型Query\n\n### 命令查看\n\nmysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\n// TODO\n\n# MySQL 事务日志（redolog & undolog）\n\n请看MySQL事务日志分析博客","slug":"oyr/MySQL/MySQL-日志系统","published":1,"updated":"2021-10-26T10:30:44.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86p002jcst7hj76bzov","content":"<h1 id=\"MySQL日志分类\"><a href=\"#MySQL日志分类\" class=\"headerlink\" title=\"MySQL日志分类\"></a>MySQL日志分类</h1><p>注意：<br>设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。<br>如果想要当前会话生效通过set sesison进行设置。</p>\n<h2 id=\"日志分类\"><a href=\"#日志分类\" class=\"headerlink\" title=\"日志分类\"></a>日志分类</h2><p>Mysql有7种日志文件，分别是：<br>1）errorlog（错误日志）<br>2）generallog（普通日志）<br>3）slow query log（慢查询日志）<br>4）binlog（二进制日志）<br>5）relaylog（中继日志）<br>6）redolog（重做日志）<br>7）undolog（回滚日志）</p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"重要日志\"><a href=\"#重要日志\" class=\"headerlink\" title=\"重要日志\"></a>重要日志</h2><p>slow query log：慢查询日志<br>undolog-redolog：事务日志（innoDB存储引擎日志）<br>binlog：二进制日志（server层日志）<br>relaylog：中继日志（主从复制）</p>\n<hr>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>\n<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://rong0624.gitee.io/images/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://rong0624.gitee.io/images/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  </p>\n<p><strong>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</strong></p>\n<hr>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>1）数据恢复<br>做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。<br>2）mysql主从复制<br>做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  </p>\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看是否启动bin log 日志<br>show variables like ‘log_bin’;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看binlog的目录<br>show global variables like “%log_bin%”;</p>\n<p>3）查看主库的日志文件，以及position信息<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       314 |</span><br><span class=\"line\">| mysql-bin.000002 |       639 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      639 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;<br>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>6）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"开启bin-log\"><a href=\"#开启bin-log\" class=\"headerlink\" title=\"开启bin log\"></a>开启bin log</h2><p>注意：mysql 8.0 版本之前，默认不开启，建议开启。</p>\n<p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://rong0624.gitee.io/images/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"bin-log-的写入时机\"><a href=\"#bin-log-的写入时机\" class=\"headerlink\" title=\"bin log 的写入时机\"></a>bin log 的写入时机</h2><p>对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。</p>\n<p>sync_binlog参数讲解：<br>1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；<br>2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。<br>3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。</p>\n<p>如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。</p>\n<p>在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。</p>\n<hr>\n<h2 id=\"bin-log-文件以及扩展\"><a href=\"#bin-log-文件以及扩展\" class=\"headerlink\" title=\"bin log 文件以及扩展\"></a>bin log 文件以及扩展</h2><p>二进制日志包含两种文件：  </p>\n<ul>\n<li>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  </li>\n<li>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</li>\n</ul>\n<p>binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  </p>\n<ul>\n<li>魔数：0xfe62696e对应的是0xfebin； </li>\n<li>Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；</li>\n<li>第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；</li>\n<li>其余的Event按照第一个Event的格式版本写入；</li>\n<li>最后一个Event用于说明下一个binlog文件；</li>\n<li>binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表</li>\n</ul>\n<p>当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：</p>\n<ul>\n<li>MySQL服务器停止或重启时</li>\n<li>使用 flush logs 命令；</li>\n<li>当 binlog 文件大小超过 max_binlog_size 变量的值时；</li>\n</ul>\n<p>max_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。</p>\n<p>注意：bin log与数据库文件在同目录中。  </p>\n<hr>\n<h2 id=\"bin-log-的日志格式\"><a href=\"#bin-log-的日志格式\" class=\"headerlink\" title=\"bin log 的日志格式\"></a>bin log 的日志格式</h2><p>记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：</p>\n<ul>\n<li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li>\n<li>ROW：基于行的复制（row-based replication, RBR）</li>\n<li>MIXED：混合模式复制（mixed-based replication, MBR）</li>\n</ul>\n<p><strong>注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。</strong></p>\n<h3 id=\"Statement\"><a href=\"#Statement\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><p>每一条会修改数据的sql都会记录在binlog中</p>\n<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p>\n<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。</p>\n<h3 id=\"Row\"><a href=\"#Row\" class=\"headerlink\" title=\"Row\"></a>Row</h3><p>5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>\n<p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p>\n<p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p>\n<p>注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。</p>\n<h3 id=\"Mixed\"><a href=\"#Mixed\" class=\"headerlink\" title=\"Mixed\"></a>Mixed</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>\n<h3 id=\"bin-log企业模式的选择\"><a href=\"#bin-log企业模式的选择\" class=\"headerlink\" title=\"bin log企业模式的选择\"></a>bin log企业模式的选择</h3><p>互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；<br>用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；<br>用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；</p>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>mysqlbinlog 使用语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysqlbinlog 的执行格式</span></span><br><span class=\"line\">mysqlbinlog [options] log_file ...</span><br><span class=\"line\">-s                          以精简的方式显示日志内容</span><br><span class=\"line\">-v                          以详细的方式显示日志内容</span><br><span class=\"line\">-d=数据库名                  只显示指定数据库的日志内容</span><br><span class=\"line\">-o=n                        忽略日志中前n行MySQL命令</span><br><span class=\"line\">-r=file                     将指定内容写入指定文件</span><br><span class=\"line\">--start-datetime  </span><br><span class=\"line\">                            显示指定时间范围内的日志内容</span><br><span class=\"line\">--stop-datetime         </span><br><span class=\"line\"></span><br><span class=\"line\">--start-position        </span><br><span class=\"line\">                            显示指定位置间隔内的日志内容</span><br><span class=\"line\">--stop-position     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（shell方式）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（带查询条件）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\</span><br><span class=\"line\">    --start-datetime=<span class=\"string\">&quot;2019-03-01 00:00:00&quot;</span>  \\</span><br><span class=\"line\">    --stop-datetime=<span class=\"string\">&quot;2019-03-10 00:00:00&quot;</span>   \\</span><br><span class=\"line\">    --start-position=<span class=\"string\">&quot;5000&quot;</span>    \\</span><br><span class=\"line\">    --stop-position=<span class=\"string\">&quot;20000&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>查看二进制日志文件：mysqlbinlog -v –base64-output=decode-rows mysql-bin.000002 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br></pre></td></tr></table></figure>\n<p>解释：  </p>\n<ul>\n<li>position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始</li>\n<li>timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）</li>\n<li>server id: 服务器标识（1）</li>\n<li>end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）</li>\n<li>thread_id: 执行该事件的线程id （thread_id=2）</li>\n<li>exec_time: 事件执行的花费时间</li>\n<li>error_code: 错误码，0意味着没有发生错误</li>\n<li>type：事件类型Query</li>\n</ul>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>// TODO</p>\n<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>请看MySQL事务日志分析博客</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"MySQL日志分类\"><a href=\"#MySQL日志分类\" class=\"headerlink\" title=\"MySQL日志分类\"></a>MySQL日志分类</h1><p>注意：<br>设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。<br>如果想要当前会话生效通过set sesison进行设置。</p>\n<h2 id=\"日志分类\"><a href=\"#日志分类\" class=\"headerlink\" title=\"日志分类\"></a>日志分类</h2><p>Mysql有7种日志文件，分别是：<br>1）errorlog（错误日志）<br>2）generallog（普通日志）<br>3）slow query log（慢查询日志）<br>4）binlog（二进制日志）<br>5）relaylog（中继日志）<br>6）redolog（重做日志）<br>7）undolog（回滚日志）</p>\n<hr>","more":"<h2 id=\"重要日志\"><a href=\"#重要日志\" class=\"headerlink\" title=\"重要日志\"></a>重要日志</h2><p>slow query log：慢查询日志<br>undolog-redolog：事务日志（innoDB存储引擎日志）<br>binlog：二进制日志（server层日志）<br>relaylog：中继日志（主从复制）</p>\n<hr>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>\n<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://rong0624.gitee.io/images/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://rong0624.gitee.io/images/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  </p>\n<p><strong>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</strong></p>\n<hr>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>1）数据恢复<br>做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。<br>2）mysql主从复制<br>做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  </p>\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看是否启动bin log 日志<br>show variables like ‘log_bin’;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看binlog的目录<br>show global variables like “%log_bin%”;</p>\n<p>3）查看主库的日志文件，以及position信息<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       314 |</span><br><span class=\"line\">| mysql-bin.000002 |       639 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      639 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;<br>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>6）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"开启bin-log\"><a href=\"#开启bin-log\" class=\"headerlink\" title=\"开启bin log\"></a>开启bin log</h2><p>注意：mysql 8.0 版本之前，默认不开启，建议开启。</p>\n<p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://rong0624.gitee.io/images/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"bin-log-的写入时机\"><a href=\"#bin-log-的写入时机\" class=\"headerlink\" title=\"bin log 的写入时机\"></a>bin log 的写入时机</h2><p>对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。</p>\n<p>sync_binlog参数讲解：<br>1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；<br>2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。<br>3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。</p>\n<p>如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。</p>\n<p>在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。</p>\n<hr>\n<h2 id=\"bin-log-文件以及扩展\"><a href=\"#bin-log-文件以及扩展\" class=\"headerlink\" title=\"bin log 文件以及扩展\"></a>bin log 文件以及扩展</h2><p>二进制日志包含两种文件：  </p>\n<ul>\n<li>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  </li>\n<li>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</li>\n</ul>\n<p>binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  </p>\n<ul>\n<li>魔数：0xfe62696e对应的是0xfebin； </li>\n<li>Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；</li>\n<li>第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；</li>\n<li>其余的Event按照第一个Event的格式版本写入；</li>\n<li>最后一个Event用于说明下一个binlog文件；</li>\n<li>binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表</li>\n</ul>\n<p>当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：</p>\n<ul>\n<li>MySQL服务器停止或重启时</li>\n<li>使用 flush logs 命令；</li>\n<li>当 binlog 文件大小超过 max_binlog_size 变量的值时；</li>\n</ul>\n<p>max_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。</p>\n<p>注意：bin log与数据库文件在同目录中。  </p>\n<hr>\n<h2 id=\"bin-log-的日志格式\"><a href=\"#bin-log-的日志格式\" class=\"headerlink\" title=\"bin log 的日志格式\"></a>bin log 的日志格式</h2><p>记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：</p>\n<ul>\n<li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li>\n<li>ROW：基于行的复制（row-based replication, RBR）</li>\n<li>MIXED：混合模式复制（mixed-based replication, MBR）</li>\n</ul>\n<p><strong>注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。</strong></p>\n<h3 id=\"Statement\"><a href=\"#Statement\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><p>每一条会修改数据的sql都会记录在binlog中</p>\n<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p>\n<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。</p>\n<h3 id=\"Row\"><a href=\"#Row\" class=\"headerlink\" title=\"Row\"></a>Row</h3><p>5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>\n<p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p>\n<p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p>\n<p>注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。</p>\n<h3 id=\"Mixed\"><a href=\"#Mixed\" class=\"headerlink\" title=\"Mixed\"></a>Mixed</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>\n<h3 id=\"bin-log企业模式的选择\"><a href=\"#bin-log企业模式的选择\" class=\"headerlink\" title=\"bin log企业模式的选择\"></a>bin log企业模式的选择</h3><p>互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；<br>用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；<br>用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；</p>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>mysqlbinlog 使用语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysqlbinlog 的执行格式</span></span><br><span class=\"line\">mysqlbinlog [options] log_file ...</span><br><span class=\"line\">-s                          以精简的方式显示日志内容</span><br><span class=\"line\">-v                          以详细的方式显示日志内容</span><br><span class=\"line\">-d=数据库名                  只显示指定数据库的日志内容</span><br><span class=\"line\">-o=n                        忽略日志中前n行MySQL命令</span><br><span class=\"line\">-r=file                     将指定内容写入指定文件</span><br><span class=\"line\">--start-datetime  </span><br><span class=\"line\">                            显示指定时间范围内的日志内容</span><br><span class=\"line\">--stop-datetime         </span><br><span class=\"line\"></span><br><span class=\"line\">--start-position        </span><br><span class=\"line\">                            显示指定位置间隔内的日志内容</span><br><span class=\"line\">--stop-position     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（shell方式）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（带查询条件）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\</span><br><span class=\"line\">    --start-datetime=<span class=\"string\">&quot;2019-03-01 00:00:00&quot;</span>  \\</span><br><span class=\"line\">    --stop-datetime=<span class=\"string\">&quot;2019-03-10 00:00:00&quot;</span>   \\</span><br><span class=\"line\">    --start-position=<span class=\"string\">&quot;5000&quot;</span>    \\</span><br><span class=\"line\">    --stop-position=<span class=\"string\">&quot;20000&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>查看二进制日志文件：mysqlbinlog -v –base64-output=decode-rows mysql-bin.000002 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br></pre></td></tr></table></figure>\n<p>解释：  </p>\n<ul>\n<li>position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始</li>\n<li>timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）</li>\n<li>server id: 服务器标识（1）</li>\n<li>end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）</li>\n<li>thread_id: 执行该事件的线程id （thread_id=2）</li>\n<li>exec_time: 事件执行的花费时间</li>\n<li>error_code: 错误码，0意味着没有发生错误</li>\n<li>type：事件类型Query</li>\n</ul>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>// TODO</p>\n<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>请看MySQL事务日志分析博客</p>"},{"title":"MySQL-基础","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n# 常用数据类型\n\n## 数值型\n\n### 整型\n\n特点：  \n1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字  \n2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值  \n3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n### 小数\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n## 字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n## 日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数   \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名（两种方式）\nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n## 条件查询\n\n### 语法\n\n```\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n```\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \n```sql\nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n```\n\n\nCONCAT：  \n作用：拼接字符串  \n```sql\nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n```\n\n\nUPPER：  \n作用：字符串变大写  \n```sql\nSELECT UPPER(\"asc\");\n```\n\nLower：  \n作用：字符串变小写\n```sql\nSELECT LOWER(\"ASC\");\n```\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n```\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n```\n\nReplace：  \n作用：替换字符串  \n```sql\nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n```\n\nInstr:  \n作用：获取子串第一次出现的索引\n```sql\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n```\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```sql\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \n```sql\nSELECT CEIL(1.52);  \n结果：2\n```\n\n\nFloor：  \n作用：向下取整  \n```sql\nSELECT FLOOR(9.99);\n结果：9\n```\n\nTruncate：  \n作用：截断  \n```sql\nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n```\n\nMod：  \n作用：取余  \n```sql\nSELECT MOD(10, 3);  \n结果：1\n```\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \n```sql\nSELECT RAND();\n```\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","source":"_posts/oyr/MySQL/MySQL-基础.md","raw":"---\ntitle: MySQL-基础\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MySQL\ntags: \n\t- MySQL\n\t- 数据库\n---\n\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n# 常用数据类型\n\n## 数值型\n\n### 整型\n\n特点：  \n1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字  \n2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值  \n3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n### 小数\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n## 字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n## 日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数   \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名（两种方式）\nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n## 条件查询\n\n### 语法\n\n```\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n```\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \n```sql\nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n```\n\n\nCONCAT：  \n作用：拼接字符串  \n```sql\nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n```\n\n\nUPPER：  \n作用：字符串变大写  \n```sql\nSELECT UPPER(\"asc\");\n```\n\nLower：  \n作用：字符串变小写\n```sql\nSELECT LOWER(\"ASC\");\n```\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n```\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n```\n\nReplace：  \n作用：替换字符串  \n```sql\nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n```\n\nInstr:  \n作用：获取子串第一次出现的索引\n```sql\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n```\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```sql\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \n```sql\nSELECT CEIL(1.52);  \n结果：2\n```\n\n\nFloor：  \n作用：向下取整  \n```sql\nSELECT FLOOR(9.99);\n结果：9\n```\n\nTruncate：  \n作用：截断  \n```sql\nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n```\n\nMod：  \n作用：取余  \n```sql\nSELECT MOD(10, 3);  \n结果：1\n```\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \n```sql\nSELECT RAND();\n```\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","slug":"oyr/MySQL/MySQL-基础","published":1,"updated":"2021-10-26T10:30:44.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86p002lcst73si1c4s3","content":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>特点：<br>1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<h3 id=\"小数\"><a href=\"#小数\" class=\"headerlink\" title=\"小数\"></a>小数</h3><p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<h2 id=\"日期型\"><a href=\"#日期型\" class=\"headerlink\" title=\"日期型\"></a>日期型</h2><p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名（两种方式）<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select 查询列表  </span><br><span class=\"line\">From 表名  </span><br><span class=\"line\">Where 筛选条件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;oyr&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;欧阳荣&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>CONCAT：<br>作用：拼接字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"string\">&#x27;abc&#x27;</span>, <span class=\"string\">&#x27;jkl&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(first_name, last_name) out_put <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n\n<p>UPPER：<br>作用：字符串变大写  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">UPPER</span>(&quot;asc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Lower：<br>作用：字符串变小写</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">LOWER</span>(&quot;ASC&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;a&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">12</span>, <span class=\"string\">&#x27;ab&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Replace：<br>作用：替换字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> REPLACE(<span class=\"string\">&#x27;赵吊彬是zz赵吊彬赵吊彬赵吊彬&#x27;</span>, <span class=\"string\">&#x27;赵吊彬&#x27;</span>, <span class=\"string\">&#x27;李执志&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Instr:<br>作用：获取子串第一次出现的索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> INSTR(<span class=\"string\">&#x27;欧阳荣多对多&#x27;</span>, <span class=\"string\">&#x27;欧阳&#x27;</span>);</span><br><span class=\"line\">结果为：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.65</span>);</span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.657</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">结果：<span class=\"number\">1.66</span></span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CEIL</span>(<span class=\"number\">1.52</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n<p>Floor：<br>作用：向下取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">FLOOR</span>(<span class=\"number\">9.99</span>);</span><br><span class=\"line\">结果：<span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<p>Truncate：<br>作用：截断  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TRUNCATE</span>(<span class=\"number\">10.19</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">10.1</span></span><br></pre></td></tr></table></figure>\n\n<p>Mod：<br>作用：取余  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">MOD</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> RAND();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>特点：<br>1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<h3 id=\"小数\"><a href=\"#小数\" class=\"headerlink\" title=\"小数\"></a>小数</h3><p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<h2 id=\"日期型\"><a href=\"#日期型\" class=\"headerlink\" title=\"日期型\"></a>日期型</h2><p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名（两种方式）<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select 查询列表  </span><br><span class=\"line\">From 表名  </span><br><span class=\"line\">Where 筛选条件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;oyr&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;欧阳荣&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>CONCAT：<br>作用：拼接字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"string\">&#x27;abc&#x27;</span>, <span class=\"string\">&#x27;jkl&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(first_name, last_name) out_put <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n\n<p>UPPER：<br>作用：字符串变大写  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">UPPER</span>(&quot;asc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Lower：<br>作用：字符串变小写</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">LOWER</span>(&quot;ASC&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;a&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">12</span>, <span class=\"string\">&#x27;ab&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Replace：<br>作用：替换字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> REPLACE(<span class=\"string\">&#x27;赵吊彬是zz赵吊彬赵吊彬赵吊彬&#x27;</span>, <span class=\"string\">&#x27;赵吊彬&#x27;</span>, <span class=\"string\">&#x27;李执志&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Instr:<br>作用：获取子串第一次出现的索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> INSTR(<span class=\"string\">&#x27;欧阳荣多对多&#x27;</span>, <span class=\"string\">&#x27;欧阳&#x27;</span>);</span><br><span class=\"line\">结果为：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.65</span>);</span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.657</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">结果：<span class=\"number\">1.66</span></span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CEIL</span>(<span class=\"number\">1.52</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n<p>Floor：<br>作用：向下取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">FLOOR</span>(<span class=\"number\">9.99</span>);</span><br><span class=\"line\">结果：<span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<p>Truncate：<br>作用：截断  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TRUNCATE</span>(<span class=\"number\">10.19</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">10.1</span></span><br></pre></td></tr></table></figure>\n\n<p>Mod：<br>作用：取余  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">MOD</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> RAND();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n"},{"title":"Redis-哨兵模式","date":"2020-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Redis/Redis-哨兵模式.md","raw":"---\ntitle: Redis-哨兵模式\ndate: 2020-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Redis\ntags: \n    - Redis\n    - 中间件\n---","slug":"oyr/Redis/Redis-哨兵模式","published":1,"updated":"2021-10-26T10:31:03.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86q002qcst70m712v56","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Redis-主从复制","date":"2020-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Redis/Redis-主从复制.md","raw":"---\ntitle: Redis-主从复制\ndate: 2020-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Redis\ntags: \n    - Redis\n    - 中间件\n---","slug":"oyr/Redis/Redis-主从复制","published":1,"updated":"2021-10-26T10:31:03.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86r002rcst708bd3bn8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Redis-基础","date":"2020-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 入门概述\n\n## Redis是什么？\n\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 \n\nredis 的官网：redis.io\n\n<!-- more -->\n\n## Redis 与其他 key/value 缓存产品有以下三个特点\n\n1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用  \n2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储  \n3）Redis支持数据的备份，即master-slave模式的数据备份\n\n## 应用场景（redis能干些什么）\n\n1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务  \n2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面  \n3）模拟类似于HttpSession这种需要设定过期时间的功能  \n4）发布、订阅消息系统（消息中间件）  \n5）定时器、计数器  \n6）可以实现session共享  \n7）可以实现分布式锁\n\n# Redis的安装\n\n提示：  \n由于企业里面做Redis开发，99%都是Linux版的运用和安装。\n几乎不会涉及到Windows版，windows安装只是为了学习而已了。\n\n# Redis启动后的杂项知识（重要）\n\n1）单进程，redis速度很快。  \nredis读写性能测试，redis官网测试读写能到10万左右。\n\n2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。\n\n3）select命令切换数据库。\n\n4）dbsize查看当前数据库的key的数量。\n\n5）flushdb：清空当前库key。\n\n6）flushall：清空全部库。\n\n7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。\n\n8）redis索引都是从零开始。\n\n9）redis默认端口是6379。\n\n# Redis五大数据类型\n\n常用命令：   \nping：ping下redis    \ndbsize：查看当前数据库的key的数量  \nselect 1：切换到下标为1的数据库中  \nflushdb：清空当前库key  \nflushall：清空全部库key\n\n## Redis键的操作（常用）\n\n查看当前数据库的所有key:  \nKeys *\n\n判断当前key是否存在：  \nexists name\n\n将当前key移动到2号库中：  \nMove name 2\n\n设置key在6秒后过期：  \nexpire name 6\n\n查看当前key还有多久过期  \nttl name \n\n查看当前key是什么结构的类型  \ntype name\n\n## String 类型（常用）\n\n### 简介\n\nString是redis最基本的类型，可以理解成一个key对应一个value。  \nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。  \nredis一个字符串value最多可以是512M。\n\n### 操作\n\n```\nset name oyr：\t\t\t给键name设置值为oyr\n\nget name：\t\t\t\t获取键name的值\n\ndel name：\t\t\t\t删除建为name值\n\nappend name 123：\t\t在name对应的值后面追加123\n\nstrlen name：\t\t\t得到当前name对应的值的长度\n\nincr age：\t\t\t\tage+1，一定要是数字才能操作\n\nincrby age 10：\t\t\tage+10\n\ndecr age：\t\t\t\tage-1，一定要是数字才能操作\n\ndecrby age 10： \t\tage-10\n\nsetex name 10 oyr：\t\t\n（set with expire）\n设置key为name，过期时间为10秒，值为oyr\n\nsexnx name ooo：\n（sex if not exist）\n设置键位name，值为ooo，只有不存在的时候才会设置进去\n\nmset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值\n\nmget k1 k2 k3：\t\t\t\t\t一次获取多个值\n\nmsetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。\n```\n\n## Hash 类型（常用）\n\n### 简介\n\nRedis hash 是一个键值对集合。  \nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。  \n类似Java里面的Map<String,Object>，K-V模式不变，但V是一个键值对。\n\n### 操作\n\n```\n（1）hset\nhset user name oyr\t\t\t给键user的name属性设置值\n\n（2）hget\nhget user name\t\t\t\t获取键user的name值\n\n（3）hmset\nhmset user age 18 sex nan  \t\t同时设置多个值\n\n（4）hmget\nhmget user name age sex\t\t\t同时获取多个属性值\n\n（5）hgetall\nhgetall user \t\t\t\t\t获取键user中的所有键和值\n\n（6）hdel\nhdel user name\t\t\t\t\t删除键user中的name属性\n\n（7）hlen\nhlen user\t\t\t\t\t\t获取键user下有几个属性\n\n（8）hexists\nhexists user nane\t\t\t\t判断键user下是否有name属性\n\n（9）hkeys\nhkys user\t\t\t\t\t\t获取键user下的所有属性\n\n（10）hvals\nhvals user \t\t\t\t\t \t获取键user下的所有值\n\n（11）hsetnx\nhsetnx user name \"oyr\"\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。\n\n（12）hincrby \nhincrby  user age 10\t\t\t给键user里的age 属性添加10\n```\n\n## Lists 类型（双向链表）\n\n### 简介\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。  \n它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出\n\n### 操作\n\n```\nlpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加\n\nlrange list1 0 -1\t\t\t获取list1链表所有数据\n\nrpush list2 1 2 3\t\t\t给链表list2尾部插入元素\n\nlpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）\n\nrpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）\n\nlindex list1 3\t\t\t\t获取链表的3索引位置的值\n\n\tlist1\t\t\t\t\t获取list1 链表的长度\n\nlset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s\n\nlrem list3 2 d\t\t\t\t删除链表2个d元素\n\nltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃\n\nlinsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素\n\nrpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表\n```\n\n### 性能总结\n\n它是一个字符串链表，left、right都可以插入添加；  \n如果键不存在，创建新的链表；  \n如果键已存在，新增内容；  \n如果值全移除，对应的键也就消失了。  \n链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n## Set 类型（不能重复）\n\n### 简介\n\nRedis的Set是string类型的无序集合。它是通过HashTable实现实现的，\n\n### 操作\n\n```\nsadd set1 a b c d \t\t\t\t给set1集合添加元素\n\nsmembers set1\t\t\t\t\t查看set1集合的所有元素\n\nsismember set1 a\t\t\t\t判断set1集合中是否有a元素\nscard set1\t\t\t\t\t\t获取集合set1 的元素个数\n\nsrem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）\n\nsrandmember set2 3\t\t\t\t在集合set2中随机出3个元素\n\ndiff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素\n\nsinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素\n\nsunion set3 set4\t\t\t\t并集\n```\n\n## Sortedsets 类型\n\n### 简介\n\nzset 和 set 一样也是string类型元素的集合,且不允许重复的成员。  \n不同的是每个元素都会关联一个double类型的分数。  \nredis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n\n### 操作\n\n```\nzadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。\n\nzrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数\n\nzrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素\n\nzcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。\n\nzcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间\n\nzcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值\n\nzrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间\n\nzrem zset1 a b\t\t\t集合删除元素a b\n```\n\n# Redis配置文件\n\n## Redis配置文件在哪?\n\nredis.conf是redis的配置文件，它在那？\n在redis安装包解压出来的目录下。\n\n## 常用配置（redis.conf）\n\n```\n参数说明\nredis.conf 配置项说明如下：\n1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n  daemonize no\n2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n  pidfile /var/run/redis.pid\n3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n  port 6379\n4. 绑定的主机地址\n  bind 127.0.0.1\n5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n  timeout 300\n6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n  loglevel verbose\n7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n  logfile stdout\n8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id\n  databases 16\n9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n  save <seconds> <changes>\n  Redis默认配置文件中提供了三个条件：\n  save 900 1\n  save 300 10\n  save 60 10000\n  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n \n10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n  rdbcompression yes\n11. 指定本地数据库文件名，默认值为dump.rdb\n  dbfilename dump.rdb\n12. 指定本地数据库存放目录\n  dir ./\n13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n  slaveof <masterip> <masterport>\n14. 当master服务设置了密码保护时，slav服务连接master的密码\n  masterauth <master-password>\n15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n  requirepass foobared\n16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n  maxclients 128\n17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n  maxmemory <bytes>\n18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n  appendonly no\n19. 指定更新日志文件名，默认为appendonly.aof\n   appendfilename appendonly.aof\n20. 指定更新日志条件，共有3个可选值： \n  no：表示等操作系统进行数据缓存同步到磁盘（快） \n  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） \n  everysec：表示每秒同步一次（折衷，默认值）\n  appendfsync everysec\n \n21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n   vm-enabled no\n22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n   vm-swap-file /tmp/redis.swap\n23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\n   vm-max-memory 0\n24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n   vm-page-size 32\n25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\n   vm-pages 134217728\n26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n   vm-max-threads 4\n27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n  glueoutputbuf yes\n28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n  hash-max-zipmap-entries 64\n  hash-max-zipmap-value 512\n29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n  activerehashing yes\n30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n  include /path/to/local.conf\n```\n\n# Redis的持久化\n\nRedis的持久化一共有两种：  \nrdb持久化  \naof持久化（推荐使用）\n\n## RDB（Redis Database）\n\n### 什么是rdb持久化\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘.   \n也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\nRedis官方解释：  \nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，\n待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。  \n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方\n式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n（因为可能出现redis宕机的情况）\n\n### Fork的解释\n\nfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n## AOF（Append Only File）\n\n# Redis的事物\n\n## 事物介绍\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：  \n1）批量操作在发送 EXEC 命令前被放入队列缓存。  \n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）  \n2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n**注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。**\n\nRedis的一个事务从开始到执行会经历以下三个阶段：\n1）开始事务。\n2）命令入队。\n3）执行事务。\n\n## 事物常用命令\n\n```\nmulti\t\t\t\t\t\t标记一个事物块的开始\n\nexec：\t\t\t\t\t\t执行所有事物块内的命令\n\ndiscard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令\n\nwatch key [key ...]：\t\t\t\n监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\nunwatch\t\t\t\t\t\t取消watch命令对所有key的监控\n```\n\n// TODO","source":"_posts/oyr/Redis/Redis-基础.md","raw":"---\ntitle: Redis-基础\ndate: 2020-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Redis\ntags: \n    - Redis\n    - 中间件\n---\n\n# 入门概述\n\n## Redis是什么？\n\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 \n\nredis 的官网：redis.io\n\n<!-- more -->\n\n## Redis 与其他 key/value 缓存产品有以下三个特点\n\n1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用  \n2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储  \n3）Redis支持数据的备份，即master-slave模式的数据备份\n\n## 应用场景（redis能干些什么）\n\n1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务  \n2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面  \n3）模拟类似于HttpSession这种需要设定过期时间的功能  \n4）发布、订阅消息系统（消息中间件）  \n5）定时器、计数器  \n6）可以实现session共享  \n7）可以实现分布式锁\n\n# Redis的安装\n\n提示：  \n由于企业里面做Redis开发，99%都是Linux版的运用和安装。\n几乎不会涉及到Windows版，windows安装只是为了学习而已了。\n\n# Redis启动后的杂项知识（重要）\n\n1）单进程，redis速度很快。  \nredis读写性能测试，redis官网测试读写能到10万左右。\n\n2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。\n\n3）select命令切换数据库。\n\n4）dbsize查看当前数据库的key的数量。\n\n5）flushdb：清空当前库key。\n\n6）flushall：清空全部库。\n\n7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。\n\n8）redis索引都是从零开始。\n\n9）redis默认端口是6379。\n\n# Redis五大数据类型\n\n常用命令：   \nping：ping下redis    \ndbsize：查看当前数据库的key的数量  \nselect 1：切换到下标为1的数据库中  \nflushdb：清空当前库key  \nflushall：清空全部库key\n\n## Redis键的操作（常用）\n\n查看当前数据库的所有key:  \nKeys *\n\n判断当前key是否存在：  \nexists name\n\n将当前key移动到2号库中：  \nMove name 2\n\n设置key在6秒后过期：  \nexpire name 6\n\n查看当前key还有多久过期  \nttl name \n\n查看当前key是什么结构的类型  \ntype name\n\n## String 类型（常用）\n\n### 简介\n\nString是redis最基本的类型，可以理解成一个key对应一个value。  \nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。  \nredis一个字符串value最多可以是512M。\n\n### 操作\n\n```\nset name oyr：\t\t\t给键name设置值为oyr\n\nget name：\t\t\t\t获取键name的值\n\ndel name：\t\t\t\t删除建为name值\n\nappend name 123：\t\t在name对应的值后面追加123\n\nstrlen name：\t\t\t得到当前name对应的值的长度\n\nincr age：\t\t\t\tage+1，一定要是数字才能操作\n\nincrby age 10：\t\t\tage+10\n\ndecr age：\t\t\t\tage-1，一定要是数字才能操作\n\ndecrby age 10： \t\tage-10\n\nsetex name 10 oyr：\t\t\n（set with expire）\n设置key为name，过期时间为10秒，值为oyr\n\nsexnx name ooo：\n（sex if not exist）\n设置键位name，值为ooo，只有不存在的时候才会设置进去\n\nmset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值\n\nmget k1 k2 k3：\t\t\t\t\t一次获取多个值\n\nmsetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。\n```\n\n## Hash 类型（常用）\n\n### 简介\n\nRedis hash 是一个键值对集合。  \nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。  \n类似Java里面的Map<String,Object>，K-V模式不变，但V是一个键值对。\n\n### 操作\n\n```\n（1）hset\nhset user name oyr\t\t\t给键user的name属性设置值\n\n（2）hget\nhget user name\t\t\t\t获取键user的name值\n\n（3）hmset\nhmset user age 18 sex nan  \t\t同时设置多个值\n\n（4）hmget\nhmget user name age sex\t\t\t同时获取多个属性值\n\n（5）hgetall\nhgetall user \t\t\t\t\t获取键user中的所有键和值\n\n（6）hdel\nhdel user name\t\t\t\t\t删除键user中的name属性\n\n（7）hlen\nhlen user\t\t\t\t\t\t获取键user下有几个属性\n\n（8）hexists\nhexists user nane\t\t\t\t判断键user下是否有name属性\n\n（9）hkeys\nhkys user\t\t\t\t\t\t获取键user下的所有属性\n\n（10）hvals\nhvals user \t\t\t\t\t \t获取键user下的所有值\n\n（11）hsetnx\nhsetnx user name \"oyr\"\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。\n\n（12）hincrby \nhincrby  user age 10\t\t\t给键user里的age 属性添加10\n```\n\n## Lists 类型（双向链表）\n\n### 简介\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。  \n它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出\n\n### 操作\n\n```\nlpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加\n\nlrange list1 0 -1\t\t\t获取list1链表所有数据\n\nrpush list2 1 2 3\t\t\t给链表list2尾部插入元素\n\nlpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）\n\nrpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）\n\nlindex list1 3\t\t\t\t获取链表的3索引位置的值\n\n\tlist1\t\t\t\t\t获取list1 链表的长度\n\nlset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s\n\nlrem list3 2 d\t\t\t\t删除链表2个d元素\n\nltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃\n\nlinsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素\n\nrpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表\n```\n\n### 性能总结\n\n它是一个字符串链表，left、right都可以插入添加；  \n如果键不存在，创建新的链表；  \n如果键已存在，新增内容；  \n如果值全移除，对应的键也就消失了。  \n链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n## Set 类型（不能重复）\n\n### 简介\n\nRedis的Set是string类型的无序集合。它是通过HashTable实现实现的，\n\n### 操作\n\n```\nsadd set1 a b c d \t\t\t\t给set1集合添加元素\n\nsmembers set1\t\t\t\t\t查看set1集合的所有元素\n\nsismember set1 a\t\t\t\t判断set1集合中是否有a元素\nscard set1\t\t\t\t\t\t获取集合set1 的元素个数\n\nsrem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）\n\nsrandmember set2 3\t\t\t\t在集合set2中随机出3个元素\n\ndiff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素\n\nsinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素\n\nsunion set3 set4\t\t\t\t并集\n```\n\n## Sortedsets 类型\n\n### 简介\n\nzset 和 set 一样也是string类型元素的集合,且不允许重复的成员。  \n不同的是每个元素都会关联一个double类型的分数。  \nredis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n\n### 操作\n\n```\nzadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。\n\nzrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数\n\nzrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素\n\nzcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。\n\nzcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间\n\nzcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值\n\nzrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间\n\nzrem zset1 a b\t\t\t集合删除元素a b\n```\n\n# Redis配置文件\n\n## Redis配置文件在哪?\n\nredis.conf是redis的配置文件，它在那？\n在redis安装包解压出来的目录下。\n\n## 常用配置（redis.conf）\n\n```\n参数说明\nredis.conf 配置项说明如下：\n1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n  daemonize no\n2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n  pidfile /var/run/redis.pid\n3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n  port 6379\n4. 绑定的主机地址\n  bind 127.0.0.1\n5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n  timeout 300\n6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n  loglevel verbose\n7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n  logfile stdout\n8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id\n  databases 16\n9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n  save <seconds> <changes>\n  Redis默认配置文件中提供了三个条件：\n  save 900 1\n  save 300 10\n  save 60 10000\n  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n \n10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n  rdbcompression yes\n11. 指定本地数据库文件名，默认值为dump.rdb\n  dbfilename dump.rdb\n12. 指定本地数据库存放目录\n  dir ./\n13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n  slaveof <masterip> <masterport>\n14. 当master服务设置了密码保护时，slav服务连接master的密码\n  masterauth <master-password>\n15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n  requirepass foobared\n16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n  maxclients 128\n17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n  maxmemory <bytes>\n18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n  appendonly no\n19. 指定更新日志文件名，默认为appendonly.aof\n   appendfilename appendonly.aof\n20. 指定更新日志条件，共有3个可选值： \n  no：表示等操作系统进行数据缓存同步到磁盘（快） \n  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） \n  everysec：表示每秒同步一次（折衷，默认值）\n  appendfsync everysec\n \n21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n   vm-enabled no\n22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n   vm-swap-file /tmp/redis.swap\n23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\n   vm-max-memory 0\n24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n   vm-page-size 32\n25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\n   vm-pages 134217728\n26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n   vm-max-threads 4\n27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n  glueoutputbuf yes\n28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n  hash-max-zipmap-entries 64\n  hash-max-zipmap-value 512\n29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n  activerehashing yes\n30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n  include /path/to/local.conf\n```\n\n# Redis的持久化\n\nRedis的持久化一共有两种：  \nrdb持久化  \naof持久化（推荐使用）\n\n## RDB（Redis Database）\n\n### 什么是rdb持久化\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘.   \n也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\nRedis官方解释：  \nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，\n待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。  \n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方\n式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n（因为可能出现redis宕机的情况）\n\n### Fork的解释\n\nfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n## AOF（Append Only File）\n\n# Redis的事物\n\n## 事物介绍\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：  \n1）批量操作在发送 EXEC 命令前被放入队列缓存。  \n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）  \n2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n**注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。**\n\nRedis的一个事务从开始到执行会经历以下三个阶段：\n1）开始事务。\n2）命令入队。\n3）执行事务。\n\n## 事物常用命令\n\n```\nmulti\t\t\t\t\t\t标记一个事物块的开始\n\nexec：\t\t\t\t\t\t执行所有事物块内的命令\n\ndiscard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令\n\nwatch key [key ...]：\t\t\t\n监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\nunwatch\t\t\t\t\t\t取消watch命令对所有key的监控\n```\n\n// TODO","slug":"oyr/Redis/Redis-基础","published":1,"updated":"2021-10-26T10:31:03.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86r002vcst76kum3h94","content":"<h1 id=\"入门概述\"><a href=\"#入门概述\" class=\"headerlink\" title=\"入门概述\"></a>入门概述</h1><h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><p>是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 </p>\n<p>redis 的官网：redis.io</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Redis-与其他-key-value-缓存产品有以下三个特点\"><a href=\"#Redis-与其他-key-value-缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis 与其他 key/value 缓存产品有以下三个特点\"></a>Redis 与其他 key/value 缓存产品有以下三个特点</h2><p>1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用<br>2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>3）Redis支持数据的备份，即master-slave模式的数据备份</p>\n<h2 id=\"应用场景（redis能干些什么）\"><a href=\"#应用场景（redis能干些什么）\" class=\"headerlink\" title=\"应用场景（redis能干些什么）\"></a>应用场景（redis能干些什么）</h2><p>1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<br>2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面<br>3）模拟类似于HttpSession这种需要设定过期时间的功能<br>4）发布、订阅消息系统（消息中间件）<br>5）定时器、计数器<br>6）可以实现session共享<br>7）可以实现分布式锁</p>\n<h1 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h1><p>提示：<br>由于企业里面做Redis开发，99%都是Linux版的运用和安装。<br>几乎不会涉及到Windows版，windows安装只是为了学习而已了。</p>\n<h1 id=\"Redis启动后的杂项知识（重要）\"><a href=\"#Redis启动后的杂项知识（重要）\" class=\"headerlink\" title=\"Redis启动后的杂项知识（重要）\"></a>Redis启动后的杂项知识（重要）</h1><p>1）单进程，redis速度很快。<br>redis读写性能测试，redis官网测试读写能到10万左右。</p>\n<p>2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>\n<p>3）select命令切换数据库。</p>\n<p>4）dbsize查看当前数据库的key的数量。</p>\n<p>5）flushdb：清空当前库key。</p>\n<p>6）flushall：清空全部库。</p>\n<p>7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。</p>\n<p>8）redis索引都是从零开始。</p>\n<p>9）redis默认端口是6379。</p>\n<h1 id=\"Redis五大数据类型\"><a href=\"#Redis五大数据类型\" class=\"headerlink\" title=\"Redis五大数据类型\"></a>Redis五大数据类型</h1><p>常用命令：<br>ping：ping下redis<br>dbsize：查看当前数据库的key的数量<br>select 1：切换到下标为1的数据库中<br>flushdb：清空当前库key<br>flushall：清空全部库key</p>\n<h2 id=\"Redis键的操作（常用）\"><a href=\"#Redis键的操作（常用）\" class=\"headerlink\" title=\"Redis键的操作（常用）\"></a>Redis键的操作（常用）</h2><p>查看当前数据库的所有key:<br>Keys *</p>\n<p>判断当前key是否存在：<br>exists name</p>\n<p>将当前key移动到2号库中：<br>Move name 2</p>\n<p>设置key在6秒后过期：<br>expire name 6</p>\n<p>查看当前key还有多久过期<br>ttl name </p>\n<p>查看当前key是什么结构的类型<br>type name</p>\n<h2 id=\"String-类型（常用）\"><a href=\"#String-类型（常用）\" class=\"headerlink\" title=\"String 类型（常用）\"></a>String 类型（常用）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>String是redis最基本的类型，可以理解成一个key对应一个value。<br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。<br>redis一个字符串value最多可以是512M。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set name oyr：\t\t\t给键name设置值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">get name：\t\t\t\t获取键name的值</span><br><span class=\"line\"></span><br><span class=\"line\">del name：\t\t\t\t删除建为name值</span><br><span class=\"line\"></span><br><span class=\"line\">append name 123：\t\t在name对应的值后面追加123</span><br><span class=\"line\"></span><br><span class=\"line\">strlen name：\t\t\t得到当前name对应的值的长度</span><br><span class=\"line\"></span><br><span class=\"line\">incr age：\t\t\t\tage+1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">incrby age 10：\t\t\tage+10</span><br><span class=\"line\"></span><br><span class=\"line\">decr age：\t\t\t\tage-1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">decrby age 10： \t\tage-10</span><br><span class=\"line\"></span><br><span class=\"line\">setex name 10 oyr：\t\t</span><br><span class=\"line\">（set with expire）</span><br><span class=\"line\">设置key为name，过期时间为10秒，值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">sexnx name ooo：</span><br><span class=\"line\">（sex if not exist）</span><br><span class=\"line\">设置键位name，值为ooo，只有不存在的时候才会设置进去</span><br><span class=\"line\"></span><br><span class=\"line\">mset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">mget k1 k2 k3：\t\t\t\t\t一次获取多个值</span><br><span class=\"line\"></span><br><span class=\"line\">msetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hash-类型（常用）\"><a href=\"#Hash-类型（常用）\" class=\"headerlink\" title=\"Hash 类型（常用）\"></a>Hash 类型（常用）</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;，K-V模式不变，但V是一个键值对。</p>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）hset</span><br><span class=\"line\">hset user name oyr\t\t\t给键user的name属性设置值</span><br><span class=\"line\"></span><br><span class=\"line\">（2）hget</span><br><span class=\"line\">hget user name\t\t\t\t获取键user的name值</span><br><span class=\"line\"></span><br><span class=\"line\">（3）hmset</span><br><span class=\"line\">hmset user age 18 sex nan  \t\t同时设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">（4）hmget</span><br><span class=\"line\">hmget user name age sex\t\t\t同时获取多个属性值</span><br><span class=\"line\"></span><br><span class=\"line\">（5）hgetall</span><br><span class=\"line\">hgetall user \t\t\t\t\t获取键user中的所有键和值</span><br><span class=\"line\"></span><br><span class=\"line\">（6）hdel</span><br><span class=\"line\">hdel user name\t\t\t\t\t删除键user中的name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（7）hlen</span><br><span class=\"line\">hlen user\t\t\t\t\t\t获取键user下有几个属性</span><br><span class=\"line\"></span><br><span class=\"line\">（8）hexists</span><br><span class=\"line\">hexists user nane\t\t\t\t判断键user下是否有name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（9）hkeys</span><br><span class=\"line\">hkys user\t\t\t\t\t\t获取键user下的所有属性</span><br><span class=\"line\"></span><br><span class=\"line\">（10）hvals</span><br><span class=\"line\">hvals user \t\t\t\t\t \t获取键user下的所有值</span><br><span class=\"line\"></span><br><span class=\"line\">（11）hsetnx</span><br><span class=\"line\">hsetnx user name &quot;oyr&quot;\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">（12）hincrby </span><br><span class=\"line\">hincrby  user age 10\t\t\t给键user里的age 属性添加10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lists-类型（双向链表）\"><a href=\"#Lists-类型（双向链表）\" class=\"headerlink\" title=\"Lists 类型（双向链表）\"></a>Lists 类型（双向链表）</h2><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出</p>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加</span><br><span class=\"line\"></span><br><span class=\"line\">lrange list1 0 -1\t\t\t获取list1链表所有数据</span><br><span class=\"line\"></span><br><span class=\"line\">rpush list2 1 2 3\t\t\t给链表list2尾部插入元素</span><br><span class=\"line\"></span><br><span class=\"line\">lpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）</span><br><span class=\"line\"></span><br><span class=\"line\">rpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）</span><br><span class=\"line\"></span><br><span class=\"line\">lindex list1 3\t\t\t\t获取链表的3索引位置的值</span><br><span class=\"line\"></span><br><span class=\"line\">\tlist1\t\t\t\t\t获取list1 链表的长度</span><br><span class=\"line\"></span><br><span class=\"line\">lset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s</span><br><span class=\"line\"></span><br><span class=\"line\">lrem list3 2 d\t\t\t\t删除链表2个d元素</span><br><span class=\"line\"></span><br><span class=\"line\">ltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃</span><br><span class=\"line\"></span><br><span class=\"line\">linsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素</span><br><span class=\"line\"></span><br><span class=\"line\">rpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><p>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>\n<h2 id=\"Set-类型（不能重复）\"><a href=\"#Set-类型（不能重复）\" class=\"headerlink\" title=\"Set 类型（不能重复）\"></a>Set 类型（不能重复）</h2><h3 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>\n<h3 id=\"操作-3\"><a href=\"#操作-3\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd set1 a b c d \t\t\t\t给set1集合添加元素</span><br><span class=\"line\"></span><br><span class=\"line\">smembers set1\t\t\t\t\t查看set1集合的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">sismember set1 a\t\t\t\t判断set1集合中是否有a元素</span><br><span class=\"line\">scard set1\t\t\t\t\t\t获取集合set1 的元素个数</span><br><span class=\"line\"></span><br><span class=\"line\">srem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）</span><br><span class=\"line\"></span><br><span class=\"line\">srandmember set2 3\t\t\t\t在集合set2中随机出3个元素</span><br><span class=\"line\"></span><br><span class=\"line\">diff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sunion set3 set4\t\t\t\t并集</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Sortedsets-类型\"><a href=\"#Sortedsets-类型\" class=\"headerlink\" title=\"Sortedsets 类型\"></a>Sortedsets 类型</h2><h3 id=\"简介-4\"><a href=\"#简介-4\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>\n<h3 id=\"操作-4\"><a href=\"#操作-4\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值</span><br><span class=\"line\"></span><br><span class=\"line\">zrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zrem zset1 a b\t\t\t集合删除元素a b</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis配置文件\"><a href=\"#Redis配置文件\" class=\"headerlink\" title=\"Redis配置文件\"></a>Redis配置文件</h1><h2 id=\"Redis配置文件在哪\"><a href=\"#Redis配置文件在哪\" class=\"headerlink\" title=\"Redis配置文件在哪?\"></a>Redis配置文件在哪?</h2><p>redis.conf是redis的配置文件，它在那？<br>在redis安装包解压出来的目录下。</p>\n<h2 id=\"常用配置（redis-conf）\"><a href=\"#常用配置（redis-conf）\" class=\"headerlink\" title=\"常用配置（redis.conf）\"></a>常用配置（redis.conf）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数说明</span><br><span class=\"line\">redis.conf 配置项说明如下：</span><br><span class=\"line\">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class=\"line\">  daemonize no</span><br><span class=\"line\">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class=\"line\">  pidfile /var/run/redis.pid</span><br><span class=\"line\">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class=\"line\">  port 6379</span><br><span class=\"line\">4. 绑定的主机地址</span><br><span class=\"line\">  bind 127.0.0.1</span><br><span class=\"line\">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">  timeout 300</span><br><span class=\"line\">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class=\"line\">  loglevel verbose</span><br><span class=\"line\">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class=\"line\">  logfile stdout</span><br><span class=\"line\">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class=\"line\">  databases 16</span><br><span class=\"line\">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class=\"line\">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class=\"line\">  Redis默认配置文件中提供了三个条件：</span><br><span class=\"line\">  save 900 1</span><br><span class=\"line\">  save 300 10</span><br><span class=\"line\">  save 60 10000</span><br><span class=\"line\">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class=\"line\"> </span><br><span class=\"line\">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class=\"line\">  rdbcompression yes</span><br><span class=\"line\">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class=\"line\">  dbfilename dump.rdb</span><br><span class=\"line\">12. 指定本地数据库存放目录</span><br><span class=\"line\">  dir ./</span><br><span class=\"line\">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class=\"line\">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class=\"line\">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class=\"line\">  masterauth &lt;master-password&gt;</span><br><span class=\"line\">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class=\"line\">  requirepass foobared</span><br><span class=\"line\">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class=\"line\">  maxclients 128</span><br><span class=\"line\">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class=\"line\">  maxmemory &lt;bytes&gt;</span><br><span class=\"line\">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class=\"line\">  appendonly no</span><br><span class=\"line\">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class=\"line\">   appendfilename appendonly.aof</span><br><span class=\"line\">20. 指定更新日志条件，共有3个可选值： </span><br><span class=\"line\">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class=\"line\">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class=\"line\">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class=\"line\">  appendfsync everysec</span><br><span class=\"line\"> </span><br><span class=\"line\">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class=\"line\">   vm-enabled no</span><br><span class=\"line\">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class=\"line\">   vm-swap-file /tmp/redis.swap</span><br><span class=\"line\">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class=\"line\">   vm-max-memory 0</span><br><span class=\"line\">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class=\"line\">   vm-page-size 32</span><br><span class=\"line\">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class=\"line\">   vm-pages 134217728</span><br><span class=\"line\">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class=\"line\">   vm-max-threads 4</span><br><span class=\"line\">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class=\"line\">  glueoutputbuf yes</span><br><span class=\"line\">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class=\"line\">  hash-max-zipmap-entries 64</span><br><span class=\"line\">  hash-max-zipmap-value 512</span><br><span class=\"line\">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class=\"line\">  activerehashing yes</span><br><span class=\"line\">30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class=\"line\">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><p>Redis的持久化一共有两种：<br>rdb持久化<br>aof持久化（推荐使用）</p>\n<h2 id=\"RDB（Redis-Database）\"><a href=\"#RDB（Redis-Database）\" class=\"headerlink\" title=\"RDB（Redis Database）\"></a>RDB（Redis Database）</h2><h3 id=\"什么是rdb持久化\"><a href=\"#什么是rdb持久化\" class=\"headerlink\" title=\"什么是rdb持久化\"></a>什么是rdb持久化</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘.<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n<p>Redis官方解释：<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，<br>待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。<br>（因为可能出现redis宕机的情况）</p>\n<h3 id=\"Fork的解释\"><a href=\"#Fork的解释\" class=\"headerlink\" title=\"Fork的解释\"></a>Fork的解释</h3><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><h1 id=\"Redis的事物\"><a href=\"#Redis的事物\" class=\"headerlink\" title=\"Redis的事物\"></a>Redis的事物</h1><h2 id=\"事物介绍\"><a href=\"#事物介绍\" class=\"headerlink\" title=\"事物介绍\"></a>事物介绍</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1）批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）<br>2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p><strong>注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong></p>\n<p>Redis的一个事务从开始到执行会经历以下三个阶段：<br>1）开始事务。<br>2）命令入队。<br>3）执行事务。</p>\n<h2 id=\"事物常用命令\"><a href=\"#事物常用命令\" class=\"headerlink\" title=\"事物常用命令\"></a>事物常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi\t\t\t\t\t\t标记一个事物块的开始</span><br><span class=\"line\"></span><br><span class=\"line\">exec：\t\t\t\t\t\t执行所有事物块内的命令</span><br><span class=\"line\"></span><br><span class=\"line\">discard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令</span><br><span class=\"line\"></span><br><span class=\"line\">watch key [key ...]：\t\t\t</span><br><span class=\"line\">监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br><span class=\"line\"></span><br><span class=\"line\">unwatch\t\t\t\t\t\t取消watch命令对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<p>// TODO</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"入门概述\"><a href=\"#入门概述\" class=\"headerlink\" title=\"入门概述\"></a>入门概述</h1><h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><p>是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 </p>\n<p>redis 的官网：redis.io</p>","more":"<h2 id=\"Redis-与其他-key-value-缓存产品有以下三个特点\"><a href=\"#Redis-与其他-key-value-缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis 与其他 key/value 缓存产品有以下三个特点\"></a>Redis 与其他 key/value 缓存产品有以下三个特点</h2><p>1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用<br>2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>3）Redis支持数据的备份，即master-slave模式的数据备份</p>\n<h2 id=\"应用场景（redis能干些什么）\"><a href=\"#应用场景（redis能干些什么）\" class=\"headerlink\" title=\"应用场景（redis能干些什么）\"></a>应用场景（redis能干些什么）</h2><p>1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<br>2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面<br>3）模拟类似于HttpSession这种需要设定过期时间的功能<br>4）发布、订阅消息系统（消息中间件）<br>5）定时器、计数器<br>6）可以实现session共享<br>7）可以实现分布式锁</p>\n<h1 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h1><p>提示：<br>由于企业里面做Redis开发，99%都是Linux版的运用和安装。<br>几乎不会涉及到Windows版，windows安装只是为了学习而已了。</p>\n<h1 id=\"Redis启动后的杂项知识（重要）\"><a href=\"#Redis启动后的杂项知识（重要）\" class=\"headerlink\" title=\"Redis启动后的杂项知识（重要）\"></a>Redis启动后的杂项知识（重要）</h1><p>1）单进程，redis速度很快。<br>redis读写性能测试，redis官网测试读写能到10万左右。</p>\n<p>2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>\n<p>3）select命令切换数据库。</p>\n<p>4）dbsize查看当前数据库的key的数量。</p>\n<p>5）flushdb：清空当前库key。</p>\n<p>6）flushall：清空全部库。</p>\n<p>7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。</p>\n<p>8）redis索引都是从零开始。</p>\n<p>9）redis默认端口是6379。</p>\n<h1 id=\"Redis五大数据类型\"><a href=\"#Redis五大数据类型\" class=\"headerlink\" title=\"Redis五大数据类型\"></a>Redis五大数据类型</h1><p>常用命令：<br>ping：ping下redis<br>dbsize：查看当前数据库的key的数量<br>select 1：切换到下标为1的数据库中<br>flushdb：清空当前库key<br>flushall：清空全部库key</p>\n<h2 id=\"Redis键的操作（常用）\"><a href=\"#Redis键的操作（常用）\" class=\"headerlink\" title=\"Redis键的操作（常用）\"></a>Redis键的操作（常用）</h2><p>查看当前数据库的所有key:<br>Keys *</p>\n<p>判断当前key是否存在：<br>exists name</p>\n<p>将当前key移动到2号库中：<br>Move name 2</p>\n<p>设置key在6秒后过期：<br>expire name 6</p>\n<p>查看当前key还有多久过期<br>ttl name </p>\n<p>查看当前key是什么结构的类型<br>type name</p>\n<h2 id=\"String-类型（常用）\"><a href=\"#String-类型（常用）\" class=\"headerlink\" title=\"String 类型（常用）\"></a>String 类型（常用）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>String是redis最基本的类型，可以理解成一个key对应一个value。<br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。<br>redis一个字符串value最多可以是512M。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set name oyr：\t\t\t给键name设置值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">get name：\t\t\t\t获取键name的值</span><br><span class=\"line\"></span><br><span class=\"line\">del name：\t\t\t\t删除建为name值</span><br><span class=\"line\"></span><br><span class=\"line\">append name 123：\t\t在name对应的值后面追加123</span><br><span class=\"line\"></span><br><span class=\"line\">strlen name：\t\t\t得到当前name对应的值的长度</span><br><span class=\"line\"></span><br><span class=\"line\">incr age：\t\t\t\tage+1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">incrby age 10：\t\t\tage+10</span><br><span class=\"line\"></span><br><span class=\"line\">decr age：\t\t\t\tage-1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">decrby age 10： \t\tage-10</span><br><span class=\"line\"></span><br><span class=\"line\">setex name 10 oyr：\t\t</span><br><span class=\"line\">（set with expire）</span><br><span class=\"line\">设置key为name，过期时间为10秒，值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">sexnx name ooo：</span><br><span class=\"line\">（sex if not exist）</span><br><span class=\"line\">设置键位name，值为ooo，只有不存在的时候才会设置进去</span><br><span class=\"line\"></span><br><span class=\"line\">mset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">mget k1 k2 k3：\t\t\t\t\t一次获取多个值</span><br><span class=\"line\"></span><br><span class=\"line\">msetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hash-类型（常用）\"><a href=\"#Hash-类型（常用）\" class=\"headerlink\" title=\"Hash 类型（常用）\"></a>Hash 类型（常用）</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;，K-V模式不变，但V是一个键值对。</p>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）hset</span><br><span class=\"line\">hset user name oyr\t\t\t给键user的name属性设置值</span><br><span class=\"line\"></span><br><span class=\"line\">（2）hget</span><br><span class=\"line\">hget user name\t\t\t\t获取键user的name值</span><br><span class=\"line\"></span><br><span class=\"line\">（3）hmset</span><br><span class=\"line\">hmset user age 18 sex nan  \t\t同时设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">（4）hmget</span><br><span class=\"line\">hmget user name age sex\t\t\t同时获取多个属性值</span><br><span class=\"line\"></span><br><span class=\"line\">（5）hgetall</span><br><span class=\"line\">hgetall user \t\t\t\t\t获取键user中的所有键和值</span><br><span class=\"line\"></span><br><span class=\"line\">（6）hdel</span><br><span class=\"line\">hdel user name\t\t\t\t\t删除键user中的name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（7）hlen</span><br><span class=\"line\">hlen user\t\t\t\t\t\t获取键user下有几个属性</span><br><span class=\"line\"></span><br><span class=\"line\">（8）hexists</span><br><span class=\"line\">hexists user nane\t\t\t\t判断键user下是否有name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（9）hkeys</span><br><span class=\"line\">hkys user\t\t\t\t\t\t获取键user下的所有属性</span><br><span class=\"line\"></span><br><span class=\"line\">（10）hvals</span><br><span class=\"line\">hvals user \t\t\t\t\t \t获取键user下的所有值</span><br><span class=\"line\"></span><br><span class=\"line\">（11）hsetnx</span><br><span class=\"line\">hsetnx user name &quot;oyr&quot;\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">（12）hincrby </span><br><span class=\"line\">hincrby  user age 10\t\t\t给键user里的age 属性添加10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lists-类型（双向链表）\"><a href=\"#Lists-类型（双向链表）\" class=\"headerlink\" title=\"Lists 类型（双向链表）\"></a>Lists 类型（双向链表）</h2><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出</p>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加</span><br><span class=\"line\"></span><br><span class=\"line\">lrange list1 0 -1\t\t\t获取list1链表所有数据</span><br><span class=\"line\"></span><br><span class=\"line\">rpush list2 1 2 3\t\t\t给链表list2尾部插入元素</span><br><span class=\"line\"></span><br><span class=\"line\">lpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）</span><br><span class=\"line\"></span><br><span class=\"line\">rpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）</span><br><span class=\"line\"></span><br><span class=\"line\">lindex list1 3\t\t\t\t获取链表的3索引位置的值</span><br><span class=\"line\"></span><br><span class=\"line\">\tlist1\t\t\t\t\t获取list1 链表的长度</span><br><span class=\"line\"></span><br><span class=\"line\">lset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s</span><br><span class=\"line\"></span><br><span class=\"line\">lrem list3 2 d\t\t\t\t删除链表2个d元素</span><br><span class=\"line\"></span><br><span class=\"line\">ltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃</span><br><span class=\"line\"></span><br><span class=\"line\">linsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素</span><br><span class=\"line\"></span><br><span class=\"line\">rpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><p>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>\n<h2 id=\"Set-类型（不能重复）\"><a href=\"#Set-类型（不能重复）\" class=\"headerlink\" title=\"Set 类型（不能重复）\"></a>Set 类型（不能重复）</h2><h3 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>\n<h3 id=\"操作-3\"><a href=\"#操作-3\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd set1 a b c d \t\t\t\t给set1集合添加元素</span><br><span class=\"line\"></span><br><span class=\"line\">smembers set1\t\t\t\t\t查看set1集合的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">sismember set1 a\t\t\t\t判断set1集合中是否有a元素</span><br><span class=\"line\">scard set1\t\t\t\t\t\t获取集合set1 的元素个数</span><br><span class=\"line\"></span><br><span class=\"line\">srem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）</span><br><span class=\"line\"></span><br><span class=\"line\">srandmember set2 3\t\t\t\t在集合set2中随机出3个元素</span><br><span class=\"line\"></span><br><span class=\"line\">diff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sunion set3 set4\t\t\t\t并集</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Sortedsets-类型\"><a href=\"#Sortedsets-类型\" class=\"headerlink\" title=\"Sortedsets 类型\"></a>Sortedsets 类型</h2><h3 id=\"简介-4\"><a href=\"#简介-4\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>\n<h3 id=\"操作-4\"><a href=\"#操作-4\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值</span><br><span class=\"line\"></span><br><span class=\"line\">zrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zrem zset1 a b\t\t\t集合删除元素a b</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis配置文件\"><a href=\"#Redis配置文件\" class=\"headerlink\" title=\"Redis配置文件\"></a>Redis配置文件</h1><h2 id=\"Redis配置文件在哪\"><a href=\"#Redis配置文件在哪\" class=\"headerlink\" title=\"Redis配置文件在哪?\"></a>Redis配置文件在哪?</h2><p>redis.conf是redis的配置文件，它在那？<br>在redis安装包解压出来的目录下。</p>\n<h2 id=\"常用配置（redis-conf）\"><a href=\"#常用配置（redis-conf）\" class=\"headerlink\" title=\"常用配置（redis.conf）\"></a>常用配置（redis.conf）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数说明</span><br><span class=\"line\">redis.conf 配置项说明如下：</span><br><span class=\"line\">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class=\"line\">  daemonize no</span><br><span class=\"line\">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class=\"line\">  pidfile /var/run/redis.pid</span><br><span class=\"line\">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class=\"line\">  port 6379</span><br><span class=\"line\">4. 绑定的主机地址</span><br><span class=\"line\">  bind 127.0.0.1</span><br><span class=\"line\">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">  timeout 300</span><br><span class=\"line\">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class=\"line\">  loglevel verbose</span><br><span class=\"line\">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class=\"line\">  logfile stdout</span><br><span class=\"line\">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class=\"line\">  databases 16</span><br><span class=\"line\">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class=\"line\">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class=\"line\">  Redis默认配置文件中提供了三个条件：</span><br><span class=\"line\">  save 900 1</span><br><span class=\"line\">  save 300 10</span><br><span class=\"line\">  save 60 10000</span><br><span class=\"line\">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class=\"line\"> </span><br><span class=\"line\">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class=\"line\">  rdbcompression yes</span><br><span class=\"line\">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class=\"line\">  dbfilename dump.rdb</span><br><span class=\"line\">12. 指定本地数据库存放目录</span><br><span class=\"line\">  dir ./</span><br><span class=\"line\">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class=\"line\">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class=\"line\">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class=\"line\">  masterauth &lt;master-password&gt;</span><br><span class=\"line\">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class=\"line\">  requirepass foobared</span><br><span class=\"line\">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class=\"line\">  maxclients 128</span><br><span class=\"line\">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class=\"line\">  maxmemory &lt;bytes&gt;</span><br><span class=\"line\">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class=\"line\">  appendonly no</span><br><span class=\"line\">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class=\"line\">   appendfilename appendonly.aof</span><br><span class=\"line\">20. 指定更新日志条件，共有3个可选值： </span><br><span class=\"line\">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class=\"line\">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class=\"line\">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class=\"line\">  appendfsync everysec</span><br><span class=\"line\"> </span><br><span class=\"line\">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class=\"line\">   vm-enabled no</span><br><span class=\"line\">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class=\"line\">   vm-swap-file /tmp/redis.swap</span><br><span class=\"line\">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class=\"line\">   vm-max-memory 0</span><br><span class=\"line\">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class=\"line\">   vm-page-size 32</span><br><span class=\"line\">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class=\"line\">   vm-pages 134217728</span><br><span class=\"line\">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class=\"line\">   vm-max-threads 4</span><br><span class=\"line\">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class=\"line\">  glueoutputbuf yes</span><br><span class=\"line\">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class=\"line\">  hash-max-zipmap-entries 64</span><br><span class=\"line\">  hash-max-zipmap-value 512</span><br><span class=\"line\">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class=\"line\">  activerehashing yes</span><br><span class=\"line\">30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class=\"line\">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><p>Redis的持久化一共有两种：<br>rdb持久化<br>aof持久化（推荐使用）</p>\n<h2 id=\"RDB（Redis-Database）\"><a href=\"#RDB（Redis-Database）\" class=\"headerlink\" title=\"RDB（Redis Database）\"></a>RDB（Redis Database）</h2><h3 id=\"什么是rdb持久化\"><a href=\"#什么是rdb持久化\" class=\"headerlink\" title=\"什么是rdb持久化\"></a>什么是rdb持久化</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘.<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n<p>Redis官方解释：<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，<br>待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。<br>（因为可能出现redis宕机的情况）</p>\n<h3 id=\"Fork的解释\"><a href=\"#Fork的解释\" class=\"headerlink\" title=\"Fork的解释\"></a>Fork的解释</h3><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><h1 id=\"Redis的事物\"><a href=\"#Redis的事物\" class=\"headerlink\" title=\"Redis的事物\"></a>Redis的事物</h1><h2 id=\"事物介绍\"><a href=\"#事物介绍\" class=\"headerlink\" title=\"事物介绍\"></a>事物介绍</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1）批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）<br>2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p><strong>注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong></p>\n<p>Redis的一个事务从开始到执行会经历以下三个阶段：<br>1）开始事务。<br>2）命令入队。<br>3）执行事务。</p>\n<h2 id=\"事物常用命令\"><a href=\"#事物常用命令\" class=\"headerlink\" title=\"事物常用命令\"></a>事物常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi\t\t\t\t\t\t标记一个事物块的开始</span><br><span class=\"line\"></span><br><span class=\"line\">exec：\t\t\t\t\t\t执行所有事物块内的命令</span><br><span class=\"line\"></span><br><span class=\"line\">discard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令</span><br><span class=\"line\"></span><br><span class=\"line\">watch key [key ...]：\t\t\t</span><br><span class=\"line\">监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br><span class=\"line\"></span><br><span class=\"line\">unwatch\t\t\t\t\t\t取消watch命令对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<p>// TODO</p>"},{"title":"Redis-数据过期策略","date":"2021-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 前提补充\n\n我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。\n\n## 我往redis里写的数据怎么没了？\n\n我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？\n\n什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。\n\n那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。\n\n所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。\n\nset key value 过期时间（1小时）\nset进去的key，1小时之后就没了，就失效了\n\n## 我的数据明明都过期了，怎么还占用着内存啊？\n\n还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。\n\nredis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。\n\n如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？\n\n# 对key设置过期时间\n\nexpire key time(以秒为单位)--这是最常用的方式\n\nRedis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。\nExpires字典保存了所有键的过期时间，Expires也被称为过期字段。\n\n注意：  \n1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间  \n2、如果没有设置时间，那缓存就是永不过期  \n3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key\n\n# 过期策略\n\n## 三种过期策略机制\n\n1）定时删除（没人用）\n含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。\n\n优点：可以保证内存被尽快释放\n\n缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key\n\n2）惰性删除\n含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。\n\n优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）\n\n缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n3）定期删除\n含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。\n\n优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理\"定时删除\"的缺点\n\n缺点：\n在内存友好方面，不如\"定时删除\"\n在CPU时间友好方面，不如\"惰性删除\"\n\n**定期删除过期key可以处理\"惰性删除\"的缺点**\n\n## 三种过期策略机制总结\n\n看完上面三种策略后可以得出以下结论：  \n定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key\n惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。\n\n定期删除可以通过：  \n第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大）   \n第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略\n\n# Redis默认采用的过期策略\n\nRedis服务器默认过期内置策略是：惰性删除+定期删除\n\n惰性删除流程：  \n在进行get或setnx等操作时，先检查key是否过期；  \n若过期，删除key，然后执行相应操作；  \n若没过期，直接执行相应操作。  \n\n定期删除流程：  \n（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）   \n遍历每个数据库（就是redis.conf中配置的\"database\"数量，默认为16）   \n检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）   \n如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。  \n随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。  \n判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。\n\n提问：为什么不使用定时删除，而使用定期删除呢？\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n# 持久化机制对过期key的处理\n\n## RDB对过期key的处理\n\n过期key对RDB没有任何影响  \n从内存数据库持久化数据到RDB文件   \n持久化key之前，会检查是否过期，过期的key不进入RDB文件  \n从RDB文件恢复数据到内存数据库   \n数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）\n\n## AOF对过期key的处理\n\n过期key对AOF没有任何影响  \n从内存数据库持久化数据到AOF文件：   \n当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）  \n当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）  \nAOF重写 \n重写时，会先判断key是否过期，已过期的key不会重写到aof文件\n\n# 内存淘汰机制\n\n## 内存淘汰引入\n\n想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。\n\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。\n通过上述两种手段结合起来，保证过期的key一定会被干掉。\n\n很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。\n\n但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？\n如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？\n\n**答案是：走内存淘汰机制。**\n\n## 内存淘汰机制\n\n如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：\nredis 10个key，现在已经满了，redis需要删除掉5个key\n1个key，最近1分钟被查询了100次\n1个key，最近10分钟被查询了50次\n1个key，最近1个小时倍查询了1次\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了  \n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）  \n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊  \n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）  \n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key  \n6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除","source":"_posts/oyr/Redis/Redis-数据过期策略.md","raw":"---\ntitle: Redis-数据过期策略\ndate: 2021-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Redis\ntags: \n    - Redis\n    - 中间件\n---\n\n# 前提补充\n\n我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。\n\n## 我往redis里写的数据怎么没了？\n\n我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？\n\n什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。\n\n那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。\n\n所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。\n\nset key value 过期时间（1小时）\nset进去的key，1小时之后就没了，就失效了\n\n## 我的数据明明都过期了，怎么还占用着内存啊？\n\n还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。\n\nredis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。\n\n如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？\n\n# 对key设置过期时间\n\nexpire key time(以秒为单位)--这是最常用的方式\n\nRedis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。\nExpires字典保存了所有键的过期时间，Expires也被称为过期字段。\n\n注意：  \n1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间  \n2、如果没有设置时间，那缓存就是永不过期  \n3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key\n\n# 过期策略\n\n## 三种过期策略机制\n\n1）定时删除（没人用）\n含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。\n\n优点：可以保证内存被尽快释放\n\n缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key\n\n2）惰性删除\n含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。\n\n优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）\n\n缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n3）定期删除\n含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。\n\n优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理\"定时删除\"的缺点\n\n缺点：\n在内存友好方面，不如\"定时删除\"\n在CPU时间友好方面，不如\"惰性删除\"\n\n**定期删除过期key可以处理\"惰性删除\"的缺点**\n\n## 三种过期策略机制总结\n\n看完上面三种策略后可以得出以下结论：  \n定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key\n惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。\n\n定期删除可以通过：  \n第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大）   \n第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略\n\n# Redis默认采用的过期策略\n\nRedis服务器默认过期内置策略是：惰性删除+定期删除\n\n惰性删除流程：  \n在进行get或setnx等操作时，先检查key是否过期；  \n若过期，删除key，然后执行相应操作；  \n若没过期，直接执行相应操作。  \n\n定期删除流程：  \n（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）   \n遍历每个数据库（就是redis.conf中配置的\"database\"数量，默认为16）   \n检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）   \n如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。  \n随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。  \n判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。\n\n提问：为什么不使用定时删除，而使用定期删除呢？\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n# 持久化机制对过期key的处理\n\n## RDB对过期key的处理\n\n过期key对RDB没有任何影响  \n从内存数据库持久化数据到RDB文件   \n持久化key之前，会检查是否过期，过期的key不进入RDB文件  \n从RDB文件恢复数据到内存数据库   \n数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）\n\n## AOF对过期key的处理\n\n过期key对AOF没有任何影响  \n从内存数据库持久化数据到AOF文件：   \n当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）  \n当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）  \nAOF重写 \n重写时，会先判断key是否过期，已过期的key不会重写到aof文件\n\n# 内存淘汰机制\n\n## 内存淘汰引入\n\n想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。\n\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。\n通过上述两种手段结合起来，保证过期的key一定会被干掉。\n\n很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。\n\n但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？\n如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？\n\n**答案是：走内存淘汰机制。**\n\n## 内存淘汰机制\n\n如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：\nredis 10个key，现在已经满了，redis需要删除掉5个key\n1个key，最近1分钟被查询了100次\n1个key，最近10分钟被查询了50次\n1个key，最近1个小时倍查询了1次\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了  \n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）  \n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊  \n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）  \n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key  \n6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除","slug":"oyr/Redis/Redis-数据过期策略","published":1,"updated":"2021-10-26T10:31:03.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86s002wcst79hag2hah","content":"<h1 id=\"前提补充\"><a href=\"#前提补充\" class=\"headerlink\" title=\"前提补充\"></a>前提补充</h1><p>我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。</p>\n<h2 id=\"我往redis里写的数据怎么没了？\"><a href=\"#我往redis里写的数据怎么没了？\" class=\"headerlink\" title=\"我往redis里写的数据怎么没了？\"></a>我往redis里写的数据怎么没了？</h2><p>我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？</p>\n<p>什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。</p>\n<p>那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。</p>\n<p>所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。</p>\n<p>set key value 过期时间（1小时）<br>set进去的key，1小时之后就没了，就失效了</p>\n<h2 id=\"我的数据明明都过期了，怎么还占用着内存啊？\"><a href=\"#我的数据明明都过期了，怎么还占用着内存啊？\" class=\"headerlink\" title=\"我的数据明明都过期了，怎么还占用着内存啊？\"></a>我的数据明明都过期了，怎么还占用着内存啊？</h2><p>还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。</p>\n<p>redis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。</p>\n<p>如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？</p>\n<h1 id=\"对key设置过期时间\"><a href=\"#对key设置过期时间\" class=\"headerlink\" title=\"对key设置过期时间\"></a>对key设置过期时间</h1><p>expire key time(以秒为单位)–这是最常用的方式</p>\n<p>Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。<br>Expires字典保存了所有键的过期时间，Expires也被称为过期字段。</p>\n<p>注意：<br>1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间<br>2、如果没有设置时间，那缓存就是永不过期<br>3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key</p>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><h2 id=\"三种过期策略机制\"><a href=\"#三种过期策略机制\" class=\"headerlink\" title=\"三种过期策略机制\"></a>三种过期策略机制</h2><p>1）定时删除（没人用）<br>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</p>\n<p>优点：可以保证内存被尽快释放</p>\n<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</p>\n<p>2）惰性删除<br>含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。</p>\n<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>\n<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<p>3）定期删除<br>含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p>\n<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</p>\n<p>缺点：<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p>\n<p><strong>定期删除过期key可以处理”惰性删除”的缺点</strong></p>\n<h2 id=\"三种过期策略机制总结\"><a href=\"#三种过期策略机制总结\" class=\"headerlink\" title=\"三种过期策略机制总结\"></a>三种过期策略机制总结</h2><p>看完上面三种策略后可以得出以下结论：<br>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key<br>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。</p>\n<p>定期删除可以通过：<br>第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） <br>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</p>\n<h1 id=\"Redis默认采用的过期策略\"><a href=\"#Redis默认采用的过期策略\" class=\"headerlink\" title=\"Redis默认采用的过期策略\"></a>Redis默认采用的过期策略</h1><p>Redis服务器默认过期内置策略是：惰性删除+定期删除</p>\n<p>惰性删除流程：<br>在进行get或setnx等操作时，先检查key是否过期；<br>若过期，删除key，然后执行相应操作；<br>若没过期，直接执行相应操作。  </p>\n<p>定期删除流程：<br>（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<br>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<br>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。<br>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。<br>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</p>\n<p>提问：为什么不使用定时删除，而使用定期删除呢？<br>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<h1 id=\"持久化机制对过期key的处理\"><a href=\"#持久化机制对过期key的处理\" class=\"headerlink\" title=\"持久化机制对过期key的处理\"></a>持久化机制对过期key的处理</h1><h2 id=\"RDB对过期key的处理\"><a href=\"#RDB对过期key的处理\" class=\"headerlink\" title=\"RDB对过期key的处理\"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响<br>从内存数据库持久化数据到RDB文件<br>持久化key之前，会检查是否过期，过期的key不进入RDB文件<br>从RDB文件恢复数据到内存数据库<br>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</p>\n<h2 id=\"AOF对过期key的处理\"><a href=\"#AOF对过期key的处理\" class=\"headerlink\" title=\"AOF对过期key的处理\"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响<br>从内存数据库持久化数据到AOF文件：<br>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）<br>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）<br>AOF重写<br>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</p>\n<h1 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h1><h2 id=\"内存淘汰引入\"><a href=\"#内存淘汰引入\" class=\"headerlink\" title=\"内存淘汰引入\"></a>内存淘汰引入</h2><p>想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。</p>\n<p>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<p>但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。<br>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。<br>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p>\n<p>很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。</p>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？<br>如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p>\n<p><strong>答案是：走内存淘汰机制。</strong></p>\n<h2 id=\"内存淘汰机制-1\"><a href=\"#内存淘汰机制-1\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h2><p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：<br>redis 10个key，现在已经满了，redis需要删除掉5个key<br>1个key，最近1分钟被查询了100次<br>1个key，最近10分钟被查询了50次<br>1个key，最近1个小时倍查询了1次</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了<br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊<br>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）<br>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前提补充\"><a href=\"#前提补充\" class=\"headerlink\" title=\"前提补充\"></a>前提补充</h1><p>我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。</p>\n<h2 id=\"我往redis里写的数据怎么没了？\"><a href=\"#我往redis里写的数据怎么没了？\" class=\"headerlink\" title=\"我往redis里写的数据怎么没了？\"></a>我往redis里写的数据怎么没了？</h2><p>我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？</p>\n<p>什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。</p>\n<p>那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。</p>\n<p>所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。</p>\n<p>set key value 过期时间（1小时）<br>set进去的key，1小时之后就没了，就失效了</p>\n<h2 id=\"我的数据明明都过期了，怎么还占用着内存啊？\"><a href=\"#我的数据明明都过期了，怎么还占用着内存啊？\" class=\"headerlink\" title=\"我的数据明明都过期了，怎么还占用着内存啊？\"></a>我的数据明明都过期了，怎么还占用着内存啊？</h2><p>还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。</p>\n<p>redis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。</p>\n<p>如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？</p>\n<h1 id=\"对key设置过期时间\"><a href=\"#对key设置过期时间\" class=\"headerlink\" title=\"对key设置过期时间\"></a>对key设置过期时间</h1><p>expire key time(以秒为单位)–这是最常用的方式</p>\n<p>Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。<br>Expires字典保存了所有键的过期时间，Expires也被称为过期字段。</p>\n<p>注意：<br>1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间<br>2、如果没有设置时间，那缓存就是永不过期<br>3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key</p>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><h2 id=\"三种过期策略机制\"><a href=\"#三种过期策略机制\" class=\"headerlink\" title=\"三种过期策略机制\"></a>三种过期策略机制</h2><p>1）定时删除（没人用）<br>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</p>\n<p>优点：可以保证内存被尽快释放</p>\n<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</p>\n<p>2）惰性删除<br>含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。</p>\n<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>\n<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<p>3）定期删除<br>含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p>\n<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</p>\n<p>缺点：<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p>\n<p><strong>定期删除过期key可以处理”惰性删除”的缺点</strong></p>\n<h2 id=\"三种过期策略机制总结\"><a href=\"#三种过期策略机制总结\" class=\"headerlink\" title=\"三种过期策略机制总结\"></a>三种过期策略机制总结</h2><p>看完上面三种策略后可以得出以下结论：<br>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key<br>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。</p>\n<p>定期删除可以通过：<br>第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） <br>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</p>\n<h1 id=\"Redis默认采用的过期策略\"><a href=\"#Redis默认采用的过期策略\" class=\"headerlink\" title=\"Redis默认采用的过期策略\"></a>Redis默认采用的过期策略</h1><p>Redis服务器默认过期内置策略是：惰性删除+定期删除</p>\n<p>惰性删除流程：<br>在进行get或setnx等操作时，先检查key是否过期；<br>若过期，删除key，然后执行相应操作；<br>若没过期，直接执行相应操作。  </p>\n<p>定期删除流程：<br>（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<br>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<br>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。<br>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。<br>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</p>\n<p>提问：为什么不使用定时删除，而使用定期删除呢？<br>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<h1 id=\"持久化机制对过期key的处理\"><a href=\"#持久化机制对过期key的处理\" class=\"headerlink\" title=\"持久化机制对过期key的处理\"></a>持久化机制对过期key的处理</h1><h2 id=\"RDB对过期key的处理\"><a href=\"#RDB对过期key的处理\" class=\"headerlink\" title=\"RDB对过期key的处理\"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响<br>从内存数据库持久化数据到RDB文件<br>持久化key之前，会检查是否过期，过期的key不进入RDB文件<br>从RDB文件恢复数据到内存数据库<br>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</p>\n<h2 id=\"AOF对过期key的处理\"><a href=\"#AOF对过期key的处理\" class=\"headerlink\" title=\"AOF对过期key的处理\"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响<br>从内存数据库持久化数据到AOF文件：<br>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）<br>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）<br>AOF重写<br>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</p>\n<h1 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h1><h2 id=\"内存淘汰引入\"><a href=\"#内存淘汰引入\" class=\"headerlink\" title=\"内存淘汰引入\"></a>内存淘汰引入</h2><p>想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。</p>\n<p>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<p>但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。<br>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。<br>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p>\n<p>很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。</p>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？<br>如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p>\n<p><strong>答案是：走内存淘汰机制。</strong></p>\n<h2 id=\"内存淘汰机制-1\"><a href=\"#内存淘汰机制-1\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h2><p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：<br>redis 10个key，现在已经满了，redis需要删除掉5个key<br>1个key，最近1分钟被查询了100次<br>1个key，最近10分钟被查询了50次<br>1个key，最近1个小时倍查询了1次</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了<br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊<br>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）<br>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p>\n"},{"title":"分布式session","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/分布式/分布式session.md","raw":"---\ntitle: 分布式session\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-分布式session\ntags: \n   - 分布式session\n   - 中间件\n---","slug":"oyr/分布式/分布式session","published":1,"updated":"2021-10-27T02:51:34.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86s0030cst7e76q84ka","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Redis-穿透&雪崩&击穿","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Redis缓存穿透\n\n## 什么是缓存穿透\n\n缓存穿透：是指查询一个数据库不存在的数据。\n\nRedis正常使用流程：  \n数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。\n\n问题引出：  \n想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。\n\n## 解决方案\n\n1）redis缓存空值（推荐方案）  \n对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。\n\n2）判断key的数据格式（有局限，列如key没有任何规则）  \n网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。\n\n# Redis缓存雪崩\n\n## 什么是缓存雪崩\n\n缓存雪崩：指在某一个时间段，缓存集中过期失效。\n\n举例：  \n马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。\n\n## 解决方案\n\n1）使用锁（不推荐效率低）  \n单点项目使用本地锁，分布式项目使用分布式锁。  \n对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。\n\n2）使用二级缓存（推荐）  \n一级缓存使用ehcache，二级缓存使用redis。  \n一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。\n\n3）均摊分配redis key的失效时间（推荐）  \n不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。\n\n# Redis缓存击穿\n\n## 什么是缓存击穿\n\n缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n\n## 解决方案\n1）设置热点数据永远不过期。（推荐）  \n\n2）使用互斥锁（不推荐，没必要）  \n指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。","source":"_posts/oyr/Redis/Redis-穿透&雪崩&击穿.md","raw":"---\ntitle: Redis-穿透&雪崩&击穿\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-Redis\ntags: \n    - Redis\n    - 中间件\n---\n\n# Redis缓存穿透\n\n## 什么是缓存穿透\n\n缓存穿透：是指查询一个数据库不存在的数据。\n\nRedis正常使用流程：  \n数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。\n\n问题引出：  \n想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。\n\n## 解决方案\n\n1）redis缓存空值（推荐方案）  \n对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。\n\n2）判断key的数据格式（有局限，列如key没有任何规则）  \n网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。\n\n# Redis缓存雪崩\n\n## 什么是缓存雪崩\n\n缓存雪崩：指在某一个时间段，缓存集中过期失效。\n\n举例：  \n马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。\n\n## 解决方案\n\n1）使用锁（不推荐效率低）  \n单点项目使用本地锁，分布式项目使用分布式锁。  \n对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。\n\n2）使用二级缓存（推荐）  \n一级缓存使用ehcache，二级缓存使用redis。  \n一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。\n\n3）均摊分配redis key的失效时间（推荐）  \n不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。\n\n# Redis缓存击穿\n\n## 什么是缓存击穿\n\n缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n\n## 解决方案\n1）设置热点数据永远不过期。（推荐）  \n\n2）使用互斥锁（不推荐，没必要）  \n指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。","slug":"oyr/Redis/Redis-穿透&雪崩&击穿","published":1,"updated":"2021-10-26T10:31:03.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86t0032cst72nl9haqs","content":"<h1 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h1><h2 id=\"什么是缓存穿透\"><a href=\"#什么是缓存穿透\" class=\"headerlink\" title=\"什么是缓存穿透\"></a>什么是缓存穿透</h2><p>缓存穿透：是指查询一个数据库不存在的数据。</p>\n<p>Redis正常使用流程：<br>数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。</p>\n<p>问题引出：<br>想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）redis缓存空值（推荐方案）<br>对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。</p>\n<p>2）判断key的数据格式（有局限，列如key没有任何规则）<br>网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。</p>\n<h1 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h1><h2 id=\"什么是缓存雪崩\"><a href=\"#什么是缓存雪崩\" class=\"headerlink\" title=\"什么是缓存雪崩\"></a>什么是缓存雪崩</h2><p>缓存雪崩：指在某一个时间段，缓存集中过期失效。</p>\n<p>举例：<br>马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）使用锁（不推荐效率低）<br>单点项目使用本地锁，分布式项目使用分布式锁。<br>对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<p>2）使用二级缓存（推荐）<br>一级缓存使用ehcache，二级缓存使用redis。<br>一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。</p>\n<p>3）均摊分配redis key的失效时间（推荐）<br>不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。</p>\n<h1 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h1><h2 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿\"></a>什么是缓存击穿</h2><p>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）设置热点数据永远不过期。（推荐）  </p>\n<p>2）使用互斥锁（不推荐，没必要）<br>指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h1><h2 id=\"什么是缓存穿透\"><a href=\"#什么是缓存穿透\" class=\"headerlink\" title=\"什么是缓存穿透\"></a>什么是缓存穿透</h2><p>缓存穿透：是指查询一个数据库不存在的数据。</p>\n<p>Redis正常使用流程：<br>数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。</p>\n<p>问题引出：<br>想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）redis缓存空值（推荐方案）<br>对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。</p>\n<p>2）判断key的数据格式（有局限，列如key没有任何规则）<br>网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。</p>\n<h1 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h1><h2 id=\"什么是缓存雪崩\"><a href=\"#什么是缓存雪崩\" class=\"headerlink\" title=\"什么是缓存雪崩\"></a>什么是缓存雪崩</h2><p>缓存雪崩：指在某一个时间段，缓存集中过期失效。</p>\n<p>举例：<br>马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）使用锁（不推荐效率低）<br>单点项目使用本地锁，分布式项目使用分布式锁。<br>对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<p>2）使用二级缓存（推荐）<br>一级缓存使用ehcache，二级缓存使用redis。<br>一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。</p>\n<p>3）均摊分配redis key的失效时间（推荐）<br>不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。</p>\n<h1 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h1><h2 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿\"></a>什么是缓存击穿</h2><p>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）设置热点数据永远不过期。（推荐）  </p>\n<p>2）使用互斥锁（不推荐，没必要）<br>指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。</p>\n"},{"_content":"","source":"_posts/oyr/Redis/Redis-集群模式.md","raw":"","slug":"oyr/Redis/Redis-集群模式","published":1,"date":"2021-07-13T09:27:26.153Z","updated":"2021-10-27T02:45:58.988Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af86u0036cst78l5kcp4w","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"链路追踪","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\nCat、Zipkin、Pinpoint、SkyWalking","source":"_posts/oyr/分布式/链路追踪.md","raw":"---\ntitle: 链路追踪\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-链路追踪\ntags: \n   - 链路追踪\n   - 中间件\n---\n\nCat、Zipkin、Pinpoint、SkyWalking","slug":"oyr/分布式/链路追踪","published":1,"updated":"2021-10-27T02:51:38.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87c006pcst76vqifezr","content":"<p>Cat、Zipkin、Pinpoint、SkyWalking</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Cat、Zipkin、Pinpoint、SkyWalking</p>\n"},{"title":"RabbitMQ-SpirngBoot整合","date":"2021-09-09T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# SpringBoot 整合\n\n## 环境准备\n\n- rabbitmq 版本：3.8.8\n- springboot 版本：2.2.4.RELEASE\n\n<!-- more -->\n\n## 订阅模式-Fanout\n\n### 生产者\n\n#### 新建maven项目，导入依赖\n\npom.xml\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.4.RELEASE</version>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-amqp</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n#### 编写配置类\n\n配置类：（声明交换机，队列，绑定关系）\n```\n@Configuration\npublic class RabbitConfig {\n\n    public final static String FANOUT_EXCHANGE = \"boot.exchange.fanout\";\n    public final static String FANOUT_QUEUE = \"boot.queue.fanout\";\n\n    // 1.声明交换机（交换机类型为fanout）\n    @Bean\n    public Exchange fanoutExchange() {\n        return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE).durable(true).build();\n    }\n\n    // 2.声明队列\n    @Bean\n    public Queue fanoutQueue() {\n        return QueueBuilder.durable(FANOUT_QUEUE).build();\n    }\n\n    /**\n     * 3.队列和交换机绑定\n     * 需要知道哪个队列\n     * 需要知道哪个交换机\n     * 需要知道路由键（因为交换机类型是fanout，所以路由键为空）\n     */\n    @Bean\n    public Binding fanoutBinding() {\n        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange()).with(\"\").noargs();\n    }\n\n}\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {Application.class})\npublic class ProducerTest {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void directTest() {\n        /**\n         * 发送消息\n         * 参数1：指定交换机\n         * 参数2：指定路由键（因为交换机类型是fanout，所以路由键为空，乱写也无所谓）\n         * 参数3：消息\n         */\n        rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, \"123\", \"boot hello\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 新建maven项目，导入依赖\n\npom.xml\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.4.RELEASE</version>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-amqp</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n#### 监听类（监听指定队列，消费消息）\n\n```java\n// 需要被spring容器扫描到\n@Component\npublic class BootListener {\n\n    // 监听指定的队列，进行消费消息\n    @RabbitListener(queues = \"boot.queue.fanout\")\n    public void listener(Message message) {\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n### 执行，查看结果\n\n这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。\n\n### 小结\n\n- 使用 springboot 整合 rabbitmq，将组件提供配置方式声明，简化编码\n- 生产者使用 spring 提供的 rabbitTemplate 发送消息\n- 消费者使用 spring 提供的 @RabbitListener 注解监听队列，消费消息\n\n## 订阅模式-Direct（rabbitAdmin 与 注解方式）\n\n### 生产者\n\n#### 配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n\n    public final static String DIRECT_EXCHANGE = \"boot.exchange.direct\";\n    public final static String Direct_QUEUE = \"boot.queue.direct\";\n\n    // 创建rabbitAdmin，并且通过rabbitAdmin创建交换机\n    @Bean\n    public RabbitAdmin rabbitAdmin(RabbitTemplate rabbitTemplate) {\n        RabbitAdmin rabbitAdmin = new RabbitAdmin(rabbitTemplate);\n\n        // 声明交换机\n        Exchange exchange = new DirectExchange(DIRECT_EXCHANGE, true, false, null);\n        rabbitAdmin.declareExchange(exchange);\n\n        return rabbitAdmin;\n    }\n\n}\n```\n\n#### 生产者发送消息\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {Application.class})\npublic class ProducerTest {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void directTest() {\n        /**\n         * 发送消息\n         * 参数1：指定交换机\n         * 参数2：指定路由键（因为交换机类型是direct，消息路由键必须和绑定路由一致）\n         * 参数3：消息\n         */\n        rabbitTemplate.convertAndSend(RabbitConfig.DIRECT_EXCHANGE, \"123\", \"boot hello\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 监听类（监听指定队列，消费消息）\n\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 监听指定的队列，进行消费消息\n     * 通过 @RabbitListener 进行：声明队列，声明队列交换机的绑定关系，并且指定绑定key\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"))\n    public void listener(@Payload String body, Message message) {\n        System.out.println(\"body：\" + body);\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n### 执行，查看结果\n\n这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。\n因为当前是 direct 交换机，如果将消息的路由键改成456 ，那么消费者就不会有消息。\n\n# @RabbitListener 使用\n\n## 简介\n\n在 SpringBoot 环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你 90% 以上的业务开发需求。\n下面我们来看一下@RabbitListener的最最常用使用姿势。\n\n前提：\n对于消费者而言其实是不需要管理 exchange 的创建/销毁的，它是由发送者定义的；\n一般来讲，消费者更关注的是自己的 queue，包括定义 queue 并与 exchange 绑定，而这一套过程是可以直接通过 rabbitmq 的控制台操作的哦。\n\n## queue，exchange, binding 已存在\n\n所以实际开发过程中，exchange 和 queue 以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；  \n在这种场景下，消费数据，可以说非常非常简单了，如下：\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 队列，队列与交换机绑定关系已经存在时，直接指定队列名进行消费\n     */\n    @RabbitListener(queues = \"boot.queue.direct\")\n    public void listener(Message message) {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n## queue 不存在\n\n不存在 Queue 的情况下，就需要我们来主动创建 Queue，并建立与 Exchange 的绑定关系，下面给出@RabbitListener的推荐使用姿势：\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 队列不存在时，需要创建一个队列，并且与exchange绑定\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"))\n    public void listener(Message message) {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！以上，就是在队列不存在时的使用姿势，看起来也不复杂。\n\n注意@QueueBinding注解的三个属性：\n- value: @Queue 注解，用于声明队列，value 为 queueName, durable 表示队列是否持久化, autoDelete 表示没有消费者之后队列是否自动删除\n- exchange: @Exchange 注解，用于声明 exchange， type 指定消息投递策略，我们这里用的 direct 方式\n- key: 在 direct 方式下，这个就是我们熟知的 routingKey\n\n## ack（消息应答）\n\nrabbitmq 的核心知识点学习过程中，我们知道有一个消息应答机制，主要是针对消费者的。\n默认情况下，消息应答机制是自动ack，我们可以通过 ack 方式(noack, auto, manual)，进行修改，可以如下处理：\n\n```java\n    /**\n     * 设置为手动ack应答，在代码中显式进行ack应答\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"), ackMode = \"MANUAL\")\n    public void listener(Message message, Channel channel) throws Exception {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n```\n\n请注意，这里使用了Channel和DeliveryTag：\n- Channel：mq 和 consumer 之间的信道，通过它来 ack/nak\n- DeliveryTag：消息的唯一标识，用于 mq 辨别是哪个消息被 ack/nak 了\n\n当我们正确消费时，通过调用 ```basicAck``` 方法即可\n```java\n// 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\nchannel.basicAck(deliveryTag, false);\n```\n\n当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 ```basicNack```\n```java\n// 用于否定确认，第三个参数true，表示这个消息会重新进入队列\nchannel.basicNack(deliveryTag, false, true);\n```\n\n当我们消费失败，想直接丢弃这个消息，可以使用 ```basicReject```\n```java\n// 用于否定确认，直接丢弃当前消息，不再入队\nchannel.basicReject(message.getMessageProperties().getDeliveryTag(), false);\n```\n\n## 并发消费\n\n当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据.\n\n要支持并行消费，如下设置即可：\n```java\n@RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n        exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n        key = \"123\"), concurrency = \"4\")\npublic void listener(Message message, Channel channel) throws Exception {\n    System.out.println(\"body：\" + new String(message.getBody()));\n    System.out.println(\"message：\" + message);\n}\n```\n\n请注意注解中的concurrency = \"4\"属性，表示固定 4 个消费者；\n\n## @Payload 与 @Headers\n\n使用 @Payload 和 @Headers 注解可以消息中的 body 与 headers 信息\n```java\n@RabbitListener(queues = \"debug\")\npublic void listener(@Payload String body, @Headers Map<String, Object> headers) {\n    System.out.println(\"body：\" + body);\n    System.out.println(\"headers：\" + headers);\n}\n```\n\n也可以获取单个 Header 属性\n```java\n@RabbitListener(queues = \"debug\")\npublic void listener(@Payload String body, @Headers String token) {\n    System.out.println(\"body：\" + body);\n    System.out.println(\"token：\" + token);\n}\n```\n\n## @RabbitListener 和 @RabbitHandler 搭配使用\n\n@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用  \n@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型\n\n```\n@Component\n@RabbitListener(queues = \"consumer_queue\")\npublic class Receiver {\n\n    @RabbitHandler\n    public void processMessage1(String message) {\n        System.out.println(message);\n    }\n\n    @RabbitHandler\n    public void processMessage2(byte[] message) {\n        System.out.println(new String(message));\n    }\n    \n}\n```\n\n# RabbitAdmin 使用\n\n## 简介\n\nRabbitAdmin主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等。\n\n## 创建RabbitAdmin\n\n查看源码发现，要创建RabbitAdmin，需要传递一个 ConnectionFactory 或 RabbitTemplate 即可。\n```java\n\t/**\n\t * Construct an instance using the provided {@link ConnectionFactory}.\n\t * @param connectionFactory the connection factory - must not be null.\n\t */\n\tpublic RabbitAdmin(ConnectionFactory connectionFactory) {\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tthis.connectionFactory = connectionFactory;\n\t\tthis.rabbitTemplate = new RabbitTemplate(connectionFactory);\n\t}\n\n\t/**\n\t * Construct an instance using the provided {@link RabbitTemplate}. Use this\n\t * constructor when, for example, you want the admin operations to be performed within\n\t * the scope of the provided template's {@code invoke()} method.\n\t * @param rabbitTemplate the template - must not be null and must have a connection\n\t * factory.\n\t * @since 2.0\n\t */\n\tpublic RabbitAdmin(RabbitTemplate rabbitTemplate) {\n\t\tAssert.notNull(rabbitTemplate, \"RabbitTemplate must not be null\");\n\t\tAssert.notNull(rabbitTemplate.getConnectionFactory(), \"RabbitTemplate's ConnectionFactory must not be null\");\n\t\tthis.connectionFactory = rabbitTemplate.getConnectionFactory();\n\t\tthis.rabbitTemplate = rabbitTemplate;\n\t}\n```\n\n## RabbitAdmin创建交换机\n\n```java\n// 创建交换机，无则创建有则跳过，存在交换机但参数不一致则报错\nrabbitAdmin.declareExchange(new FanoutExchange(\"test.exchange.fanout\", true, false));\nrabbitAdmin.declareExchange(new DirectExchange(\"test.exchange.direct\", true, false));\nrabbitAdmin.declareExchange(new TopicExchange(\"test.exchange.topic\", true, false));\n```\n\n## RabbitAdmin创建队列\n\n```java\n// 创建队列\nrabbitAdmin.declareQueue(new Queue(\"test.queue\"));\n```\n\n## RabbitAdmin绑定交换机与队列\n\n```java\n//绑定队列\nrabbitAdmin.declareBinding(new Binding(\"test.queue\", Binding.DestinationType.QUEUE, \"test.exchange.topic\", \"#\", new HashMap<String, Object>()));        \n```\n\n## RabbitAdmin发送消息\n\n```java\n//发送消息\nrabbitAdmin.getRabbitTemplate().convertAndSend(\"test.exchange.topic\", \"hello\", \"abc123\");\n```","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-SpringBoot整合.md","raw":"---\ntitle: RabbitMQ-SpirngBoot整合\ndate: 2021-09-10 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n# SpringBoot 整合\n\n## 环境准备\n\n- rabbitmq 版本：3.8.8\n- springboot 版本：2.2.4.RELEASE\n\n<!-- more -->\n\n## 订阅模式-Fanout\n\n### 生产者\n\n#### 新建maven项目，导入依赖\n\npom.xml\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.4.RELEASE</version>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-amqp</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n#### 编写配置类\n\n配置类：（声明交换机，队列，绑定关系）\n```\n@Configuration\npublic class RabbitConfig {\n\n    public final static String FANOUT_EXCHANGE = \"boot.exchange.fanout\";\n    public final static String FANOUT_QUEUE = \"boot.queue.fanout\";\n\n    // 1.声明交换机（交换机类型为fanout）\n    @Bean\n    public Exchange fanoutExchange() {\n        return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE).durable(true).build();\n    }\n\n    // 2.声明队列\n    @Bean\n    public Queue fanoutQueue() {\n        return QueueBuilder.durable(FANOUT_QUEUE).build();\n    }\n\n    /**\n     * 3.队列和交换机绑定\n     * 需要知道哪个队列\n     * 需要知道哪个交换机\n     * 需要知道路由键（因为交换机类型是fanout，所以路由键为空）\n     */\n    @Bean\n    public Binding fanoutBinding() {\n        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange()).with(\"\").noargs();\n    }\n\n}\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {Application.class})\npublic class ProducerTest {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void directTest() {\n        /**\n         * 发送消息\n         * 参数1：指定交换机\n         * 参数2：指定路由键（因为交换机类型是fanout，所以路由键为空，乱写也无所谓）\n         * 参数3：消息\n         */\n        rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, \"123\", \"boot hello\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 新建maven项目，导入依赖\n\npom.xml\n```xml\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.4.RELEASE</version>\n    </parent>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-amqp</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n#### 监听类（监听指定队列，消费消息）\n\n```java\n// 需要被spring容器扫描到\n@Component\npublic class BootListener {\n\n    // 监听指定的队列，进行消费消息\n    @RabbitListener(queues = \"boot.queue.fanout\")\n    public void listener(Message message) {\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n### 执行，查看结果\n\n这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。\n\n### 小结\n\n- 使用 springboot 整合 rabbitmq，将组件提供配置方式声明，简化编码\n- 生产者使用 spring 提供的 rabbitTemplate 发送消息\n- 消费者使用 spring 提供的 @RabbitListener 注解监听队列，消费消息\n\n## 订阅模式-Direct（rabbitAdmin 与 注解方式）\n\n### 生产者\n\n#### 配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n\n    public final static String DIRECT_EXCHANGE = \"boot.exchange.direct\";\n    public final static String Direct_QUEUE = \"boot.queue.direct\";\n\n    // 创建rabbitAdmin，并且通过rabbitAdmin创建交换机\n    @Bean\n    public RabbitAdmin rabbitAdmin(RabbitTemplate rabbitTemplate) {\n        RabbitAdmin rabbitAdmin = new RabbitAdmin(rabbitTemplate);\n\n        // 声明交换机\n        Exchange exchange = new DirectExchange(DIRECT_EXCHANGE, true, false, null);\n        rabbitAdmin.declareExchange(exchange);\n\n        return rabbitAdmin;\n    }\n\n}\n```\n\n#### 生产者发送消息\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {Application.class})\npublic class ProducerTest {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void directTest() {\n        /**\n         * 发送消息\n         * 参数1：指定交换机\n         * 参数2：指定路由键（因为交换机类型是direct，消息路由键必须和绑定路由一致）\n         * 参数3：消息\n         */\n        rabbitTemplate.convertAndSend(RabbitConfig.DIRECT_EXCHANGE, \"123\", \"boot hello\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 监听类（监听指定队列，消费消息）\n\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 监听指定的队列，进行消费消息\n     * 通过 @RabbitListener 进行：声明队列，声明队列交换机的绑定关系，并且指定绑定key\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"))\n    public void listener(@Payload String body, Message message) {\n        System.out.println(\"body：\" + body);\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n### 执行，查看结果\n\n这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。\n因为当前是 direct 交换机，如果将消息的路由键改成456 ，那么消费者就不会有消息。\n\n# @RabbitListener 使用\n\n## 简介\n\n在 SpringBoot 环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你 90% 以上的业务开发需求。\n下面我们来看一下@RabbitListener的最最常用使用姿势。\n\n前提：\n对于消费者而言其实是不需要管理 exchange 的创建/销毁的，它是由发送者定义的；\n一般来讲，消费者更关注的是自己的 queue，包括定义 queue 并与 exchange 绑定，而这一套过程是可以直接通过 rabbitmq 的控制台操作的哦。\n\n## queue，exchange, binding 已存在\n\n所以实际开发过程中，exchange 和 queue 以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；  \n在这种场景下，消费数据，可以说非常非常简单了，如下：\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 队列，队列与交换机绑定关系已经存在时，直接指定队列名进行消费\n     */\n    @RabbitListener(queues = \"boot.queue.direct\")\n    public void listener(Message message) {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n## queue 不存在\n\n不存在 Queue 的情况下，就需要我们来主动创建 Queue，并建立与 Exchange 的绑定关系，下面给出@RabbitListener的推荐使用姿势：\n```java\n@Component\npublic class BootListener {\n\n    /**\n     * 队列不存在时，需要创建一个队列，并且与exchange绑定\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"))\n    public void listener(Message message) {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n    }\n\n}\n```\n\n一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！以上，就是在队列不存在时的使用姿势，看起来也不复杂。\n\n注意@QueueBinding注解的三个属性：\n- value: @Queue 注解，用于声明队列，value 为 queueName, durable 表示队列是否持久化, autoDelete 表示没有消费者之后队列是否自动删除\n- exchange: @Exchange 注解，用于声明 exchange， type 指定消息投递策略，我们这里用的 direct 方式\n- key: 在 direct 方式下，这个就是我们熟知的 routingKey\n\n## ack（消息应答）\n\nrabbitmq 的核心知识点学习过程中，我们知道有一个消息应答机制，主要是针对消费者的。\n默认情况下，消息应答机制是自动ack，我们可以通过 ack 方式(noack, auto, manual)，进行修改，可以如下处理：\n\n```java\n    /**\n     * 设置为手动ack应答，在代码中显式进行ack应答\n     */\n    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n            exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n            key = \"123\"), ackMode = \"MANUAL\")\n    public void listener(Message message, Channel channel) throws Exception {\n        System.out.println(\"body：\" + new String(message.getBody()));\n        System.out.println(\"message：\" + message);\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n```\n\n请注意，这里使用了Channel和DeliveryTag：\n- Channel：mq 和 consumer 之间的信道，通过它来 ack/nak\n- DeliveryTag：消息的唯一标识，用于 mq 辨别是哪个消息被 ack/nak 了\n\n当我们正确消费时，通过调用 ```basicAck``` 方法即可\n```java\n// 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\nchannel.basicAck(deliveryTag, false);\n```\n\n当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 ```basicNack```\n```java\n// 用于否定确认，第三个参数true，表示这个消息会重新进入队列\nchannel.basicNack(deliveryTag, false, true);\n```\n\n当我们消费失败，想直接丢弃这个消息，可以使用 ```basicReject```\n```java\n// 用于否定确认，直接丢弃当前消息，不再入队\nchannel.basicReject(message.getMessageProperties().getDeliveryTag(), false);\n```\n\n## 并发消费\n\n当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据.\n\n要支持并行消费，如下设置即可：\n```java\n@RabbitListener(bindings = @QueueBinding(value = @Queue(name = \"boot.queue.direct\"),\n        exchange = @Exchange(name = \"boot.exchange.direct\", type = ExchangeTypes.DIRECT),\n        key = \"123\"), concurrency = \"4\")\npublic void listener(Message message, Channel channel) throws Exception {\n    System.out.println(\"body：\" + new String(message.getBody()));\n    System.out.println(\"message：\" + message);\n}\n```\n\n请注意注解中的concurrency = \"4\"属性，表示固定 4 个消费者；\n\n## @Payload 与 @Headers\n\n使用 @Payload 和 @Headers 注解可以消息中的 body 与 headers 信息\n```java\n@RabbitListener(queues = \"debug\")\npublic void listener(@Payload String body, @Headers Map<String, Object> headers) {\n    System.out.println(\"body：\" + body);\n    System.out.println(\"headers：\" + headers);\n}\n```\n\n也可以获取单个 Header 属性\n```java\n@RabbitListener(queues = \"debug\")\npublic void listener(@Payload String body, @Headers String token) {\n    System.out.println(\"body：\" + body);\n    System.out.println(\"token：\" + token);\n}\n```\n\n## @RabbitListener 和 @RabbitHandler 搭配使用\n\n@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用  \n@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型\n\n```\n@Component\n@RabbitListener(queues = \"consumer_queue\")\npublic class Receiver {\n\n    @RabbitHandler\n    public void processMessage1(String message) {\n        System.out.println(message);\n    }\n\n    @RabbitHandler\n    public void processMessage2(byte[] message) {\n        System.out.println(new String(message));\n    }\n    \n}\n```\n\n# RabbitAdmin 使用\n\n## 简介\n\nRabbitAdmin主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等。\n\n## 创建RabbitAdmin\n\n查看源码发现，要创建RabbitAdmin，需要传递一个 ConnectionFactory 或 RabbitTemplate 即可。\n```java\n\t/**\n\t * Construct an instance using the provided {@link ConnectionFactory}.\n\t * @param connectionFactory the connection factory - must not be null.\n\t */\n\tpublic RabbitAdmin(ConnectionFactory connectionFactory) {\n\t\tAssert.notNull(connectionFactory, \"ConnectionFactory must not be null\");\n\t\tthis.connectionFactory = connectionFactory;\n\t\tthis.rabbitTemplate = new RabbitTemplate(connectionFactory);\n\t}\n\n\t/**\n\t * Construct an instance using the provided {@link RabbitTemplate}. Use this\n\t * constructor when, for example, you want the admin operations to be performed within\n\t * the scope of the provided template's {@code invoke()} method.\n\t * @param rabbitTemplate the template - must not be null and must have a connection\n\t * factory.\n\t * @since 2.0\n\t */\n\tpublic RabbitAdmin(RabbitTemplate rabbitTemplate) {\n\t\tAssert.notNull(rabbitTemplate, \"RabbitTemplate must not be null\");\n\t\tAssert.notNull(rabbitTemplate.getConnectionFactory(), \"RabbitTemplate's ConnectionFactory must not be null\");\n\t\tthis.connectionFactory = rabbitTemplate.getConnectionFactory();\n\t\tthis.rabbitTemplate = rabbitTemplate;\n\t}\n```\n\n## RabbitAdmin创建交换机\n\n```java\n// 创建交换机，无则创建有则跳过，存在交换机但参数不一致则报错\nrabbitAdmin.declareExchange(new FanoutExchange(\"test.exchange.fanout\", true, false));\nrabbitAdmin.declareExchange(new DirectExchange(\"test.exchange.direct\", true, false));\nrabbitAdmin.declareExchange(new TopicExchange(\"test.exchange.topic\", true, false));\n```\n\n## RabbitAdmin创建队列\n\n```java\n// 创建队列\nrabbitAdmin.declareQueue(new Queue(\"test.queue\"));\n```\n\n## RabbitAdmin绑定交换机与队列\n\n```java\n//绑定队列\nrabbitAdmin.declareBinding(new Binding(\"test.queue\", Binding.DestinationType.QUEUE, \"test.exchange.topic\", \"#\", new HashMap<String, Object>()));        \n```\n\n## RabbitAdmin发送消息\n\n```java\n//发送消息\nrabbitAdmin.getRabbitTemplate().convertAndSend(\"test.exchange.topic\", \"hello\", \"abc123\");\n```","slug":"oyr/MQ/RabbitMQ/RabbitMQ-SpringBoot整合","published":1,"updated":"2021-10-26T10:30:26.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87d006qcst712qx0v12","content":"<h1 id=\"SpringBoot-整合\"><a href=\"#SpringBoot-整合\" class=\"headerlink\" title=\"SpringBoot 整合\"></a>SpringBoot 整合</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>rabbitmq 版本：3.8.8</li>\n<li>springboot 版本：2.2.4.RELEASE</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"新建maven项目，导入依赖\"><a href=\"#新建maven项目，导入依赖\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置类\"><a href=\"#编写配置类\" class=\"headerlink\" title=\"编写配置类\"></a>编写配置类</h4><p>配置类：（声明交换机，队列，绑定关系）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RabbitConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final static String FANOUT_EXCHANGE = &quot;boot.exchange.fanout&quot;;</span><br><span class=\"line\">    public final static String FANOUT_QUEUE = &quot;boot.queue.fanout&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 1.声明交换机（交换机类型为fanout）</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Exchange fanoutExchange() &#123;</span><br><span class=\"line\">        return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE).durable(true).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2.声明队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue fanoutQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder.durable(FANOUT_QUEUE).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 3.队列和交换机绑定</span><br><span class=\"line\">     * 需要知道哪个队列</span><br><span class=\"line\">     * 需要知道哪个交换机</span><br><span class=\"line\">     * 需要知道路由键（因为交换机类型是fanout，所以路由键为空）</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding fanoutBinding() &#123;</span><br><span class=\"line\">        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange()).with(&quot;&quot;).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码\"><a href=\"#发送消息代码\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = &#123;Application.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">directTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：指定交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：指定路由键（因为交换机类型是fanout，所以路由键为空，乱写也无所谓）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消息</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"新建maven项目，导入依赖-1\"><a href=\"#新建maven项目，导入依赖-1\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"监听类（监听指定队列，消费消息）\"><a href=\"#监听类（监听指定队列，消费消息）\" class=\"headerlink\" title=\"监听类（监听指定队列，消费消息）\"></a>监听类（监听指定队列，消费消息）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要被spring容器扫描到</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听指定的队列，进行消费消息</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;boot.queue.fanout&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果\"><a href=\"#执行，查看结果\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>使用 springboot 整合 rabbitmq，将组件提供配置方式声明，简化编码</li>\n<li>生产者使用 spring 提供的 rabbitTemplate 发送消息</li>\n<li>消费者使用 spring 提供的 @RabbitListener 注解监听队列，消费消息</li>\n</ul>\n<h2 id=\"订阅模式-Direct（rabbitAdmin-与-注解方式）\"><a href=\"#订阅模式-Direct（rabbitAdmin-与-注解方式）\" class=\"headerlink\" title=\"订阅模式-Direct（rabbitAdmin 与 注解方式）\"></a>订阅模式-Direct（rabbitAdmin 与 注解方式）</h2><h3 id=\"生产者-1\"><a href=\"#生产者-1\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String DIRECT_EXCHANGE = <span class=\"string\">&quot;boot.exchange.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String Direct_QUEUE = <span class=\"string\">&quot;boot.queue.direct&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建rabbitAdmin，并且通过rabbitAdmin创建交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RabbitAdmin <span class=\"title\">rabbitAdmin</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class=\"line\">        RabbitAdmin rabbitAdmin = <span class=\"keyword\">new</span> RabbitAdmin(rabbitTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        Exchange exchange = <span class=\"keyword\">new</span> DirectExchange(DIRECT_EXCHANGE, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        rabbitAdmin.declareExchange(exchange);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitAdmin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生产者发送消息\"><a href=\"#生产者发送消息\" class=\"headerlink\" title=\"生产者发送消息\"></a>生产者发送消息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = &#123;Application.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">directTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：指定交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：指定路由键（因为交换机类型是direct，消息路由键必须和绑定路由一致）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消息</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(RabbitConfig.DIRECT_EXCHANGE, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-1\"><a href=\"#消费者-1\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"监听类（监听指定队列，消费消息）-1\"><a href=\"#监听类（监听指定队列，消费消息）-1\" class=\"headerlink\" title=\"监听类（监听指定队列，消费消息）\"></a>监听类（监听指定队列，消费消息）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 监听指定的队列，进行消费消息</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过 <span class=\"doctag\">@RabbitListener</span> 进行：声明队列，声明队列交换机的绑定关系，并且指定绑定key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;123&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果-1\"><a href=\"#执行，查看结果-1\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。<br>因为当前是 direct 交换机，如果将消息的路由键改成456 ，那么消费者就不会有消息。</p>\n<h1 id=\"RabbitListener-使用\"><a href=\"#RabbitListener-使用\" class=\"headerlink\" title=\"@RabbitListener 使用\"></a>@RabbitListener 使用</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在 SpringBoot 环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你 90% 以上的业务开发需求。<br>下面我们来看一下@RabbitListener的最最常用使用姿势。</p>\n<p>前提：<br>对于消费者而言其实是不需要管理 exchange 的创建/销毁的，它是由发送者定义的；<br>一般来讲，消费者更关注的是自己的 queue，包括定义 queue 并与 exchange 绑定，而这一套过程是可以直接通过 rabbitmq 的控制台操作的哦。</p>\n<h2 id=\"queue，exchange-binding-已存在\"><a href=\"#queue，exchange-binding-已存在\" class=\"headerlink\" title=\"queue，exchange, binding 已存在\"></a>queue，exchange, binding 已存在</h2><p>所以实际开发过程中，exchange 和 queue 以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；<br>在这种场景下，消费数据，可以说非常非常简单了，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列，队列与交换机绑定关系已经存在时，直接指定队列名进行消费</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;boot.queue.direct&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"queue-不存在\"><a href=\"#queue-不存在\" class=\"headerlink\" title=\"queue 不存在\"></a>queue 不存在</h2><p>不存在 Queue 的情况下，就需要我们来主动创建 Queue，并建立与 Exchange 的绑定关系，下面给出@RabbitListener的推荐使用姿势：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列不存在时，需要创建一个队列，并且与exchange绑定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;123&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！以上，就是在队列不存在时的使用姿势，看起来也不复杂。</p>\n<p>注意@QueueBinding注解的三个属性：</p>\n<ul>\n<li>value: @Queue 注解，用于声明队列，value 为 queueName, durable 表示队列是否持久化, autoDelete 表示没有消费者之后队列是否自动删除</li>\n<li>exchange: @Exchange 注解，用于声明 exchange， type 指定消息投递策略，我们这里用的 direct 方式</li>\n<li>key: 在 direct 方式下，这个就是我们熟知的 routingKey</li>\n</ul>\n<h2 id=\"ack（消息应答）\"><a href=\"#ack（消息应答）\" class=\"headerlink\" title=\"ack（消息应答）\"></a>ack（消息应答）</h2><p>rabbitmq 的核心知识点学习过程中，我们知道有一个消息应答机制，主要是针对消费者的。<br>默认情况下，消息应答机制是自动ack，我们可以通过 ack 方式(noack, auto, manual)，进行修改，可以如下处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置为手动ack应答，在代码中显式进行ack应答</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;123&quot;), ackMode = &quot;MANUAL&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这里使用了Channel和DeliveryTag：</p>\n<ul>\n<li>Channel：mq 和 consumer 之间的信道，通过它来 ack/nak</li>\n<li>DeliveryTag：消息的唯一标识，用于 mq 辨别是哪个消息被 ack/nak 了</li>\n</ul>\n<p>当我们正确消费时，通过调用 <code>basicAck</code> 方法即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</span></span><br><span class=\"line\">channel.basicAck(deliveryTag, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 <code>basicNack</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于否定确认，第三个参数true，表示这个消息会重新进入队列</span></span><br><span class=\"line\">channel.basicNack(deliveryTag, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当我们消费失败，想直接丢弃这个消息，可以使用 <code>basicReject</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于否定确认，直接丢弃当前消息，不再入队</span></span><br><span class=\"line\">channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发消费\"><a href=\"#并发消费\" class=\"headerlink\" title=\"并发消费\"></a>并发消费</h2><p>当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据.</p>\n<p>要支持并行消费，如下设置即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;123&quot;), concurrency = &quot;4&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意注解中的concurrency = “4”属性，表示固定 4 个消费者；</p>\n<h2 id=\"Payload-与-Headers\"><a href=\"#Payload-与-Headers\" class=\"headerlink\" title=\"@Payload 与 @Headers\"></a>@Payload 与 @Headers</h2><p>使用 @Payload 和 @Headers 注解可以消息中的 body 与 headers 信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, <span class=\"meta\">@Headers</span> Map&lt;String, Object&gt; headers)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;headers：&quot;</span> + headers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以获取单个 Header 属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, <span class=\"meta\">@Headers</span> String token)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;token：&quot;</span> + token);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitListener-和-RabbitHandler-搭配使用\"><a href=\"#RabbitListener-和-RabbitHandler-搭配使用\" class=\"headerlink\" title=\"@RabbitListener 和 @RabbitHandler 搭配使用\"></a>@RabbitListener 和 @RabbitHandler 搭配使用</h2><p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用<br>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@RabbitListener(queues = &quot;consumer_queue&quot;)</span><br><span class=\"line\">public class Receiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RabbitHandler</span><br><span class=\"line\">    public void processMessage1(String message) &#123;</span><br><span class=\"line\">        System.out.println(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RabbitHandler</span><br><span class=\"line\">    public void processMessage2(byte[] message) &#123;</span><br><span class=\"line\">        System.out.println(new String(message));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"RabbitAdmin-使用\"><a href=\"#RabbitAdmin-使用\" class=\"headerlink\" title=\"RabbitAdmin 使用\"></a>RabbitAdmin 使用</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitAdmin主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等。</p>\n<h2 id=\"创建RabbitAdmin\"><a href=\"#创建RabbitAdmin\" class=\"headerlink\" title=\"创建RabbitAdmin\"></a>创建RabbitAdmin</h2><p>查看源码发现，要创建RabbitAdmin，需要传递一个 ConnectionFactory 或 RabbitTemplate 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct an instance using the provided &#123;<span class=\"doctag\">@link</span> ConnectionFactory&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> connectionFactory the connection factory - must not be null.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitAdmin</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class=\"line\">\tAssert.notNull(connectionFactory, <span class=\"string\">&quot;ConnectionFactory must not be null&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.connectionFactory = connectionFactory;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct an instance using the provided &#123;<span class=\"doctag\">@link</span> RabbitTemplate&#125;. Use this</span></span><br><span class=\"line\"><span class=\"comment\"> * constructor when, for example, you want the admin operations to be performed within</span></span><br><span class=\"line\"><span class=\"comment\"> * the scope of the provided template&#x27;s &#123;<span class=\"doctag\">@code</span> invoke()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> rabbitTemplate the template - must not be null and must have a connection</span></span><br><span class=\"line\"><span class=\"comment\"> * factory.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitAdmin</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class=\"line\">\tAssert.notNull(rabbitTemplate, <span class=\"string\">&quot;RabbitTemplate must not be null&quot;</span>);</span><br><span class=\"line\">\tAssert.notNull(rabbitTemplate.getConnectionFactory(), <span class=\"string\">&quot;RabbitTemplate&#x27;s ConnectionFactory must not be null&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.connectionFactory = rabbitTemplate.getConnectionFactory();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin创建交换机\"><a href=\"#RabbitAdmin创建交换机\" class=\"headerlink\" title=\"RabbitAdmin创建交换机\"></a>RabbitAdmin创建交换机</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建交换机，无则创建有则跳过，存在交换机但参数不一致则报错</span></span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;test.exchange.fanout&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;test.exchange.direct&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin创建队列\"><a href=\"#RabbitAdmin创建队列\" class=\"headerlink\" title=\"RabbitAdmin创建队列\"></a>RabbitAdmin创建队列</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\">rabbitAdmin.declareQueue(<span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;test.queue&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin绑定交换机与队列\"><a href=\"#RabbitAdmin绑定交换机与队列\" class=\"headerlink\" title=\"RabbitAdmin绑定交换机与队列\"></a>RabbitAdmin绑定交换机与队列</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//绑定队列</span></span><br><span class=\"line\">rabbitAdmin.declareBinding(<span class=\"keyword\">new</span> Binding(<span class=\"string\">&quot;test.queue&quot;</span>, Binding.DestinationType.QUEUE, <span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"string\">&quot;#&quot;</span>, <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;()));        </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin发送消息\"><a href=\"#RabbitAdmin发送消息\" class=\"headerlink\" title=\"RabbitAdmin发送消息\"></a>RabbitAdmin发送消息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">rabbitAdmin.getRabbitTemplate().convertAndSend(<span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;abc123&quot;</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"SpringBoot-整合\"><a href=\"#SpringBoot-整合\" class=\"headerlink\" title=\"SpringBoot 整合\"></a>SpringBoot 整合</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>rabbitmq 版本：3.8.8</li>\n<li>springboot 版本：2.2.4.RELEASE</li>\n</ul>","more":"<h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"新建maven项目，导入依赖\"><a href=\"#新建maven项目，导入依赖\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置类\"><a href=\"#编写配置类\" class=\"headerlink\" title=\"编写配置类\"></a>编写配置类</h4><p>配置类：（声明交换机，队列，绑定关系）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class RabbitConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final static String FANOUT_EXCHANGE = &quot;boot.exchange.fanout&quot;;</span><br><span class=\"line\">    public final static String FANOUT_QUEUE = &quot;boot.queue.fanout&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 1.声明交换机（交换机类型为fanout）</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Exchange fanoutExchange() &#123;</span><br><span class=\"line\">        return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE).durable(true).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2.声明队列</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Queue fanoutQueue() &#123;</span><br><span class=\"line\">        return QueueBuilder.durable(FANOUT_QUEUE).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 3.队列和交换机绑定</span><br><span class=\"line\">     * 需要知道哪个队列</span><br><span class=\"line\">     * 需要知道哪个交换机</span><br><span class=\"line\">     * 需要知道路由键（因为交换机类型是fanout，所以路由键为空）</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Binding fanoutBinding() &#123;</span><br><span class=\"line\">        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange()).with(&quot;&quot;).noargs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码\"><a href=\"#发送消息代码\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = &#123;Application.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">directTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：指定交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：指定路由键（因为交换机类型是fanout，所以路由键为空，乱写也无所谓）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消息</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(RabbitConfig.FANOUT_EXCHANGE, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"新建maven项目，导入依赖-1\"><a href=\"#新建maven项目，导入依赖-1\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><p>pom.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"监听类（监听指定队列，消费消息）\"><a href=\"#监听类（监听指定队列，消费消息）\" class=\"headerlink\" title=\"监听类（监听指定队列，消费消息）\"></a>监听类（监听指定队列，消费消息）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要被spring容器扫描到</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听指定的队列，进行消费消息</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;boot.queue.fanout&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果\"><a href=\"#执行，查看结果\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>使用 springboot 整合 rabbitmq，将组件提供配置方式声明，简化编码</li>\n<li>生产者使用 spring 提供的 rabbitTemplate 发送消息</li>\n<li>消费者使用 spring 提供的 @RabbitListener 注解监听队列，消费消息</li>\n</ul>\n<h2 id=\"订阅模式-Direct（rabbitAdmin-与-注解方式）\"><a href=\"#订阅模式-Direct（rabbitAdmin-与-注解方式）\" class=\"headerlink\" title=\"订阅模式-Direct（rabbitAdmin 与 注解方式）\"></a>订阅模式-Direct（rabbitAdmin 与 注解方式）</h2><h3 id=\"生产者-1\"><a href=\"#生产者-1\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String DIRECT_EXCHANGE = <span class=\"string\">&quot;boot.exchange.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String Direct_QUEUE = <span class=\"string\">&quot;boot.queue.direct&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建rabbitAdmin，并且通过rabbitAdmin创建交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RabbitAdmin <span class=\"title\">rabbitAdmin</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class=\"line\">        RabbitAdmin rabbitAdmin = <span class=\"keyword\">new</span> RabbitAdmin(rabbitTemplate);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        Exchange exchange = <span class=\"keyword\">new</span> DirectExchange(DIRECT_EXCHANGE, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        rabbitAdmin.declareExchange(exchange);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitAdmin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生产者发送消息\"><a href=\"#生产者发送消息\" class=\"headerlink\" title=\"生产者发送消息\"></a>生产者发送消息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = &#123;Application.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">directTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：指定交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：指定路由键（因为交换机类型是direct，消息路由键必须和绑定路由一致）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消息</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(RabbitConfig.DIRECT_EXCHANGE, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-1\"><a href=\"#消费者-1\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"监听类（监听指定队列，消费消息）-1\"><a href=\"#监听类（监听指定队列，消费消息）-1\" class=\"headerlink\" title=\"监听类（监听指定队列，消费消息）\"></a>监听类（监听指定队列，消费消息）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 监听指定的队列，进行消费消息</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过 <span class=\"doctag\">@RabbitListener</span> 进行：声明队列，声明队列交换机的绑定关系，并且指定绑定key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;123&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果-1\"><a href=\"#执行，查看结果-1\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>这里不截图了，启动消费者进行监听，生产者发送消息后，消费者成功消费到消息。<br>因为当前是 direct 交换机，如果将消息的路由键改成456 ，那么消费者就不会有消息。</p>\n<h1 id=\"RabbitListener-使用\"><a href=\"#RabbitListener-使用\" class=\"headerlink\" title=\"@RabbitListener 使用\"></a>@RabbitListener 使用</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在 SpringBoot 环境下，消费可以说比较简单了，借助@RabbitListener注解，基本上可以满足你 90% 以上的业务开发需求。<br>下面我们来看一下@RabbitListener的最最常用使用姿势。</p>\n<p>前提：<br>对于消费者而言其实是不需要管理 exchange 的创建/销毁的，它是由发送者定义的；<br>一般来讲，消费者更关注的是自己的 queue，包括定义 queue 并与 exchange 绑定，而这一套过程是可以直接通过 rabbitmq 的控制台操作的哦。</p>\n<h2 id=\"queue，exchange-binding-已存在\"><a href=\"#queue，exchange-binding-已存在\" class=\"headerlink\" title=\"queue，exchange, binding 已存在\"></a>queue，exchange, binding 已存在</h2><p>所以实际开发过程中，exchange 和 queue 以及对应的绑定关系已经存在的可能性是很高的，并不需要再代码中额外处理；<br>在这种场景下，消费数据，可以说非常非常简单了，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列，队列与交换机绑定关系已经存在时，直接指定队列名进行消费</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;boot.queue.direct&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"queue-不存在\"><a href=\"#queue-不存在\" class=\"headerlink\" title=\"queue 不存在\"></a>queue 不存在</h2><p>不存在 Queue 的情况下，就需要我们来主动创建 Queue，并建立与 Exchange 的绑定关系，下面给出@RabbitListener的推荐使用姿势：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列不存在时，需要创建一个队列，并且与exchange绑定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;123&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个注解，内部声明了队列，并建立绑定关系，就是这么神奇！！！以上，就是在队列不存在时的使用姿势，看起来也不复杂。</p>\n<p>注意@QueueBinding注解的三个属性：</p>\n<ul>\n<li>value: @Queue 注解，用于声明队列，value 为 queueName, durable 表示队列是否持久化, autoDelete 表示没有消费者之后队列是否自动删除</li>\n<li>exchange: @Exchange 注解，用于声明 exchange， type 指定消息投递策略，我们这里用的 direct 方式</li>\n<li>key: 在 direct 方式下，这个就是我们熟知的 routingKey</li>\n</ul>\n<h2 id=\"ack（消息应答）\"><a href=\"#ack（消息应答）\" class=\"headerlink\" title=\"ack（消息应答）\"></a>ack（消息应答）</h2><p>rabbitmq 的核心知识点学习过程中，我们知道有一个消息应答机制，主要是针对消费者的。<br>默认情况下，消息应答机制是自动ack，我们可以通过 ack 方式(noack, auto, manual)，进行修改，可以如下处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 设置为手动ack应答，在代码中显式进行ack应答</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;123&quot;), ackMode = &quot;MANUAL&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">    <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这里使用了Channel和DeliveryTag：</p>\n<ul>\n<li>Channel：mq 和 consumer 之间的信道，通过它来 ack/nak</li>\n<li>DeliveryTag：消息的唯一标识，用于 mq 辨别是哪个消息被 ack/nak 了</li>\n</ul>\n<p>当我们正确消费时，通过调用 <code>basicAck</code> 方法即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</span></span><br><span class=\"line\">channel.basicAck(deliveryTag, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当我们消费失败，需要将消息重新塞入队列，等待重新消费时，可以使用 <code>basicNack</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于否定确认，第三个参数true，表示这个消息会重新进入队列</span></span><br><span class=\"line\">channel.basicNack(deliveryTag, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当我们消费失败，想直接丢弃这个消息，可以使用 <code>basicReject</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于否定确认，直接丢弃当前消息，不再入队</span></span><br><span class=\"line\">channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发消费\"><a href=\"#并发消费\" class=\"headerlink\" title=\"并发消费\"></a>并发消费</h2><p>当消息很多，一个消费者吭哧吭哧的消费太慢，但是我的机器性能又杠杠的，这个时候我就希望并行消费，相当于同时有多个消费者来处理数据.</p>\n<p>要支持并行消费，如下设置即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;boot.queue.direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(name = &quot;boot.exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;123&quot;), concurrency = &quot;4&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意注解中的concurrency = “4”属性，表示固定 4 个消费者；</p>\n<h2 id=\"Payload-与-Headers\"><a href=\"#Payload-与-Headers\" class=\"headerlink\" title=\"@Payload 与 @Headers\"></a>@Payload 与 @Headers</h2><p>使用 @Payload 和 @Headers 注解可以消息中的 body 与 headers 信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, <span class=\"meta\">@Headers</span> Map&lt;String, Object&gt; headers)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;headers：&quot;</span> + headers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以获取单个 Header 属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listener</span><span class=\"params\">(<span class=\"meta\">@Payload</span> String body, <span class=\"meta\">@Headers</span> String token)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;body：&quot;</span> + body);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;token：&quot;</span> + token);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitListener-和-RabbitHandler-搭配使用\"><a href=\"#RabbitListener-和-RabbitHandler-搭配使用\" class=\"headerlink\" title=\"@RabbitListener 和 @RabbitHandler 搭配使用\"></a>@RabbitListener 和 @RabbitHandler 搭配使用</h2><p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用<br>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@RabbitListener(queues = &quot;consumer_queue&quot;)</span><br><span class=\"line\">public class Receiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RabbitHandler</span><br><span class=\"line\">    public void processMessage1(String message) &#123;</span><br><span class=\"line\">        System.out.println(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RabbitHandler</span><br><span class=\"line\">    public void processMessage2(byte[] message) &#123;</span><br><span class=\"line\">        System.out.println(new String(message));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"RabbitAdmin-使用\"><a href=\"#RabbitAdmin-使用\" class=\"headerlink\" title=\"RabbitAdmin 使用\"></a>RabbitAdmin 使用</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitAdmin主要用于在Java代码中对理队和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息等。</p>\n<h2 id=\"创建RabbitAdmin\"><a href=\"#创建RabbitAdmin\" class=\"headerlink\" title=\"创建RabbitAdmin\"></a>创建RabbitAdmin</h2><p>查看源码发现，要创建RabbitAdmin，需要传递一个 ConnectionFactory 或 RabbitTemplate 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct an instance using the provided &#123;<span class=\"doctag\">@link</span> ConnectionFactory&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> connectionFactory the connection factory - must not be null.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitAdmin</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class=\"line\">\tAssert.notNull(connectionFactory, <span class=\"string\">&quot;ConnectionFactory must not be null&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.connectionFactory = connectionFactory;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct an instance using the provided &#123;<span class=\"doctag\">@link</span> RabbitTemplate&#125;. Use this</span></span><br><span class=\"line\"><span class=\"comment\"> * constructor when, for example, you want the admin operations to be performed within</span></span><br><span class=\"line\"><span class=\"comment\"> * the scope of the provided template&#x27;s &#123;<span class=\"doctag\">@code</span> invoke()&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> rabbitTemplate the template - must not be null and must have a connection</span></span><br><span class=\"line\"><span class=\"comment\"> * factory.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitAdmin</span><span class=\"params\">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class=\"line\">\tAssert.notNull(rabbitTemplate, <span class=\"string\">&quot;RabbitTemplate must not be null&quot;</span>);</span><br><span class=\"line\">\tAssert.notNull(rabbitTemplate.getConnectionFactory(), <span class=\"string\">&quot;RabbitTemplate&#x27;s ConnectionFactory must not be null&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.connectionFactory = rabbitTemplate.getConnectionFactory();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin创建交换机\"><a href=\"#RabbitAdmin创建交换机\" class=\"headerlink\" title=\"RabbitAdmin创建交换机\"></a>RabbitAdmin创建交换机</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建交换机，无则创建有则跳过，存在交换机但参数不一致则报错</span></span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;test.exchange.fanout&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;test.exchange.direct&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">rabbitAdmin.declareExchange(<span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin创建队列\"><a href=\"#RabbitAdmin创建队列\" class=\"headerlink\" title=\"RabbitAdmin创建队列\"></a>RabbitAdmin创建队列</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\">rabbitAdmin.declareQueue(<span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;test.queue&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin绑定交换机与队列\"><a href=\"#RabbitAdmin绑定交换机与队列\" class=\"headerlink\" title=\"RabbitAdmin绑定交换机与队列\"></a>RabbitAdmin绑定交换机与队列</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//绑定队列</span></span><br><span class=\"line\">rabbitAdmin.declareBinding(<span class=\"keyword\">new</span> Binding(<span class=\"string\">&quot;test.queue&quot;</span>, Binding.DestinationType.QUEUE, <span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"string\">&quot;#&quot;</span>, <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;()));        </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RabbitAdmin发送消息\"><a href=\"#RabbitAdmin发送消息\" class=\"headerlink\" title=\"RabbitAdmin发送消息\"></a>RabbitAdmin发送消息</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">rabbitAdmin.getRabbitTemplate().convertAndSend(<span class=\"string\">&quot;test.exchange.topic&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;abc123&quot;</span>);</span><br></pre></td></tr></table></figure>"},{"title":"RabbitMQ-Spring整合","date":"2021-09-09T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Spring 整合\n\n## 环境准备\n\n- rabbitmq 版本：3.8.8\n- spring 版本：5.1.7.RELEASE\n- spring-amqp 版本：2.1.8.RELEASE\n\n<!-- more -->\n\n## 简单消息模式\n\n### 生产者\n\n#### 新建maven项目，导入依赖\n\n```xml\n<dependencies>\n    <!-- spring上下文 & spring amqp -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit</artifactId>\n        <version>2.1.8.RELEASE</version>\n    </dependency>\n\n    <!-- test -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.8.0</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### 编写配置文件\n\nrabbitmq.properties（属性类）\n```properties\n# rabbitmq 基本配置\nrabbitmq.host=106.52.180.14\nrabbitmq.port=5672\nrabbitmq.username=admin\nrabbitmq.password=123\nrabbitmq.virtual-host=/\n```\n\nspring-rabbitmq-producer.xml（spring配置类）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!--\n        定义持久化队列，不存在则自动创建；不绑定到交换机则绑定到默认交换机\n        默认交换机类型为direct，名字为：\"\"，路由键为队列的名称\n    -->\n    <rabbit:queue id=\"spring_queue\" name=\"spring_queue\" auto-declare=\"true\"/>\n\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void hello() {\n        // 给spring_queue发送消息，当前队列绑定到默认交换机，路由键为队列名\n        rabbitTemplate.convertAndSend(\"spring_queue\", \"hello spring\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 新建maven项目，导入依赖\n\n```xml\n<dependencies>\n    <!-- spring上下文 & spring amqp -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit</artifactId>\n        <version>2.1.8.RELEASE</version>\n    </dependency>\n\n    <!-- test -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.8.0</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### 编写配置文件\n\nrabbitmq.properties（属性文件）\n```properties\n# rabbitmq 基本配置\nrabbitmq.host=106.52.180.14\nrabbitmq.port=5672\nrabbitmq.username=admin\nrabbitmq.password=123\nrabbitmq.virtual-host=/\n```\n\nspring-rabbitmq-consumer.xml（spring配置文件）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"springQueueListener\" queue-names=\"spring_queue\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"springQueueListener\" class=\"com.oyr.rabbit.spring.listener.SpringQueueListener\"/>\n</beans>\n```\n\n#### 消费消息代码\n\n```java\n// 监听器对象\npublic class SpringQueueListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。\n当前模式是简单模式，声明一个队列，绑定到默认交换机上，由于是默认交换机（Direct类型），所以绑定的路由键是队列名，发送消息路由键需要和绑定路由键一致就可以成功消费消息。\n\n## 订阅模式-Fanout\n\n### 生产者\n\n#### 修改配置\n\nspring-rabbitmq-producer.xml（spring配置）\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有绑定队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->\n    <!--定义广播交换机中的持久化队列，不存在则自动创建-->\n    <rabbit:queue id=\"spring_fanout_queue_1\" name=\"spring_fanout_queue_1\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_fanout_queue_2\" name=\"spring_fanout_queue_2\" auto-declare=\"true\"/>\n\n    <!--定义广播类型交换机；并绑定上述两个队列-->\n    <rabbit:fanout-exchange id=\"spring_fanout_exchange\" name=\"spring_fanout_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <rabbit:binding queue=\"spring_fanout_queue_1\"/>\n            <rabbit:binding queue=\"spring_fanout_queue_2\"/>\n        </rabbit:bindings>\n    </rabbit:fanout-exchange>\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void fanoutTest() {\n        // 给fanout交换机发送消息，所有绑定的队列都能接受到消息\n        rabbitTemplate.convertAndSend(\"spring_fanout_exchange\", \"\", \"spring fanout\");\n    }\n}\n```\n\n### 消费者\n\n#### 修改配置\n\nspring-rabbitmq-consumer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"fanoutListener1\" queue-names=\"spring_fanout_queue_1\"/>\n        <rabbit:listener ref=\"fanoutListener2\" queue-names=\"spring_fanout_queue_2\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"fanoutListener1\" class=\"com.oyr.rabbit.spring.listener.FanoutListener1\"/>\n    <bean id=\"fanoutListener2\" class=\"com.oyr.rabbit.spring.listener.FanoutListener2\"/>\n\n</beans>\n```\n\n#### 消息消费代码\n\nFanoutListener1：\n```java\npublic class FanoutListener1 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"FanoutListener1消费消息：\" + message);\n    }\n\n}\n```\n\nFanoutListener2：\n```java\npublic class FanoutListener2 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"FanoutListener2消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。\n当前模式是订阅模式-Fanout，声明一个fanout类型的交换机，只要队列绑定到该交换机上，生产者发送消息后都可以消费到，fanout类型交换机忽略了路由键。\n\n## 订阅模式-Topic\n\n### 生产者\n\n#### 修改配置\n\nspring-rabbitmq-producer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~主题；*匹配一个单词，#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->\n    <!--定义广播交换机中的持久化队列，不存在则自动创建-->\n    <rabbit:queue id=\"spring_topic_queue_star\" name=\"spring_topic_queue_star\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_topic_queue_well\" name=\"spring_topic_queue_well\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_topic_queue_well2\" name=\"spring_topic_queue_well2\" auto-declare=\"true\"/>\n\n    <rabbit:topic-exchange id=\"spring_topic_exchange\" name=\"spring_topic_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"heima.*\" queue=\"spring_topic_queue_star\"/>\n            <rabbit:binding pattern=\"heima.#\" queue=\"spring_topic_queue_well\"/>\n            <rabbit:binding pattern=\"itcast.#\" queue=\"spring_topic_queue_well2\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void topicTest() {\n        // 给topic交换机发送消息，路由键进行模糊匹配\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.oyr\", \"heima.oyr\");\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.laihong.nan\", \"heima.laihong.nan\");\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"itcast.oyr\", \"itcast.oyr\");\n    }\n}\n```\n\n### 消费者\n\n#### 修改配置\n\nspring-rabbitmq-consumer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"topicListenerStar\" queue-names=\"spring_topic_queue_star\"/>\n        <rabbit:listener ref=\"topicListenerWell\" queue-names=\"spring_topic_queue_well\"/>\n        <rabbit:listener ref=\"topicListenerWell2\" queue-names=\"spring_topic_queue_well2\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"topicListenerStar\" class=\"com.oyr.rabbit.spring.listener.TopicListenerStar\"/>\n    <bean id=\"topicListenerWell\" class=\"com.oyr.rabbit.spring.listener.TopicListenerWell\"/>\n    <bean id=\"topicListenerWell2\" class=\"com.oyr.rabbit.spring.listener.TopicListenerWell2\"/>\n\n</beans>\n```\n\n#### 消息消费代码\n\nTopicListenerStar：\n```java\npublic class TopicListenerStar implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerStar消费消息：\" + message);\n    }\n\n}\n```\n\nTopicListenerWell：\n```java\npublic class TopicListenerWell implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerWell消费消息：\" + message);\n    }\n\n}\n```\n\nTopicListenerWell2：\n```java\npublic class TopicListenerWell2 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerWell2消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。  \nspring_topic_queue_star队列有一条信息；spring_topic_queue_well队列有两条信息；spring_topic_queue_well2有一条消息；  \n当前模式是订阅模式-Topic，声明一个topic类型的交换机，将队列绑定到该交换机上，绑定的路由键可以有约定模糊匹配功能，只需要跟消息路由键模糊匹配上就可以成功消费消息。\n\n## 配置详解\n\n### rabbitmq 链接相关\n\n```xml\n<!--\n    定义rabbitmq connectionFactory\n    id：bean id\n    host：mq服务地址\n    port：mq服务端口\n    username：用户名\n    password：密码\n    -->\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\"/>\n```\n\n### rabbitAdmin\n\n```xml\n<!--\n    定义RabbitAdmin（管理交换机、队列）\n-->\n<rabbit:admin connection-factory=\"connectionFactory\"/>\n```\n\n### rabbitTemplate\n\n```xml\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n```\n\n### 声明队列\n\n```xml\n    <!--\n        声明队列，不绑定到交换机则绑定到默认交换机\n        id：bean id\n        name：队列名称\n        auto-declare：不存在自动创建\n        auto-delete：是否自动删除，如果最后一个消费者连接断开是否自动删除\n        durable：持久化\n    -->\n    <rabbit:queue id=\"spring_queue\" name=\"spring_queue\" durable=\"true\" auto-delete=\"false\" exclusive=\"false\" auto-declare=\"true\"/>\n```\n\n### 声明监听器\n\n```xml\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n     -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"spring_topic_queue_star\" ref=\"topicListenerStar\"/>\n    </rabbit:listener-container>\n```\n\n### 声明交换机\n\n#### 声明Fanout交换机\n\n```xml\n    <!--\n        声明fanout交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:fanout-exchange id=\"fanoutExchange\" name=\"fanout_exchange\" auto-declare=\"true\" durable=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系（由于是广播模式，所以没有路由键）\n                queue：队列名\n             -->\n            <rabbit:binding queue=\"spring_queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:fanout-exchange>\n```\n\n#### 声明Direct交换机\n\n```xml\n    <!--\n        声明direct交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:direct-exchange id=\"directExchange\" name=\"direct_exchange\" auto-declare=\"true\" durable=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系\n                queue：队列名\n                key：绑定路由键\n             -->\n            <rabbit:binding queue=\"spring_queue\" key=\"spring_queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:direct-exchange>\n```\n\n#### 声明Topic交换机\n\n```xml\n    <!--\n        声明topic交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:topic-exchange id=\"spring_topic_exchange\" name=\"spring_topic_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系\n                queue：队列名\n                pattern：模糊路由键\n             -->\n            <rabbit:binding queue=\"spring_topic_queue_star\" pattern=\"heima.*\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n```","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-Spring整合.md","raw":"---\ntitle: RabbitMQ-Spring整合\ndate: 2021-09-10 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n# Spring 整合\n\n## 环境准备\n\n- rabbitmq 版本：3.8.8\n- spring 版本：5.1.7.RELEASE\n- spring-amqp 版本：2.1.8.RELEASE\n\n<!-- more -->\n\n## 简单消息模式\n\n### 生产者\n\n#### 新建maven项目，导入依赖\n\n```xml\n<dependencies>\n    <!-- spring上下文 & spring amqp -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit</artifactId>\n        <version>2.1.8.RELEASE</version>\n    </dependency>\n\n    <!-- test -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.8.0</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### 编写配置文件\n\nrabbitmq.properties（属性类）\n```properties\n# rabbitmq 基本配置\nrabbitmq.host=106.52.180.14\nrabbitmq.port=5672\nrabbitmq.username=admin\nrabbitmq.password=123\nrabbitmq.virtual-host=/\n```\n\nspring-rabbitmq-producer.xml（spring配置类）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!--\n        定义持久化队列，不存在则自动创建；不绑定到交换机则绑定到默认交换机\n        默认交换机类型为direct，名字为：\"\"，路由键为队列的名称\n    -->\n    <rabbit:queue id=\"spring_queue\" name=\"spring_queue\" auto-declare=\"true\"/>\n\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void hello() {\n        // 给spring_queue发送消息，当前队列绑定到默认交换机，路由键为队列名\n        rabbitTemplate.convertAndSend(\"spring_queue\", \"hello spring\");\n    }\n\n}\n```\n\n### 消费者\n\n#### 新建maven项目，导入依赖\n\n```xml\n<dependencies>\n    <!-- spring上下文 & spring amqp -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.amqp</groupId>\n        <artifactId>spring-rabbit</artifactId>\n        <version>2.1.8.RELEASE</version>\n    </dependency>\n\n    <!-- test -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.1.7.RELEASE</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.8.0</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### 编写配置文件\n\nrabbitmq.properties（属性文件）\n```properties\n# rabbitmq 基本配置\nrabbitmq.host=106.52.180.14\nrabbitmq.port=5672\nrabbitmq.username=admin\nrabbitmq.password=123\nrabbitmq.virtual-host=/\n```\n\nspring-rabbitmq-consumer.xml（spring配置文件）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"springQueueListener\" queue-names=\"spring_queue\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"springQueueListener\" class=\"com.oyr.rabbit.spring.listener.SpringQueueListener\"/>\n</beans>\n```\n\n#### 消费消息代码\n\n```java\n// 监听器对象\npublic class SpringQueueListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。\n当前模式是简单模式，声明一个队列，绑定到默认交换机上，由于是默认交换机（Direct类型），所以绑定的路由键是队列名，发送消息路由键需要和绑定路由键一致就可以成功消费消息。\n\n## 订阅模式-Fanout\n\n### 生产者\n\n#### 修改配置\n\nspring-rabbitmq-producer.xml（spring配置）\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有绑定队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->\n    <!--定义广播交换机中的持久化队列，不存在则自动创建-->\n    <rabbit:queue id=\"spring_fanout_queue_1\" name=\"spring_fanout_queue_1\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_fanout_queue_2\" name=\"spring_fanout_queue_2\" auto-declare=\"true\"/>\n\n    <!--定义广播类型交换机；并绑定上述两个队列-->\n    <rabbit:fanout-exchange id=\"spring_fanout_exchange\" name=\"spring_fanout_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <rabbit:binding queue=\"spring_fanout_queue_1\"/>\n            <rabbit:binding queue=\"spring_fanout_queue_2\"/>\n        </rabbit:bindings>\n    </rabbit:fanout-exchange>\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void fanoutTest() {\n        // 给fanout交换机发送消息，所有绑定的队列都能接受到消息\n        rabbitTemplate.convertAndSend(\"spring_fanout_exchange\", \"\", \"spring fanout\");\n    }\n}\n```\n\n### 消费者\n\n#### 修改配置\n\nspring-rabbitmq-consumer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"fanoutListener1\" queue-names=\"spring_fanout_queue_1\"/>\n        <rabbit:listener ref=\"fanoutListener2\" queue-names=\"spring_fanout_queue_2\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"fanoutListener1\" class=\"com.oyr.rabbit.spring.listener.FanoutListener1\"/>\n    <bean id=\"fanoutListener2\" class=\"com.oyr.rabbit.spring.listener.FanoutListener2\"/>\n\n</beans>\n```\n\n#### 消息消费代码\n\nFanoutListener1：\n```java\npublic class FanoutListener1 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"FanoutListener1消费消息：\" + message);\n    }\n\n}\n```\n\nFanoutListener2：\n```java\npublic class FanoutListener2 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"FanoutListener2消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。\n当前模式是订阅模式-Fanout，声明一个fanout类型的交换机，只要队列绑定到该交换机上，生产者发送消息后都可以消费到，fanout类型交换机忽略了路由键。\n\n## 订阅模式-Topic\n\n### 生产者\n\n#### 修改配置\n\nspring-rabbitmq-producer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~主题；*匹配一个单词，#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->\n    <!--定义广播交换机中的持久化队列，不存在则自动创建-->\n    <rabbit:queue id=\"spring_topic_queue_star\" name=\"spring_topic_queue_star\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_topic_queue_well\" name=\"spring_topic_queue_well\" auto-declare=\"true\"/>\n    <rabbit:queue id=\"spring_topic_queue_well2\" name=\"spring_topic_queue_well2\" auto-declare=\"true\"/>\n\n    <rabbit:topic-exchange id=\"spring_topic_exchange\" name=\"spring_topic_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"heima.*\" queue=\"spring_topic_queue_star\"/>\n            <rabbit:binding pattern=\"heima.#\" queue=\"spring_topic_queue_well\"/>\n            <rabbit:binding pattern=\"itcast.#\" queue=\"spring_topic_queue_well2\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n</beans>\n```\n\n#### 发送消息代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void topicTest() {\n        // 给topic交换机发送消息，路由键进行模糊匹配\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.oyr\", \"heima.oyr\");\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.laihong.nan\", \"heima.laihong.nan\");\n        rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"itcast.oyr\", \"itcast.oyr\");\n    }\n}\n```\n\n### 消费者\n\n#### 修改配置\n\nspring-rabbitmq-consumer.xml（spring配置）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!-- 监听器容器 -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"topicListenerStar\" queue-names=\"spring_topic_queue_star\"/>\n        <rabbit:listener ref=\"topicListenerWell\" queue-names=\"spring_topic_queue_well\"/>\n        <rabbit:listener ref=\"topicListenerWell2\" queue-names=\"spring_topic_queue_well2\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"topicListenerStar\" class=\"com.oyr.rabbit.spring.listener.TopicListenerStar\"/>\n    <bean id=\"topicListenerWell\" class=\"com.oyr.rabbit.spring.listener.TopicListenerWell\"/>\n    <bean id=\"topicListenerWell2\" class=\"com.oyr.rabbit.spring.listener.TopicListenerWell2\"/>\n\n</beans>\n```\n\n#### 消息消费代码\n\nTopicListenerStar：\n```java\npublic class TopicListenerStar implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerStar消费消息：\" + message);\n    }\n\n}\n```\n\nTopicListenerWell：\n```java\npublic class TopicListenerWell implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerWell消费消息：\" + message);\n    }\n\n}\n```\n\nTopicListenerWell2：\n```java\npublic class TopicListenerWell2 implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"TopicListenerWell2消费消息：\" + message);\n    }\n\n}\n```\n\n### 执行代码，查看结果\n\n生产者发送消息，消费者成功消费消息。  \nspring_topic_queue_star队列有一条信息；spring_topic_queue_well队列有两条信息；spring_topic_queue_well2有一条消息；  \n当前模式是订阅模式-Topic，声明一个topic类型的交换机，将队列绑定到该交换机上，绑定的路由键可以有约定模糊匹配功能，只需要跟消息路由键模糊匹配上就可以成功消费消息。\n\n## 配置详解\n\n### rabbitmq 链接相关\n\n```xml\n<!--\n    定义rabbitmq connectionFactory\n    id：bean id\n    host：mq服务地址\n    port：mq服务端口\n    username：用户名\n    password：密码\n    -->\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\"/>\n```\n\n### rabbitAdmin\n\n```xml\n<!--\n    定义RabbitAdmin（管理交换机、队列）\n-->\n<rabbit:admin connection-factory=\"connectionFactory\"/>\n```\n\n### rabbitTemplate\n\n```xml\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n```\n\n### 声明队列\n\n```xml\n    <!--\n        声明队列，不绑定到交换机则绑定到默认交换机\n        id：bean id\n        name：队列名称\n        auto-declare：不存在自动创建\n        auto-delete：是否自动删除，如果最后一个消费者连接断开是否自动删除\n        durable：持久化\n    -->\n    <rabbit:queue id=\"spring_queue\" name=\"spring_queue\" durable=\"true\" auto-delete=\"false\" exclusive=\"false\" auto-declare=\"true\"/>\n```\n\n### 声明监听器\n\n```xml\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n     -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"spring_topic_queue_star\" ref=\"topicListenerStar\"/>\n    </rabbit:listener-container>\n```\n\n### 声明交换机\n\n#### 声明Fanout交换机\n\n```xml\n    <!--\n        声明fanout交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:fanout-exchange id=\"fanoutExchange\" name=\"fanout_exchange\" auto-declare=\"true\" durable=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系（由于是广播模式，所以没有路由键）\n                queue：队列名\n             -->\n            <rabbit:binding queue=\"spring_queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:fanout-exchange>\n```\n\n#### 声明Direct交换机\n\n```xml\n    <!--\n        声明direct交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:direct-exchange id=\"directExchange\" name=\"direct_exchange\" auto-declare=\"true\" durable=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系\n                queue：队列名\n                key：绑定路由键\n             -->\n            <rabbit:binding queue=\"spring_queue\" key=\"spring_queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:direct-exchange>\n```\n\n#### 声明Topic交换机\n\n```xml\n    <!--\n        声明topic交换机\n        id：bean id\n        name：交换机名称\n        auto-declare：是否自动创建\n        durable：是否持久化\n    -->\n    <rabbit:topic-exchange id=\"spring_topic_exchange\" name=\"spring_topic_exchange\" auto-declare=\"true\">\n        <rabbit:bindings>\n            <!--\n                声明绑定关系\n                queue：队列名\n                pattern：模糊路由键\n             -->\n            <rabbit:binding queue=\"spring_topic_queue_star\" pattern=\"heima.*\"/>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n```","slug":"oyr/MQ/RabbitMQ/RabbitMQ-Spring整合","published":1,"updated":"2021-10-26T10:30:26.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87f006tcst7dfutfuzn","content":"<h1 id=\"Spring-整合\"><a href=\"#Spring-整合\" class=\"headerlink\" title=\"Spring 整合\"></a>Spring 整合</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>rabbitmq 版本：3.8.8</li>\n<li>spring 版本：5.1.7.RELEASE</li>\n<li>spring-amqp 版本：2.1.8.RELEASE</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"简单消息模式\"><a href=\"#简单消息模式\" class=\"headerlink\" title=\"简单消息模式\"></a>简单消息模式</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"新建maven项目，导入依赖\"><a href=\"#新建maven项目，导入依赖\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring上下文 &amp; spring amqp --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- test --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置文件\"><a href=\"#编写配置文件\" class=\"headerlink\" title=\"编写配置文件\"></a>编写配置文件</h4><p>rabbitmq.properties（属性类）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq 基本配置</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.host</span>=<span class=\"string\">106.52.180.14</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.password</span>=<span class=\"string\">123</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.virtual-host</span>=<span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>spring-rabbitmq-producer.xml（spring配置类）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义持久化队列，不存在则自动创建；不绑定到交换机则绑定到默认交换机</span></span><br><span class=\"line\"><span class=\"comment\">        默认交换机类型为direct，名字为：&quot;&quot;，路由键为队列的名称</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码\"><a href=\"#发送消息代码\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给spring_queue发送消息，当前队列绑定到默认交换机，路由键为队列名</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_queue&quot;</span>, <span class=\"string\">&quot;hello spring&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"新建maven项目，导入依赖-1\"><a href=\"#新建maven项目，导入依赖-1\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring上下文 &amp; spring amqp --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- test --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置文件-1\"><a href=\"#编写配置文件-1\" class=\"headerlink\" title=\"编写配置文件\"></a>编写配置文件</h4><p>rabbitmq.properties（属性文件）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq 基本配置</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.host</span>=<span class=\"string\">106.52.180.14</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.password</span>=<span class=\"string\">123</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.virtual-host</span>=<span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>spring-rabbitmq-consumer.xml（spring配置文件）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;springQueueListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_queue&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;springQueueListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.SpringQueueListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消费消息代码\"><a href=\"#消费消息代码\" class=\"headerlink\" title=\"消费消息代码\"></a>消费消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听器对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringQueueListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果\"><a href=\"#执行代码，查看结果\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>当前模式是简单模式，声明一个队列，绑定到默认交换机上，由于是默认交换机（Direct类型），所以绑定的路由键是队列名，发送消息路由键需要和绑定路由键一致就可以成功消费消息。</p>\n<h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h3 id=\"生产者-1\"><a href=\"#生产者-1\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-producer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有绑定队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:fanout-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:fanout-exchange</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码-1\"><a href=\"#发送消息代码-1\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给fanout交换机发送消息，所有绑定的队列都能接受到消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_fanout_exchange&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;spring fanout&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-1\"><a href=\"#消费者-1\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"修改配置-1\"><a href=\"#修改配置-1\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-consumer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;fanoutListener1&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;fanoutListener2&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutListener1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.FanoutListener1&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutListener2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.FanoutListener2&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息消费代码\"><a href=\"#消息消费代码\" class=\"headerlink\" title=\"消息消费代码\"></a>消息消费代码</h4><p>FanoutListener1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutListener1</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;FanoutListener1消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FanoutListener2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutListener2</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;FanoutListener2消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果-1\"><a href=\"#执行代码，查看结果-1\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>当前模式是订阅模式-Fanout，声明一个fanout类型的交换机，只要队列绑定到该交换机上，生产者发送消息后都可以消费到，fanout类型交换机忽略了路由键。</p>\n<h2 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><h3 id=\"生产者-2\"><a href=\"#生产者-2\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"修改配置-2\"><a href=\"#修改配置-2\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-producer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~主题；*匹配一个单词，#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.*&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;itcast.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码-2\"><a href=\"#发送消息代码-2\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">topicTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给topic交换机发送消息，路由键进行模糊匹配</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;heima.oyr&quot;</span>, <span class=\"string\">&quot;heima.oyr&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;heima.laihong.nan&quot;</span>, <span class=\"string\">&quot;heima.laihong.nan&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;itcast.oyr&quot;</span>, <span class=\"string\">&quot;itcast.oyr&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-2\"><a href=\"#消费者-2\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"修改配置-3\"><a href=\"#修改配置-3\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-consumer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerWell&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerWell2&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerStar&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerWell&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerWell&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerWell2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerWell2&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息消费代码-1\"><a href=\"#消息消费代码-1\" class=\"headerlink\" title=\"消息消费代码\"></a>消息消费代码</h4><p>TopicListenerStar：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerStar</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerStar消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TopicListenerWell：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerWell</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerWell消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TopicListenerWell2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerWell2</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerWell2消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果-2\"><a href=\"#执行代码，查看结果-2\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>spring_topic_queue_star队列有一条信息；spring_topic_queue_well队列有两条信息；spring_topic_queue_well2有一条消息；<br>当前模式是订阅模式-Topic，声明一个topic类型的交换机，将队列绑定到该交换机上，绑定的路由键可以有约定模糊匹配功能，只需要跟消息路由键模糊匹配上就可以成功消费消息。</p>\n<h2 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h2><h3 id=\"rabbitmq-链接相关\"><a href=\"#rabbitmq-链接相关\" class=\"headerlink\" title=\"rabbitmq 链接相关\"></a>rabbitmq 链接相关</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    定义rabbitmq connectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    host：mq服务地址</span></span><br><span class=\"line\"><span class=\"comment\">    port：mq服务端口</span></span><br><span class=\"line\"><span class=\"comment\">    username：用户名</span></span><br><span class=\"line\"><span class=\"comment\">    password：密码</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbitAdmin\"><a href=\"#rabbitAdmin\" class=\"headerlink\" title=\"rabbitAdmin\"></a>rabbitAdmin</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    定义RabbitAdmin（管理交换机、队列）</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbitTemplate\"><a href=\"#rabbitTemplate\" class=\"headerlink\" title=\"rabbitTemplate\"></a>rabbitTemplate</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明队列\"><a href=\"#声明队列\" class=\"headerlink\" title=\"声明队列\"></a>声明队列</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明队列，不绑定到交换机则绑定到默认交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：不存在自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    auto-delete：是否自动删除，如果最后一个消费者连接断开是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">    durable：持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">auto-delete</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">exclusive</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明监听器\"><a href=\"#声明监听器\" class=\"headerlink\" title=\"声明监听器\"></a>声明监听器</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">    connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明交换机\"><a href=\"#声明交换机\" class=\"headerlink\" title=\"声明交换机\"></a>声明交换机</h3><h4 id=\"声明Fanout交换机\"><a href=\"#声明Fanout交换机\" class=\"headerlink\" title=\"声明Fanout交换机\"></a>声明Fanout交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明fanout交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:fanout-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutExchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fanout_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系（由于是广播模式，所以没有路由键）</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:fanout-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"声明Direct交换机\"><a href=\"#声明Direct交换机\" class=\"headerlink\" title=\"声明Direct交换机\"></a>声明Direct交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明direct交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:direct-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;directExchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;direct_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">            key：绑定路由键</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;spring_queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:direct-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"声明Topic交换机\"><a href=\"#声明Topic交换机\" class=\"headerlink\" title=\"声明Topic交换机\"></a>声明Topic交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明topic交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">            pattern：模糊路由键</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.*&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Spring-整合\"><a href=\"#Spring-整合\" class=\"headerlink\" title=\"Spring 整合\"></a>Spring 整合</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>rabbitmq 版本：3.8.8</li>\n<li>spring 版本：5.1.7.RELEASE</li>\n<li>spring-amqp 版本：2.1.8.RELEASE</li>\n</ul>","more":"<h2 id=\"简单消息模式\"><a href=\"#简单消息模式\" class=\"headerlink\" title=\"简单消息模式\"></a>简单消息模式</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"新建maven项目，导入依赖\"><a href=\"#新建maven项目，导入依赖\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring上下文 &amp; spring amqp --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- test --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置文件\"><a href=\"#编写配置文件\" class=\"headerlink\" title=\"编写配置文件\"></a>编写配置文件</h4><p>rabbitmq.properties（属性类）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq 基本配置</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.host</span>=<span class=\"string\">106.52.180.14</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.password</span>=<span class=\"string\">123</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.virtual-host</span>=<span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>spring-rabbitmq-producer.xml（spring配置类）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义持久化队列，不存在则自动创建；不绑定到交换机则绑定到默认交换机</span></span><br><span class=\"line\"><span class=\"comment\">        默认交换机类型为direct，名字为：&quot;&quot;，路由键为队列的名称</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码\"><a href=\"#发送消息代码\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给spring_queue发送消息，当前队列绑定到默认交换机，路由键为队列名</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_queue&quot;</span>, <span class=\"string\">&quot;hello spring&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"新建maven项目，导入依赖-1\"><a href=\"#新建maven项目，导入依赖-1\" class=\"headerlink\" title=\"新建maven项目，导入依赖\"></a>新建maven项目，导入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring上下文 &amp; spring amqp --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.amqp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-rabbit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- test --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.7.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写配置文件-1\"><a href=\"#编写配置文件-1\" class=\"headerlink\" title=\"编写配置文件\"></a>编写配置文件</h4><p>rabbitmq.properties（属性文件）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rabbitmq 基本配置</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.host</span>=<span class=\"string\">106.52.180.14</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.port</span>=<span class=\"string\">5672</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.username</span>=<span class=\"string\">admin</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.password</span>=<span class=\"string\">123</span></span><br><span class=\"line\"><span class=\"meta\">rabbitmq.virtual-host</span>=<span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>spring-rabbitmq-consumer.xml（spring配置文件）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;springQueueListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_queue&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;springQueueListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.SpringQueueListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消费消息代码\"><a href=\"#消费消息代码\" class=\"headerlink\" title=\"消费消息代码\"></a>消费消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听器对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringQueueListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果\"><a href=\"#执行代码，查看结果\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>当前模式是简单模式，声明一个队列，绑定到默认交换机上，由于是默认交换机（Direct类型），所以绑定的路由键是队列名，发送消息路由键需要和绑定路由键一致就可以成功消费消息。</p>\n<h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h3 id=\"生产者-1\"><a href=\"#生产者-1\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-producer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~广播；所有绑定队列都能收到消息~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:fanout-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_fanout_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_fanout_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:fanout-exchange</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码-1\"><a href=\"#发送消息代码-1\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给fanout交换机发送消息，所有绑定的队列都能接受到消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_fanout_exchange&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;spring fanout&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-1\"><a href=\"#消费者-1\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"修改配置-1\"><a href=\"#修改配置-1\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-consumer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;fanoutListener1&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_fanout_queue_1&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;fanoutListener2&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_fanout_queue_2&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutListener1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.FanoutListener1&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutListener2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.FanoutListener2&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息消费代码\"><a href=\"#消息消费代码\" class=\"headerlink\" title=\"消息消费代码\"></a>消息消费代码</h4><p>FanoutListener1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutListener1</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;FanoutListener1消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FanoutListener2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutListener2</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;FanoutListener2消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果-1\"><a href=\"#执行代码，查看结果-1\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>当前模式是订阅模式-Fanout，声明一个fanout类型的交换机，只要队列绑定到该交换机上，生产者发送消息后都可以消费到，fanout类型交换机忽略了路由键。</p>\n<h2 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><h3 id=\"生产者-2\"><a href=\"#生产者-2\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><h4 id=\"修改配置-2\"><a href=\"#修改配置-2\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-producer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~主题；*匹配一个单词，#匹配多个单词 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义广播交换机中的持久化队列，不存在则自动创建--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.*&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;itcast.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"发送消息代码-2\"><a href=\"#发送消息代码-2\" class=\"headerlink\" title=\"发送消息代码\"></a>发送消息代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">topicTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给topic交换机发送消息，路由键进行模糊匹配</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;heima.oyr&quot;</span>, <span class=\"string\">&quot;heima.oyr&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;heima.laihong.nan&quot;</span>, <span class=\"string\">&quot;heima.laihong.nan&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;spring_topic_exchange&quot;</span>, <span class=\"string\">&quot;itcast.oyr&quot;</span>, <span class=\"string\">&quot;itcast.oyr&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者-2\"><a href=\"#消费者-2\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><h4 id=\"修改配置-3\"><a href=\"#修改配置-3\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h4><p>spring-rabbitmq-consumer.xml（spring配置）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器容器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerWell&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_well&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerWell2&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_well2&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerStar&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerWell&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerWell&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;topicListenerWell2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TopicListenerWell2&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息消费代码-1\"><a href=\"#消息消费代码-1\" class=\"headerlink\" title=\"消息消费代码\"></a>消息消费代码</h4><p>TopicListenerStar：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerStar</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerStar消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TopicListenerWell：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerWell</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerWell消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TopicListenerWell2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicListenerWell2</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;TopicListenerWell2消费消息：&quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行代码，查看结果-2\"><a href=\"#执行代码，查看结果-2\" class=\"headerlink\" title=\"执行代码，查看结果\"></a>执行代码，查看结果</h3><p>生产者发送消息，消费者成功消费消息。<br>spring_topic_queue_star队列有一条信息；spring_topic_queue_well队列有两条信息；spring_topic_queue_well2有一条消息；<br>当前模式是订阅模式-Topic，声明一个topic类型的交换机，将队列绑定到该交换机上，绑定的路由键可以有约定模糊匹配功能，只需要跟消息路由键模糊匹配上就可以成功消费消息。</p>\n<h2 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h2><h3 id=\"rabbitmq-链接相关\"><a href=\"#rabbitmq-链接相关\" class=\"headerlink\" title=\"rabbitmq 链接相关\"></a>rabbitmq 链接相关</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    定义rabbitmq connectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    host：mq服务地址</span></span><br><span class=\"line\"><span class=\"comment\">    port：mq服务端口</span></span><br><span class=\"line\"><span class=\"comment\">    username：用户名</span></span><br><span class=\"line\"><span class=\"comment\">    password：密码</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbitAdmin\"><a href=\"#rabbitAdmin\" class=\"headerlink\" title=\"rabbitAdmin\"></a>rabbitAdmin</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    定义RabbitAdmin（管理交换机、队列）</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbitTemplate\"><a href=\"#rabbitTemplate\" class=\"headerlink\" title=\"rabbitTemplate\"></a>rabbitTemplate</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明队列\"><a href=\"#声明队列\" class=\"headerlink\" title=\"声明队列\"></a>声明队列</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明队列，不绑定到交换机则绑定到默认交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：不存在自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    auto-delete：是否自动删除，如果最后一个消费者连接断开是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">    durable：持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">auto-delete</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">exclusive</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明监听器\"><a href=\"#声明监听器\" class=\"headerlink\" title=\"声明监听器\"></a>声明监听器</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">    connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;topicListenerStar&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明交换机\"><a href=\"#声明交换机\" class=\"headerlink\" title=\"声明交换机\"></a>声明交换机</h3><h4 id=\"声明Fanout交换机\"><a href=\"#声明Fanout交换机\" class=\"headerlink\" title=\"声明Fanout交换机\"></a>声明Fanout交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明fanout交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:fanout-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fanoutExchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fanout_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系（由于是广播模式，所以没有路由键）</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:fanout-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"声明Direct交换机\"><a href=\"#声明Direct交换机\" class=\"headerlink\" title=\"声明Direct交换机\"></a>声明Direct交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明direct交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:direct-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;directExchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;direct_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">durable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">            key：绑定路由键</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_queue&quot;</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;spring_queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:direct-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"声明Topic交换机\"><a href=\"#声明Topic交换机\" class=\"headerlink\" title=\"声明Topic交换机\"></a>声明Topic交换机</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    声明topic交换机</span></span><br><span class=\"line\"><span class=\"comment\">    id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">    name：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">    auto-declare：是否自动创建</span></span><br><span class=\"line\"><span class=\"comment\">    durable：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;spring_topic_exchange&quot;</span> <span class=\"attr\">auto-declare</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            声明绑定关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue：队列名</span></span><br><span class=\"line\"><span class=\"comment\">            pattern：模糊路由键</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;spring_topic_queue_star&quot;</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;heima.*&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"RabbitMQ-基础","date":"2021-07-12T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# RabbitMQ 基本概念\n\n## 简介\n\nRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息中间件。  \n\nRabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，\n你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，\n一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件，而是接收，存储和转发消息数据。\n\nRabbitMQ官方地址：http://www.rabbitmq.com\n\n<!-- more -->\n\n## 核心概念\n\n![AMQP模式](https://rong0624.gitee.io/images/MQ/amqp模型.png)\n\nRabbitMQ核心概念：\n- Broker\n    - 表示消息队列服务器实体（一个进程）。  \n    - 一个server，接受客户端的连接，上线AMQP实体服务。\n- Connection\n    - 连接.\n    - 应用程序与broker的网络连接，TCP/IP套接字连接。\n- Channel \n    - 消息通道 \n    - 几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个Channel，每个Channel代表一个会话任务。\n- Exchange\n    - 交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n- Queue\n    - 消息队列，存储消息，用于发送给消费者。\n    - 它是消息的容器，也是消息的终点。一个消息可以投入多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。\n- Binding\n    - 绑定，消息队列和交换器之间的关联。\n    - 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n- Routing Key\n    - 路由关键字，一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n- Message\n    - 消息\n    - 消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n- Publisher\n    - 消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n- Consumer\n    - 消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n- Virtual Host  \n    - 虚拟主机\n\n## 消息模式\n\n![消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626769058993.jpg)\n\n1. 简单模式（simple）\n2. 工作队列模式（work queues）\n3. 订阅模式-Fanout（publish/subscribe）\n4. 订阅模式-Direct（routing）\n5. 订阅模式-Topic（topics）\n\n**注意：订阅模式-Fanout，订阅模式-Direct，订阅模式-Topic都属于发布/订阅模式类型。**\n\n# RabbitMQ 安装和配置\n\n## 相关版本\n\n```\nerlang 21.3.x\nrabbitmq 3.8.8\n```\n\nErlang rpm下载：  \nhttps://github.com/rabbitmq/erlang-rpm/releases\n\nRabbitmq rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n## Linux下安装\n\n### 环境准备\n\n```\nlinux（CentOS 7.5）\nerlang 21.3.x\nrabbitmq 3.8.8\n```\n\n### 安装Erlang\n\n![erlang版本信息](https://rong0624.gitee.io/images/MQ/RabbitMQ/erlang版本.png)   \n下载erlang时需要注意，要和rabbitmq版本兼容.\n\n1）erlang rpm下载：\nhttps://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm\nerlang-21.3.1-1.el7.x86_64.rpm\n\n2）rpm上传到系统中，安装erlang \nrpm -ivh erlang-21.3-1.el7.x86_64.rpm\n\n3）查看erlang版本\nerl -v\n\n### 安装socat\n\n安装Erlang后直接安装RabbitMQ，需要安装socat。\n\n安装socat：  \nyum install socat -y\n\n### 安装RabbitMQ\n\n```\n1）rabbitmq rpm下载  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n2）rpm上传到系统中，并安装rabbitmq  \nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm \n\n3）启动服务并测试  \n# 启动服务 \nservice rabbitmq-server start\n\n# 查看服务状态\nservice rabbitmq-server status\n\n4）常用命令\n\n# 启动服务 \nservice rabbitmq-server start \n\n# 查看服务状态\nservice rabbitmq-server status\n\n# 停止服务 \nservice rabbitmq-server stop\n\n# 重启服务 \nservice rabbitmq-server restart\n\n# 开机自动启动 \nchkconfig rabbitmq-server on\n```\n\n## Windos下安装\n\n## Mac下安装\n\n## RabbitMQ 管理界面及授权操作\n\n### 管理界面\n\n1）默认情况下，是没有安装web端的客户端插件，需要安装才可以生效。\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n注意：管理界面会在15672端口提供服务\n\n2）安装完毕以后，重启服务即可\n```shell\nservice rabbitmq-server restart\n```\n\n3）在浏览器访问  \n\n```\n# 关闭防火墙服务\n## 关闭防火墙\nsystemctl stop firewalld\n## 关闭防火墙开机启动\nsystemctl disable firewalld\n# 注意：一定要记住，在对应服务器（阿里云，腾讯云等）的安全组中开放15672端口\n\n# 访问web管理界面\nhttp://106.52.180.14:15672\n```\n\n成功访问：![RabbitMQ管理界面](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626777167279.jpg)\n\n### 授权账号和密码\n\n![guest登录](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721213622.png)  \n说明：rabbitmq有一个默认账号和密码是：guest/guest，但guest默认情况只能在localhost本机下访问，所以需要添加一个远程登录的用户。\n\n1）新增用户并授权：\n```\n#新增用户\nrabbitmqctl add_user admin 123\n\n#设置用户分配操作权限\nrabbitmqctl set_user_tags admin administrator\n\n#为用户添加资源权限\n#set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n#解释：用户 admin 具有 / 这个 virtual host 中所有资源的配置、写、读权限\nrabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n```\n\n2）使用admin登录管理页面\n登录成功：  \n![admin登录](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721215337.png)  \n\n### 小结\n\n管理用户常见命令如下：\n```\n# 查看用户列表\nrabbitmqctl list_users\n\n# 新增账号[并设置密码]\nrabbitmqctl add_user 账号 密码\n\n# 修改密码\nrabbitmqctl change_password 账号 新密码\n\n# 删除账号\nrabbitmqctl delete_user 账号\n\n# 给账号设置角色\nrabbitmqctl set_user_tags 账号 角色\n\n# 给账号设置权限\nrabbitmqctl set_permissions -p \"/\" 账号 \".*\" \".*\" \".*\"\n```\n\n# 快速入门（simple）\n\n## 环境准备\n\n在学习RabbitMQ前必须掌握以下内容：  \n熟悉使用Java  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具  \n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nRabbitMQ 3.8.8\n\n## 实现需求\n\n需求：使用简单模式完成消息传递;\n\n1. 创建生产者程序，发送消息\n2. 创建消费者程序，消费消息\n\n## 导入依赖\n\n```xml\n    <!-- rabbitmq 依赖客户端 -->\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n```\n\n## 消息生产者\n\n消息生产者：生产消息\n\n```java\npublic class Producer {\n\n    private final static String QUEUE_NAME = \"Hello\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        /**\n         * 4.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        /**\n         * 5.发送消息\n         * 参数1：交换机（不指定，使用默认交换机）\n         * 参数2：路由键\n         * 参数3：其他参数\n         * 参数4：消息主体\n         */\n        String message = \"hello world\";\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n\n        System.out.println(\"消息发送完成~\");\n    }\n\n}\n```\n\n## 消息消费者\n\n消息消费者：消费消息\n\n```java\npublic class Consumer {\n\n    private final static String QUEUE_NAME = \"Hello\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消费消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动生产者，发送消息\n\n启动生产者，发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949235794.jpg)\n\n查看管理页面，可以发现：新建了一个队列：Hello，并且队列里有一条消息等待读取：  \n![管理页面，查看队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949728101.jpg)\n\n进入队列详情，还可以看到消息主题内容：  \n![管理页面，查看消息主体内容](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949629441.jpg)\n\n2）启动消费者，消费消息\n\n启动消费者，消费消息：  \n![消费者消费消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949896540.jpg)\n\n查看管理页面，可以发现：Hello队列，消息已经被消费了：  \n![管理页面，查看队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949947003.jpg)\n\n## 小结\n\n上述的入门案例中其实使用的是的简单模式。\n\n![基本消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721223009.png)  \n在上图的模式中，有以下概念：\n1. 生产者（P）：也就是要发送消息的程序\n2. 消费者（C）：消息的接受者，会一直等待消息到来。\n3. 消息队列：图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n# 工作队列模式（work queue）\n\n工作队列(又称任务队列)  \n主要思想是避免立即执行资源密集型任务，必须等待它执行完成。  \n相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。\n\n## 图解\n\n![工作消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721224055.png)  \n\n- Work Queues：与基本消息模式相比，多了一个或多个消费者，多个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。\n- 应用场景：对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。\n\n思考：当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？  \n主要有两种模式：\n1. 轮询分发：一个消费者一条，按均分配；\n2. 不公平分发：根据消费者的消费能力进行分发，处理快的处理的多，处理慢的处理的少；\n\n## 抽取工具类\n\n```java\npublic class RabbitMqUtils {\n\n    public static Channel getChannel() throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        return channel;\n    }\n\n}\n```\n\n## 轮询分发\n\n### 生产者\n\n```java\npublic class Producer {\n\n    private final static String QUEUE_NAME = \"work_queue\";\n\n    public static void main(String[] args) throws Exception {\n        // 获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 发送消息，模拟发送多个消息，测试工作队列\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n### 消费者\n\n```java\npublic class Consumer {\n\n    private final static String QUEUE_NAME = \"work_queue\";\n\n    public static void main(String[] args) throws Exception {\n        // 获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, (consumerTag, message) -> {\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消费消息，消息内容：\" + msgBody);\n        }, (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        });\n    }\n\n}\n```\n\n### 执行结果\n\n1）启动两个消息者线程，模拟两个消费者在监听队列消息消息：  \n![消费者1](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232358.png)  \n![消费者2](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232422.png)  \n\n2）启动生产者进行发送消息。\n\n3）结论\n通过生产者总共发送 4 个消息；  \n消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息：  \n![工作消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232715.png)  \n\n## 不公平分发（能者多劳）\n\n以上RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好。  \n比方说：有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，  \n这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。\n\n现在想要做的是：不公平分发，消费越快的人，消费的越多，怎么实现呢？在消费者指定prefetchCount。\n```java\nInteger prefetchCount = 1\nchannel.basicQos(prefetchCount);\n```\n\n![不公平分发图](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626919721516.jpg)\n\n解释：如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，  \n然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，  \n队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。\n\n## 小结\n\n1. 在一个队列中，如果有多个消费者，那么消费者之间对同一个消息的关系是竞争关系，一个消息只能被一个消费者获取。\n2. Work Queues 对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。列如：关系服务部署多个，只需要一个节点成功发送即可。\n\n# 订阅模式-Fanout\n\nFanout，也称为广播模式。在改模式下会将消息交给所有绑定到交换机的队列。\n\n## 图解\n\n![订阅模式-Fanout](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630658875186.jpg)\n\n- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机（X）\n- C：消费者，消息的接收者，会一直等待消息到来\n- Queue：消息队列，接收消息、缓存消息\n- Exchange：交换机（X），一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。\n- Fanout类型交换机会将消息交给所有绑定到交换机的队列。\n\n## 实现需求\n\n同一个消息，通过订阅模式-Fanout被多个消费者消费。\n\n## 消息生产者\n\n变化：\n```\n1. 声明Exchange，不再声明Queue\n2. 发送消息到指定Exchange，而不是默认交换机\n```\n\n```\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n变化：\n```\n1. 需要声明队列\n2. 建立队列与交换机的绑定\n```\n\n消费者1：\n```\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n    private final static String QUEUE_NAME = \"funout_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为fanout，routingKey设置为\"\"\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：\n```\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n    private final static String QUEUE_NAME = \"funout_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为fanout，routingKey设置为\"\"\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消息保存到数据，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动生产者\n\n启动生产者后，可以看到我们自己声明的交换机  \n![fanout-自己声明的交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659575657.jpg)\n\n2）启动消费者\n\n启动两个消费者后，可以在交换机上看到队列与交换机的绑定关系  \n![fanout-队列&交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659702681.jpg)\n\n3）生产者发送消息，查看消费者消息情况\n\n这边不演示了，当发送三条消息后，每个消费者都可以消费到三条消息。  \n得出结论：每个队列里面的消息只能被消费一次，但可以通过订阅模式-funout下声明多个队列来多次消费同一条消息。\n\n## 小结\n\n在订阅-fanout模式下的小结：\n1. 消费者可以有自己的Queue（多个队列）\n2. 队列要绑定到Exchange（交换机）\n3. 当交换机类型为fanout，会把消息发送给绑定过的所有队列（忽略路由键）\n4. 在订阅-fanout模式下，多个队列可以存储同一个消息，实现一条消息被多个消费者消费\n5. 订阅-fanout与工作队列模式的区别：\n    - 发布/订阅模式需要定义交换机，而工作队列模式不用定义交换机（工作队列使用默认交换机）\n    - 发布/订阅模式需要设置队列和交换机的绑定，工作队列不需要设置（工作队列实际上会自动将队列绑定到默认的交换机上）\n\n# 订阅模式-Direct\n\nDirect，也称为直连模式。在该模式下必须队列的绑定 Routing key 与消息的 Routing key 完全一致才能接受到消息。\n\n订阅模式-Direct的约定：\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）\n- 消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey\n- Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的绑定 Routing key 与消息的 Routing key 完全一致，才会接收到消息\n\n## 图解\n\n![订阅模式-Direct图解](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630664309047.jpg)  \n- P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key\n- X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列\n- C1：消费者，其所在队列指定了需要 routing key 为 error 的消息\n- C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息\n\n## 实现需求\n\n生产者发送 info、error、warning 路由键消息。\n消费者1消费所有的消息，消费者2只消费error的消息。\n\n## 消息生产者\n\n```java\n\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            String routingKey;\n            if (message.contains(\"info\")) {\n                routingKey = \"info\";\n            } else if (message.contains(\"error\")) {\n                routingKey = \"error\";\n            } else {\n                routingKey = \"warning\";\n            }\n            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n消费者1：接受 warning，info，error 路由键的消息\n```java\n\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n    private final static String QUEUE_NAME = \"direct_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"warning\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"info\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"error\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：接受 error 路由键的消息\n```java\n\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n    private final static String QUEUE_NAME = \"direct_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"error\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"数据库保存消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动消息生产者\n\n启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：direct。\n![声明direct类型交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175266353.jpg)\n\n2）启动消息消费者\n\n启动消费者1和消费者2，可以看到绑定关系。  \n可以看到：消费者1等待接收warning，info，error路由键的消息，消费者2等待接收error路由键的消息。\n![direct类型交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175314170.jpg)\n\n3）生产者发送消息，查看结果\n\n生产者发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175556983.jpg)\n\n消费者1消费情况：  \n![消费者1消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175568487.jpg)\n\n消费者2消费情况：  \n![消费者2消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175573846.jpg)\n\n生产者分别发送warning，info，error路由键消息内容，消费者1都接收到了，消费者2只接收到error路由键的消息。\n\n## 小结\n\n订阅模式-Direct要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。\n\n# 订阅模式-Topic\n\n订阅模式-Topic的约定：\n- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符！\n- Routing key 中可以存在两种特殊字符 \"\\*”与“#”，用于做模糊匹配，其中 “\\*” 用于匹配一个单词，“#”用于匹配一个或多个词（可以是零个）\n- Routing key 一般都是有一个或多个单词组成，这些单词可以是任意单词，多个单词之间以”.”分割，例如\"stock.usd.nyse\", \"nyse.vmw\"\n\n## 图解\n\n![订阅模式-Topic图解](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631182623236.jpg)\n- 红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到\n- 黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配\n\n## 实现需求\n\n生产者发送 info、error、warning 路由键消息 和 订单相关的日志。\n消费者1消费所有（#.info.#，#.error.#，#.warning.#）的消息；\n消费者2只消费error的消息和订单相关的日志（#.error.#，#.order.#）。\n\n## 消息生产者\n\n```java\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            String routingKey = \"\";\n            if (message.contains(\"order\")) {\n                routingKey = \"order.\";\n            }\n            if (message.contains(\"info\")) {\n                routingKey += \"info\";\n            } else if (message.contains(\"error\")) {\n                routingKey += \"error\";\n            } else {\n                routingKey += \"warning\";\n            }\n            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n消费者1：接受 #.info.#，#.error.#，#.warning.# 路由键的消息\n```java\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n    private final static String QUEUE_NAME = \"topic_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.warning.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.info.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.error.#\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：接受 #.error.#，#.order.# 路由键的消息\n```java\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n    private final static String QUEUE_NAME = \"topic_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.error.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"order.#\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"数据库保存消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动消息生产者\n\n启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：topic。\n![声明topic类型交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242891106.jpg)\n\n2）启动消息消费者\n\n启动消费者1和消费者2，可以看到绑定关系。  \n![topic类型交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242898127.jpg)\n\n3）生产者发送消息，查看结果\n\n生产者发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242903958.jpg)\n\n消费者1消费情况：  \n![消费者1消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242910856.jpg)\n\n消费者2消费情况：  \n![消费者2消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242916251.jpg)\n\n生产者分别发送 warning，info，error，订单相关 路由键消息内容（共6条）。\n消费者1都接收到了（接受到共6条），消费者2只接收到 error 与 订单 相关路由键的消息（接受到共4条）。\n\n## 小结\n\n订阅-Topic模式可以实现 订阅-Funout模式 与 订阅-Direct模式 的功能，只是 订阅-Topic模式 在配置 routing key 的时候可以使用通配符，显得更加灵活。\n\n# Exchange 交换机\n\n## 概念\n\nRabbitMQ 消息传递模式的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)。\n\n交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n交换机是用来发送消息的AMQP实体。  \n交换机拿到一个消息之后将它路由给一个或零个队列。  \n交换机使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。  \n交换机只负责转发消息，不具备存储消息的功能，如果没有符合路由规则的队列，那么消息会丢失。\n\n## 交换机属性\n\n在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  \n- Name  \n- Type（交换机类型）\n- Durability（消息代理重启后，交换机是否还存在）  \n- Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  \n- Arguments（依赖代理本身）\n\n## Binding 绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。\n如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n## 交换机类型\n\nAMQP 0-9-1的代理提供了四种交换机：  \n![交换机类型](https://rong0624.gitee.io/images/MQ/交换机类型.png)  \n\n默认交换机，直连交换机，扇形交换机，主题交换机，头交换机；\n\n## 默认交换机（default exchange）\n\n### 概念\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：  \n当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n### 实战\n\n基本消息模式和工作队列消息模式案例中使用的都是默认交换机，路由键名是队列名称，所以消息才可以成功的被发送到队列中。\n```java\n/**\n* 5.发送消息\n* 参数1：交换机（不指定，使用默认交换机）\n* 参数2：路由键\n* 参数3：其他参数\n* 参数4：消息主体\n*/\nString message = \"hello world\";\nchannel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n```\n\n## 扇型交换机（funout exchange）\n\n### 概念\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.gitee.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1，并将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n### 实战\n\n请看：订阅模式-Fanout\n\n## 直连交换机（direct exchange）\n\n### 概念\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.gitee.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。  \n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n### 实战\n\n请看：订阅模式-Direct\n\n## 主题交换机（topic exchanges）\n\n### 概念\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “*” 与“#”，用于做模糊匹配，其中 “*” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.gitee.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n### 实战\n\n请看：订阅模式-Topic","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-基础.md","raw":"---\ntitle: RabbitMQ-基础\ndate: 2021-07-13 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n# RabbitMQ 基本概念\n\n## 简介\n\nRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息中间件。  \n\nRabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，\n你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，\n一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件，而是接收，存储和转发消息数据。\n\nRabbitMQ官方地址：http://www.rabbitmq.com\n\n<!-- more -->\n\n## 核心概念\n\n![AMQP模式](https://rong0624.gitee.io/images/MQ/amqp模型.png)\n\nRabbitMQ核心概念：\n- Broker\n    - 表示消息队列服务器实体（一个进程）。  \n    - 一个server，接受客户端的连接，上线AMQP实体服务。\n- Connection\n    - 连接.\n    - 应用程序与broker的网络连接，TCP/IP套接字连接。\n- Channel \n    - 消息通道 \n    - 几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个Channel，每个Channel代表一个会话任务。\n- Exchange\n    - 交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n- Queue\n    - 消息队列，存储消息，用于发送给消费者。\n    - 它是消息的容器，也是消息的终点。一个消息可以投入多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。\n- Binding\n    - 绑定，消息队列和交换器之间的关联。\n    - 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n- Routing Key\n    - 路由关键字，一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n- Message\n    - 消息\n    - 消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n- Publisher\n    - 消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n- Consumer\n    - 消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n- Virtual Host  \n    - 虚拟主机\n\n## 消息模式\n\n![消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626769058993.jpg)\n\n1. 简单模式（simple）\n2. 工作队列模式（work queues）\n3. 订阅模式-Fanout（publish/subscribe）\n4. 订阅模式-Direct（routing）\n5. 订阅模式-Topic（topics）\n\n**注意：订阅模式-Fanout，订阅模式-Direct，订阅模式-Topic都属于发布/订阅模式类型。**\n\n# RabbitMQ 安装和配置\n\n## 相关版本\n\n```\nerlang 21.3.x\nrabbitmq 3.8.8\n```\n\nErlang rpm下载：  \nhttps://github.com/rabbitmq/erlang-rpm/releases\n\nRabbitmq rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n## Linux下安装\n\n### 环境准备\n\n```\nlinux（CentOS 7.5）\nerlang 21.3.x\nrabbitmq 3.8.8\n```\n\n### 安装Erlang\n\n![erlang版本信息](https://rong0624.gitee.io/images/MQ/RabbitMQ/erlang版本.png)   \n下载erlang时需要注意，要和rabbitmq版本兼容.\n\n1）erlang rpm下载：\nhttps://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm\nerlang-21.3.1-1.el7.x86_64.rpm\n\n2）rpm上传到系统中，安装erlang \nrpm -ivh erlang-21.3-1.el7.x86_64.rpm\n\n3）查看erlang版本\nerl -v\n\n### 安装socat\n\n安装Erlang后直接安装RabbitMQ，需要安装socat。\n\n安装socat：  \nyum install socat -y\n\n### 安装RabbitMQ\n\n```\n1）rabbitmq rpm下载  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n2）rpm上传到系统中，并安装rabbitmq  \nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm \n\n3）启动服务并测试  \n# 启动服务 \nservice rabbitmq-server start\n\n# 查看服务状态\nservice rabbitmq-server status\n\n4）常用命令\n\n# 启动服务 \nservice rabbitmq-server start \n\n# 查看服务状态\nservice rabbitmq-server status\n\n# 停止服务 \nservice rabbitmq-server stop\n\n# 重启服务 \nservice rabbitmq-server restart\n\n# 开机自动启动 \nchkconfig rabbitmq-server on\n```\n\n## Windos下安装\n\n## Mac下安装\n\n## RabbitMQ 管理界面及授权操作\n\n### 管理界面\n\n1）默认情况下，是没有安装web端的客户端插件，需要安装才可以生效。\n```shell\nrabbitmq-plugins enable rabbitmq_management\n```\n注意：管理界面会在15672端口提供服务\n\n2）安装完毕以后，重启服务即可\n```shell\nservice rabbitmq-server restart\n```\n\n3）在浏览器访问  \n\n```\n# 关闭防火墙服务\n## 关闭防火墙\nsystemctl stop firewalld\n## 关闭防火墙开机启动\nsystemctl disable firewalld\n# 注意：一定要记住，在对应服务器（阿里云，腾讯云等）的安全组中开放15672端口\n\n# 访问web管理界面\nhttp://106.52.180.14:15672\n```\n\n成功访问：![RabbitMQ管理界面](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626777167279.jpg)\n\n### 授权账号和密码\n\n![guest登录](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721213622.png)  \n说明：rabbitmq有一个默认账号和密码是：guest/guest，但guest默认情况只能在localhost本机下访问，所以需要添加一个远程登录的用户。\n\n1）新增用户并授权：\n```\n#新增用户\nrabbitmqctl add_user admin 123\n\n#设置用户分配操作权限\nrabbitmqctl set_user_tags admin administrator\n\n#为用户添加资源权限\n#set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n#解释：用户 admin 具有 / 这个 virtual host 中所有资源的配置、写、读权限\nrabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\"\n```\n\n2）使用admin登录管理页面\n登录成功：  \n![admin登录](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721215337.png)  \n\n### 小结\n\n管理用户常见命令如下：\n```\n# 查看用户列表\nrabbitmqctl list_users\n\n# 新增账号[并设置密码]\nrabbitmqctl add_user 账号 密码\n\n# 修改密码\nrabbitmqctl change_password 账号 新密码\n\n# 删除账号\nrabbitmqctl delete_user 账号\n\n# 给账号设置角色\nrabbitmqctl set_user_tags 账号 角色\n\n# 给账号设置权限\nrabbitmqctl set_permissions -p \"/\" 账号 \".*\" \".*\" \".*\"\n```\n\n# 快速入门（simple）\n\n## 环境准备\n\n在学习RabbitMQ前必须掌握以下内容：  \n熟悉使用Java  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具  \n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nRabbitMQ 3.8.8\n\n## 实现需求\n\n需求：使用简单模式完成消息传递;\n\n1. 创建生产者程序，发送消息\n2. 创建消费者程序，消费消息\n\n## 导入依赖\n\n```xml\n    <!-- rabbitmq 依赖客户端 -->\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n```\n\n## 消息生产者\n\n消息生产者：生产消息\n\n```java\npublic class Producer {\n\n    private final static String QUEUE_NAME = \"Hello\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        /**\n         * 4.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        /**\n         * 5.发送消息\n         * 参数1：交换机（不指定，使用默认交换机）\n         * 参数2：路由键\n         * 参数3：其他参数\n         * 参数4：消息主体\n         */\n        String message = \"hello world\";\n        channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n\n        System.out.println(\"消息发送完成~\");\n    }\n\n}\n```\n\n## 消息消费者\n\n消息消费者：消费消息\n\n```java\npublic class Consumer {\n\n    private final static String QUEUE_NAME = \"Hello\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消费消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动生产者，发送消息\n\n启动生产者，发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949235794.jpg)\n\n查看管理页面，可以发现：新建了一个队列：Hello，并且队列里有一条消息等待读取：  \n![管理页面，查看队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949728101.jpg)\n\n进入队列详情，还可以看到消息主题内容：  \n![管理页面，查看消息主体内容](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949629441.jpg)\n\n2）启动消费者，消费消息\n\n启动消费者，消费消息：  \n![消费者消费消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949896540.jpg)\n\n查看管理页面，可以发现：Hello队列，消息已经被消费了：  \n![管理页面，查看队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949947003.jpg)\n\n## 小结\n\n上述的入门案例中其实使用的是的简单模式。\n\n![基本消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721223009.png)  \n在上图的模式中，有以下概念：\n1. 生产者（P）：也就是要发送消息的程序\n2. 消费者（C）：消息的接受者，会一直等待消息到来。\n3. 消息队列：图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\n\n# 工作队列模式（work queue）\n\n工作队列(又称任务队列)  \n主要思想是避免立即执行资源密集型任务，必须等待它执行完成。  \n相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。\n\n## 图解\n\n![工作消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721224055.png)  \n\n- Work Queues：与基本消息模式相比，多了一个或多个消费者，多个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。\n- 应用场景：对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。\n\n思考：当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？  \n主要有两种模式：\n1. 轮询分发：一个消费者一条，按均分配；\n2. 不公平分发：根据消费者的消费能力进行分发，处理快的处理的多，处理慢的处理的少；\n\n## 抽取工具类\n\n```java\npublic class RabbitMqUtils {\n\n    public static Channel getChannel() throws Exception {\n        // 1.创建连接工厂\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(\"106.52.180.14\");\n        factory.setPort(5672);\n        factory.setUsername(\"admin\");\n        factory.setPassword(\"123\");\n\n        // 2.创建连接\n        Connection connection = factory.newConnection();\n\n        // 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）\n        Channel channel = connection.createChannel();\n\n        return channel;\n    }\n\n}\n```\n\n## 轮询分发\n\n### 生产者\n\n```java\npublic class Producer {\n\n    private final static String QUEUE_NAME = \"work_queue\";\n\n    public static void main(String[] args) throws Exception {\n        // 获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 发送消息，模拟发送多个消息，测试工作队列\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n### 消费者\n\n```java\npublic class Consumer {\n\n    private final static String QUEUE_NAME = \"work_queue\";\n\n    public static void main(String[] args) throws Exception {\n        // 获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, (consumerTag, message) -> {\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消费消息，消息内容：\" + msgBody);\n        }, (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        });\n    }\n\n}\n```\n\n### 执行结果\n\n1）启动两个消息者线程，模拟两个消费者在监听队列消息消息：  \n![消费者1](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232358.png)  \n![消费者2](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232422.png)  \n\n2）启动生产者进行发送消息。\n\n3）结论\n通过生产者总共发送 4 个消息；  \n消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息：  \n![工作消息模式](https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232715.png)  \n\n## 不公平分发（能者多劳）\n\n以上RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好。  \n比方说：有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，  \n这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。\n\n现在想要做的是：不公平分发，消费越快的人，消费的越多，怎么实现呢？在消费者指定prefetchCount。\n```java\nInteger prefetchCount = 1\nchannel.basicQos(prefetchCount);\n```\n\n![不公平分发图](https://rong0624.gitee.io/images/MQ/RabbitMQ/1626919721516.jpg)\n\n解释：如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，  \n然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，  \n队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。\n\n## 小结\n\n1. 在一个队列中，如果有多个消费者，那么消费者之间对同一个消息的关系是竞争关系，一个消息只能被一个消费者获取。\n2. Work Queues 对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。列如：关系服务部署多个，只需要一个节点成功发送即可。\n\n# 订阅模式-Fanout\n\nFanout，也称为广播模式。在改模式下会将消息交给所有绑定到交换机的队列。\n\n## 图解\n\n![订阅模式-Fanout](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630658875186.jpg)\n\n- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机（X）\n- C：消费者，消息的接收者，会一直等待消息到来\n- Queue：消息队列，接收消息、缓存消息\n- Exchange：交换机（X），一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。\n- Fanout类型交换机会将消息交给所有绑定到交换机的队列。\n\n## 实现需求\n\n同一个消息，通过订阅模式-Fanout被多个消费者消费。\n\n## 消息生产者\n\n变化：\n```\n1. 声明Exchange，不再声明Queue\n2. 发送消息到指定Exchange，而不是默认交换机\n```\n\n```\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n变化：\n```\n1. 需要声明队列\n2. 建立队列与交换机的绑定\n```\n\n消费者1：\n```\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n    private final static String QUEUE_NAME = \"funout_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为fanout，routingKey设置为\"\"\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：\n```\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.fanout\";\n    private final static String QUEUE_NAME = \"funout_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为fanout，routingKey设置为\"\"\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"消息保存到数据，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动生产者\n\n启动生产者后，可以看到我们自己声明的交换机  \n![fanout-自己声明的交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659575657.jpg)\n\n2）启动消费者\n\n启动两个消费者后，可以在交换机上看到队列与交换机的绑定关系  \n![fanout-队列&交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659702681.jpg)\n\n3）生产者发送消息，查看消费者消息情况\n\n这边不演示了，当发送三条消息后，每个消费者都可以消费到三条消息。  \n得出结论：每个队列里面的消息只能被消费一次，但可以通过订阅模式-funout下声明多个队列来多次消费同一条消息。\n\n## 小结\n\n在订阅-fanout模式下的小结：\n1. 消费者可以有自己的Queue（多个队列）\n2. 队列要绑定到Exchange（交换机）\n3. 当交换机类型为fanout，会把消息发送给绑定过的所有队列（忽略路由键）\n4. 在订阅-fanout模式下，多个队列可以存储同一个消息，实现一条消息被多个消费者消费\n5. 订阅-fanout与工作队列模式的区别：\n    - 发布/订阅模式需要定义交换机，而工作队列模式不用定义交换机（工作队列使用默认交换机）\n    - 发布/订阅模式需要设置队列和交换机的绑定，工作队列不需要设置（工作队列实际上会自动将队列绑定到默认的交换机上）\n\n# 订阅模式-Direct\n\nDirect，也称为直连模式。在该模式下必须队列的绑定 Routing key 与消息的 Routing key 完全一致才能接受到消息。\n\n订阅模式-Direct的约定：\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）\n- 消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey\n- Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的绑定 Routing key 与消息的 Routing key 完全一致，才会接收到消息\n\n## 图解\n\n![订阅模式-Direct图解](https://rong0624.gitee.io/images/MQ/RabbitMQ/1630664309047.jpg)  \n- P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key\n- X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列\n- C1：消费者，其所在队列指定了需要 routing key 为 error 的消息\n- C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息\n\n## 实现需求\n\n生产者发送 info、error、warning 路由键消息。\n消费者1消费所有的消息，消费者2只消费error的消息。\n\n## 消息生产者\n\n```java\n\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            String routingKey;\n            if (message.contains(\"info\")) {\n                routingKey = \"info\";\n            } else if (message.contains(\"error\")) {\n                routingKey = \"error\";\n            } else {\n                routingKey = \"warning\";\n            }\n            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n消费者1：接受 warning，info，error 路由键的消息\n```java\n\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n    private final static String QUEUE_NAME = \"direct_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"warning\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"info\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"error\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：接受 error 路由键的消息\n```java\n\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.direct\";\n    private final static String QUEUE_NAME = \"direct_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"error\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"数据库保存消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动消息生产者\n\n启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：direct。\n![声明direct类型交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175266353.jpg)\n\n2）启动消息消费者\n\n启动消费者1和消费者2，可以看到绑定关系。  \n可以看到：消费者1等待接收warning，info，error路由键的消息，消费者2等待接收error路由键的消息。\n![direct类型交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175314170.jpg)\n\n3）生产者发送消息，查看结果\n\n生产者发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175556983.jpg)\n\n消费者1消费情况：  \n![消费者1消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175568487.jpg)\n\n消费者2消费情况：  \n![消费者2消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175573846.jpg)\n\n生产者分别发送warning，info，error路由键消息内容，消费者1都接收到了，消费者2只接收到error路由键的消息。\n\n## 小结\n\n订阅模式-Direct要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。\n\n# 订阅模式-Topic\n\n订阅模式-Topic的约定：\n- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符！\n- Routing key 中可以存在两种特殊字符 \"\\*”与“#”，用于做模糊匹配，其中 “\\*” 用于匹配一个单词，“#”用于匹配一个或多个词（可以是零个）\n- Routing key 一般都是有一个或多个单词组成，这些单词可以是任意单词，多个单词之间以”.”分割，例如\"stock.usd.nyse\", \"nyse.vmw\"\n\n## 图解\n\n![订阅模式-Topic图解](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631182623236.jpg)\n- 红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到\n- 黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配\n\n## 实现需求\n\n生产者发送 info、error、warning 路由键消息 和 订单相关的日志。\n消费者1消费所有（#.info.#，#.error.#，#.warning.#）的消息；\n消费者2只消费error的消息和订单相关的日志（#.error.#，#.order.#）。\n\n## 消息生产者\n\n```java\npublic class Producer {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明交换机\n         * 参数1：交换机名称\n         * 参数2：交换机类型\n         * 参数3：是否持久化\n         * 参数4：是否自动删除\n         * 参数5：其他参数\n         */\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, false, false, null);\n\n        // 发送消息\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            /**\n             * 3.发送消息\n             * 参数1：交换机（不指定，使用默认交换机）\n             * 参数2：路由键\n             * 参数3：其他参数\n             * 参数4：消息主体\n             */\n            String routingKey = \"\";\n            if (message.contains(\"order\")) {\n                routingKey = \"order.\";\n            }\n            if (message.contains(\"info\")) {\n                routingKey += \"info\";\n            } else if (message.contains(\"error\")) {\n                routingKey += \"error\";\n            } else {\n                routingKey += \"warning\";\n            }\n            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes());\n            System.out.println(\"发送消息：\" + message);\n        }\n    }\n\n}\n```\n\n## 消息消费者\n\n消费者1：接受 #.info.#，#.error.#，#.warning.# 路由键的消息\n```java\npublic class Consumer1 {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n    private final static String QUEUE_NAME = \"topic_consumer1\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.warning.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.info.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.error.#\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"控制台打印消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n消费者2：接受 #.error.#，#.order.# 路由键的消息\n```java\npublic class Consumer2 {\n\n    private final static String EXCHANGE_NAME = \"test.topic\";\n    private final static String QUEUE_NAME = \"topic_consumer2\";\n\n    public static void main(String[] args) throws Exception {\n        // 1.获取通道\n        Channel channel = RabbitMqUtils.getChannel();\n\n        /**\n         * 2.声明队列\n         * 参数1：队列名称\n         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失\n         * 参数3：是否独占队列\n         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除\n         * 参数5：其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        /**\n         * 3.绑定（队列与交换机建立绑定）\n         * 参数1：队列名称\n         * 参数2：交换机名称\n         * 参数3：路由键\n         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键\n         */\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"#.error.#\");\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"order.#\");\n\n        // 消费消息的程序\n        DeliverCallback deliverCallback = (consumerTag, message) -> {\n            // 模拟异常\n            String msgBody = new String(message.getBody());\n            System.out.println(\"数据库保存消息，消息内容：\" + msgBody);\n        };\n\n        // 消费消息失败的程序\n        CancelCallback cancelCallback = (consumerTag) -> {\n            System.out.println(\"消费消息失败了~\");\n        };\n\n        /**\n         * 4.接受消息\n         * 参数1：监听的队列\n         * 参数2：是否自动应答\n         * 参数3：消费消息的程序\n         * 参数4：消费消息失败的程序\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n\n}\n```\n\n## 执行结果\n\n1）启动消息生产者\n\n启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：topic。\n![声明topic类型交换机](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242891106.jpg)\n\n2）启动消息消费者\n\n启动消费者1和消费者2，可以看到绑定关系。  \n![topic类型交换机绑定关系](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242898127.jpg)\n\n3）生产者发送消息，查看结果\n\n生产者发送消息：  \n![生产者发送消息](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242903958.jpg)\n\n消费者1消费情况：  \n![消费者1消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242910856.jpg)\n\n消费者2消费情况：  \n![消费者2消费情况](https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242916251.jpg)\n\n生产者分别发送 warning，info，error，订单相关 路由键消息内容（共6条）。\n消费者1都接收到了（接受到共6条），消费者2只接收到 error 与 订单 相关路由键的消息（接受到共4条）。\n\n## 小结\n\n订阅-Topic模式可以实现 订阅-Funout模式 与 订阅-Direct模式 的功能，只是 订阅-Topic模式 在配置 routing key 的时候可以使用通配符，显得更加灵活。\n\n# Exchange 交换机\n\n## 概念\n\nRabbitMQ 消息传递模式的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)。\n\n交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\n交换机是用来发送消息的AMQP实体。  \n交换机拿到一个消息之后将它路由给一个或零个队列。  \n交换机使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。  \n交换机只负责转发消息，不具备存储消息的功能，如果没有符合路由规则的队列，那么消息会丢失。\n\n## 交换机属性\n\n在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  \n- Name  \n- Type（交换机类型）\n- Durability（消息代理重启后，交换机是否还存在）  \n- Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  \n- Arguments（依赖代理本身）\n\n## Binding 绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。\n如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n## 交换机类型\n\nAMQP 0-9-1的代理提供了四种交换机：  \n![交换机类型](https://rong0624.gitee.io/images/MQ/交换机类型.png)  \n\n默认交换机，直连交换机，扇形交换机，主题交换机，头交换机；\n\n## 默认交换机（default exchange）\n\n### 概念\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：  \n当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n### 实战\n\n基本消息模式和工作队列消息模式案例中使用的都是默认交换机，路由键名是队列名称，所以消息才可以成功的被发送到队列中。\n```java\n/**\n* 5.发送消息\n* 参数1：交换机（不指定，使用默认交换机）\n* 参数2：路由键\n* 参数3：其他参数\n* 参数4：消息主体\n*/\nString message = \"hello world\";\nchannel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\n```\n\n## 扇型交换机（funout exchange）\n\n### 概念\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n扇型交换机图例：  \n![扇型交换机图解](https://rong0624.gitee.io/images/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1，并将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n### 实战\n\n请看：订阅模式-Fanout\n\n## 直连交换机（direct exchange）\n\n### 概念\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连型交换机图例：  \n![直连交换机图解](https://rong0624.gitee.io/images/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。  \n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n### 实战\n\n请看：订阅模式-Direct\n\n## 主题交换机（topic exchanges）\n\n### 概念\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “*” 与“#”，用于做模糊匹配，其中 “*” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://rong0624.gitee.io/images/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n### 实战\n\n请看：订阅模式-Topic","slug":"oyr/MQ/RabbitMQ/RabbitMQ-基础","published":1,"updated":"2021-10-26T10:30:26.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87n006ucst70wxs4jii","content":"<h1 id=\"RabbitMQ-基本概念\"><a href=\"#RabbitMQ-基本概念\" class=\"headerlink\" title=\"RabbitMQ 基本概念\"></a>RabbitMQ 基本概念</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息中间件。  </p>\n<p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，<br>你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，<br>一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件，而是接收，存储和转发消息数据。</p>\n<p>RabbitMQ官方地址：<a href=\"http://www.rabbitmq.com/\">http://www.rabbitmq.com</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模式\"></p>\n<p>RabbitMQ核心概念：</p>\n<ul>\n<li>Broker<ul>\n<li>表示消息队列服务器实体（一个进程）。  </li>\n<li>一个server，接受客户端的连接，上线AMQP实体服务。</li>\n</ul>\n</li>\n<li>Connection<ul>\n<li>连接.</li>\n<li>应用程序与broker的网络连接，TCP/IP套接字连接。</li>\n</ul>\n</li>\n<li>Channel <ul>\n<li>消息通道 </li>\n<li>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个Channel，每个Channel代表一个会话任务。</li>\n</ul>\n</li>\n<li>Exchange<ul>\n<li>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</li>\n</ul>\n</li>\n<li>Queue<ul>\n<li>消息队列，存储消息，用于发送给消费者。</li>\n<li>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>\n</ul>\n</li>\n<li>Binding<ul>\n<li>绑定，消息队列和交换器之间的关联。</li>\n<li>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>\n</ul>\n</li>\n<li>Routing Key<ul>\n<li>路由关键字，一个消息头，交换机可以用这个消息头决定如何路由某条消息。</li>\n</ul>\n</li>\n<li>Message<ul>\n<li>消息</li>\n<li>消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</li>\n</ul>\n</li>\n<li>Publisher<ul>\n<li>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</li>\n</ul>\n</li>\n<li>Consumer<ul>\n<li>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</li>\n</ul>\n</li>\n<li>Virtual Host  <ul>\n<li>虚拟主机</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"消息模式\"><a href=\"#消息模式\" class=\"headerlink\" title=\"消息模式\"></a>消息模式</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626769058993.jpg\" alt=\"消息模式\"></p>\n<ol>\n<li>简单模式（simple）</li>\n<li>工作队列模式（work queues）</li>\n<li>订阅模式-Fanout（publish/subscribe）</li>\n<li>订阅模式-Direct（routing）</li>\n<li>订阅模式-Topic（topics）</li>\n</ol>\n<p><strong>注意：订阅模式-Fanout，订阅模式-Direct，订阅模式-Topic都属于发布/订阅模式类型。</strong></p>\n<h1 id=\"RabbitMQ-安装和配置\"><a href=\"#RabbitMQ-安装和配置\" class=\"headerlink\" title=\"RabbitMQ 安装和配置\"></a>RabbitMQ 安装和配置</h1><h2 id=\"相关版本\"><a href=\"#相关版本\" class=\"headerlink\" title=\"相关版本\"></a>相关版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang 21.3.x</span><br><span class=\"line\">rabbitmq 3.8.8</span><br></pre></td></tr></table></figure>\n\n<p>Erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/erlang-rpm/releases\">https://github.com/rabbitmq/erlang-rpm/releases</a></p>\n<p>Rabbitmq rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p>\n<h2 id=\"Linux下安装\"><a href=\"#Linux下安装\" class=\"headerlink\" title=\"Linux下安装\"></a>Linux下安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux（CentOS 7.5）</span><br><span class=\"line\">erlang 21.3.x</span><br><span class=\"line\">rabbitmq 3.8.8</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Erlang\"><a href=\"#安装Erlang\" class=\"headerlink\" title=\"安装Erlang\"></a>安装Erlang</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/erlang%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本信息\"><br>下载erlang时需要注意，要和rabbitmq版本兼容.</p>\n<p>1）erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm\">https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm</a><br>erlang-21.3.1-1.el7.x86_64.rpm</p>\n<p>2）rpm上传到系统中，安装erlang<br>rpm -ivh erlang-21.3-1.el7.x86_64.rpm</p>\n<p>3）查看erlang版本<br>erl -v</p>\n<h3 id=\"安装socat\"><a href=\"#安装socat\" class=\"headerlink\" title=\"安装socat\"></a>安装socat</h3><p>安装Erlang后直接安装RabbitMQ，需要安装socat。</p>\n<p>安装socat：<br>yum install socat -y</p>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）rabbitmq rpm下载  </span><br><span class=\"line\">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">2）rpm上传到系统中，并安装rabbitmq  </span><br><span class=\"line\">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm </span><br><span class=\"line\"></span><br><span class=\"line\">3）启动服务并测试  </span><br><span class=\"line\"># 启动服务 </span><br><span class=\"line\">service rabbitmq-server start</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\"></span><br><span class=\"line\">4）常用命令</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动服务 </span><br><span class=\"line\">service rabbitmq-server start </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止服务 </span><br><span class=\"line\">service rabbitmq-server stop</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启服务 </span><br><span class=\"line\">service rabbitmq-server restart</span><br><span class=\"line\"></span><br><span class=\"line\"># 开机自动启动 </span><br><span class=\"line\">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Windos下安装\"><a href=\"#Windos下安装\" class=\"headerlink\" title=\"Windos下安装\"></a>Windos下安装</h2><h2 id=\"Mac下安装\"><a href=\"#Mac下安装\" class=\"headerlink\" title=\"Mac下安装\"></a>Mac下安装</h2><h2 id=\"RabbitMQ-管理界面及授权操作\"><a href=\"#RabbitMQ-管理界面及授权操作\" class=\"headerlink\" title=\"RabbitMQ 管理界面及授权操作\"></a>RabbitMQ 管理界面及授权操作</h2><h3 id=\"管理界面\"><a href=\"#管理界面\" class=\"headerlink\" title=\"管理界面\"></a>管理界面</h3><p>1）默认情况下，是没有安装web端的客户端插件，需要安装才可以生效。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n<p>注意：管理界面会在15672端口提供服务</p>\n<p>2）安装完毕以后，重启服务即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service rabbitmq-server restart</span><br></pre></td></tr></table></figure>\n\n<p>3）在浏览器访问  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 关闭防火墙服务</span><br><span class=\"line\">## 关闭防火墙</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">## 关闭防火墙开机启动</span><br><span class=\"line\">systemctl disable firewalld</span><br><span class=\"line\"># 注意：一定要记住，在对应服务器（阿里云，腾讯云等）的安全组中开放15672端口</span><br><span class=\"line\"></span><br><span class=\"line\"># 访问web管理界面</span><br><span class=\"line\">http://106.52.180.14:15672</span><br></pre></td></tr></table></figure>\n\n<p>成功访问：<img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626777167279.jpg\" alt=\"RabbitMQ管理界面\"></p>\n<h3 id=\"授权账号和密码\"><a href=\"#授权账号和密码\" class=\"headerlink\" title=\"授权账号和密码\"></a>授权账号和密码</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721213622.png\" alt=\"guest登录\"><br>说明：rabbitmq有一个默认账号和密码是：guest/guest，但guest默认情况只能在localhost本机下访问，所以需要添加一个远程登录的用户。</p>\n<p>1）新增用户并授权：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新增用户</span><br><span class=\"line\">rabbitmqctl add_user admin 123</span><br><span class=\"line\"></span><br><span class=\"line\">#设置用户分配操作权限</span><br><span class=\"line\">rabbitmqctl set_user_tags admin administrator</span><br><span class=\"line\"></span><br><span class=\"line\">#为用户添加资源权限</span><br><span class=\"line\">#set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class=\"line\">#解释：用户 admin 具有 / 这个 virtual host 中所有资源的配置、写、读权限</span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>\n\n<p>2）使用admin登录管理页面<br>登录成功：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721215337.png\" alt=\"admin登录\">  </p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>管理用户常见命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看用户列表</span><br><span class=\"line\">rabbitmqctl list_users</span><br><span class=\"line\"></span><br><span class=\"line\"># 新增账号[并设置密码]</span><br><span class=\"line\">rabbitmqctl add_user 账号 密码</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改密码</span><br><span class=\"line\">rabbitmqctl change_password 账号 新密码</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除账号</span><br><span class=\"line\">rabbitmqctl delete_user 账号</span><br><span class=\"line\"></span><br><span class=\"line\"># 给账号设置角色</span><br><span class=\"line\">rabbitmqctl set_user_tags 账号 角色</span><br><span class=\"line\"></span><br><span class=\"line\"># 给账号设置权限</span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; 账号 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快速入门（simple）\"><a href=\"#快速入门（simple）\" class=\"headerlink\" title=\"快速入门（simple）\"></a>快速入门（simple）</h1><h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>在学习RabbitMQ前必须掌握以下内容：<br>熟悉使用Java<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具  </p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>RabbitMQ 3.8.8</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>需求：使用简单模式完成消息传递;</p>\n<ol>\n<li>创建生产者程序，发送消息</li>\n<li>创建消费者程序，消费消息</li>\n</ol>\n<h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- rabbitmq 依赖客户端 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息生产者\"><a href=\"#消息生产者\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><p>消息生产者：生产消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 5.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息发送完成~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者\"><a href=\"#消息消费者\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消息消费者：消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动生产者，发送消息</p>\n<p>启动生产者，发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949235794.jpg\" alt=\"生产者发送消息\"></p>\n<p>查看管理页面，可以发现：新建了一个队列：Hello，并且队列里有一条消息等待读取：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949728101.jpg\" alt=\"管理页面，查看队列\"></p>\n<p>进入队列详情，还可以看到消息主题内容：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949629441.jpg\" alt=\"管理页面，查看消息主体内容\"></p>\n<p>2）启动消费者，消费消息</p>\n<p>启动消费者，消费消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949896540.jpg\" alt=\"消费者消费消息\"></p>\n<p>查看管理页面，可以发现：Hello队列，消息已经被消费了：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949947003.jpg\" alt=\"管理页面，查看队列\"></p>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>上述的入门案例中其实使用的是的简单模式。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721223009.png\" alt=\"基本消息模式\"><br>在上图的模式中，有以下概念：</p>\n<ol>\n<li>生产者（P）：也就是要发送消息的程序</li>\n<li>消费者（C）：消息的接受者，会一直等待消息到来。</li>\n<li>消息队列：图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>\n</ol>\n<h1 id=\"工作队列模式（work-queue）\"><a href=\"#工作队列模式（work-queue）\" class=\"headerlink\" title=\"工作队列模式（work queue）\"></a>工作队列模式（work queue）</h1><p>工作队列(又称任务队列)<br>主要思想是避免立即执行资源密集型任务，必须等待它执行完成。<br>相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。</p>\n<h2 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721224055.png\" alt=\"工作消息模式\">  </p>\n<ul>\n<li>Work Queues：与基本消息模式相比，多了一个或多个消费者，多个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。</li>\n<li>应用场景：对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。</li>\n</ul>\n<p>思考：当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？<br>主要有两种模式：</p>\n<ol>\n<li>轮询分发：一个消费者一条，按均分配；</li>\n<li>不公平分发：根据消费者的消费能力进行分发，处理快的处理的多，处理慢的处理的少；</li>\n</ol>\n<h2 id=\"抽取工具类\"><a href=\"#抽取工具类\" class=\"headerlink\" title=\"抽取工具类\"></a>抽取工具类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"轮询分发\"><a href=\"#轮询分发\" class=\"headerlink\" title=\"轮询分发\"></a>轮询分发</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;work_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息，模拟发送多个消息，测试工作队列</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;work_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;, (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><p>1）启动两个消息者线程，模拟两个消费者在监听队列消息消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232358.png\" alt=\"消费者1\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232422.png\" alt=\"消费者2\">  </p>\n<p>2）启动生产者进行发送消息。</p>\n<p>3）结论<br>通过生产者总共发送 4 个消息；<br>消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232715.png\" alt=\"工作消息模式\">  </p>\n<h2 id=\"不公平分发（能者多劳）\"><a href=\"#不公平分发（能者多劳）\" class=\"headerlink\" title=\"不公平分发（能者多劳）\"></a>不公平分发（能者多劳）</h2><p>以上RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好。<br>比方说：有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，<br>这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。</p>\n<p>现在想要做的是：不公平分发，消费越快的人，消费的越多，怎么实现呢？在消费者指定prefetchCount。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer prefetchCount = <span class=\"number\">1</span></span><br><span class=\"line\">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626919721516.jpg\" alt=\"不公平分发图\"></p>\n<p>解释：如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，<br>然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，<br>队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>\n<h2 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>在一个队列中，如果有多个消费者，那么消费者之间对同一个消息的关系是竞争关系，一个消息只能被一个消费者获取。</li>\n<li>Work Queues 对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。列如：关系服务部署多个，只需要一个节点成功发送即可。</li>\n</ol>\n<h1 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h1><p>Fanout，也称为广播模式。在改模式下会将消息交给所有绑定到交换机的队列。</p>\n<h2 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630658875186.jpg\" alt=\"订阅模式-Fanout\"></p>\n<ul>\n<li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机（X）</li>\n<li>C：消费者，消息的接收者，会一直等待消息到来</li>\n<li>Queue：消息队列，接收消息、缓存消息</li>\n<li>Exchange：交换机（X），一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li>\n<li>Fanout类型交换机会将消息交给所有绑定到交换机的队列。</li>\n</ul>\n<h2 id=\"实现需求-1\"><a href=\"#实现需求-1\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>同一个消息，通过订阅模式-Fanout被多个消费者消费。</p>\n<h2 id=\"消息生产者-1\"><a href=\"#消息生产者-1\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><p>变化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 声明Exchange，不再声明Queue</span><br><span class=\"line\">2. 发送消息到指定Exchange，而不是默认交换机</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Producer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明交换机</span><br><span class=\"line\">         * 参数1：交换机名称</span><br><span class=\"line\">         * 参数2：交换机类型</span><br><span class=\"line\">         * 参数3：是否持久化</span><br><span class=\"line\">         * 参数4：是否自动删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 发送消息</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\">        while (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            /**</span><br><span class=\"line\">             * 3.发送消息</span><br><span class=\"line\">             * 参数1：交换机（不指定，使用默认交换机）</span><br><span class=\"line\">             * 参数2：路由键</span><br><span class=\"line\">             * 参数3：其他参数</span><br><span class=\"line\">             * 参数4：消息主体</span><br><span class=\"line\">             */</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());</span><br><span class=\"line\">            System.out.println(&quot;发送消息：&quot; + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-1\"><a href=\"#消息消费者-1\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>变化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 需要声明队列</span><br><span class=\"line\">2. 建立队列与交换机的绑定</span><br></pre></td></tr></table></figure>\n\n<p>消费者1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Consumer1 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;funout_consumer1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明队列</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span><br><span class=\"line\">         * 参数3：是否独占队列</span><br><span class=\"line\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3.绑定（队列与交换机建立绑定）</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：交换机名称</span><br><span class=\"line\">         * 参数3：路由键</span><br><span class=\"line\">         *          如果交换机类型为fanout，routingKey设置为&quot;&quot;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息的程序</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            // 模拟异常</span><br><span class=\"line\">            String msgBody = new String(message.getBody());</span><br><span class=\"line\">            System.out.println(&quot;控制台打印消息，消息内容：&quot; + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息失败的程序</span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;消费消息失败了~&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4.接受消息</span><br><span class=\"line\">         * 参数1：监听的队列</span><br><span class=\"line\">         * 参数2：是否自动应答</span><br><span class=\"line\">         * 参数3：消费消息的程序</span><br><span class=\"line\">         * 参数4：消费消息失败的程序</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Consumer2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;funout_consumer2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明队列</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span><br><span class=\"line\">         * 参数3：是否独占队列</span><br><span class=\"line\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3.绑定（队列与交换机建立绑定）</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：交换机名称</span><br><span class=\"line\">         * 参数3：路由键</span><br><span class=\"line\">         *          如果交换机类型为fanout，routingKey设置为&quot;&quot;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息的程序</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            // 模拟异常</span><br><span class=\"line\">            String msgBody = new String(message.getBody());</span><br><span class=\"line\">            System.out.println(&quot;消息保存到数据，消息内容：&quot; + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息失败的程序</span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;消费消息失败了~&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4.接受消息</span><br><span class=\"line\">         * 参数1：监听的队列</span><br><span class=\"line\">         * 参数2：是否自动应答</span><br><span class=\"line\">         * 参数3：消费消息的程序</span><br><span class=\"line\">         * 参数4：消费消息失败的程序</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659575657.jpg\" alt=\"fanout-自己声明的交换机\"></p>\n<p>2）启动消费者</p>\n<p>启动两个消费者后，可以在交换机上看到队列与交换机的绑定关系<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659702681.jpg\" alt=\"fanout-队列&amp;交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看消费者消息情况</p>\n<p>这边不演示了，当发送三条消息后，每个消费者都可以消费到三条消息。<br>得出结论：每个队列里面的消息只能被消费一次，但可以通过订阅模式-funout下声明多个队列来多次消费同一条消息。</p>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在订阅-fanout模式下的小结：</p>\n<ol>\n<li>消费者可以有自己的Queue（多个队列）</li>\n<li>队列要绑定到Exchange（交换机）</li>\n<li>当交换机类型为fanout，会把消息发送给绑定过的所有队列（忽略路由键）</li>\n<li>在订阅-fanout模式下，多个队列可以存储同一个消息，实现一条消息被多个消费者消费</li>\n<li>订阅-fanout与工作队列模式的区别：<ul>\n<li>发布/订阅模式需要定义交换机，而工作队列模式不用定义交换机（工作队列使用默认交换机）</li>\n<li>发布/订阅模式需要设置队列和交换机的绑定，工作队列不需要设置（工作队列实际上会自动将队列绑定到默认的交换机上）</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"订阅模式-Direct\"><a href=\"#订阅模式-Direct\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h1><p>Direct，也称为直连模式。在该模式下必须队列的绑定 Routing key 与消息的 Routing key 完全一致才能接受到消息。</p>\n<p>订阅模式-Direct的约定：</p>\n<ul>\n<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</li>\n<li>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</li>\n<li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的绑定 Routing key 与消息的 Routing key 完全一致，才会接收到消息</li>\n</ul>\n<h2 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630664309047.jpg\" alt=\"订阅模式-Direct图解\">  </p>\n<ul>\n<li>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key</li>\n<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列</li>\n<li>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</li>\n<li>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</li>\n</ul>\n<h2 id=\"实现需求-2\"><a href=\"#实现需求-2\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>生产者发送 info、error、warning 路由键消息。<br>消费者1消费所有的消息，消费者2只消费error的消息。</p>\n<h2 id=\"消息生产者-2\"><a href=\"#消息生产者-2\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机类型</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            String routingKey;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;info&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-2\"><a href=\"#消息消费者-2\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消费者1：接受 warning，info，error 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;direct_consumer1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：接受 error 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;direct_consumer2&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库保存消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-3\"><a href=\"#执行结果-3\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动消息生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：direct。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175266353.jpg\" alt=\"声明direct类型交换机\"></p>\n<p>2）启动消息消费者</p>\n<p>启动消费者1和消费者2，可以看到绑定关系。<br>可以看到：消费者1等待接收warning，info，error路由键的消息，消费者2等待接收error路由键的消息。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175314170.jpg\" alt=\"direct类型交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看结果</p>\n<p>生产者发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175556983.jpg\" alt=\"生产者发送消息\"></p>\n<p>消费者1消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175568487.jpg\" alt=\"消费者1消费情况\"></p>\n<p>消费者2消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175573846.jpg\" alt=\"消费者2消费情况\"></p>\n<p>生产者分别发送warning，info，error路由键消息内容，消费者1都接收到了，消费者2只接收到error路由键的消息。</p>\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>订阅模式-Direct要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。</p>\n<h1 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h1><p>订阅模式-Topic的约定：</p>\n<ul>\n<li>Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符！</li>\n<li>Routing key 中可以存在两种特殊字符 “*”与“#”，用于做模糊匹配，其中 “*” 用于匹配一个单词，“#”用于匹配一个或多个词（可以是零个）</li>\n<li>Routing key 一般都是有一个或多个单词组成，这些单词可以是任意单词，多个单词之间以”.”分割，例如”stock.usd.nyse”, “nyse.vmw”</li>\n</ul>\n<h2 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631182623236.jpg\" alt=\"订阅模式-Topic图解\"></p>\n<ul>\n<li>红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到</li>\n<li>黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配</li>\n</ul>\n<h2 id=\"实现需求-3\"><a href=\"#实现需求-3\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>生产者发送 info、error、warning 路由键消息 和 订单相关的日志。<br>消费者1消费所有（#.info.#，#.error.#，#.warning.#）的消息；<br>消费者2只消费error的消息和订单相关的日志（#.error.#，#.order.#）。</p>\n<h2 id=\"消息生产者-3\"><a href=\"#消息生产者-3\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机类型</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            String routingKey = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;order&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;order.&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;info&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-3\"><a href=\"#消息消费者-3\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消费者1：接受 #.info.#，#.error.#，#.warning.# 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;topic_consumer1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.warning.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.info.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.error.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：接受 #.error.#，#.order.# 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;topic_consumer2&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.error.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;order.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库保存消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-4\"><a href=\"#执行结果-4\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动消息生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：topic。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242891106.jpg\" alt=\"声明topic类型交换机\"></p>\n<p>2）启动消息消费者</p>\n<p>启动消费者1和消费者2，可以看到绑定关系。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242898127.jpg\" alt=\"topic类型交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看结果</p>\n<p>生产者发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242903958.jpg\" alt=\"生产者发送消息\"></p>\n<p>消费者1消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242910856.jpg\" alt=\"消费者1消费情况\"></p>\n<p>消费者2消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242916251.jpg\" alt=\"消费者2消费情况\"></p>\n<p>生产者分别发送 warning，info，error，订单相关 路由键消息内容（共6条）。<br>消费者1都接收到了（接受到共6条），消费者2只接收到 error 与 订单 相关路由键的消息（接受到共4条）。</p>\n<h2 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>订阅-Topic模式可以实现 订阅-Funout模式 与 订阅-Direct模式 的功能，只是 订阅-Topic模式 在配置 routing key 的时候可以使用通配符，显得更加灵活。</p>\n<h1 id=\"Exchange-交换机\"><a href=\"#Exchange-交换机\" class=\"headerlink\" title=\"Exchange 交换机\"></a>Exchange 交换机</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>RabbitMQ 消息传递模式的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)。</p>\n<p>交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n<p>交换机是用来发送消息的AMQP实体。<br>交换机拿到一个消息之后将它路由给一个或零个队列。<br>交换机使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。<br>交换机只负责转发消息，不具备存储消息的功能，如果没有符合路由规则的队列，那么消息会丢失。</p>\n<h2 id=\"交换机属性\"><a href=\"#交换机属性\" class=\"headerlink\" title=\"交换机属性\"></a>交换机属性</h2><p>在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  </p>\n<ul>\n<li>Name  </li>\n<li>Type（交换机类型）</li>\n<li>Durability（消息代理重启后，交换机是否还存在）  </li>\n<li>Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  </li>\n<li>Arguments（依赖代理本身）</li>\n</ul>\n<h2 id=\"Binding-绑定\"><a href=\"#Binding-绑定\" class=\"headerlink\" title=\"Binding 绑定\"></a>Binding 绑定</h2><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。<br>如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<h2 id=\"交换机类型\"><a href=\"#交换机类型\" class=\"headerlink\" title=\"交换机类型\"></a>交换机类型</h2><p>AMQP 0-9-1的代理提供了四种交换机：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B.png\" alt=\"交换机类型\">  </p>\n<p>默认交换机，直连交换机，扇形交换机，主题交换机，头交换机；</p>\n<h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：<br>当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>基本消息模式和工作队列消息模式案例中使用的都是默认交换机，路由键名是队列名称，所以消息才可以成功的被发送到队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">* 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">* 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">* 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">* 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1，并将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<h3 id=\"实战-1\"><a href=\"#实战-1\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Fanout</p>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><h3 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。<br>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<h3 id=\"实战-2\"><a href=\"#实战-2\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Direct</p>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><h3 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “<em>” 与“#”，用于做模糊匹配，其中 “</em>” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<h3 id=\"实战-3\"><a href=\"#实战-3\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Topic</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RabbitMQ-基本概念\"><a href=\"#RabbitMQ-基本概念\" class=\"headerlink\" title=\"RabbitMQ 基本概念\"></a>RabbitMQ 基本概念</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息中间件。  </p>\n<p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，<br>你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是一个快递站，<br>一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件，而是接收，存储和转发消息数据。</p>\n<p>RabbitMQ官方地址：<a href=\"http://www.rabbitmq.com/\">http://www.rabbitmq.com</a></p>","more":"<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模式\"></p>\n<p>RabbitMQ核心概念：</p>\n<ul>\n<li>Broker<ul>\n<li>表示消息队列服务器实体（一个进程）。  </li>\n<li>一个server，接受客户端的连接，上线AMQP实体服务。</li>\n</ul>\n</li>\n<li>Connection<ul>\n<li>连接.</li>\n<li>应用程序与broker的网络连接，TCP/IP套接字连接。</li>\n</ul>\n</li>\n<li>Channel <ul>\n<li>消息通道 </li>\n<li>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个Channel，每个Channel代表一个会话任务。</li>\n</ul>\n</li>\n<li>Exchange<ul>\n<li>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</li>\n</ul>\n</li>\n<li>Queue<ul>\n<li>消息队列，存储消息，用于发送给消费者。</li>\n<li>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li>\n</ul>\n</li>\n<li>Binding<ul>\n<li>绑定，消息队列和交换器之间的关联。</li>\n<li>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li>\n</ul>\n</li>\n<li>Routing Key<ul>\n<li>路由关键字，一个消息头，交换机可以用这个消息头决定如何路由某条消息。</li>\n</ul>\n</li>\n<li>Message<ul>\n<li>消息</li>\n<li>消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</li>\n</ul>\n</li>\n<li>Publisher<ul>\n<li>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</li>\n</ul>\n</li>\n<li>Consumer<ul>\n<li>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</li>\n</ul>\n</li>\n<li>Virtual Host  <ul>\n<li>虚拟主机</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"消息模式\"><a href=\"#消息模式\" class=\"headerlink\" title=\"消息模式\"></a>消息模式</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626769058993.jpg\" alt=\"消息模式\"></p>\n<ol>\n<li>简单模式（simple）</li>\n<li>工作队列模式（work queues）</li>\n<li>订阅模式-Fanout（publish/subscribe）</li>\n<li>订阅模式-Direct（routing）</li>\n<li>订阅模式-Topic（topics）</li>\n</ol>\n<p><strong>注意：订阅模式-Fanout，订阅模式-Direct，订阅模式-Topic都属于发布/订阅模式类型。</strong></p>\n<h1 id=\"RabbitMQ-安装和配置\"><a href=\"#RabbitMQ-安装和配置\" class=\"headerlink\" title=\"RabbitMQ 安装和配置\"></a>RabbitMQ 安装和配置</h1><h2 id=\"相关版本\"><a href=\"#相关版本\" class=\"headerlink\" title=\"相关版本\"></a>相关版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erlang 21.3.x</span><br><span class=\"line\">rabbitmq 3.8.8</span><br></pre></td></tr></table></figure>\n\n<p>Erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/erlang-rpm/releases\">https://github.com/rabbitmq/erlang-rpm/releases</a></p>\n<p>Rabbitmq rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm\">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</a></p>\n<h2 id=\"Linux下安装\"><a href=\"#Linux下安装\" class=\"headerlink\" title=\"Linux下安装\"></a>Linux下安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linux（CentOS 7.5）</span><br><span class=\"line\">erlang 21.3.x</span><br><span class=\"line\">rabbitmq 3.8.8</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Erlang\"><a href=\"#安装Erlang\" class=\"headerlink\" title=\"安装Erlang\"></a>安装Erlang</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/erlang%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本信息\"><br>下载erlang时需要注意，要和rabbitmq版本兼容.</p>\n<p>1）erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm\">https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.1/erlang-21.3.1-1.el7.x86_64.rpm</a><br>erlang-21.3.1-1.el7.x86_64.rpm</p>\n<p>2）rpm上传到系统中，安装erlang<br>rpm -ivh erlang-21.3-1.el7.x86_64.rpm</p>\n<p>3）查看erlang版本<br>erl -v</p>\n<h3 id=\"安装socat\"><a href=\"#安装socat\" class=\"headerlink\" title=\"安装socat\"></a>安装socat</h3><p>安装Erlang后直接安装RabbitMQ，需要安装socat。</p>\n<p>安装socat：<br>yum install socat -y</p>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）rabbitmq rpm下载  </span><br><span class=\"line\">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">2）rpm上传到系统中，并安装rabbitmq  </span><br><span class=\"line\">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm </span><br><span class=\"line\"></span><br><span class=\"line\">3）启动服务并测试  </span><br><span class=\"line\"># 启动服务 </span><br><span class=\"line\">service rabbitmq-server start</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\"></span><br><span class=\"line\">4）常用命令</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动服务 </span><br><span class=\"line\">service rabbitmq-server start </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止服务 </span><br><span class=\"line\">service rabbitmq-server stop</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启服务 </span><br><span class=\"line\">service rabbitmq-server restart</span><br><span class=\"line\"></span><br><span class=\"line\"># 开机自动启动 </span><br><span class=\"line\">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Windos下安装\"><a href=\"#Windos下安装\" class=\"headerlink\" title=\"Windos下安装\"></a>Windos下安装</h2><h2 id=\"Mac下安装\"><a href=\"#Mac下安装\" class=\"headerlink\" title=\"Mac下安装\"></a>Mac下安装</h2><h2 id=\"RabbitMQ-管理界面及授权操作\"><a href=\"#RabbitMQ-管理界面及授权操作\" class=\"headerlink\" title=\"RabbitMQ 管理界面及授权操作\"></a>RabbitMQ 管理界面及授权操作</h2><h3 id=\"管理界面\"><a href=\"#管理界面\" class=\"headerlink\" title=\"管理界面\"></a>管理界面</h3><p>1）默认情况下，是没有安装web端的客户端插件，需要安装才可以生效。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n<p>注意：管理界面会在15672端口提供服务</p>\n<p>2）安装完毕以后，重启服务即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service rabbitmq-server restart</span><br></pre></td></tr></table></figure>\n\n<p>3）在浏览器访问  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 关闭防火墙服务</span><br><span class=\"line\">## 关闭防火墙</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">## 关闭防火墙开机启动</span><br><span class=\"line\">systemctl disable firewalld</span><br><span class=\"line\"># 注意：一定要记住，在对应服务器（阿里云，腾讯云等）的安全组中开放15672端口</span><br><span class=\"line\"></span><br><span class=\"line\"># 访问web管理界面</span><br><span class=\"line\">http://106.52.180.14:15672</span><br></pre></td></tr></table></figure>\n\n<p>成功访问：<img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626777167279.jpg\" alt=\"RabbitMQ管理界面\"></p>\n<h3 id=\"授权账号和密码\"><a href=\"#授权账号和密码\" class=\"headerlink\" title=\"授权账号和密码\"></a>授权账号和密码</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721213622.png\" alt=\"guest登录\"><br>说明：rabbitmq有一个默认账号和密码是：guest/guest，但guest默认情况只能在localhost本机下访问，所以需要添加一个远程登录的用户。</p>\n<p>1）新增用户并授权：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新增用户</span><br><span class=\"line\">rabbitmqctl add_user admin 123</span><br><span class=\"line\"></span><br><span class=\"line\">#设置用户分配操作权限</span><br><span class=\"line\">rabbitmqctl set_user_tags admin administrator</span><br><span class=\"line\"></span><br><span class=\"line\">#为用户添加资源权限</span><br><span class=\"line\">#set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class=\"line\">#解释：用户 admin 具有 / 这个 virtual host 中所有资源的配置、写、读权限</span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>\n\n<p>2）使用admin登录管理页面<br>登录成功：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721215337.png\" alt=\"admin登录\">  </p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>管理用户常见命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看用户列表</span><br><span class=\"line\">rabbitmqctl list_users</span><br><span class=\"line\"></span><br><span class=\"line\"># 新增账号[并设置密码]</span><br><span class=\"line\">rabbitmqctl add_user 账号 密码</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改密码</span><br><span class=\"line\">rabbitmqctl change_password 账号 新密码</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除账号</span><br><span class=\"line\">rabbitmqctl delete_user 账号</span><br><span class=\"line\"></span><br><span class=\"line\"># 给账号设置角色</span><br><span class=\"line\">rabbitmqctl set_user_tags 账号 角色</span><br><span class=\"line\"></span><br><span class=\"line\"># 给账号设置权限</span><br><span class=\"line\">rabbitmqctl set_permissions -p &quot;/&quot; 账号 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"快速入门（simple）\"><a href=\"#快速入门（simple）\" class=\"headerlink\" title=\"快速入门（simple）\"></a>快速入门（simple）</h1><h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>在学习RabbitMQ前必须掌握以下内容：<br>熟悉使用Java<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具  </p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>RabbitMQ 3.8.8</p>\n<h2 id=\"实现需求\"><a href=\"#实现需求\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>需求：使用简单模式完成消息传递;</p>\n<ol>\n<li>创建生产者程序，发送消息</li>\n<li>创建消费者程序，消费消息</li>\n</ol>\n<h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- rabbitmq 依赖客户端 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息生产者\"><a href=\"#消息生产者\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><p>消息生产者：生产消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 5.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息发送完成~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者\"><a href=\"#消息消费者\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消息消费者：消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动生产者，发送消息</p>\n<p>启动生产者，发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949235794.jpg\" alt=\"生产者发送消息\"></p>\n<p>查看管理页面，可以发现：新建了一个队列：Hello，并且队列里有一条消息等待读取：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949728101.jpg\" alt=\"管理页面，查看队列\"></p>\n<p>进入队列详情，还可以看到消息主题内容：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949629441.jpg\" alt=\"管理页面，查看消息主体内容\"></p>\n<p>2）启动消费者，消费消息</p>\n<p>启动消费者，消费消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949896540.jpg\" alt=\"消费者消费消息\"></p>\n<p>查看管理页面，可以发现：Hello队列，消息已经被消费了：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626949947003.jpg\" alt=\"管理页面，查看队列\"></p>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>上述的入门案例中其实使用的是的简单模式。</p>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721223009.png\" alt=\"基本消息模式\"><br>在上图的模式中，有以下概念：</p>\n<ol>\n<li>生产者（P）：也就是要发送消息的程序</li>\n<li>消费者（C）：消息的接受者，会一直等待消息到来。</li>\n<li>消息队列：图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>\n</ol>\n<h1 id=\"工作队列模式（work-queue）\"><a href=\"#工作队列模式（work-queue）\" class=\"headerlink\" title=\"工作队列模式（work queue）\"></a>工作队列模式（work queue）</h1><p>工作队列(又称任务队列)<br>主要思想是避免立即执行资源密集型任务，必须等待它执行完成。<br>相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。</p>\n<h2 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721224055.png\" alt=\"工作消息模式\">  </p>\n<ul>\n<li>Work Queues：与基本消息模式相比，多了一个或多个消费者，多个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。</li>\n<li>应用场景：对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。</li>\n</ul>\n<p>思考：当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？<br>主要有两种模式：</p>\n<ol>\n<li>轮询分发：一个消费者一条，按均分配；</li>\n<li>不公平分发：根据消费者的消费能力进行分发，处理快的处理的多，处理慢的处理的少；</li>\n</ol>\n<h2 id=\"抽取工具类\"><a href=\"#抽取工具类\" class=\"headerlink\" title=\"抽取工具类\"></a>抽取工具类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqUtils</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工厂</span></span><br><span class=\"line\">        ConnectionFactory factory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        factory.setHost(<span class=\"string\">&quot;106.52.180.14&quot;</span>);</span><br><span class=\"line\">        factory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        factory.setUsername(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        factory.setPassword(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = factory.newConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道（实现了自动 close 接口 自动关闭 不需要显示关闭）</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"轮询分发\"><a href=\"#轮询分发\" class=\"headerlink\" title=\"轮询分发\"></a>轮询分发</h2><h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;work_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息，模拟发送多个消息，测试工作队列</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;work_queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;, (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><p>1）启动两个消息者线程，模拟两个消费者在监听队列消息消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232358.png\" alt=\"消费者1\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232422.png\" alt=\"消费者2\">  </p>\n<p>2）启动生产者进行发送消息。</p>\n<p>3）结论<br>通过生产者总共发送 4 个消息；<br>消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20210721232715.png\" alt=\"工作消息模式\">  </p>\n<h2 id=\"不公平分发（能者多劳）\"><a href=\"#不公平分发（能者多劳）\" class=\"headerlink\" title=\"不公平分发（能者多劳）\"></a>不公平分发（能者多劳）</h2><p>以上RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好。<br>比方说：有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话，<br>这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况，它依然很公平的进行分发。</p>\n<p>现在想要做的是：不公平分发，消费越快的人，消费的越多，怎么实现呢？在消费者指定prefetchCount。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer prefetchCount = <span class=\"number\">1</span></span><br><span class=\"line\">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1626919721516.jpg\" alt=\"不公平分发图\"></p>\n<p>解释：如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，<br>然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，<br>队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>\n<h2 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>在一个队列中，如果有多个消费者，那么消费者之间对同一个消息的关系是竞争关系，一个消息只能被一个消费者获取。</li>\n<li>Work Queues 对于任务过重或任务比较多情况使用工作队列可以提高任务处理的速度。列如：关系服务部署多个，只需要一个节点成功发送即可。</li>\n</ol>\n<h1 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h1><p>Fanout，也称为广播模式。在改模式下会将消息交给所有绑定到交换机的队列。</p>\n<h2 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630658875186.jpg\" alt=\"订阅模式-Fanout\"></p>\n<ul>\n<li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给交换机（X）</li>\n<li>C：消费者，消息的接收者，会一直等待消息到来</li>\n<li>Queue：消息队列，接收消息、缓存消息</li>\n<li>Exchange：交换机（X），一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li>\n<li>Fanout类型交换机会将消息交给所有绑定到交换机的队列。</li>\n</ul>\n<h2 id=\"实现需求-1\"><a href=\"#实现需求-1\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>同一个消息，通过订阅模式-Fanout被多个消费者消费。</p>\n<h2 id=\"消息生产者-1\"><a href=\"#消息生产者-1\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><p>变化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 声明Exchange，不再声明Queue</span><br><span class=\"line\">2. 发送消息到指定Exchange，而不是默认交换机</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Producer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明交换机</span><br><span class=\"line\">         * 参数1：交换机名称</span><br><span class=\"line\">         * 参数2：交换机类型</span><br><span class=\"line\">         * 参数3：是否持久化</span><br><span class=\"line\">         * 参数4：是否自动删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 发送消息</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\">        while (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            /**</span><br><span class=\"line\">             * 3.发送消息</span><br><span class=\"line\">             * 参数1：交换机（不指定，使用默认交换机）</span><br><span class=\"line\">             * 参数2：路由键</span><br><span class=\"line\">             * 参数3：其他参数</span><br><span class=\"line\">             * 参数4：消息主体</span><br><span class=\"line\">             */</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());</span><br><span class=\"line\">            System.out.println(&quot;发送消息：&quot; + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-1\"><a href=\"#消息消费者-1\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>变化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 需要声明队列</span><br><span class=\"line\">2. 建立队列与交换机的绑定</span><br></pre></td></tr></table></figure>\n\n<p>消费者1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Consumer1 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;funout_consumer1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明队列</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span><br><span class=\"line\">         * 参数3：是否独占队列</span><br><span class=\"line\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3.绑定（队列与交换机建立绑定）</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：交换机名称</span><br><span class=\"line\">         * 参数3：路由键</span><br><span class=\"line\">         *          如果交换机类型为fanout，routingKey设置为&quot;&quot;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息的程序</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            // 模拟异常</span><br><span class=\"line\">            String msgBody = new String(message.getBody());</span><br><span class=\"line\">            System.out.println(&quot;控制台打印消息，消息内容：&quot; + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息失败的程序</span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;消费消息失败了~&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4.接受消息</span><br><span class=\"line\">         * 参数1：监听的队列</span><br><span class=\"line\">         * 参数2：是否自动应答</span><br><span class=\"line\">         * 参数3：消费消息的程序</span><br><span class=\"line\">         * 参数4：消费消息失败的程序</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Consumer2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String EXCHANGE_NAME = &quot;test.fanout&quot;;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;funout_consumer2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">        // 1.获取通道</span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 2.声明队列</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span><br><span class=\"line\">         * 参数3：是否独占队列</span><br><span class=\"line\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span><br><span class=\"line\">         * 参数5：其他参数</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 3.绑定（队列与交换机建立绑定）</span><br><span class=\"line\">         * 参数1：队列名称</span><br><span class=\"line\">         * 参数2：交换机名称</span><br><span class=\"line\">         * 参数3：路由键</span><br><span class=\"line\">         *          如果交换机类型为fanout，routingKey设置为&quot;&quot;</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息的程序</span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            // 模拟异常</span><br><span class=\"line\">            String msgBody = new String(message.getBody());</span><br><span class=\"line\">            System.out.println(&quot;消息保存到数据，消息内容：&quot; + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费消息失败的程序</span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;消费消息失败了~&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 4.接受消息</span><br><span class=\"line\">         * 参数1：监听的队列</span><br><span class=\"line\">         * 参数2：是否自动应答</span><br><span class=\"line\">         * 参数3：消费消息的程序</span><br><span class=\"line\">         * 参数4：消费消息失败的程序</span><br><span class=\"line\">         */</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659575657.jpg\" alt=\"fanout-自己声明的交换机\"></p>\n<p>2）启动消费者</p>\n<p>启动两个消费者后，可以在交换机上看到队列与交换机的绑定关系<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630659702681.jpg\" alt=\"fanout-队列&amp;交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看消费者消息情况</p>\n<p>这边不演示了，当发送三条消息后，每个消费者都可以消费到三条消息。<br>得出结论：每个队列里面的消息只能被消费一次，但可以通过订阅模式-funout下声明多个队列来多次消费同一条消息。</p>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在订阅-fanout模式下的小结：</p>\n<ol>\n<li>消费者可以有自己的Queue（多个队列）</li>\n<li>队列要绑定到Exchange（交换机）</li>\n<li>当交换机类型为fanout，会把消息发送给绑定过的所有队列（忽略路由键）</li>\n<li>在订阅-fanout模式下，多个队列可以存储同一个消息，实现一条消息被多个消费者消费</li>\n<li>订阅-fanout与工作队列模式的区别：<ul>\n<li>发布/订阅模式需要定义交换机，而工作队列模式不用定义交换机（工作队列使用默认交换机）</li>\n<li>发布/订阅模式需要设置队列和交换机的绑定，工作队列不需要设置（工作队列实际上会自动将队列绑定到默认的交换机上）</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"订阅模式-Direct\"><a href=\"#订阅模式-Direct\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h1><p>Direct，也称为直连模式。在该模式下必须队列的绑定 Routing key 与消息的 Routing key 完全一致才能接受到消息。</p>\n<p>订阅模式-Direct的约定：</p>\n<ul>\n<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</li>\n<li>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</li>\n<li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的绑定 Routing key 与消息的 Routing key 完全一致，才会接收到消息</li>\n</ul>\n<h2 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1630664309047.jpg\" alt=\"订阅模式-Direct图解\">  </p>\n<ul>\n<li>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key</li>\n<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列</li>\n<li>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</li>\n<li>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</li>\n</ul>\n<h2 id=\"实现需求-2\"><a href=\"#实现需求-2\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>生产者发送 info、error、warning 路由键消息。<br>消费者1消费所有的消息，消费者2只消费error的消息。</p>\n<h2 id=\"消息生产者-2\"><a href=\"#消息生产者-2\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机类型</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            String routingKey;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;info&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-2\"><a href=\"#消息消费者-2\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消费者1：接受 warning，info，error 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;direct_consumer1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：接受 error 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.direct&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;direct_consumer2&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库保存消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-3\"><a href=\"#执行结果-3\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动消息生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：direct。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175266353.jpg\" alt=\"声明direct类型交换机\"></p>\n<p>2）启动消息消费者</p>\n<p>启动消费者1和消费者2，可以看到绑定关系。<br>可以看到：消费者1等待接收warning，info，error路由键的消息，消费者2等待接收error路由键的消息。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175314170.jpg\" alt=\"direct类型交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看结果</p>\n<p>生产者发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175556983.jpg\" alt=\"生产者发送消息\"></p>\n<p>消费者1消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175568487.jpg\" alt=\"消费者1消费情况\"></p>\n<p>消费者2消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631175573846.jpg\" alt=\"消费者2消费情况\"></p>\n<p>生产者分别发送warning，info，error路由键消息内容，消费者1都接收到了，消费者2只接收到error路由键的消息。</p>\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>订阅模式-Direct要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。</p>\n<h1 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h1><p>订阅模式-Topic的约定：</p>\n<ul>\n<li>Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符！</li>\n<li>Routing key 中可以存在两种特殊字符 “*”与“#”，用于做模糊匹配，其中 “*” 用于匹配一个单词，“#”用于匹配一个或多个词（可以是零个）</li>\n<li>Routing key 一般都是有一个或多个单词组成，这些单词可以是任意单词，多个单词之间以”.”分割，例如”stock.usd.nyse”, “nyse.vmw”</li>\n</ul>\n<h2 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h2><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631182623236.jpg\" alt=\"订阅模式-Topic图解\"></p>\n<ul>\n<li>红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到</li>\n<li>黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配</li>\n</ul>\n<h2 id=\"实现需求-3\"><a href=\"#实现需求-3\" class=\"headerlink\" title=\"实现需求\"></a>实现需求</h2><p>生产者发送 info、error、warning 路由键消息 和 订单相关的日志。<br>消费者1消费所有（#.info.#，#.error.#，#.warning.#）的消息；<br>消费者2只消费error的消息和订单相关的日志（#.error.#，#.order.#）。</p>\n<h2 id=\"消息生产者-3\"><a href=\"#消息生产者-3\" class=\"headerlink\" title=\"消息生产者\"></a>消息生产者</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明交换机</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机类型</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否持久化</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">            String message = scanner.next();</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * 3.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">             * 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            String routingKey = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;order&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey = <span class=\"string\">&quot;order.&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;info&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message.contains(<span class=\"string\">&quot;error&quot;</span>)) &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                routingKey += <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class=\"keyword\">null</span>, message.getBytes());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;发送消息：&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息消费者-3\"><a href=\"#消息消费者-3\" class=\"headerlink\" title=\"消息消费者\"></a>消息消费者</h2><p>消费者1：接受 #.info.#，#.error.#，#.warning.# 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;topic_consumer1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.warning.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.info.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.error.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;控制台打印消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者2：接受 #.error.#，#.order.# 路由键的消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String EXCHANGE_NAME = <span class=\"string\">&quot;test.topic&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> String QUEUE_NAME = <span class=\"string\">&quot;topic_consumer2&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.声明队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否持久化队列，不持久化的队列重启访问后丢失</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：是否独占队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：是否自动删除队列，当最后一个消费者退订后即被删除</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数5：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.绑定（队列与交换机建立绑定）</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：队列名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：交换机名称</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：路由键</span></span><br><span class=\"line\"><span class=\"comment\">         *          如果交换机类型为direct，routingKey设置为想要接受的消息路由键</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;#.error.#&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class=\"string\">&quot;order.#&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息的程序</span></span><br><span class=\"line\">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">            String msgBody = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;数据库保存消息，消息内容：&quot;</span> + msgBody);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 消费消息失败的程序</span></span><br><span class=\"line\">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;消费消息失败了~&quot;</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 4.接受消息</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数1：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数2：是否自动应答</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数3：消费消息的程序</span></span><br><span class=\"line\"><span class=\"comment\">         * 参数4：消费消息失败的程序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, deliverCallback, cancelCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行结果-4\"><a href=\"#执行结果-4\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h2><p>1）启动消息生产者</p>\n<p>启动生产者后，可以看到我们自己声明的交换机，并且交换机类型是：topic。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242891106.jpg\" alt=\"声明topic类型交换机\"></p>\n<p>2）启动消息消费者</p>\n<p>启动消费者1和消费者2，可以看到绑定关系。<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242898127.jpg\" alt=\"topic类型交换机绑定关系\"></p>\n<p>3）生产者发送消息，查看结果</p>\n<p>生产者发送消息：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242903958.jpg\" alt=\"生产者发送消息\"></p>\n<p>消费者1消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242910856.jpg\" alt=\"消费者1消费情况\"></p>\n<p>消费者2消费情况：<br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1631242916251.jpg\" alt=\"消费者2消费情况\"></p>\n<p>生产者分别发送 warning，info，error，订单相关 路由键消息内容（共6条）。<br>消费者1都接收到了（接受到共6条），消费者2只接收到 error 与 订单 相关路由键的消息（接受到共4条）。</p>\n<h2 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>订阅-Topic模式可以实现 订阅-Funout模式 与 订阅-Direct模式 的功能，只是 订阅-Topic模式 在配置 routing key 的时候可以使用通配符，显得更加灵活。</p>\n<h1 id=\"Exchange-交换机\"><a href=\"#Exchange-交换机\" class=\"headerlink\" title=\"Exchange 交换机\"></a>Exchange 交换机</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>RabbitMQ 消息传递模式的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)。</p>\n<p>交换机工作的内容非常简单：一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>\n<p>交换机是用来发送消息的AMQP实体。<br>交换机拿到一个消息之后将它路由给一个或零个队列。<br>交换机使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。<br>交换机只负责转发消息，不具备存储消息的功能，如果没有符合路由规则的队列，那么消息会丢失。</p>\n<h2 id=\"交换机属性\"><a href=\"#交换机属性\" class=\"headerlink\" title=\"交换机属性\"></a>交换机属性</h2><p>在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：  </p>\n<ul>\n<li>Name  </li>\n<li>Type（交换机类型）</li>\n<li>Durability（消息代理重启后，交换机是否还存在）  </li>\n<li>Auto-delete（当所有与之绑定的消息队列都完成了对此交换机的使用后，删除它）  </li>\n<li>Arguments（依赖代理本身）</li>\n</ul>\n<h2 id=\"Binding-绑定\"><a href=\"#Binding-绑定\" class=\"headerlink\" title=\"Binding 绑定\"></a>Binding 绑定</h2><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。<br>如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<h2 id=\"交换机类型\"><a href=\"#交换机类型\" class=\"headerlink\" title=\"交换机类型\"></a>交换机类型</h2><p>AMQP 0-9-1的代理提供了四种交换机：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B.png\" alt=\"交换机类型\">  </p>\n<p>默认交换机，直连交换机，扇形交换机，主题交换机，头交换机；</p>\n<h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：<br>当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>基本消息模式和工作队列消息模式案例中使用的都是默认交换机，路由键名是队列名称，所以消息才可以成功的被发送到队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.发送消息</span></span><br><span class=\"line\"><span class=\"comment\">* 参数1：交换机（不指定，使用默认交换机）</span></span><br><span class=\"line\"><span class=\"comment\">* 参数2：路由键</span></span><br><span class=\"line\"><span class=\"comment\">* 参数3：其他参数</span></span><br><span class=\"line\"><span class=\"comment\">* 参数4：消息主体</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">String message = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>扇型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1，并将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<h3 id=\"实战-1\"><a href=\"#实战-1\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Fanout</p>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><h3 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连型交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。<br>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<h3 id=\"实战-2\"><a href=\"#实战-2\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Direct</p>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><h3 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “<em>” 与“#”，用于做模糊匹配，其中 “</em>” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://rong0624.gitee.io/images/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<h3 id=\"实战-3\"><a href=\"#实战-3\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>请看：订阅模式-Topic</p>"},{"title":"RabbitMQ-集群","date":"2021-09-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n大龄剩女着急结婚的，基本上都有难言之隐。\n大龄剩女经历得多，心思重，城府深，你要是不提防着她，弄不巧就阴沟里翻船——底朝天啊。\n兄弟，送你一句话：看一个女人要看她的过去，看一个男人要看他的未来。\n现在的舆论环境，把女性捧得比天还高，如果我要是把这些话说出来了，我还不得被喷死。\n男人嘛，表面上要学会给女性说好话听，谁也不得罪。毕竟如果你要是得罪了一个女人，你基本上得罪了一个范围内的所有女人。\n所以在舆论上来说，尽量顺了女性的心意，把她们往天上吹，这样你就会成为一个受欢迎的男人。因为女人堆里提到你就是好男人，这样更多的女性会把你当成一个潜在的交往对象，你的资源不就多了起来了吗？\n我说的那些对女性的要求，都是不能说出来的，因为说出来，会被喷成大男子主义，这样就很难在女人圈子里搞好名声了。\n所以，和女人交往，一定要在嘴上尽情地吹捧她们。\n但是，在要不要结婚的关键时刻，千万不要放下自己的要求，这时候最好的办法就是找一些既不影响自己的口碑，又能够拒绝对方的理由来加以回绝。\n在拒绝的时候，一定要同时吹捧对方，让她还是飘在天上，不能掉地上，毕竟你要是打破了对方的梦，她还不得在背后嚼舌根把你踩到泥土里，够你受的。\n对女人，千万不要跟她讲道理。因为女性是活在幻想中的，她们根本不愿意接受道理，更不要说面对现实了，讲了也没用，而且还会遭人烦。\n最好的办法就是，无脑吹，把她们捧到天上去。慢慢地，时间会让她们从天上掉下来的。\n记住：打败女人的，唯有时间！熬过那几年，她比你要着急。\n不要听什么说现在能够养活自己，做一个独立的女人这种鬼话。\n那是她们还年轻，那是她们还有父母做后盾。一场疫情下来，经济下滑了，看看有多少女人想结婚。\n经济好的时候，女人能赚点钱养活自己，可以对外宣称自己不需要男人；经济变差了，养活不了自己了，开始想着结婚了。\n经济会一直好下去吗？会一直年轻能赚钱吗？\n能赚钱的只有少数人，那些\n男人，把所有的时间放在搞钱上，你要是像我这么有钱，你就会发现，你再也看不上那些年龄超过30岁的女人了，因为你想要的她们早已没了，她们有的，你也早都有了。\n不要着急，因为，她们比你还着急，哈哈！","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-集群.md","raw":"---\ntitle: RabbitMQ-集群\ndate: 2021-09-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n大龄剩女着急结婚的，基本上都有难言之隐。\n大龄剩女经历得多，心思重，城府深，你要是不提防着她，弄不巧就阴沟里翻船——底朝天啊。\n兄弟，送你一句话：看一个女人要看她的过去，看一个男人要看他的未来。\n现在的舆论环境，把女性捧得比天还高，如果我要是把这些话说出来了，我还不得被喷死。\n男人嘛，表面上要学会给女性说好话听，谁也不得罪。毕竟如果你要是得罪了一个女人，你基本上得罪了一个范围内的所有女人。\n所以在舆论上来说，尽量顺了女性的心意，把她们往天上吹，这样你就会成为一个受欢迎的男人。因为女人堆里提到你就是好男人，这样更多的女性会把你当成一个潜在的交往对象，你的资源不就多了起来了吗？\n我说的那些对女性的要求，都是不能说出来的，因为说出来，会被喷成大男子主义，这样就很难在女人圈子里搞好名声了。\n所以，和女人交往，一定要在嘴上尽情地吹捧她们。\n但是，在要不要结婚的关键时刻，千万不要放下自己的要求，这时候最好的办法就是找一些既不影响自己的口碑，又能够拒绝对方的理由来加以回绝。\n在拒绝的时候，一定要同时吹捧对方，让她还是飘在天上，不能掉地上，毕竟你要是打破了对方的梦，她还不得在背后嚼舌根把你踩到泥土里，够你受的。\n对女人，千万不要跟她讲道理。因为女性是活在幻想中的，她们根本不愿意接受道理，更不要说面对现实了，讲了也没用，而且还会遭人烦。\n最好的办法就是，无脑吹，把她们捧到天上去。慢慢地，时间会让她们从天上掉下来的。\n记住：打败女人的，唯有时间！熬过那几年，她比你要着急。\n不要听什么说现在能够养活自己，做一个独立的女人这种鬼话。\n那是她们还年轻，那是她们还有父母做后盾。一场疫情下来，经济下滑了，看看有多少女人想结婚。\n经济好的时候，女人能赚点钱养活自己，可以对外宣称自己不需要男人；经济变差了，养活不了自己了，开始想着结婚了。\n经济会一直好下去吗？会一直年轻能赚钱吗？\n能赚钱的只有少数人，那些\n男人，把所有的时间放在搞钱上，你要是像我这么有钱，你就会发现，你再也看不上那些年龄超过30岁的女人了，因为你想要的她们早已没了，她们有的，你也早都有了。\n不要着急，因为，她们比你还着急，哈哈！","slug":"oyr/MQ/RabbitMQ/RabbitMQ-集群","published":1,"updated":"2021-10-26T10:30:26.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87o006vcst761ri5w5d","content":"<p>大龄剩女着急结婚的，基本上都有难言之隐。<br>大龄剩女经历得多，心思重，城府深，你要是不提防着她，弄不巧就阴沟里翻船——底朝天啊。<br>兄弟，送你一句话：看一个女人要看她的过去，看一个男人要看他的未来。<br>现在的舆论环境，把女性捧得比天还高，如果我要是把这些话说出来了，我还不得被喷死。<br>男人嘛，表面上要学会给女性说好话听，谁也不得罪。毕竟如果你要是得罪了一个女人，你基本上得罪了一个范围内的所有女人。<br>所以在舆论上来说，尽量顺了女性的心意，把她们往天上吹，这样你就会成为一个受欢迎的男人。因为女人堆里提到你就是好男人，这样更多的女性会把你当成一个潜在的交往对象，你的资源不就多了起来了吗？<br>我说的那些对女性的要求，都是不能说出来的，因为说出来，会被喷成大男子主义，这样就很难在女人圈子里搞好名声了。<br>所以，和女人交往，一定要在嘴上尽情地吹捧她们。<br>但是，在要不要结婚的关键时刻，千万不要放下自己的要求，这时候最好的办法就是找一些既不影响自己的口碑，又能够拒绝对方的理由来加以回绝。<br>在拒绝的时候，一定要同时吹捧对方，让她还是飘在天上，不能掉地上，毕竟你要是打破了对方的梦，她还不得在背后嚼舌根把你踩到泥土里，够你受的。<br>对女人，千万不要跟她讲道理。因为女性是活在幻想中的，她们根本不愿意接受道理，更不要说面对现实了，讲了也没用，而且还会遭人烦。<br>最好的办法就是，无脑吹，把她们捧到天上去。慢慢地，时间会让她们从天上掉下来的。<br>记住：打败女人的，唯有时间！熬过那几年，她比你要着急。<br>不要听什么说现在能够养活自己，做一个独立的女人这种鬼话。<br>那是她们还年轻，那是她们还有父母做后盾。一场疫情下来，经济下滑了，看看有多少女人想结婚。<br>经济好的时候，女人能赚点钱养活自己，可以对外宣称自己不需要男人；经济变差了，养活不了自己了，开始想着结婚了。<br>经济会一直好下去吗？会一直年轻能赚钱吗？<br>能赚钱的只有少数人，那些<br>男人，把所有的时间放在搞钱上，你要是像我这么有钱，你就会发现，你再也看不上那些年龄超过30岁的女人了，因为你想要的她们早已没了，她们有的，你也早都有了。<br>不要着急，因为，她们比你还着急，哈哈！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>大龄剩女着急结婚的，基本上都有难言之隐。<br>大龄剩女经历得多，心思重，城府深，你要是不提防着她，弄不巧就阴沟里翻船——底朝天啊。<br>兄弟，送你一句话：看一个女人要看她的过去，看一个男人要看他的未来。<br>现在的舆论环境，把女性捧得比天还高，如果我要是把这些话说出来了，我还不得被喷死。<br>男人嘛，表面上要学会给女性说好话听，谁也不得罪。毕竟如果你要是得罪了一个女人，你基本上得罪了一个范围内的所有女人。<br>所以在舆论上来说，尽量顺了女性的心意，把她们往天上吹，这样你就会成为一个受欢迎的男人。因为女人堆里提到你就是好男人，这样更多的女性会把你当成一个潜在的交往对象，你的资源不就多了起来了吗？<br>我说的那些对女性的要求，都是不能说出来的，因为说出来，会被喷成大男子主义，这样就很难在女人圈子里搞好名声了。<br>所以，和女人交往，一定要在嘴上尽情地吹捧她们。<br>但是，在要不要结婚的关键时刻，千万不要放下自己的要求，这时候最好的办法就是找一些既不影响自己的口碑，又能够拒绝对方的理由来加以回绝。<br>在拒绝的时候，一定要同时吹捧对方，让她还是飘在天上，不能掉地上，毕竟你要是打破了对方的梦，她还不得在背后嚼舌根把你踩到泥土里，够你受的。<br>对女人，千万不要跟她讲道理。因为女性是活在幻想中的，她们根本不愿意接受道理，更不要说面对现实了，讲了也没用，而且还会遭人烦。<br>最好的办法就是，无脑吹，把她们捧到天上去。慢慢地，时间会让她们从天上掉下来的。<br>记住：打败女人的，唯有时间！熬过那几年，她比你要着急。<br>不要听什么说现在能够养活自己，做一个独立的女人这种鬼话。<br>那是她们还年轻，那是她们还有父母做后盾。一场疫情下来，经济下滑了，看看有多少女人想结婚。<br>经济好的时候，女人能赚点钱养活自己，可以对外宣称自己不需要男人；经济变差了，养活不了自己了，开始想着结婚了。<br>经济会一直好下去吗？会一直年轻能赚钱吗？<br>能赚钱的只有少数人，那些<br>男人，把所有的时间放在搞钱上，你要是像我这么有钱，你就会发现，你再也看不上那些年龄超过30岁的女人了，因为你想要的她们早已没了，她们有的，你也早都有了。<br>不要着急，因为，她们比你还着急，哈哈！</p>\n"},{"title":"RabbitMQ-应用问题","date":"2021-10-25T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 如何保证消息不丢失\n\n## 消息丢失场景\n\n### 生产者消息丢失\n\n#### 问题\n\n- 外界环境问题导致：发生网络丢包、网络故障等造成RabbitMQ Server端收不到消息，因为生产环境的网络是很复杂的，网络抖动，丢包现象很常见\n    - 一般情况下，生产者使用Confirm模式投递消息，如果方案不够严谨，比如RabbitMQ Server 接收消息失败后会发送nack消息通知生产者，生产者监听消息失败或者没做任何事情，消息存在丢失风险；\n- 代码层面，配置层面，考虑不全导致消息丢失\n    - 生产者发送消息到exchange后，发送的路由和queue没有绑定，消息会存在丢失情况，下面会讲到具体的例子，保证意外情况的发生，即使发生，也在可控范围内。\n\n### MQ存储的消息丢失或可靠性不足\n\n- 消息未完全持久化，当机器重启后，消息会全部丢失，甚至Queue也不见了\n- 单节点模式问题，如果某个节点挂了，消息就不能用了，业务可能瘫痪，只能等待\n    - 如果做了消息持久化方案，消息会持久化硬盘，机器重启后消息不会丢失；但是还有一个极端情况，这台服务器磁盘突然坏了（公司遇到过磁盘问题还是很多的），消息持久化不了，非高可用状态，这个模式生产环境慎重考虑。\n- 普通集群模式：某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（建立在消息持久化）\n    - RabbitMQ 集群模式有点特殊，队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据\n- 镜像模式：可以解决上面的问题，但是还是有意外情况发生\n    - 比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？\n\n### 消费者消息丢失\n\n消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了，此时消息如果处理不当会有丢失风险\n\n## 如何避免消息丢失？\n\n下面也是从三个方面介绍：\n1.生产者消息如何不丢\n2.MQ中存储的消息如何保证\n3.消费者消息如何不丢\n\n### \n\n# 消息幂等性\n\n\n\n### ","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-应用问题.md","raw":"---\ntitle: RabbitMQ-应用问题\ndate: 2021-10-26 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n# 如何保证消息不丢失\n\n## 消息丢失场景\n\n### 生产者消息丢失\n\n#### 问题\n\n- 外界环境问题导致：发生网络丢包、网络故障等造成RabbitMQ Server端收不到消息，因为生产环境的网络是很复杂的，网络抖动，丢包现象很常见\n    - 一般情况下，生产者使用Confirm模式投递消息，如果方案不够严谨，比如RabbitMQ Server 接收消息失败后会发送nack消息通知生产者，生产者监听消息失败或者没做任何事情，消息存在丢失风险；\n- 代码层面，配置层面，考虑不全导致消息丢失\n    - 生产者发送消息到exchange后，发送的路由和queue没有绑定，消息会存在丢失情况，下面会讲到具体的例子，保证意外情况的发生，即使发生，也在可控范围内。\n\n### MQ存储的消息丢失或可靠性不足\n\n- 消息未完全持久化，当机器重启后，消息会全部丢失，甚至Queue也不见了\n- 单节点模式问题，如果某个节点挂了，消息就不能用了，业务可能瘫痪，只能等待\n    - 如果做了消息持久化方案，消息会持久化硬盘，机器重启后消息不会丢失；但是还有一个极端情况，这台服务器磁盘突然坏了（公司遇到过磁盘问题还是很多的），消息持久化不了，非高可用状态，这个模式生产环境慎重考虑。\n- 普通集群模式：某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（建立在消息持久化）\n    - RabbitMQ 集群模式有点特殊，队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据\n- 镜像模式：可以解决上面的问题，但是还是有意外情况发生\n    - 比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？\n\n### 消费者消息丢失\n\n消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了，此时消息如果处理不当会有丢失风险\n\n## 如何避免消息丢失？\n\n下面也是从三个方面介绍：\n1.生产者消息如何不丢\n2.MQ中存储的消息如何保证\n3.消费者消息如何不丢\n\n### \n\n# 消息幂等性\n\n\n\n### ","slug":"oyr/MQ/RabbitMQ/RabbitMQ-应用问题","published":1,"updated":"2021-10-26T10:30:26.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87q006zcst70nb8esll","content":"<h1 id=\"如何保证消息不丢失\"><a href=\"#如何保证消息不丢失\" class=\"headerlink\" title=\"如何保证消息不丢失\"></a>如何保证消息不丢失</h1><h2 id=\"消息丢失场景\"><a href=\"#消息丢失场景\" class=\"headerlink\" title=\"消息丢失场景\"></a>消息丢失场景</h2><h3 id=\"生产者消息丢失\"><a href=\"#生产者消息丢失\" class=\"headerlink\" title=\"生产者消息丢失\"></a>生产者消息丢失</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ul>\n<li>外界环境问题导致：发生网络丢包、网络故障等造成RabbitMQ Server端收不到消息，因为生产环境的网络是很复杂的，网络抖动，丢包现象很常见<ul>\n<li>一般情况下，生产者使用Confirm模式投递消息，如果方案不够严谨，比如RabbitMQ Server 接收消息失败后会发送nack消息通知生产者，生产者监听消息失败或者没做任何事情，消息存在丢失风险；</li>\n</ul>\n</li>\n<li>代码层面，配置层面，考虑不全导致消息丢失<ul>\n<li>生产者发送消息到exchange后，发送的路由和queue没有绑定，消息会存在丢失情况，下面会讲到具体的例子，保证意外情况的发生，即使发生，也在可控范围内。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MQ存储的消息丢失或可靠性不足\"><a href=\"#MQ存储的消息丢失或可靠性不足\" class=\"headerlink\" title=\"MQ存储的消息丢失或可靠性不足\"></a>MQ存储的消息丢失或可靠性不足</h3><ul>\n<li>消息未完全持久化，当机器重启后，消息会全部丢失，甚至Queue也不见了</li>\n<li>单节点模式问题，如果某个节点挂了，消息就不能用了，业务可能瘫痪，只能等待<ul>\n<li>如果做了消息持久化方案，消息会持久化硬盘，机器重启后消息不会丢失；但是还有一个极端情况，这台服务器磁盘突然坏了（公司遇到过磁盘问题还是很多的），消息持久化不了，非高可用状态，这个模式生产环境慎重考虑。</li>\n</ul>\n</li>\n<li>普通集群模式：某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（建立在消息持久化）<ul>\n<li>RabbitMQ 集群模式有点特殊，队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据</li>\n</ul>\n</li>\n<li>镜像模式：可以解决上面的问题，但是还是有意外情况发生<ul>\n<li>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消费者消息丢失\"><a href=\"#消费者消息丢失\" class=\"headerlink\" title=\"消费者消息丢失\"></a>消费者消息丢失</h3><p>消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了，此时消息如果处理不当会有丢失风险</p>\n<h2 id=\"如何避免消息丢失？\"><a href=\"#如何避免消息丢失？\" class=\"headerlink\" title=\"如何避免消息丢失？\"></a>如何避免消息丢失？</h2><p>下面也是从三个方面介绍：<br>1.生产者消息如何不丢<br>2.MQ中存储的消息如何保证<br>3.消费者消息如何不丢</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h1 id=\"消息幂等性\"><a href=\"#消息幂等性\" class=\"headerlink\" title=\"消息幂等性\"></a>消息幂等性</h1><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何保证消息不丢失\"><a href=\"#如何保证消息不丢失\" class=\"headerlink\" title=\"如何保证消息不丢失\"></a>如何保证消息不丢失</h1><h2 id=\"消息丢失场景\"><a href=\"#消息丢失场景\" class=\"headerlink\" title=\"消息丢失场景\"></a>消息丢失场景</h2><h3 id=\"生产者消息丢失\"><a href=\"#生产者消息丢失\" class=\"headerlink\" title=\"生产者消息丢失\"></a>生产者消息丢失</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ul>\n<li>外界环境问题导致：发生网络丢包、网络故障等造成RabbitMQ Server端收不到消息，因为生产环境的网络是很复杂的，网络抖动，丢包现象很常见<ul>\n<li>一般情况下，生产者使用Confirm模式投递消息，如果方案不够严谨，比如RabbitMQ Server 接收消息失败后会发送nack消息通知生产者，生产者监听消息失败或者没做任何事情，消息存在丢失风险；</li>\n</ul>\n</li>\n<li>代码层面，配置层面，考虑不全导致消息丢失<ul>\n<li>生产者发送消息到exchange后，发送的路由和queue没有绑定，消息会存在丢失情况，下面会讲到具体的例子，保证意外情况的发生，即使发生，也在可控范围内。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MQ存储的消息丢失或可靠性不足\"><a href=\"#MQ存储的消息丢失或可靠性不足\" class=\"headerlink\" title=\"MQ存储的消息丢失或可靠性不足\"></a>MQ存储的消息丢失或可靠性不足</h3><ul>\n<li>消息未完全持久化，当机器重启后，消息会全部丢失，甚至Queue也不见了</li>\n<li>单节点模式问题，如果某个节点挂了，消息就不能用了，业务可能瘫痪，只能等待<ul>\n<li>如果做了消息持久化方案，消息会持久化硬盘，机器重启后消息不会丢失；但是还有一个极端情况，这台服务器磁盘突然坏了（公司遇到过磁盘问题还是很多的），消息持久化不了，非高可用状态，这个模式生产环境慎重考虑。</li>\n</ul>\n</li>\n<li>普通集群模式：某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（建立在消息持久化）<ul>\n<li>RabbitMQ 集群模式有点特殊，队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据</li>\n</ul>\n</li>\n<li>镜像模式：可以解决上面的问题，但是还是有意外情况发生<ul>\n<li>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消费者消息丢失\"><a href=\"#消费者消息丢失\" class=\"headerlink\" title=\"消费者消息丢失\"></a>消费者消息丢失</h3><p>消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了，此时消息如果处理不当会有丢失风险</p>\n<h2 id=\"如何避免消息丢失？\"><a href=\"#如何避免消息丢失？\" class=\"headerlink\" title=\"如何避免消息丢失？\"></a>如何避免消息丢失？</h2><p>下面也是从三个方面介绍：<br>1.生产者消息如何不丢<br>2.MQ中存储的消息如何保证<br>3.消费者消息如何不丢</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h1 id=\"消息幂等性\"><a href=\"#消息幂等性\" class=\"headerlink\" title=\"消息幂等性\"></a>消息幂等性</h1><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h3>"},{"title":"ShardingSphere","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/分布式/分库分表/ShardingSphere.md","raw":"---\ntitle: ShardingSphere\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-ShardingSphere\ntags: \n   - ShardingSphere\n   - 中间件\n---","slug":"oyr/分布式/分库分表/ShardingSphere","published":1,"updated":"2021-10-27T02:51:22.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87r0072cst77uboa6gp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RabbitMQ-高级","date":"2021-08-12T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 前提\n\n当前文章代码演示，是基于amqp原生或spring整合的。\n\n# 持久化\n\n在生产过程中，难免会发生服务器宕机的事情，RabbitMQ也不例外，可能由于某种特殊情况下的异常而导致RabbitMQ宕机从而重启，那么这个时候对于消息队列里的数据，包括交换机、队列以及队列中存在消息恢复就显得尤为重要了。\nRabbitMQ本身带有持久化机制，包括交换机、队列以及消息的持久化。持久化的主要机制就是将信息写入磁盘，当RabbtiMQ服务宕机重启后，从磁盘中读取存入的持久化信息，恢复数据。\n\n## 交换机持久化\n\n### 概念\n\n交换机可以有两个状态：持久（durable）、暂存（transient）。\n持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。\n\n注意：并不是所有的应用场景都需要持久化的交换机。\n\n### 交换机持久化实现\n\n```java\n// 声明交换机，并且指定持久化\nboolean exchangeDurable = true;\nchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, exchangeDurable, false, null);\n```\n\n## 队列持久化\n\n### 概念\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。\n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n注意：并不是所有的应用场景都需要持久化的队列。\n\n### 队列持久化实现\n\n```java\n// 声明队列，并且指定持久化\nboolean durable = true;\nchannel.queueDeclare(QUEUE_NAME, durable, false, false, null);\n```\n\n## 消息持久化\n\n### 概念\n\n消息能够以持久化的方式发布，RabbitMQ 会将此消息存储在磁盘上。如果服务器重启，持久化消息不会丢失。\n将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n注意：RabbitMQ的消息是依附于队列存在的，所以想要消息持久化，那么前提是队列也要持久化。\n\n### 消息持久化实现\n\n要想让消息实现持久化需要在消息生产者修改代码，在发送消息时添加属性：MessageProperties.PERSISTENT_TEXT_PLAIN\n```java\n// 发送消息，并且指定持久化\n// channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\nchannel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, \"hello\".getBytes());\n```\n\n# 消息确认（producer ack）\n\n消息确认是针对消息生产者的。\n\n## 概念\n\n前提知识点：rabbitmq整个消息投递的路径为 producer -> rabbitmq broker -> exchange -> queue -> consumer。\n\n在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。\n思考：如何才能进行 RabbitMQ 的消息可靠投递呢？\n\n> 消息确认包含两部分。  \n> 第一部分：用来确认生产者是否成功将消息发送到 exchange。  \n> 第二部分：用来确认 exchange 路由消息给 queue 的过程中，消息是否成功投递。\n\nRabbitMQ 为我们提供了两种方式来确保消息的投递：\n- confirm 确认模式\n    - 对应消息确认第一部分\n- return 退回模式\n    - 对应消息确认第二部分\n\n<!-- more -->\n\n## confirm 确认模式\n\n### 简介\n\n消息从生产者到交换机会有一个 confirm 确认模式，当消息被 Borker 接收到就会触发 ConfirmCallback 进行回调，当前回调会包含消息是否成功发送到交换机中，生产者可以对针对失败情况做处理。\n\n### 三种实现方式\n\nConfirm的三种实现方式：\n1. 普通发送确认模式\n2. 批量确认模式\n3. 异步监听确认模式\n\n只有第三种方式是最长使用，这里只讲解第三种方式。\n\n### 案例\n\n#### 开启消息确认模式\n\nconnectionFactory.publisher-confirms=\"true\"：开启确认模式\n```xml\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\" publisher-confirms=\"true\"/>\n```\n\n#### 编写confirm回调\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void confirmTest() {\n        // 消息发送到broker回调（返回ack，代表消息是否发送到交换机）\n        RabbitTemplate.ConfirmCallback confirmCallback = (CorrelationData correlationData, boolean ack, String cause) -> {\n            if (ack) {\n                System.out.println(\"消息成功发送到交换机\");\n            } else {\n                System.out.println(\"消息发送到交换机出现异常，异常消息：\" + cause);\n            }\n        };\n\n        // 设置确认回调\n        rabbitTemplate.setConfirmCallback(confirmCallback);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(\"direct_exchange\", \"456\", \"boot hello\");\n    }\n}\n```\n\n## return 退回模式\n\n### 简介\n\n消息从交换机到队列投递会有一个 retunr 退回模式，当消息没有被成功投递到队列中后会触发 ReturnCallback 进行回调，生产者可以针对这种情况做对应的处理。\n\n### 案例\n\n#### 开启消息退回模式\n\nconnectionFactory.publisher-returns=\"true\"：开启退回模式\n```xml\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\"\n                            publisher-returns=\"true\"/>\n```\n\n#### 编写return回调\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void confirmTest() {\n        // 消息如果不能路由，默认丢弃，设置通知给生产者\n        rabbitTemplate.setMandatory(true);\n        \n        // 消息没有成功投递到队列回调\n        RabbitTemplate.ReturnCallback returnCallback = (Message message, int replyCode, String replyText, String exchange, String routingKey) -> {\n            System.out.println(\"message：\" + message);\n            System.out.println(\"exchange：\" + exchange);\n            System.out.println(\"routingKey：\" + routingKey);\n        };\n\n        // 设置退回回调\n        rabbitTemplate.setReturnCallback(returnCallback);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(\"direct_exchange\", \"1111\", \"boot hello\");\n    }\n}\n```\n\n## 小结\n\n### confirm 确认模式\n\n- 设置connectionFactory.publisher-confirms=\"true\"，开启确认模式\n- 使用rabbitTemplate.setConfirmCallback设置回调函数，当消息发送到broker时触发回调方法，通过ack判断当前消息是否成功发送到交换机，如果失败，则需处理。\n\n### return 回退模式\n\n- connectionFactory.publisher-returns=\"true\"，开启回退模式\n- 使用rabbitTemplate.setReturnCallback设置回调函数，当消息从exchange路由到queue失败后，如果设置了rabbittemplate.setMandatory(true)参数，则消息退回给producer，并执行回调方法。\n\n# 消息应答（consumer ack）\n\n消息应答是针对消息消费者的。\n\n## 概念\n\n问题：消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。\n\n为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：**消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。**\n\nack指Acknowledge，确认，表示消费者收到消息后的确认（应答）方式。  \nrabbitmq ack有三种应答方式：\n- 自动应答：ack=\"none\"\n- 手动应答：ack=\"manual\"\n- 根据情况自动应答：ack=\"auto\"（根据逻辑判断是否抛出异常，自动进行ack或nack）\n\n## 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。\n\n### 自动应答演示\n\nspring 整合下，消费者默认是自动应答。（listener-container.acknowledge默认是auto）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n     -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"auto\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"ack_queue\" ref=\"ackListener\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"ackListener\" class=\"com.oyr.rabbit.spring.listener.AckListener\"/>\n</beans>\n```\n\n监听器：(自动应答，无需手动应答)\n```java\npublic class AckListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n    }\n\n}\n```\n\n### 自动应答存在的问题\n\n修改消费者，添加异常，代码如下：\n```java\npublic class AckListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        // 模拟异常\n        int i = 1 / 0;\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n    }\n\n}\n```\n\n启动消费者，消费消息：  \n可以发现消息消费失败了，并且队列里面的消息消失了，而消费者还一直处于监听状态，一直在获取消息消费，但都消费不成功，这样就导致了消息的丢失。\n\n## 手动应答\n\n### 手动应答方法\n\n* Channel.basicAck(long deliveryTag, boolean multiple)\n    - 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\n    - 参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；\n* Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)\n    - 用于否定确认\n    - 参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；requeue：被拒绝的消息是否重新入队列；\n* Channel.basicReject(long deliveryTag, boolean requeue)\n    - 用于否定确认\n    - 与basicNack相比少一个参数，区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息\n\n### Multiple 的解释\n\nmultiple 表示批量应答； \n```\nvoid basicAck(long deliveryTag, boolean multiple) throws IOException;\n\nvoid basicReject(long deliveryTag, boolean requeue) throws IOException;\n```\n\nmultiple 的 true 和 false 代表不同意思\n* true\n    - 代表批量应答 channel 上未应答的消息\n    - 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n* false\n    - 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n![批量应答](https://rong0624.gitee.io/images/MQ/RabbitMQ/1628672592616.jpg)\n\n### 手动应答演示\n\n#### 设置手动应答\n\nlistener-container.acknowledge=\"manual\"：设置手动应答\n```xml\n<rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n    <!--\n        监听器，指定监听的队列与监听器的关系\n        queue-names：监听的队列\n        ref：监听对象的id\n        -->\n    <rabbit:listener queue-names=\"ack_queue\" ref=\"ackListener\"/>\n</rabbit:listener-container>\n```\n\n#### 监听器手动应答\n\n```java\npublic class AckListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        try {\n            System.out.println(\"监听器消费消息：\" + message);\n            System.out.println(\"body：\" + new String(message.getBody()));\n            // 手动ack应答\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        } catch (Exception e) {\n            // 异常，拒绝消息\n            // 参数3：true放回到mq中，false丢弃消息\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n        }\n    }\n}\n```\n\n## 小结\n\n- ack有三种应答方式，none：自动应答，manual：手动应答，auto：根据情况确认\n- 手动应答下，在消费者没有出现异常情况下，调用channel.basicAck进行手动应答。\n- 手动应答下，在消费者出现异常情况下，调用channel.basicNack或channel.basicReject进行拒绝消息，根据情况判断消息是否重新入队。\n\n# 消息预取\n\n## 概念\n\n- 本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。\n- 因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。\n- 这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。\n- 当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n## 消息预取实现\n\n```java\n/**\n * 消息预取\n * 1. 确保ack为手动应答\n * 2. listener-container配置属性\n *      prefetch=\"1\"\n */\npublic class AqsListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        // 1.获取消息\n        System.out.println(\"监听器消费消息：\" + message);\n\n        // 2.处理业务逻辑\n\n        // 3.ack消费者应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n\n}\n```\n\n```xml\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n        acknowledge=\"manual\" 消息手动应答\n        prefetch=\"1\" 消费者每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\" prefetch=\"1\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"aqs_queue\" ref=\"aqsListener\"/>\n    </rabbit:listener-container>\n```\n\n## 小结\n\n- 消费者需要保证ack为手动应答模式（acknowledge=\"manual\"）\n- 消费者设置属性listener-container.prefetch，指定每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。\n\n# TTL\n\nTTL是什么呢？\n> TTL是RabbitMQ中的一个消息或队列的属性，表明一条消息或该队列中的所有消息的最大存活时间，单位是毫秒。\n> 换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为\"死信\".\n\n有两种方式设置TTL\n- 队列设置TTL\n- 消息设置TTL\n\n如果同时配置了队列的TTL和消息的TTL，哪个会生效呢？答案是较小的那个值会生效。\n\n## 队列设置TTL\n\n声明队列时，指定队列中消息的过期时间\n```xml\n    <!-- 定义队列 -->\n    <rabbit:queue id=\"test.queue.ttl\" name=\"test.queue.ttl\">\n        <!-- 设置队列的参数 -->\n        <rabbit:queue-arguments>\n            <!-- x-message-ttl 指定队列消息的过期时间 -->\n            <entry key=\"x-message-ttl\" value=\"10000\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n```\n\n## 消息设置TTL\n\n发送消息时，指定消息的过期时间\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void ttlHello() {\n        MessagePostProcessor processor = new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置消息属性，消息的过期时间（单位：毫秒）\n                message.getMessageProperties().setExpiration(\"5000\");\n                return message;\n            }\n        };\n        rabbitTemplate.convertAndSend(\"test.exchange.ttl\", \"ttl.hello\", \"message ttl\", processor);\n    }\n}\n```\n\n## 队列TTL与消息TTL区别\n\n队列TTL 与 消息TTL是有区别的。\n队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。\n消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间.\n\n注意：还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n## 小结\n\n- 设置统一队列过期时间使用参数：x-message-ttl，单位：毫秒，会对整个队列消息设置统一的过期时间。\n- 设置消息过期时间使用参数：expiration，单位：毫秒，可以对消息设置不同的过期时间。\n- 队列设置过期时间和消息设置过期时间，如果两者都进行了设置，以时间短的为准。\n\n# 死信队列\n\n## 概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，\n一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，\n但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n## 死信的来源\n\n1. 消息TTL过期，消息到达超时时间未被消费\n2. 队列达到最大长度（队列满了，无法再添加到mq中）\n3. 消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false\n\n## 死信队列实战\n\n### 死信队列架构\n\n![死信队列架构](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png)\n![死信队列架构](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png)\n\n死信队列架构图解：\n> 第一步：声明正常的队列和正常的交换机\n> 第二步：声明死信队列和死信交换机\n> 第三步：正常队列绑定死信交换机并且指定消息成为死信的路由键\n> 第四步：当前生产者发送消息后，消息由于某种原因成为死信，就会将死信发送给死信交换机，死信交换机会根据指定的死信路由键发送到相关的死信队列\n\n### 搭建死信队列\n\n修改生产者：spring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明正常的队列（test.queue.dlx）和交换机（test.exchange.ttl） -->\n    <rabbit:queue id=\"test.queue.dlx\" name=\"test.queue.dlx\">\n        <rabbit:queue-arguments>\n            <!-- 指定队列绑定死信交换机 -->\n            <entry key=\"x-dead-letter-exchange\" value=\"exchange.dlx\" />\n            <!-- 指定消息成为死信后的路由键 -->\n            <entry key=\"x-dead-letter-routing-key\" value=\"dlx.hello\" />\n            <!-- 指定队列最大长度 -->\n            <entry key=\"x-max-length\" value=\"10\" value-type=\"java.lang.Integer\" />\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n    <rabbit:topic-exchange name=\"test.exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"test.dlx.#\" queue=\"test.queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明死信队列和交换机 -->\n    <rabbit:queue id=\"queue.dlx\" name=\"queue.dlx\"/>\n    <rabbit:topic-exchange name=\"exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"dlx.#\" queue=\"queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n</beans>\n```\n\n### 消息TTL过期\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void dlxTest() {\n        // 消息过期后，成为死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        MessagePostProcessor processor = new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置消息属性，消息的过期时间（单位：毫秒）\n                message.getMessageProperties().setExpiration(\"10000\");\n                return message;\n            }\n        };\n        rabbitTemplate.convertAndSend(\"test.exchange.dlx\", \"test.dlx.hello\", \"message dlx\", processor);\n    }\n}\n```\n\n### 队列达到最大长度\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void dlxTest() {\n        // 队列最大长度为10，一共发送15个消息，有5个消息成功死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        for (int i = 0; i < 15; i++) {\n            rabbitTemplate.convertAndSend(\"test.exchange.dlx\", \"test.dlx.hello\", \"message dlx\" + i);\n        }\n    }\n}\n```\n\n### 消费者拒绝消息\n\n消费者配置：spring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"testDlxListener\" queue-names=\"test.queue.dlx\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"testDlxListener\" class=\"com.oyr.rabbitmq.consumer.DlxListener\"/>\n</beans>\n```\n\n```java\npackage com.oyr.rabbitmq.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\npublic class DlxListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n        // ack，拒绝消息，并且丢弃消息\n        // 消费者拒绝消息并丢弃消息后，成为死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n    }\n\n}\n```\n\n## 小结\n\n- 死信交换机和死信队列和普通的没有区别（换了一个叫法）\n- 当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机路由到死信队列中\n- 消息成为死信的情况\n    - 消息TTL过期，消息到达超时时间未被消费\n    - 队列达到最大长度（队列满了，无法再添加到mq中）\n    - 消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false\n\n# 延迟队列\n\n## 概念\n\n延时队列，首先，它是一种队列，队列意味着内部的元素是有序的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。\n\n其次，延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。\n\n简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。\n\n## 使用场景\n\n1. 新用户注册成功后，7天后发送短信问候\n2. 订单下单后，三十分钟未支付则自动取消订单\n3. 用户发起退款，如果三天内没有被处理则通知相关的运营人员\n\n## 实现延迟队列（TTL + 死信队列）\n\n### 前提\n\n队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。\n消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间\n\n我们需要的效果是，消息拥有统一的过期时间，并且一旦消息过期，就会成为死信，所以使用队列TTL。\n\n### 架构\n\n![TTL+死信队列实现延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png)\n![TTL+死信队列实现延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png)\n\n### 生产者代码\n\nspring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明正常的队列（order.queue）和正常交换机（order.exchange） -->\n    <rabbit:queue id=\"order.queue\" name=\"order.queue\">\n        <rabbit:queue-arguments>\n            <!-- 指定队列绑定死信交换机 -->\n            <entry key=\"x-dead-letter-exchange\" value=\"order.exchange.dlx\" />\n            <!-- 指定消息成为死信后的路由键 -->\n            <entry key=\"x-dead-letter-routing-key\" value=\"order.dlx.hello\" />\n            <!-- 指定队列消息的过期时间 -->\n            <entry key=\"x-message-ttl\" value=\"10000\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n    <rabbit:topic-exchange name=\"order.exchange\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"order.#\" queue=\"order.queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明死信队列和死信交换机 -->\n    <rabbit:queue id=\"order.queue.dlx\" name=\"order.queue.dlx\"/>\n    <rabbit:topic-exchange name=\"order.exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"order.dlx.#\" queue=\"order.queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void delayTest() throws InterruptedException {\n        // 队列TTL + 死信队列 = 延迟队列\n        // 消息在10秒后成为死信\n        // 消息成为死信后，被死信队列接受到\n        rabbitTemplate.convertAndSend(\"order.exchange\", \"order.msg\", \"orderId:1,createTime:\" + new Date());\n        for (int i = 0; i < 10; i++) {\n            System.out.println(i + 1);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- \n            监听器，指定监听的队列\n            注意，当前是监听死信队列\n        -->\n        <rabbit:listener ref=\"delayListener\" queue-names=\"order.queue.dlx\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"delayListener\" class=\"com.oyr.rabbitmq.consumer.DelayListener\"/>\n</beans>\n```\n\n```java\npackage com.oyr.rabbitmq.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\npublic class DlxListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n        // 消息在过期被死信队列接受到，最终被死信队列消费者消费\n        // ack，拒绝消息，并且丢弃消息\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n    }\n\n}\n```\n\n### 小结\n\nrabbitMQ没有提供延迟队列功能，但是可以使用：TTL（队列TTL）+死信队列来实现延迟队列效果。\n\n## 实现延迟队列（基于延迟插件）\n\n### 前提\n\n上文TTL+死信队列实现的延迟队列，队列消息过期时间是统一的。\n现在想实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡应该如何实现呢？\n\n思考：消息TTL + 死信队列是否能实现？\n> 答案是不能的。\n> 消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。在这种情况下，过期的消息还可能继续存活，没有满足在指定时间要进行处理的情况。\n\n如何解决？答案：mq提供的延迟插件。\n\n### 架构\n\n![基于延迟插件实现的延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211024170444.png)\n\n图解：\n> 生产者发送消息到延迟交换机中\n> 延迟交换机在消息到达投递时间后，才将消息投递到对应的队列中\n\n注意：在自定义的延迟交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n### 延迟插件安装\n\n1）下载rabbitmq_delayed_message_exchange插件\n> https://www.rabbitmq.com/community-plugins.html \n\n2）将插件解压到RabbitMQ的插件目录\n> cp ~/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/\n\n3）安装插件，并重启rabbitmq\n> rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n> service rabbitmq-server restart\n\n### 生产者代码\n\nspring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitAdmin管理组件\n    @Resource\n    private RabbitAdmin rabbitAdmin;\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void delayTest() throws InterruptedException {\n        // 声明交换机\n        String exchangeName = \"delay.exchange\";\n        String exchangeType = \"x-delayed-message\"; // 指定延迟交换机类型\n        Map<String, Object> arg = new HashMap<>();\n        arg.put(\"x-delayed-type\" , \"topic\");\n        Exchange delayExchange = new CustomExchange(exchangeName, exchangeType, true, false, arg);\n        rabbitAdmin.declareExchange(delayExchange);\n\n        // 声明队列\n        String queueName = \"delay.queue\";\n        Queue queue = new Queue(queueName, true, false, false);\n        rabbitAdmin.declareQueue(queue);\n\n        // 声明绑定关系\n        Binding binding = BindingBuilder.bind(queue).to(delayExchange).with(\"delay.#\").noargs();\n        rabbitAdmin.declareBinding(binding);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"delay.hello\", \"boy，发送一条20过期时间消息，现在时间\" + new Date(), (msg) -> {\n            msg.getMessageProperties().setDelay(20000);\n            return msg;\n        });\n        rabbitTemplate.convertAndSend(exchangeName, \"delay.hello\", \"girl，发送一条5秒过期时间消息，现在时间\" + new Date(), (msg) -> {\n            msg.getMessageProperties().setDelay(5000);\n            return msg;\n        });\n\n        for (int i = 0; i < 20; i++) {\n            System.out.println(i +1);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"delayListener\" queue-names=\"delay.queue\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"delayListener\" class=\"com.oyr.rabbitmq.consumer.DelayListener\"/>\n</beans>\n```\n\n### 小结\n\n在当前方式下，实现在消息粒度上的 TTL。\n第一条消息时间为20秒，第二条消息时间为5秒。消费者成功按时间顺序消费到消息，这里不展示了。\n\n## 小结\n\nrabbitmq实现延迟队列有两种方式\n- TTL（队列TTL） + 死信队列模式实现延迟队列\n- 延迟插件实现延迟队列（消息时间在延迟交换机上判断）\n\n# 优先级队列\n\n## 使用场景\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创\n造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，\n所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。\n\n## 概念\n\n优先级队列，顾名思义，优先级高的具备优先消费的特权。\n\n> 1.RabbitMQ在3.5.0版本的时候实现了优先级队列。任何一个队列都可以通过客户端配置参数方式设置一个优先级(但是不能使用策略的方式配置这个参数)。当前优先级的最大值为：255。这个值最好在1到10之间\n> 2.队列的优先级设置只能通过声明方式设定，不能通过策略方式修改某个队列\n> 3.消息发布者可以发送一个优先级消息通过basic.properties数字越大表示优先级越高\n> 4.所谓的优先级队列就是，当消费者阻塞的时候，对具有优先级的消息直接按照优先级排序操作，然后按照优先级在一个一个的发送给消费者，这里需要多个条件(优先级队列、优先级消息、消费者阻塞、并且server对消费者排序)\n\n## 优先级队列实现\n\n### 生产者代码\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!--\n        定义rabbitmq connectionFactory\n        id：bean id\n        host：mq服务地址\n        port：mq服务端口\n        username：用户名\n        password：密码\n     -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"\n                               publisher-returns=\"true\"/>\n    <!--\n        定义RabbitAdmin（管理交换机、队列）\n    -->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明交换机 -->\n    <rabbit:topic-exchange name=\"priority.exchange\">\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"priority.#\" queue=\"priority.queue\"></rabbit:binding>\n            <rabbit:binding pattern=\"priority.#\" queue=\"test.priority.queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明优先级队列 -->\n    <rabbit:queue id=\"priority.queue\" name=\"priority.queue\">\n        <rabbit:queue-arguments>\n            <!-- 队列最大优先级设置为10 [当前优先级的最大值为：255。这个值最好在1到10之间] -->\n            <entry key=\"x-max-priority\" value=\"10\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n\n    <!-- 声明普通队列 -->\n    <rabbit:queue id=\"test.priority.queue\" name=\"test.priority.queue\"/>\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void priorityTest() {\n        for (int i = 0; i < 20; i++) {\n            if (i % 3 == 0) {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级3，消息：\" + i, (message) -> {\n                    // 消息发送，指定优先级\n                    message.getMessageProperties().setPriority(3);\n                    return message;\n                });\n            } else if (i % 5 == 0) {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级5，消息\" + i, (message) -> {\n                    message.getMessageProperties().setPriority(5);\n                    return message;\n                });\n            } else {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级1，消息\" + i, (message) -> {\n                    message.getMessageProperties().setPriority(1);\n                    return message;\n                });\n            }\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n        acknowledge=\"manual\" 消息手动应答\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听优先级队列 -->\n        <rabbit:listener queue-names=\"priority.queue\" ref=\"priorityListener\"/>\n        <!-- 监听普通队列 -->\n        <rabbit:listener queue-names=\"test.priority.queue\" ref=\"testPriorityListener\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"priorityListener\" class=\"com.oyr.rabbit.spring.listener.PriorityListener\"/>\n    <bean id=\"testPriorityListener\" class=\"com.oyr.rabbit.spring.listener.TestPriorityListener\"/>\n</beans>\n```\n\n优先级队列监听器（优先级消息只有在优先级队列下才是按优先级排序的）\n```java\npublic class PriorityListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"优先级队列消息：\" + new String(message.getBody()));\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n```\n\n普通队列监听器（优先级消息在普通队列下是正常顺序的，先进先出）\n```java\npublic class TestPriorityListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"普通队列消息：\" + new String(message.getBody()));\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n```\n\n### 执行，查看结果\n\n1）执行生产者，发送消息\n> 发送消息后，普通队列和优先级队列都会有20条消息\n\n2）启动消费者，监听消息\n> 优先级队列监听器，会发现消息根据优先级排序消费 \n> 普通队列监听器，会发现消息是正常顺序，按先进先出进行消费\n\n3）启动消费者，执行生产者再次发送消息\n> 发现，优先级监听器和普通队列监听器，消息消费顺序一致。\n> 原因：优先级队列，其实就是就是在消息积压的时候进行按照优先级排序，如果是发一条消费一条就完全没有排序效果了。\n\n## 小结\n\n- 优先级队列，队列需要设置x-max-priority参数\n- 优先级消息，消息需要设置priority参数\n- 优先级队列必须和优先级消息一起使用，才能发挥出效果，但是会消耗性能\n- 优先级队列必须在消费者繁忙的时候，才能对消息按照优先级排序\n- 非优先级队列发送优先级消息是不会排序的，所以向非优先级队列发送优先级是没有任何作用的\n\n# 惰性队列 \n\n## 概念\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。\n惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，\n即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，\n这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。\n当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。\n虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n## 惰性队列实现\n\n队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。\nlazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置。\n如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。\n如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n```xml\n<!-- 声明惰性队列 -->\n<rabbit:queue id=\"lazy.queue\" name=\"lazy.queue\">\n    <rabbit:queue-arguments>\n        <!-- 设置当前队列模式为惰性队列 -->\n        <entry key=\"x-queue-mode\" value=\"lazy\"/>\n    </rabbit:queue-arguments>\n</rabbit:queue>\n```\n\n## 小结\n\n- 惰性队列，因为需要将消息存入磁盘中，减少了内存的开销，磁盘远远比内存大的，所以可以存储更多的消息。\n- 惰性队列，因为需要将消息存入磁盘中，在消费时再取出，需要操作io，所以性能上不如普通队列。\n\n# 备份交换机","source":"_posts/oyr/MQ/RabbitMQ/RabbitMQ-高级.md","raw":"---\ntitle: RabbitMQ-高级\ndate: 2021-08-13 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MQ\ntags: \n    - MQ\n    - 中间件\n    - RabbitMQ\n---\n\n# 前提\n\n当前文章代码演示，是基于amqp原生或spring整合的。\n\n# 持久化\n\n在生产过程中，难免会发生服务器宕机的事情，RabbitMQ也不例外，可能由于某种特殊情况下的异常而导致RabbitMQ宕机从而重启，那么这个时候对于消息队列里的数据，包括交换机、队列以及队列中存在消息恢复就显得尤为重要了。\nRabbitMQ本身带有持久化机制，包括交换机、队列以及消息的持久化。持久化的主要机制就是将信息写入磁盘，当RabbtiMQ服务宕机重启后，从磁盘中读取存入的持久化信息，恢复数据。\n\n## 交换机持久化\n\n### 概念\n\n交换机可以有两个状态：持久（durable）、暂存（transient）。\n持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。\n\n注意：并不是所有的应用场景都需要持久化的交换机。\n\n### 交换机持久化实现\n\n```java\n// 声明交换机，并且指定持久化\nboolean exchangeDurable = true;\nchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, exchangeDurable, false, null);\n```\n\n## 队列持久化\n\n### 概念\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。\n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n注意：并不是所有的应用场景都需要持久化的队列。\n\n### 队列持久化实现\n\n```java\n// 声明队列，并且指定持久化\nboolean durable = true;\nchannel.queueDeclare(QUEUE_NAME, durable, false, false, null);\n```\n\n## 消息持久化\n\n### 概念\n\n消息能够以持久化的方式发布，RabbitMQ 会将此消息存储在磁盘上。如果服务器重启，持久化消息不会丢失。\n将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n注意：RabbitMQ的消息是依附于队列存在的，所以想要消息持久化，那么前提是队列也要持久化。\n\n### 消息持久化实现\n\n要想让消息实现持久化需要在消息生产者修改代码，在发送消息时添加属性：MessageProperties.PERSISTENT_TEXT_PLAIN\n```java\n// 发送消息，并且指定持久化\n// channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());\nchannel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, \"hello\".getBytes());\n```\n\n# 消息确认（producer ack）\n\n消息确认是针对消息生产者的。\n\n## 概念\n\n前提知识点：rabbitmq整个消息投递的路径为 producer -> rabbitmq broker -> exchange -> queue -> consumer。\n\n在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。\n思考：如何才能进行 RabbitMQ 的消息可靠投递呢？\n\n> 消息确认包含两部分。  \n> 第一部分：用来确认生产者是否成功将消息发送到 exchange。  \n> 第二部分：用来确认 exchange 路由消息给 queue 的过程中，消息是否成功投递。\n\nRabbitMQ 为我们提供了两种方式来确保消息的投递：\n- confirm 确认模式\n    - 对应消息确认第一部分\n- return 退回模式\n    - 对应消息确认第二部分\n\n<!-- more -->\n\n## confirm 确认模式\n\n### 简介\n\n消息从生产者到交换机会有一个 confirm 确认模式，当消息被 Borker 接收到就会触发 ConfirmCallback 进行回调，当前回调会包含消息是否成功发送到交换机中，生产者可以对针对失败情况做处理。\n\n### 三种实现方式\n\nConfirm的三种实现方式：\n1. 普通发送确认模式\n2. 批量确认模式\n3. 异步监听确认模式\n\n只有第三种方式是最长使用，这里只讲解第三种方式。\n\n### 案例\n\n#### 开启消息确认模式\n\nconnectionFactory.publisher-confirms=\"true\"：开启确认模式\n```xml\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\" publisher-confirms=\"true\"/>\n```\n\n#### 编写confirm回调\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void confirmTest() {\n        // 消息发送到broker回调（返回ack，代表消息是否发送到交换机）\n        RabbitTemplate.ConfirmCallback confirmCallback = (CorrelationData correlationData, boolean ack, String cause) -> {\n            if (ack) {\n                System.out.println(\"消息成功发送到交换机\");\n            } else {\n                System.out.println(\"消息发送到交换机出现异常，异常消息：\" + cause);\n            }\n        };\n\n        // 设置确认回调\n        rabbitTemplate.setConfirmCallback(confirmCallback);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(\"direct_exchange\", \"456\", \"boot hello\");\n    }\n}\n```\n\n## return 退回模式\n\n### 简介\n\n消息从交换机到队列投递会有一个 retunr 退回模式，当消息没有被成功投递到队列中后会触发 ReturnCallback 进行回调，生产者可以针对这种情况做对应的处理。\n\n### 案例\n\n#### 开启消息退回模式\n\nconnectionFactory.publisher-returns=\"true\"：开启退回模式\n```xml\n<rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                            port=\"${rabbitmq.port}\"\n                            username=\"${rabbitmq.username}\"\n                            password=\"${rabbitmq.password}\"\n                            virtual-host=\"${rabbitmq.virtual-host}\"\n                            publisher-returns=\"true\"/>\n```\n\n#### 编写return回调\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void confirmTest() {\n        // 消息如果不能路由，默认丢弃，设置通知给生产者\n        rabbitTemplate.setMandatory(true);\n        \n        // 消息没有成功投递到队列回调\n        RabbitTemplate.ReturnCallback returnCallback = (Message message, int replyCode, String replyText, String exchange, String routingKey) -> {\n            System.out.println(\"message：\" + message);\n            System.out.println(\"exchange：\" + exchange);\n            System.out.println(\"routingKey：\" + routingKey);\n        };\n\n        // 设置退回回调\n        rabbitTemplate.setReturnCallback(returnCallback);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(\"direct_exchange\", \"1111\", \"boot hello\");\n    }\n}\n```\n\n## 小结\n\n### confirm 确认模式\n\n- 设置connectionFactory.publisher-confirms=\"true\"，开启确认模式\n- 使用rabbitTemplate.setConfirmCallback设置回调函数，当消息发送到broker时触发回调方法，通过ack判断当前消息是否成功发送到交换机，如果失败，则需处理。\n\n### return 回退模式\n\n- connectionFactory.publisher-returns=\"true\"，开启回退模式\n- 使用rabbitTemplate.setReturnCallback设置回调函数，当消息从exchange路由到queue失败后，如果设置了rabbittemplate.setMandatory(true)参数，则消息退回给producer，并执行回调方法。\n\n# 消息应答（consumer ack）\n\n消息应答是针对消息消费者的。\n\n## 概念\n\n问题：消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。\n\n为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：**消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。**\n\nack指Acknowledge，确认，表示消费者收到消息后的确认（应答）方式。  \nrabbitmq ack有三种应答方式：\n- 自动应答：ack=\"none\"\n- 手动应答：ack=\"manual\"\n- 根据情况自动应答：ack=\"auto\"（根据逻辑判断是否抛出异常，自动进行ack或nack）\n\n## 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。\n\n### 自动应答演示\n\nspring 整合下，消费者默认是自动应答。（listener-container.acknowledge默认是auto）\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n     -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"auto\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"ack_queue\" ref=\"ackListener\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"ackListener\" class=\"com.oyr.rabbit.spring.listener.AckListener\"/>\n</beans>\n```\n\n监听器：(自动应答，无需手动应答)\n```java\npublic class AckListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n    }\n\n}\n```\n\n### 自动应答存在的问题\n\n修改消费者，添加异常，代码如下：\n```java\npublic class AckListener implements MessageListener {\n\n    @Override\n    public void onMessage(Message message) {\n        // 模拟异常\n        int i = 1 / 0;\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n    }\n\n}\n```\n\n启动消费者，消费消息：  \n可以发现消息消费失败了，并且队列里面的消息消失了，而消费者还一直处于监听状态，一直在获取消息消费，但都消费不成功，这样就导致了消息的丢失。\n\n## 手动应答\n\n### 手动应答方法\n\n* Channel.basicAck(long deliveryTag, boolean multiple)\n    - 用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\n    - 参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；\n* Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)\n    - 用于否定确认\n    - 参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；requeue：被拒绝的消息是否重新入队列；\n* Channel.basicReject(long deliveryTag, boolean requeue)\n    - 用于否定确认\n    - 与basicNack相比少一个参数，区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息\n\n### Multiple 的解释\n\nmultiple 表示批量应答； \n```\nvoid basicAck(long deliveryTag, boolean multiple) throws IOException;\n\nvoid basicReject(long deliveryTag, boolean requeue) throws IOException;\n```\n\nmultiple 的 true 和 false 代表不同意思\n* true\n    - 代表批量应答 channel 上未应答的消息\n    - 比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n* false\n    - 只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n![批量应答](https://rong0624.gitee.io/images/MQ/RabbitMQ/1628672592616.jpg)\n\n### 手动应答演示\n\n#### 设置手动应答\n\nlistener-container.acknowledge=\"manual\"：设置手动应答\n```xml\n<rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n    <!--\n        监听器，指定监听的队列与监听器的关系\n        queue-names：监听的队列\n        ref：监听对象的id\n        -->\n    <rabbit:listener queue-names=\"ack_queue\" ref=\"ackListener\"/>\n</rabbit:listener-container>\n```\n\n#### 监听器手动应答\n\n```java\npublic class AckListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        try {\n            System.out.println(\"监听器消费消息：\" + message);\n            System.out.println(\"body：\" + new String(message.getBody()));\n            // 手动ack应答\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        } catch (Exception e) {\n            // 异常，拒绝消息\n            // 参数3：true放回到mq中，false丢弃消息\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n        }\n    }\n}\n```\n\n## 小结\n\n- ack有三种应答方式，none：自动应答，manual：手动应答，auto：根据情况确认\n- 手动应答下，在消费者没有出现异常情况下，调用channel.basicAck进行手动应答。\n- 手动应答下，在消费者出现异常情况下，调用channel.basicNack或channel.basicReject进行拒绝消息，根据情况判断消息是否重新入队。\n\n# 消息预取\n\n## 概念\n\n- 本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。\n- 因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。\n- 这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。\n- 当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n## 消息预取实现\n\n```java\n/**\n * 消息预取\n * 1. 确保ack为手动应答\n * 2. listener-container配置属性\n *      prefetch=\"1\"\n */\npublic class AqsListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        // 1.获取消息\n        System.out.println(\"监听器消费消息：\" + message);\n\n        // 2.处理业务逻辑\n\n        // 3.ack消费者应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n\n}\n```\n\n```xml\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n        acknowledge=\"manual\" 消息手动应答\n        prefetch=\"1\" 消费者每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\" prefetch=\"1\">\n        <!--\n            监听器，指定监听的队列与监听器的关系\n            queue-names：监听的队列\n            ref：监听对象的id\n         -->\n        <rabbit:listener queue-names=\"aqs_queue\" ref=\"aqsListener\"/>\n    </rabbit:listener-container>\n```\n\n## 小结\n\n- 消费者需要保证ack为手动应答模式（acknowledge=\"manual\"）\n- 消费者设置属性listener-container.prefetch，指定每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。\n\n# TTL\n\nTTL是什么呢？\n> TTL是RabbitMQ中的一个消息或队列的属性，表明一条消息或该队列中的所有消息的最大存活时间，单位是毫秒。\n> 换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为\"死信\".\n\n有两种方式设置TTL\n- 队列设置TTL\n- 消息设置TTL\n\n如果同时配置了队列的TTL和消息的TTL，哪个会生效呢？答案是较小的那个值会生效。\n\n## 队列设置TTL\n\n声明队列时，指定队列中消息的过期时间\n```xml\n    <!-- 定义队列 -->\n    <rabbit:queue id=\"test.queue.ttl\" name=\"test.queue.ttl\">\n        <!-- 设置队列的参数 -->\n        <rabbit:queue-arguments>\n            <!-- x-message-ttl 指定队列消息的过期时间 -->\n            <entry key=\"x-message-ttl\" value=\"10000\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n```\n\n## 消息设置TTL\n\n发送消息时，指定消息的过期时间\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void ttlHello() {\n        MessagePostProcessor processor = new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置消息属性，消息的过期时间（单位：毫秒）\n                message.getMessageProperties().setExpiration(\"5000\");\n                return message;\n            }\n        };\n        rabbitTemplate.convertAndSend(\"test.exchange.ttl\", \"ttl.hello\", \"message ttl\", processor);\n    }\n}\n```\n\n## 队列TTL与消息TTL区别\n\n队列TTL 与 消息TTL是有区别的。\n队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。\n消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间.\n\n注意：还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n## 小结\n\n- 设置统一队列过期时间使用参数：x-message-ttl，单位：毫秒，会对整个队列消息设置统一的过期时间。\n- 设置消息过期时间使用参数：expiration，单位：毫秒，可以对消息设置不同的过期时间。\n- 队列设置过期时间和消息设置过期时间，如果两者都进行了设置，以时间短的为准。\n\n# 死信队列\n\n## 概念\n\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，\n一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，\n但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n## 死信的来源\n\n1. 消息TTL过期，消息到达超时时间未被消费\n2. 队列达到最大长度（队列满了，无法再添加到mq中）\n3. 消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false\n\n## 死信队列实战\n\n### 死信队列架构\n\n![死信队列架构](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png)\n![死信队列架构](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png)\n\n死信队列架构图解：\n> 第一步：声明正常的队列和正常的交换机\n> 第二步：声明死信队列和死信交换机\n> 第三步：正常队列绑定死信交换机并且指定消息成为死信的路由键\n> 第四步：当前生产者发送消息后，消息由于某种原因成为死信，就会将死信发送给死信交换机，死信交换机会根据指定的死信路由键发送到相关的死信队列\n\n### 搭建死信队列\n\n修改生产者：spring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明正常的队列（test.queue.dlx）和交换机（test.exchange.ttl） -->\n    <rabbit:queue id=\"test.queue.dlx\" name=\"test.queue.dlx\">\n        <rabbit:queue-arguments>\n            <!-- 指定队列绑定死信交换机 -->\n            <entry key=\"x-dead-letter-exchange\" value=\"exchange.dlx\" />\n            <!-- 指定消息成为死信后的路由键 -->\n            <entry key=\"x-dead-letter-routing-key\" value=\"dlx.hello\" />\n            <!-- 指定队列最大长度 -->\n            <entry key=\"x-max-length\" value=\"10\" value-type=\"java.lang.Integer\" />\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n    <rabbit:topic-exchange name=\"test.exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"test.dlx.#\" queue=\"test.queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明死信队列和交换机 -->\n    <rabbit:queue id=\"queue.dlx\" name=\"queue.dlx\"/>\n    <rabbit:topic-exchange name=\"exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"dlx.#\" queue=\"queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n</beans>\n```\n\n### 消息TTL过期\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void dlxTest() {\n        // 消息过期后，成为死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        MessagePostProcessor processor = new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                // 设置消息属性，消息的过期时间（单位：毫秒）\n                message.getMessageProperties().setExpiration(\"10000\");\n                return message;\n            }\n        };\n        rabbitTemplate.convertAndSend(\"test.exchange.dlx\", \"test.dlx.hello\", \"message dlx\", processor);\n    }\n}\n```\n\n### 队列达到最大长度\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void dlxTest() {\n        // 队列最大长度为10，一共发送15个消息，有5个消息成功死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        for (int i = 0; i < 15; i++) {\n            rabbitTemplate.convertAndSend(\"test.exchange.dlx\", \"test.dlx.hello\", \"message dlx\" + i);\n        }\n    }\n}\n```\n\n### 消费者拒绝消息\n\n消费者配置：spring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"testDlxListener\" queue-names=\"test.queue.dlx\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"testDlxListener\" class=\"com.oyr.rabbitmq.consumer.DlxListener\"/>\n</beans>\n```\n\n```java\npackage com.oyr.rabbitmq.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\npublic class DlxListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n        // ack，拒绝消息，并且丢弃消息\n        // 消费者拒绝消息并丢弃消息后，成为死信\n        // 消息成为死信，会被发送到死信交换机并被路由到死信队列\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n    }\n\n}\n```\n\n## 小结\n\n- 死信交换机和死信队列和普通的没有区别（换了一个叫法）\n- 当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机路由到死信队列中\n- 消息成为死信的情况\n    - 消息TTL过期，消息到达超时时间未被消费\n    - 队列达到最大长度（队列满了，无法再添加到mq中）\n    - 消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false\n\n# 延迟队列\n\n## 概念\n\n延时队列，首先，它是一种队列，队列意味着内部的元素是有序的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。\n\n其次，延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。\n\n简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。\n\n## 使用场景\n\n1. 新用户注册成功后，7天后发送短信问候\n2. 订单下单后，三十分钟未支付则自动取消订单\n3. 用户发起退款，如果三天内没有被处理则通知相关的运营人员\n\n## 实现延迟队列（TTL + 死信队列）\n\n### 前提\n\n队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。\n消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间\n\n我们需要的效果是，消息拥有统一的过期时间，并且一旦消息过期，就会成为死信，所以使用队列TTL。\n\n### 架构\n\n![TTL+死信队列实现延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png)\n![TTL+死信队列实现延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png)\n\n### 生产者代码\n\nspring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明正常的队列（order.queue）和正常交换机（order.exchange） -->\n    <rabbit:queue id=\"order.queue\" name=\"order.queue\">\n        <rabbit:queue-arguments>\n            <!-- 指定队列绑定死信交换机 -->\n            <entry key=\"x-dead-letter-exchange\" value=\"order.exchange.dlx\" />\n            <!-- 指定消息成为死信后的路由键 -->\n            <entry key=\"x-dead-letter-routing-key\" value=\"order.dlx.hello\" />\n            <!-- 指定队列消息的过期时间 -->\n            <entry key=\"x-message-ttl\" value=\"10000\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n    <rabbit:topic-exchange name=\"order.exchange\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"order.#\" queue=\"order.queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明死信队列和死信交换机 -->\n    <rabbit:queue id=\"order.queue.dlx\" name=\"order.queue.dlx\"/>\n    <rabbit:topic-exchange name=\"order.exchange.dlx\">\n        <!-- 指定绑定关系 -->\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"order.dlx.#\" queue=\"order.queue.dlx\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void delayTest() throws InterruptedException {\n        // 队列TTL + 死信队列 = 延迟队列\n        // 消息在10秒后成为死信\n        // 消息成为死信后，被死信队列接受到\n        rabbitTemplate.convertAndSend(\"order.exchange\", \"order.msg\", \"orderId:1,createTime:\" + new Date());\n        for (int i = 0; i < 10; i++) {\n            System.out.println(i + 1);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- \n            监听器，指定监听的队列\n            注意，当前是监听死信队列\n        -->\n        <rabbit:listener ref=\"delayListener\" queue-names=\"order.queue.dlx\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"delayListener\" class=\"com.oyr.rabbitmq.consumer.DelayListener\"/>\n</beans>\n```\n\n```java\npackage com.oyr.rabbitmq.consumer;\n\nimport com.rabbitmq.client.Channel;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;\n\npublic class DlxListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"监听器消费消息：\" + message);\n        System.out.println(\"body：\" + new String(message.getBody()));\n        // 消息在过期被死信队列接受到，最终被死信队列消费者消费\n        // ack，拒绝消息，并且丢弃消息\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);\n    }\n\n}\n```\n\n### 小结\n\nrabbitMQ没有提供延迟队列功能，但是可以使用：TTL（队列TTL）+死信队列来实现延迟队列效果。\n\n## 实现延迟队列（基于延迟插件）\n\n### 前提\n\n上文TTL+死信队列实现的延迟队列，队列消息过期时间是统一的。\n现在想实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡应该如何实现呢？\n\n思考：消息TTL + 死信队列是否能实现？\n> 答案是不能的。\n> 消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。在这种情况下，过期的消息还可能继续存活，没有满足在指定时间要进行处理的情况。\n\n如何解决？答案：mq提供的延迟插件。\n\n### 架构\n\n![基于延迟插件实现的延迟队列](https://rong0624.gitee.io/images/MQ/RabbitMQ/20211024170444.png)\n\n图解：\n> 生产者发送消息到延迟交换机中\n> 延迟交换机在消息到达投递时间后，才将消息投递到对应的队列中\n\n注意：在自定义的延迟交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n\n### 延迟插件安装\n\n1）下载rabbitmq_delayed_message_exchange插件\n> https://www.rabbitmq.com/community-plugins.html \n\n2）将插件解压到RabbitMQ的插件目录\n> cp ~/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/\n\n3）安装插件，并重启rabbitmq\n> rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n> service rabbitmq-server restart\n\n### 生产者代码\n\nspring-rabbitmq-producer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n    <!--定义管理交换机、队列-->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitAdmin管理组件\n    @Resource\n    private RabbitAdmin rabbitAdmin;\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void delayTest() throws InterruptedException {\n        // 声明交换机\n        String exchangeName = \"delay.exchange\";\n        String exchangeType = \"x-delayed-message\"; // 指定延迟交换机类型\n        Map<String, Object> arg = new HashMap<>();\n        arg.put(\"x-delayed-type\" , \"topic\");\n        Exchange delayExchange = new CustomExchange(exchangeName, exchangeType, true, false, arg);\n        rabbitAdmin.declareExchange(delayExchange);\n\n        // 声明队列\n        String queueName = \"delay.queue\";\n        Queue queue = new Queue(queueName, true, false, false);\n        rabbitAdmin.declareQueue(queue);\n\n        // 声明绑定关系\n        Binding binding = BindingBuilder.bind(queue).to(delayExchange).with(\"delay.#\").noargs();\n        rabbitAdmin.declareBinding(binding);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"delay.hello\", \"boy，发送一条20过期时间消息，现在时间\" + new Date(), (msg) -> {\n            msg.getMessageProperties().setDelay(20000);\n            return msg;\n        });\n        rabbitTemplate.convertAndSend(exchangeName, \"delay.hello\", \"girl，发送一条5秒过期时间消息，现在时间\" + new Date(), (msg) -> {\n            msg.getMessageProperties().setDelay(5000);\n            return msg;\n        });\n\n        for (int i = 0; i < 20; i++) {\n            System.out.println(i +1);\n            Thread.sleep(1000);\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        acknowledge=\"manual\" 手动ack确认\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听器，指定监听的队列 -->\n        <rabbit:listener ref=\"delayListener\" queue-names=\"delay.queue\"/>\n    </rabbit:listener-container>\n\n    <bean id=\"delayListener\" class=\"com.oyr.rabbitmq.consumer.DelayListener\"/>\n</beans>\n```\n\n### 小结\n\n在当前方式下，实现在消息粒度上的 TTL。\n第一条消息时间为20秒，第二条消息时间为5秒。消费者成功按时间顺序消费到消息，这里不展示了。\n\n## 小结\n\nrabbitmq实现延迟队列有两种方式\n- TTL（队列TTL） + 死信队列模式实现延迟队列\n- 延迟插件实现延迟队列（消息时间在延迟交换机上判断）\n\n# 优先级队列\n\n## 使用场景\n\n在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创\n造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，\n所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。\n\n## 概念\n\n优先级队列，顾名思义，优先级高的具备优先消费的特权。\n\n> 1.RabbitMQ在3.5.0版本的时候实现了优先级队列。任何一个队列都可以通过客户端配置参数方式设置一个优先级(但是不能使用策略的方式配置这个参数)。当前优先级的最大值为：255。这个值最好在1到10之间\n> 2.队列的优先级设置只能通过声明方式设定，不能通过策略方式修改某个队列\n> 3.消息发布者可以发送一个优先级消息通过basic.properties数字越大表示优先级越高\n> 4.所谓的优先级队列就是，当消费者阻塞的时候，对具有优先级的消息直接按照优先级排序操作，然后按照优先级在一个一个的发送给消费者，这里需要多个条件(优先级队列、优先级消息、消费者阻塞、并且server对消费者排序)\n\n## 优先级队列实现\n\n### 生产者代码\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!--\n        定义rabbitmq connectionFactory\n        id：bean id\n        host：mq服务地址\n        port：mq服务端口\n        username：用户名\n        password：密码\n     -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"\n                               publisher-returns=\"true\"/>\n    <!--\n        定义RabbitAdmin（管理交换机、队列）\n    -->\n    <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n    <!--定义rabbitTemplate对象操作可以在代码中方便发送消息-->\n    <rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\"/>\n\n    <!-- 声明交换机 -->\n    <rabbit:topic-exchange name=\"priority.exchange\">\n        <rabbit:bindings>\n            <rabbit:binding pattern=\"priority.#\" queue=\"priority.queue\"></rabbit:binding>\n            <rabbit:binding pattern=\"priority.#\" queue=\"test.priority.queue\"></rabbit:binding>\n        </rabbit:bindings>\n    </rabbit:topic-exchange>\n\n    <!-- 声明优先级队列 -->\n    <rabbit:queue id=\"priority.queue\" name=\"priority.queue\">\n        <rabbit:queue-arguments>\n            <!-- 队列最大优先级设置为10 [当前优先级的最大值为：255。这个值最好在1到10之间] -->\n            <entry key=\"x-max-priority\" value=\"10\" value-type=\"java.lang.Integer\"/>\n        </rabbit:queue-arguments>\n    </rabbit:queue>\n\n    <!-- 声明普通队列 -->\n    <rabbit:queue id=\"test.priority.queue\" name=\"test.priority.queue\"/>\n</beans>\n```\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:spring-rabbitmq-producer.xml\")\npublic class ProducerTest {\n\n    // 通过rabbitTemplate发送消息\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void priorityTest() {\n        for (int i = 0; i < 20; i++) {\n            if (i % 3 == 0) {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级3，消息：\" + i, (message) -> {\n                    // 消息发送，指定优先级\n                    message.getMessageProperties().setPriority(3);\n                    return message;\n                });\n            } else if (i % 5 == 0) {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级5，消息\" + i, (message) -> {\n                    message.getMessageProperties().setPriority(5);\n                    return message;\n                });\n            } else {\n                rabbitTemplate.convertAndSend(\"priority.exchange\", \"priority.hello\", \"优先级1，消息\" + i, (message) -> {\n                    message.getMessageProperties().setPriority(1);\n                    return message;\n                });\n            }\n        }\n    }\n}\n```\n\n### 消费者代码\n\nspring-rabbitmq-consumer.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/rabbit\n       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\">\n\n    <!--加载配置文件-->\n    <context:property-placeholder location=\"classpath:rabbitmq.properties\"/>\n\n    <!-- 定义rabbitmq connectionFactory -->\n    <rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\"\n                               port=\"${rabbitmq.port}\"\n                               username=\"${rabbitmq.username}\"\n                               password=\"${rabbitmq.password}\"\n                               virtual-host=\"${rabbitmq.virtual-host}\"/>\n\n    <!--\n        监听器容器\n        connection-factory：连接工厂\n        acknowledge=\"manual\" 消息手动应答\n    -->\n    <rabbit:listener-container connection-factory=\"connectionFactory\" acknowledge=\"manual\">\n        <!-- 监听优先级队列 -->\n        <rabbit:listener queue-names=\"priority.queue\" ref=\"priorityListener\"/>\n        <!-- 监听普通队列 -->\n        <rabbit:listener queue-names=\"test.priority.queue\" ref=\"testPriorityListener\"/>\n    </rabbit:listener-container>\n\n    <!-- 监听器 -->\n    <bean id=\"priorityListener\" class=\"com.oyr.rabbit.spring.listener.PriorityListener\"/>\n    <bean id=\"testPriorityListener\" class=\"com.oyr.rabbit.spring.listener.TestPriorityListener\"/>\n</beans>\n```\n\n优先级队列监听器（优先级消息只有在优先级队列下才是按优先级排序的）\n```java\npublic class PriorityListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"优先级队列消息：\" + new String(message.getBody()));\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n```\n\n普通队列监听器（优先级消息在普通队列下是正常顺序的，先进先出）\n```java\npublic class TestPriorityListener implements ChannelAwareMessageListener {\n\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        System.out.println(\"普通队列消息：\" + new String(message.getBody()));\n        // 手动ack应答\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n```\n\n### 执行，查看结果\n\n1）执行生产者，发送消息\n> 发送消息后，普通队列和优先级队列都会有20条消息\n\n2）启动消费者，监听消息\n> 优先级队列监听器，会发现消息根据优先级排序消费 \n> 普通队列监听器，会发现消息是正常顺序，按先进先出进行消费\n\n3）启动消费者，执行生产者再次发送消息\n> 发现，优先级监听器和普通队列监听器，消息消费顺序一致。\n> 原因：优先级队列，其实就是就是在消息积压的时候进行按照优先级排序，如果是发一条消费一条就完全没有排序效果了。\n\n## 小结\n\n- 优先级队列，队列需要设置x-max-priority参数\n- 优先级消息，消息需要设置priority参数\n- 优先级队列必须和优先级消息一起使用，才能发挥出效果，但是会消耗性能\n- 优先级队列必须在消费者繁忙的时候，才能对消息按照优先级排序\n- 非优先级队列发送优先级消息是不会排序的，所以向非优先级队列发送优先级是没有任何作用的\n\n# 惰性队列 \n\n## 概念\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。\n惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，\n即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，\n这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。\n当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。\n虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n## 惰性队列实现\n\n队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。\nlazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置。\n如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。\n如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n```xml\n<!-- 声明惰性队列 -->\n<rabbit:queue id=\"lazy.queue\" name=\"lazy.queue\">\n    <rabbit:queue-arguments>\n        <!-- 设置当前队列模式为惰性队列 -->\n        <entry key=\"x-queue-mode\" value=\"lazy\"/>\n    </rabbit:queue-arguments>\n</rabbit:queue>\n```\n\n## 小结\n\n- 惰性队列，因为需要将消息存入磁盘中，减少了内存的开销，磁盘远远比内存大的，所以可以存储更多的消息。\n- 惰性队列，因为需要将消息存入磁盘中，在消费时再取出，需要操作io，所以性能上不如普通队列。\n\n# 备份交换机","slug":"oyr/MQ/RabbitMQ/RabbitMQ-高级","published":1,"updated":"2021-10-26T10:30:26.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87s0076cst7h79xf9f2","content":"<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><p>当前文章代码演示，是基于amqp原生或spring整合的。</p>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>在生产过程中，难免会发生服务器宕机的事情，RabbitMQ也不例外，可能由于某种特殊情况下的异常而导致RabbitMQ宕机从而重启，那么这个时候对于消息队列里的数据，包括交换机、队列以及队列中存在消息恢复就显得尤为重要了。<br>RabbitMQ本身带有持久化机制，包括交换机、队列以及消息的持久化。持久化的主要机制就是将信息写入磁盘，当RabbtiMQ服务宕机重启后，从磁盘中读取存入的持久化信息，恢复数据。</p>\n<h2 id=\"交换机持久化\"><a href=\"#交换机持久化\" class=\"headerlink\" title=\"交换机持久化\"></a>交换机持久化</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>交换机可以有两个状态：持久（durable）、暂存（transient）。<br>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</p>\n<p>注意：并不是所有的应用场景都需要持久化的交换机。</p>\n<h3 id=\"交换机持久化实现\"><a href=\"#交换机持久化实现\" class=\"headerlink\" title=\"交换机持久化实现\"></a>交换机持久化实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明交换机，并且指定持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> exchangeDurable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, exchangeDurable, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<p>注意：并不是所有的应用场景都需要持久化的队列。</p>\n<h3 id=\"队列持久化实现\"><a href=\"#队列持久化实现\" class=\"headerlink\" title=\"队列持久化实现\"></a>队列持久化实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明队列，并且指定持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> durable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">channel.queueDeclare(QUEUE_NAME, durable, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>消息能够以持久化的方式发布，RabbitMQ 会将此消息存储在磁盘上。如果服务器重启，持久化消息不会丢失。<br>将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<p>注意：RabbitMQ的消息是依附于队列存在的，所以想要消息持久化，那么前提是队列也要持久化。</p>\n<h3 id=\"消息持久化实现\"><a href=\"#消息持久化实现\" class=\"headerlink\" title=\"消息持久化实现\"></a>消息持久化实现</h3><p>要想让消息实现持久化需要在消息生产者修改代码，在发送消息时添加属性：MessageProperties.PERSISTENT_TEXT_PLAIN</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送消息，并且指定持久化</span></span><br><span class=\"line\"><span class=\"comment\">// channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span></span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class=\"string\">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"消息确认（producer-ack）\"><a href=\"#消息确认（producer-ack）\" class=\"headerlink\" title=\"消息确认（producer ack）\"></a>消息确认（producer ack）</h1><p>消息确认是针对消息生产者的。</p>\n<h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>前提知识点：rabbitmq整个消息投递的路径为 producer -&gt; rabbitmq broker -&gt; exchange -&gt; queue -&gt; consumer。</p>\n<p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。<br>思考：如何才能进行 RabbitMQ 的消息可靠投递呢？</p>\n<blockquote>\n<p>消息确认包含两部分。<br>第一部分：用来确认生产者是否成功将消息发送到 exchange。<br>第二部分：用来确认 exchange 路由消息给 queue 的过程中，消息是否成功投递。</p>\n</blockquote>\n<p>RabbitMQ 为我们提供了两种方式来确保消息的投递：</p>\n<ul>\n<li>confirm 确认模式<ul>\n<li>对应消息确认第一部分</li>\n</ul>\n</li>\n<li>return 退回模式<ul>\n<li>对应消息确认第二部分</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"confirm-确认模式\"><a href=\"#confirm-确认模式\" class=\"headerlink\" title=\"confirm 确认模式\"></a>confirm 确认模式</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>消息从生产者到交换机会有一个 confirm 确认模式，当消息被 Borker 接收到就会触发 ConfirmCallback 进行回调，当前回调会包含消息是否成功发送到交换机中，生产者可以对针对失败情况做处理。</p>\n<h3 id=\"三种实现方式\"><a href=\"#三种实现方式\" class=\"headerlink\" title=\"三种实现方式\"></a>三种实现方式</h3><p>Confirm的三种实现方式：</p>\n<ol>\n<li>普通发送确认模式</li>\n<li>批量确认模式</li>\n<li>异步监听确认模式</li>\n</ol>\n<p>只有第三种方式是最长使用，这里只讲解第三种方式。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"开启消息确认模式\"><a href=\"#开启消息确认模式\" class=\"headerlink\" title=\"开启消息确认模式\"></a>开启消息确认模式</h4><p>connectionFactory.publisher-confirms=”true”：开启确认模式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span> <span class=\"attr\">publisher-confirms</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写confirm回调\"><a href=\"#编写confirm回调\" class=\"headerlink\" title=\"编写confirm回调\"></a>编写confirm回调</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息发送到broker回调（返回ack，代表消息是否发送到交换机）</span></span><br><span class=\"line\">        RabbitTemplate.ConfirmCallback confirmCallback = (CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消息成功发送到交换机&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消息发送到交换机出现异常，异常消息：&quot;</span> + cause);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置确认回调</span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct_exchange&quot;</span>, <span class=\"string\">&quot;456&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"return-退回模式\"><a href=\"#return-退回模式\" class=\"headerlink\" title=\"return 退回模式\"></a>return 退回模式</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>消息从交换机到队列投递会有一个 retunr 退回模式，当消息没有被成功投递到队列中后会触发 ReturnCallback 进行回调，生产者可以针对这种情况做对应的处理。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"开启消息退回模式\"><a href=\"#开启消息退回模式\" class=\"headerlink\" title=\"开启消息退回模式\"></a>开启消息退回模式</h4><p>connectionFactory.publisher-returns=”true”：开启退回模式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">publisher-returns</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写return回调\"><a href=\"#编写return回调\" class=\"headerlink\" title=\"编写return回调\"></a>编写return回调</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息如果不能路由，默认丢弃，设置通知给生产者</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 消息没有成功投递到队列回调</span></span><br><span class=\"line\">        RabbitTemplate.ReturnCallback returnCallback = (Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String exchange, String routingKey) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;exchange：&quot;</span> + exchange);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;routingKey：&quot;</span> + routingKey);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置退回回调</span></span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct_exchange&quot;</span>, <span class=\"string\">&quot;1111&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"confirm-确认模式-1\"><a href=\"#confirm-确认模式-1\" class=\"headerlink\" title=\"confirm 确认模式\"></a>confirm 确认模式</h3><ul>\n<li>设置connectionFactory.publisher-confirms=”true”，开启确认模式</li>\n<li>使用rabbitTemplate.setConfirmCallback设置回调函数，当消息发送到broker时触发回调方法，通过ack判断当前消息是否成功发送到交换机，如果失败，则需处理。</li>\n</ul>\n<h3 id=\"return-回退模式\"><a href=\"#return-回退模式\" class=\"headerlink\" title=\"return 回退模式\"></a>return 回退模式</h3><ul>\n<li>connectionFactory.publisher-returns=”true”，开启回退模式</li>\n<li>使用rabbitTemplate.setReturnCallback设置回调函数，当消息从exchange路由到queue失败后，如果设置了rabbittemplate.setMandatory(true)参数，则消息退回给producer，并执行回调方法。</li>\n</ul>\n<h1 id=\"消息应答（consumer-ack）\"><a href=\"#消息应答（consumer-ack）\" class=\"headerlink\" title=\"消息应答（consumer ack）\"></a>消息应答（consumer ack）</h1><p>消息应答是针对消息消费者的。</p>\n<h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>问题：消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。</p>\n<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p>\n<p>ack指Acknowledge，确认，表示消费者收到消息后的确认（应答）方式。<br>rabbitmq ack有三种应答方式：</p>\n<ul>\n<li>自动应答：ack=”none”</li>\n<li>手动应答：ack=”manual”</li>\n<li>根据情况自动应答：ack=”auto”（根据逻辑判断是否抛出异常，自动进行ack或nack）</li>\n</ul>\n<h2 id=\"自动应答\"><a href=\"#自动应答\" class=\"headerlink\" title=\"自动应答\"></a>自动应答</h2><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>\n<h3 id=\"自动应答演示\"><a href=\"#自动应答演示\" class=\"headerlink\" title=\"自动应答演示\"></a>自动应答演示</h3><p>spring 整合下，消费者默认是自动应答。（listener-container.acknowledge默认是auto）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;auto&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">            ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;ack_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ackListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ackListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.AckListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>监听器：(自动应答，无需手动应答)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动应答存在的问题\"><a href=\"#自动应答存在的问题\" class=\"headerlink\" title=\"自动应答存在的问题\"></a>自动应答存在的问题</h3><p>修改消费者，添加异常，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动消费者，消费消息：<br>可以发现消息消费失败了，并且队列里面的消息消失了，而消费者还一直处于监听状态，一直在获取消息消费，但都消费不成功，这样就导致了消息的丢失。</p>\n<h2 id=\"手动应答\"><a href=\"#手动应答\" class=\"headerlink\" title=\"手动应答\"></a>手动应答</h2><h3 id=\"手动应答方法\"><a href=\"#手动应答方法\" class=\"headerlink\" title=\"手动应答方法\"></a>手动应答方法</h3><ul>\n<li>Channel.basicAck(long deliveryTag, boolean multiple)<ul>\n<li>用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li>\n<li>参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；</li>\n</ul>\n</li>\n<li>Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)<ul>\n<li>用于否定确认</li>\n<li>参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；requeue：被拒绝的消息是否重新入队列；</li>\n</ul>\n</li>\n<li>Channel.basicReject(long deliveryTag, boolean requeue)<ul>\n<li>用于否定确认</li>\n<li>与basicNack相比少一个参数，区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Multiple-的解释\"><a href=\"#Multiple-的解释\" class=\"headerlink\" title=\"Multiple 的解释\"></a>Multiple 的解释</h3><p>multiple 表示批量应答； </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void basicAck(long deliveryTag, boolean multiple) throws IOException;</span><br><span class=\"line\"></span><br><span class=\"line\">void basicReject(long deliveryTag, boolean requeue) throws IOException;</span><br></pre></td></tr></table></figure>\n\n<p>multiple 的 true 和 false 代表不同意思</p>\n<ul>\n<li>true<ul>\n<li>代表批量应答 channel 上未应答的消息</li>\n<li>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</li>\n</ul>\n</li>\n<li>false<ul>\n<li>只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1628672592616.jpg\" alt=\"批量应答\"></p>\n<h3 id=\"手动应答演示\"><a href=\"#手动应答演示\" class=\"headerlink\" title=\"手动应答演示\"></a>手动应答演示</h3><h4 id=\"设置手动应答\"><a href=\"#设置手动应答\" class=\"headerlink\" title=\"设置手动应答\"></a>设置手动应答</h4><p>listener-container.acknowledge=”manual”：设置手动应答</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;ack_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ackListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"监听器手动应答\"><a href=\"#监听器手动应答\" class=\"headerlink\" title=\"监听器手动应答\"></a>监听器手动应答</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">            <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常，拒绝消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 参数3：true放回到mq中，false丢弃消息</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>ack有三种应答方式，none：自动应答，manual：手动应答，auto：根据情况确认</li>\n<li>手动应答下，在消费者没有出现异常情况下，调用channel.basicAck进行手动应答。</li>\n<li>手动应答下，在消费者出现异常情况下，调用channel.basicNack或channel.basicReject进行拒绝消息，根据情况判断消息是否重新入队。</li>\n</ul>\n<h1 id=\"消息预取\"><a href=\"#消息预取\" class=\"headerlink\" title=\"消息预取\"></a>消息预取</h1><h2 id=\"概念-5\"><a href=\"#概念-5\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。</li>\n<li>因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</li>\n<li>这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。</li>\n<li>当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</li>\n</ul>\n<h2 id=\"消息预取实现\"><a href=\"#消息预取实现\" class=\"headerlink\" title=\"消息预取实现\"></a>消息预取实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息预取</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 确保ack为手动应答</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. listener-container配置属性</span></span><br><span class=\"line\"><span class=\"comment\"> *      prefetch=&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AqsListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取消息</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.处理业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.ack消费者应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">    connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">    acknowledge=&quot;manual&quot; 消息手动应答</span></span><br><span class=\"line\"><span class=\"comment\">    prefetch=&quot;1&quot; 消费者每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span> <span class=\"attr\">prefetch</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;aqs_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;aqsListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>消费者需要保证ack为手动应答模式（acknowledge=”manual”）</li>\n<li>消费者设置属性listener-container.prefetch，指定每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。</li>\n</ul>\n<h1 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h1><p>TTL是什么呢？</p>\n<blockquote>\n<p>TTL是RabbitMQ中的一个消息或队列的属性，表明一条消息或该队列中的所有消息的最大存活时间，单位是毫秒。<br>换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为”死信”.</p>\n</blockquote>\n<p>有两种方式设置TTL</p>\n<ul>\n<li>队列设置TTL</li>\n<li>消息设置TTL</li>\n</ul>\n<p>如果同时配置了队列的TTL和消息的TTL，哪个会生效呢？答案是较小的那个值会生效。</p>\n<h2 id=\"队列设置TTL\"><a href=\"#队列设置TTL\" class=\"headerlink\" title=\"队列设置TTL\"></a>队列设置TTL</h2><p>声明队列时，指定队列中消息的过期时间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 定义队列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.queue.ttl&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.queue.ttl&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 设置队列的参数 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- x-message-ttl 指定队列消息的过期时间 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-message-ttl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10000&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息设置TTL\"><a href=\"#消息设置TTL\" class=\"headerlink\" title=\"消息设置TTL\"></a>消息设置TTL</h2><p>发送消息时，指定消息的过期时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ttlHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MessagePostProcessor processor = <span class=\"keyword\">new</span> MessagePostProcessor() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置消息属性，消息的过期时间（单位：毫秒）</span></span><br><span class=\"line\">                message.getMessageProperties().setExpiration(<span class=\"string\">&quot;5000&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.ttl&quot;</span>, <span class=\"string\">&quot;ttl.hello&quot;</span>, <span class=\"string\">&quot;message ttl&quot;</span>, processor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列TTL与消息TTL区别\"><a href=\"#队列TTL与消息TTL区别\" class=\"headerlink\" title=\"队列TTL与消息TTL区别\"></a>队列TTL与消息TTL区别</h2><p>队列TTL 与 消息TTL是有区别的。<br>队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间.</p>\n<p>注意：还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>设置统一队列过期时间使用参数：x-message-ttl，单位：毫秒，会对整个队列消息设置统一的过期时间。</li>\n<li>设置消息过期时间使用参数：expiration，单位：毫秒，可以对消息设置不同的过期时间。</li>\n<li>队列设置过期时间和消息设置过期时间，如果两者都进行了设置，以时间短的为准。</li>\n</ul>\n<h1 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h1><h2 id=\"概念-6\"><a href=\"#概念-6\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，<br>一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，<br>但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<h2 id=\"死信的来源\"><a href=\"#死信的来源\" class=\"headerlink\" title=\"死信的来源\"></a>死信的来源</h2><ol>\n<li>消息TTL过期，消息到达超时时间未被消费</li>\n<li>队列达到最大长度（队列满了，无法再添加到mq中）</li>\n<li>消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false</li>\n</ol>\n<h2 id=\"死信队列实战\"><a href=\"#死信队列实战\" class=\"headerlink\" title=\"死信队列实战\"></a>死信队列实战</h2><h3 id=\"死信队列架构\"><a href=\"#死信队列架构\" class=\"headerlink\" title=\"死信队列架构\"></a>死信队列架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png\" alt=\"死信队列架构\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png\" alt=\"死信队列架构\"></p>\n<p>死信队列架构图解：</p>\n<blockquote>\n<p>第一步：声明正常的队列和正常的交换机<br>第二步：声明死信队列和死信交换机<br>第三步：正常队列绑定死信交换机并且指定消息成为死信的路由键<br>第四步：当前生产者发送消息后，消息由于某种原因成为死信，就会将死信发送给死信交换机，死信交换机会根据指定的死信路由键发送到相关的死信队列</p>\n</blockquote>\n<h3 id=\"搭建死信队列\"><a href=\"#搭建死信队列\" class=\"headerlink\" title=\"搭建死信队列\"></a>搭建死信队列</h3><p>修改生产者：spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明正常的队列（test.queue.dlx）和交换机（test.exchange.ttl） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列绑定死信交换机 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;exchange.dlx&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定消息成为死信后的路由键 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;dlx.hello&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列最大长度 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-max-length&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;test.dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明死信队列和交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息TTL过期\"><a href=\"#消息TTL过期\" class=\"headerlink\" title=\"消息TTL过期\"></a>消息TTL过期</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dlxTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息过期后，成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        MessagePostProcessor processor = <span class=\"keyword\">new</span> MessagePostProcessor() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置消息属性，消息的过期时间（单位：毫秒）</span></span><br><span class=\"line\">                message.getMessageProperties().setExpiration(<span class=\"string\">&quot;10000&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.dlx&quot;</span>, <span class=\"string\">&quot;test.dlx.hello&quot;</span>, <span class=\"string\">&quot;message dlx&quot;</span>, processor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"队列达到最大长度\"><a href=\"#队列达到最大长度\" class=\"headerlink\" title=\"队列达到最大长度\"></a>队列达到最大长度</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dlxTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 队列最大长度为10，一共发送15个消息，有5个消息成功死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">15</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.dlx&quot;</span>, <span class=\"string\">&quot;test.dlx.hello&quot;</span>, <span class=\"string\">&quot;message dlx&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者拒绝消息\"><a href=\"#消费者拒绝消息\" class=\"headerlink\" title=\"消费者拒绝消息\"></a>消费者拒绝消息</h3><p>消费者配置：spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;testDlxListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;testDlxListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DlxListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.rabbitmq.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DlxListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// ack，拒绝消息，并且丢弃消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 消费者拒绝消息并丢弃消息后，成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>死信交换机和死信队列和普通的没有区别（换了一个叫法）</li>\n<li>当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机路由到死信队列中</li>\n<li>消息成为死信的情况<ul>\n<li>消息TTL过期，消息到达超时时间未被消费</li>\n<li>队列达到最大长度（队列满了，无法再添加到mq中）</li>\n<li>消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"延迟队列\"><a href=\"#延迟队列\" class=\"headerlink\" title=\"延迟队列\"></a>延迟队列</h1><h2 id=\"概念-7\"><a href=\"#概念-7\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>延时队列，首先，它是一种队列，队列意味着内部的元素是有序的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p>\n<p>其次，延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p>\n<p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><ol>\n<li>新用户注册成功后，7天后发送短信问候</li>\n<li>订单下单后，三十分钟未支付则自动取消订单</li>\n<li>用户发起退款，如果三天内没有被处理则通知相关的运营人员</li>\n</ol>\n<h2 id=\"实现延迟队列（TTL-死信队列）\"><a href=\"#实现延迟队列（TTL-死信队列）\" class=\"headerlink\" title=\"实现延迟队列（TTL + 死信队列）\"></a>实现延迟队列（TTL + 死信队列）</h2><h3 id=\"前提-1\"><a href=\"#前提-1\" class=\"headerlink\" title=\"前提\"></a>前提</h3><p>队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间</p>\n<p>我们需要的效果是，消息拥有统一的过期时间，并且一旦消息过期，就会成为死信，所以使用队列TTL。</p>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png\" alt=\"TTL+死信队列实现延迟队列\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png\" alt=\"TTL+死信队列实现延迟队列\"></p>\n<h3 id=\"生产者代码\"><a href=\"#生产者代码\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><p>spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明正常的队列（order.queue）和正常交换机（order.exchange） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.queue&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列绑定死信交换机 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;order.exchange.dlx&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定消息成为死信后的路由键 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;order.dlx.hello&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列消息的过期时间 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-message-ttl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10000&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.exchange&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;order.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;order.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明死信队列和死信交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;order.dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 队列TTL + 死信队列 = 延迟队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息在10秒后成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信后，被死信队列接受到</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;order.exchange&quot;</span>, <span class=\"string\">&quot;order.msg&quot;</span>, <span class=\"string\">&quot;orderId:1,createTime:&quot;</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码\"><a href=\"#消费者代码\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">            监听器，指定监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">            注意，当前是监听死信队列</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DelayListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.rabbitmq.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DlxListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 消息在过期被死信队列接受到，最终被死信队列消费者消费</span></span><br><span class=\"line\">        <span class=\"comment\">// ack，拒绝消息，并且丢弃消息</span></span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>rabbitMQ没有提供延迟队列功能，但是可以使用：TTL（队列TTL）+死信队列来实现延迟队列效果。</p>\n<h2 id=\"实现延迟队列（基于延迟插件）\"><a href=\"#实现延迟队列（基于延迟插件）\" class=\"headerlink\" title=\"实现延迟队列（基于延迟插件）\"></a>实现延迟队列（基于延迟插件）</h2><h3 id=\"前提-2\"><a href=\"#前提-2\" class=\"headerlink\" title=\"前提\"></a>前提</h3><p>上文TTL+死信队列实现的延迟队列，队列消息过期时间是统一的。<br>现在想实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡应该如何实现呢？</p>\n<p>思考：消息TTL + 死信队列是否能实现？</p>\n<blockquote>\n<p>答案是不能的。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。在这种情况下，过期的消息还可能继续存活，没有满足在指定时间要进行处理的情况。</p>\n</blockquote>\n<p>如何解决？答案：mq提供的延迟插件。</p>\n<h3 id=\"架构-1\"><a href=\"#架构-1\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211024170444.png\" alt=\"基于延迟插件实现的延迟队列\"></p>\n<p>图解：</p>\n<blockquote>\n<p>生产者发送消息到延迟交换机中<br>延迟交换机在消息到达投递时间后，才将消息投递到对应的队列中</p>\n</blockquote>\n<p>注意：在自定义的延迟交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>\n<h3 id=\"延迟插件安装\"><a href=\"#延迟插件安装\" class=\"headerlink\" title=\"延迟插件安装\"></a>延迟插件安装</h3><p>1）下载rabbitmq_delayed_message_exchange插件</p>\n<blockquote>\n<p><a href=\"https://www.rabbitmq.com/community-plugins.html\">https://www.rabbitmq.com/community-plugins.html</a> </p>\n</blockquote>\n<p>2）将插件解压到RabbitMQ的插件目录</p>\n<blockquote>\n<p>cp ~/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</p>\n</blockquote>\n<p>3）安装插件，并重启rabbitmq</p>\n<blockquote>\n<p>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br>service rabbitmq-server restart</p>\n</blockquote>\n<h3 id=\"生产者代码-1\"><a href=\"#生产者代码-1\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><p>spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitAdmin管理组件</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitAdmin rabbitAdmin;</span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        String exchangeName = <span class=\"string\">&quot;delay.exchange&quot;</span>;</span><br><span class=\"line\">        String exchangeType = <span class=\"string\">&quot;x-delayed-message&quot;</span>; <span class=\"comment\">// 指定延迟交换机类型</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arg = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        arg.put(<span class=\"string\">&quot;x-delayed-type&quot;</span> , <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        Exchange delayExchange = <span class=\"keyword\">new</span> CustomExchange(exchangeName, exchangeType, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, arg);</span><br><span class=\"line\">        rabbitAdmin.declareExchange(delayExchange);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;delay.queue&quot;</span>;</span><br><span class=\"line\">        Queue queue = <span class=\"keyword\">new</span> Queue(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        rabbitAdmin.declareQueue(queue);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明绑定关系</span></span><br><span class=\"line\">        Binding binding = BindingBuilder.bind(queue).to(delayExchange).with(<span class=\"string\">&quot;delay.#&quot;</span>).noargs();</span><br><span class=\"line\">        rabbitAdmin.declareBinding(binding);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;delay.hello&quot;</span>, <span class=\"string\">&quot;boy，发送一条20过期时间消息，现在时间&quot;</span> + <span class=\"keyword\">new</span> Date(), (msg) -&gt; &#123;</span><br><span class=\"line\">            msg.getMessageProperties().setDelay(<span class=\"number\">20000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;delay.hello&quot;</span>, <span class=\"string\">&quot;girl，发送一条5秒过期时间消息，现在时间&quot;</span> + <span class=\"keyword\">new</span> Date(), (msg) -&gt; &#123;</span><br><span class=\"line\">            msg.getMessageProperties().setDelay(<span class=\"number\">5000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i +<span class=\"number\">1</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码-1\"><a href=\"#消费者代码-1\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;delay.queue&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DelayListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-6\"><a href=\"#小结-6\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在当前方式下，实现在消息粒度上的 TTL。<br>第一条消息时间为20秒，第二条消息时间为5秒。消费者成功按时间顺序消费到消息，这里不展示了。</p>\n<h2 id=\"小结-7\"><a href=\"#小结-7\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>rabbitmq实现延迟队列有两种方式</p>\n<ul>\n<li>TTL（队列TTL） + 死信队列模式实现延迟队列</li>\n<li>延迟插件实现延迟队列（消息时间在延迟交换机上判断）</li>\n</ul>\n<h1 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h1><h2 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创<br>造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，<br>所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。</p>\n<h2 id=\"概念-8\"><a href=\"#概念-8\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>优先级队列，顾名思义，优先级高的具备优先消费的特权。</p>\n<blockquote>\n<p>1.RabbitMQ在3.5.0版本的时候实现了优先级队列。任何一个队列都可以通过客户端配置参数方式设置一个优先级(但是不能使用策略的方式配置这个参数)。当前优先级的最大值为：255。这个值最好在1到10之间<br>2.队列的优先级设置只能通过声明方式设定，不能通过策略方式修改某个队列<br>3.消息发布者可以发送一个优先级消息通过basic.properties数字越大表示优先级越高<br>4.所谓的优先级队列就是，当消费者阻塞的时候，对具有优先级的消息直接按照优先级排序操作，然后按照优先级在一个一个的发送给消费者，这里需要多个条件(优先级队列、优先级消息、消费者阻塞、并且server对消费者排序)</p>\n</blockquote>\n<h2 id=\"优先级队列实现\"><a href=\"#优先级队列实现\" class=\"headerlink\" title=\"优先级队列实现\"></a>优先级队列实现</h2><h3 id=\"生产者代码-2\"><a href=\"#生产者代码-2\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义rabbitmq connectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">        id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">        host：mq服务地址</span></span><br><span class=\"line\"><span class=\"comment\">        port：mq服务端口</span></span><br><span class=\"line\"><span class=\"comment\">        username：用户名</span></span><br><span class=\"line\"><span class=\"comment\">        password：密码</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">publisher-returns</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义RabbitAdmin（管理交换机、队列）</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;priority.exchange&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;priority.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;priority.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;priority.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明优先级队列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;priority.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;priority.queue&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 队列最大优先级设置为10 [当前优先级的最大值为：255。这个值最好在1到10之间] --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-max-priority&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明普通队列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">priorityTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级3，消息：&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 消息发送，指定优先级</span></span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">5</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级5，消息&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">5</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级1，消息&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码-2\"><a href=\"#消费者代码-2\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 消息手动应答</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听优先级队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;priority.queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;priorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听普通队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;testPriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;priorityListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.PriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;testPriorityListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TestPriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>优先级队列监听器（优先级消息只有在优先级队列下才是按优先级排序的）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;优先级队列消息：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>普通队列监听器（优先级消息在普通队列下是正常顺序的，先进先出）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPriorityListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通队列消息：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果\"><a href=\"#执行，查看结果\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>1）执行生产者，发送消息</p>\n<blockquote>\n<p>发送消息后，普通队列和优先级队列都会有20条消息</p>\n</blockquote>\n<p>2）启动消费者，监听消息</p>\n<blockquote>\n<p>优先级队列监听器，会发现消息根据优先级排序消费<br>普通队列监听器，会发现消息是正常顺序，按先进先出进行消费</p>\n</blockquote>\n<p>3）启动消费者，执行生产者再次发送消息</p>\n<blockquote>\n<p>发现，优先级监听器和普通队列监听器，消息消费顺序一致。<br>原因：优先级队列，其实就是就是在消息积压的时候进行按照优先级排序，如果是发一条消费一条就完全没有排序效果了。</p>\n</blockquote>\n<h2 id=\"小结-8\"><a href=\"#小结-8\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>优先级队列，队列需要设置x-max-priority参数</li>\n<li>优先级消息，消息需要设置priority参数</li>\n<li>优先级队列必须和优先级消息一起使用，才能发挥出效果，但是会消耗性能</li>\n<li>优先级队列必须在消费者繁忙的时候，才能对消息按照优先级排序</li>\n<li>非优先级队列发送优先级消息是不会排序的，所以向非优先级队列发送优先级是没有任何作用的</li>\n</ul>\n<h1 id=\"惰性队列\"><a href=\"#惰性队列\" class=\"headerlink\" title=\"惰性队列\"></a>惰性队列</h1><h2 id=\"概念-9\"><a href=\"#概念-9\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<br>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，<br>即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>\n<p>默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，<br>这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。<br>当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。<br>虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</p>\n<h2 id=\"惰性队列实现\"><a href=\"#惰性队列实现\" class=\"headerlink\" title=\"惰性队列实现\"></a>惰性队列实现</h2><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。<br>lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置。<br>如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。<br>如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 声明惰性队列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;lazy.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;lazy.queue&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 设置当前队列模式为惰性队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-queue-mode&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lazy&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-9\"><a href=\"#小结-9\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>惰性队列，因为需要将消息存入磁盘中，减少了内存的开销，磁盘远远比内存大的，所以可以存储更多的消息。</li>\n<li>惰性队列，因为需要将消息存入磁盘中，在消费时再取出，需要操作io，所以性能上不如普通队列。</li>\n</ul>\n<h1 id=\"备份交换机\"><a href=\"#备份交换机\" class=\"headerlink\" title=\"备份交换机\"></a>备份交换机</h1>","site":{"data":{}},"excerpt":"<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><p>当前文章代码演示，是基于amqp原生或spring整合的。</p>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>在生产过程中，难免会发生服务器宕机的事情，RabbitMQ也不例外，可能由于某种特殊情况下的异常而导致RabbitMQ宕机从而重启，那么这个时候对于消息队列里的数据，包括交换机、队列以及队列中存在消息恢复就显得尤为重要了。<br>RabbitMQ本身带有持久化机制，包括交换机、队列以及消息的持久化。持久化的主要机制就是将信息写入磁盘，当RabbtiMQ服务宕机重启后，从磁盘中读取存入的持久化信息，恢复数据。</p>\n<h2 id=\"交换机持久化\"><a href=\"#交换机持久化\" class=\"headerlink\" title=\"交换机持久化\"></a>交换机持久化</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>交换机可以有两个状态：持久（durable）、暂存（transient）。<br>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</p>\n<p>注意：并不是所有的应用场景都需要持久化的交换机。</p>\n<h3 id=\"交换机持久化实现\"><a href=\"#交换机持久化实现\" class=\"headerlink\" title=\"交换机持久化实现\"></a>交换机持久化实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明交换机，并且指定持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> exchangeDurable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, exchangeDurable, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><h3 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<p>注意：并不是所有的应用场景都需要持久化的队列。</p>\n<h3 id=\"队列持久化实现\"><a href=\"#队列持久化实现\" class=\"headerlink\" title=\"队列持久化实现\"></a>队列持久化实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明队列，并且指定持久化</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> durable = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">channel.queueDeclare(QUEUE_NAME, durable, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>消息能够以持久化的方式发布，RabbitMQ 会将此消息存储在磁盘上。如果服务器重启，持久化消息不会丢失。<br>将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<p>注意：RabbitMQ的消息是依附于队列存在的，所以想要消息持久化，那么前提是队列也要持久化。</p>\n<h3 id=\"消息持久化实现\"><a href=\"#消息持久化实现\" class=\"headerlink\" title=\"消息持久化实现\"></a>消息持久化实现</h3><p>要想让消息实现持久化需要在消息生产者修改代码，在发送消息时添加属性：MessageProperties.PERSISTENT_TEXT_PLAIN</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送消息，并且指定持久化</span></span><br><span class=\"line\"><span class=\"comment\">// channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span></span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class=\"string\">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"消息确认（producer-ack）\"><a href=\"#消息确认（producer-ack）\" class=\"headerlink\" title=\"消息确认（producer ack）\"></a>消息确认（producer ack）</h1><p>消息确认是针对消息生产者的。</p>\n<h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>前提知识点：rabbitmq整个消息投递的路径为 producer -&gt; rabbitmq broker -&gt; exchange -&gt; queue -&gt; consumer。</p>\n<p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。<br>思考：如何才能进行 RabbitMQ 的消息可靠投递呢？</p>\n<blockquote>\n<p>消息确认包含两部分。<br>第一部分：用来确认生产者是否成功将消息发送到 exchange。<br>第二部分：用来确认 exchange 路由消息给 queue 的过程中，消息是否成功投递。</p>\n</blockquote>\n<p>RabbitMQ 为我们提供了两种方式来确保消息的投递：</p>\n<ul>\n<li>confirm 确认模式<ul>\n<li>对应消息确认第一部分</li>\n</ul>\n</li>\n<li>return 退回模式<ul>\n<li>对应消息确认第二部分</li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"confirm-确认模式\"><a href=\"#confirm-确认模式\" class=\"headerlink\" title=\"confirm 确认模式\"></a>confirm 确认模式</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>消息从生产者到交换机会有一个 confirm 确认模式，当消息被 Borker 接收到就会触发 ConfirmCallback 进行回调，当前回调会包含消息是否成功发送到交换机中，生产者可以对针对失败情况做处理。</p>\n<h3 id=\"三种实现方式\"><a href=\"#三种实现方式\" class=\"headerlink\" title=\"三种实现方式\"></a>三种实现方式</h3><p>Confirm的三种实现方式：</p>\n<ol>\n<li>普通发送确认模式</li>\n<li>批量确认模式</li>\n<li>异步监听确认模式</li>\n</ol>\n<p>只有第三种方式是最长使用，这里只讲解第三种方式。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"开启消息确认模式\"><a href=\"#开启消息确认模式\" class=\"headerlink\" title=\"开启消息确认模式\"></a>开启消息确认模式</h4><p>connectionFactory.publisher-confirms=”true”：开启确认模式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span> <span class=\"attr\">publisher-confirms</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写confirm回调\"><a href=\"#编写confirm回调\" class=\"headerlink\" title=\"编写confirm回调\"></a>编写confirm回调</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息发送到broker回调（返回ack，代表消息是否发送到交换机）</span></span><br><span class=\"line\">        RabbitTemplate.ConfirmCallback confirmCallback = (CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消息成功发送到交换机&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;消息发送到交换机出现异常，异常消息：&quot;</span> + cause);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置确认回调</span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct_exchange&quot;</span>, <span class=\"string\">&quot;456&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"return-退回模式\"><a href=\"#return-退回模式\" class=\"headerlink\" title=\"return 退回模式\"></a>return 退回模式</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>消息从交换机到队列投递会有一个 retunr 退回模式，当消息没有被成功投递到队列中后会触发 ReturnCallback 进行回调，生产者可以针对这种情况做对应的处理。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"开启消息退回模式\"><a href=\"#开启消息退回模式\" class=\"headerlink\" title=\"开启消息退回模式\"></a>开启消息退回模式</h4><p>connectionFactory.publisher-returns=”true”：开启退回模式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                            <span class=\"attr\">publisher-returns</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编写return回调\"><a href=\"#编写return回调\" class=\"headerlink\" title=\"编写return回调\"></a>编写return回调</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息如果不能路由，默认丢弃，设置通知给生产者</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 消息没有成功投递到队列回调</span></span><br><span class=\"line\">        RabbitTemplate.ReturnCallback returnCallback = (Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String exchange, String routingKey) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;message：&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;exchange：&quot;</span> + exchange);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;routingKey：&quot;</span> + routingKey);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置退回回调</span></span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct_exchange&quot;</span>, <span class=\"string\">&quot;1111&quot;</span>, <span class=\"string\">&quot;boot hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"confirm-确认模式-1\"><a href=\"#confirm-确认模式-1\" class=\"headerlink\" title=\"confirm 确认模式\"></a>confirm 确认模式</h3><ul>\n<li>设置connectionFactory.publisher-confirms=”true”，开启确认模式</li>\n<li>使用rabbitTemplate.setConfirmCallback设置回调函数，当消息发送到broker时触发回调方法，通过ack判断当前消息是否成功发送到交换机，如果失败，则需处理。</li>\n</ul>\n<h3 id=\"return-回退模式\"><a href=\"#return-回退模式\" class=\"headerlink\" title=\"return 回退模式\"></a>return 回退模式</h3><ul>\n<li>connectionFactory.publisher-returns=”true”，开启回退模式</li>\n<li>使用rabbitTemplate.setReturnCallback设置回调函数，当消息从exchange路由到queue失败后，如果设置了rabbittemplate.setMandatory(true)参数，则消息退回给producer，并执行回调方法。</li>\n</ul>\n<h1 id=\"消息应答（consumer-ack）\"><a href=\"#消息应答（consumer-ack）\" class=\"headerlink\" title=\"消息应答（consumer ack）\"></a>消息应答（consumer ack）</h1><p>消息应答是针对消息消费者的。</p>\n<h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>问题：消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。</p>\n<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p>\n<p>ack指Acknowledge，确认，表示消费者收到消息后的确认（应答）方式。<br>rabbitmq ack有三种应答方式：</p>\n<ul>\n<li>自动应答：ack=”none”</li>\n<li>手动应答：ack=”manual”</li>\n<li>根据情况自动应答：ack=”auto”（根据逻辑判断是否抛出异常，自动进行ack或nack）</li>\n</ul>\n<h2 id=\"自动应答\"><a href=\"#自动应答\" class=\"headerlink\" title=\"自动应答\"></a>自动应答</h2><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p>\n<h3 id=\"自动应答演示\"><a href=\"#自动应答演示\" class=\"headerlink\" title=\"自动应答演示\"></a>自动应答演示</h3><p>spring 整合下，消费者默认是自动应答。（listener-container.acknowledge默认是auto）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;auto&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">            queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">            ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">         --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;ack_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ackListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ackListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.AckListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>监听器：(自动应答，无需手动应答)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动应答存在的问题\"><a href=\"#自动应答存在的问题\" class=\"headerlink\" title=\"自动应答存在的问题\"></a>自动应答存在的问题</h3><p>修改消费者，添加异常，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟异常</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> / <span class=\"number\">0</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动消费者，消费消息：<br>可以发现消息消费失败了，并且队列里面的消息消失了，而消费者还一直处于监听状态，一直在获取消息消费，但都消费不成功，这样就导致了消息的丢失。</p>\n<h2 id=\"手动应答\"><a href=\"#手动应答\" class=\"headerlink\" title=\"手动应答\"></a>手动应答</h2><h3 id=\"手动应答方法\"><a href=\"#手动应答方法\" class=\"headerlink\" title=\"手动应答方法\"></a>手动应答方法</h3><ul>\n<li>Channel.basicAck(long deliveryTag, boolean multiple)<ul>\n<li>用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</li>\n<li>参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；</li>\n</ul>\n</li>\n<li>Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)<ul>\n<li>用于否定确认</li>\n<li>参数deliveryTag：是消息唯一id；参数multiple：是否批量处理；requeue：被拒绝的消息是否重新入队列；</li>\n</ul>\n</li>\n<li>Channel.basicReject(long deliveryTag, boolean requeue)<ul>\n<li>用于否定确认</li>\n<li>与basicNack相比少一个参数，区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Multiple-的解释\"><a href=\"#Multiple-的解释\" class=\"headerlink\" title=\"Multiple 的解释\"></a>Multiple 的解释</h3><p>multiple 表示批量应答； </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void basicAck(long deliveryTag, boolean multiple) throws IOException;</span><br><span class=\"line\"></span><br><span class=\"line\">void basicReject(long deliveryTag, boolean requeue) throws IOException;</span><br></pre></td></tr></table></figure>\n\n<p>multiple 的 true 和 false 代表不同意思</p>\n<ul>\n<li>true<ul>\n<li>代表批量应答 channel 上未应答的消息</li>\n<li>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</li>\n</ul>\n</li>\n<li>false<ul>\n<li>只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/1628672592616.jpg\" alt=\"批量应答\"></p>\n<h3 id=\"手动应答演示\"><a href=\"#手动应答演示\" class=\"headerlink\" title=\"手动应答演示\"></a>手动应答演示</h3><h4 id=\"设置手动应答\"><a href=\"#设置手动应答\" class=\"headerlink\" title=\"设置手动应答\"></a>设置手动应答</h4><p>listener-container.acknowledge=”manual”：设置手动应答</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;ack_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ackListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"监听器手动应答\"><a href=\"#监听器手动应答\" class=\"headerlink\" title=\"监听器手动应答\"></a>监听器手动应答</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AckListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">            <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 异常，拒绝消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 参数3：true放回到mq中，false丢弃消息</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>ack有三种应答方式，none：自动应答，manual：手动应答，auto：根据情况确认</li>\n<li>手动应答下，在消费者没有出现异常情况下，调用channel.basicAck进行手动应答。</li>\n<li>手动应答下，在消费者出现异常情况下，调用channel.basicNack或channel.basicReject进行拒绝消息，根据情况判断消息是否重新入队。</li>\n</ul>\n<h1 id=\"消息预取\"><a href=\"#消息预取\" class=\"headerlink\" title=\"消息预取\"></a>消息预取</h1><h2 id=\"概念-5\"><a href=\"#概念-5\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。</li>\n<li>因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</li>\n<li>这个时候就可以通过使用 basic.qos 方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。</li>\n<li>当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</li>\n</ul>\n<h2 id=\"消息预取实现\"><a href=\"#消息预取实现\" class=\"headerlink\" title=\"消息预取实现\"></a>消息预取实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 消息预取</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. 确保ack为手动应答</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. listener-container配置属性</span></span><br><span class=\"line\"><span class=\"comment\"> *      prefetch=&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AqsListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.获取消息</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.处理业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.ack消费者应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">    connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">    acknowledge=&quot;manual&quot; 消息手动应答</span></span><br><span class=\"line\"><span class=\"comment\">    prefetch=&quot;1&quot; 消费者每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span> <span class=\"attr\">prefetch</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器，指定监听的队列与监听器的关系</span></span><br><span class=\"line\"><span class=\"comment\">        queue-names：监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">        ref：监听对象的id</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;aqs_queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;aqsListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>消费者需要保证ack为手动应答模式（acknowledge=”manual”）</li>\n<li>消费者设置属性listener-container.prefetch，指定每次从broker里面一次性取出几个待消费的消息，并且只有消息ack确认后，才会再去拉取。</li>\n</ul>\n<h1 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h1><p>TTL是什么呢？</p>\n<blockquote>\n<p>TTL是RabbitMQ中的一个消息或队列的属性，表明一条消息或该队列中的所有消息的最大存活时间，单位是毫秒。<br>换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为”死信”.</p>\n</blockquote>\n<p>有两种方式设置TTL</p>\n<ul>\n<li>队列设置TTL</li>\n<li>消息设置TTL</li>\n</ul>\n<p>如果同时配置了队列的TTL和消息的TTL，哪个会生效呢？答案是较小的那个值会生效。</p>\n<h2 id=\"队列设置TTL\"><a href=\"#队列设置TTL\" class=\"headerlink\" title=\"队列设置TTL\"></a>队列设置TTL</h2><p>声明队列时，指定队列中消息的过期时间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 定义队列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.queue.ttl&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.queue.ttl&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 设置队列的参数 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- x-message-ttl 指定队列消息的过期时间 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-message-ttl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10000&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"消息设置TTL\"><a href=\"#消息设置TTL\" class=\"headerlink\" title=\"消息设置TTL\"></a>消息设置TTL</h2><p>发送消息时，指定消息的过期时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ttlHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MessagePostProcessor processor = <span class=\"keyword\">new</span> MessagePostProcessor() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置消息属性，消息的过期时间（单位：毫秒）</span></span><br><span class=\"line\">                message.getMessageProperties().setExpiration(<span class=\"string\">&quot;5000&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.ttl&quot;</span>, <span class=\"string\">&quot;ttl.hello&quot;</span>, <span class=\"string\">&quot;message ttl&quot;</span>, processor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"队列TTL与消息TTL区别\"><a href=\"#队列TTL与消息TTL区别\" class=\"headerlink\" title=\"队列TTL与消息TTL区别\"></a>队列TTL与消息TTL区别</h2><p>队列TTL 与 消息TTL是有区别的。<br>队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间.</p>\n<p>注意：还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>\n<h2 id=\"小结-3\"><a href=\"#小结-3\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>设置统一队列过期时间使用参数：x-message-ttl，单位：毫秒，会对整个队列消息设置统一的过期时间。</li>\n<li>设置消息过期时间使用参数：expiration，单位：毫秒，可以对消息设置不同的过期时间。</li>\n<li>队列设置过期时间和消息设置过期时间，如果两者都进行了设置，以时间短的为准。</li>\n</ul>\n<h1 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h1><h2 id=\"概念-6\"><a href=\"#概念-6\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，<br>一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，<br>但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<h2 id=\"死信的来源\"><a href=\"#死信的来源\" class=\"headerlink\" title=\"死信的来源\"></a>死信的来源</h2><ol>\n<li>消息TTL过期，消息到达超时时间未被消费</li>\n<li>队列达到最大长度（队列满了，无法再添加到mq中）</li>\n<li>消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false</li>\n</ol>\n<h2 id=\"死信队列实战\"><a href=\"#死信队列实战\" class=\"headerlink\" title=\"死信队列实战\"></a>死信队列实战</h2><h3 id=\"死信队列架构\"><a href=\"#死信队列架构\" class=\"headerlink\" title=\"死信队列架构\"></a>死信队列架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png\" alt=\"死信队列架构\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png\" alt=\"死信队列架构\"></p>\n<p>死信队列架构图解：</p>\n<blockquote>\n<p>第一步：声明正常的队列和正常的交换机<br>第二步：声明死信队列和死信交换机<br>第三步：正常队列绑定死信交换机并且指定消息成为死信的路由键<br>第四步：当前生产者发送消息后，消息由于某种原因成为死信，就会将死信发送给死信交换机，死信交换机会根据指定的死信路由键发送到相关的死信队列</p>\n</blockquote>\n<h3 id=\"搭建死信队列\"><a href=\"#搭建死信队列\" class=\"headerlink\" title=\"搭建死信队列\"></a>搭建死信队列</h3><p>修改生产者：spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明正常的队列（test.queue.dlx）和交换机（test.exchange.ttl） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列绑定死信交换机 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;exchange.dlx&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定消息成为死信后的路由键 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;dlx.hello&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列最大长度 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-max-length&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;test.dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明死信队列和交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息TTL过期\"><a href=\"#消息TTL过期\" class=\"headerlink\" title=\"消息TTL过期\"></a>消息TTL过期</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dlxTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 消息过期后，成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        MessagePostProcessor processor = <span class=\"keyword\">new</span> MessagePostProcessor() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置消息属性，消息的过期时间（单位：毫秒）</span></span><br><span class=\"line\">                message.getMessageProperties().setExpiration(<span class=\"string\">&quot;10000&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.dlx&quot;</span>, <span class=\"string\">&quot;test.dlx.hello&quot;</span>, <span class=\"string\">&quot;message dlx&quot;</span>, processor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"队列达到最大长度\"><a href=\"#队列达到最大长度\" class=\"headerlink\" title=\"队列达到最大长度\"></a>队列达到最大长度</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dlxTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 队列最大长度为10，一共发送15个消息，有5个消息成功死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">15</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;test.exchange.dlx&quot;</span>, <span class=\"string\">&quot;test.dlx.hello&quot;</span>, <span class=\"string\">&quot;message dlx&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者拒绝消息\"><a href=\"#消费者拒绝消息\" class=\"headerlink\" title=\"消费者拒绝消息\"></a>消费者拒绝消息</h3><p>消费者配置：spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;testDlxListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;test.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;testDlxListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DlxListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.rabbitmq.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DlxListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// ack，拒绝消息，并且丢弃消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 消费者拒绝消息并丢弃消息后，成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信，会被发送到死信交换机并被路由到死信队列</span></span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-4\"><a href=\"#小结-4\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>死信交换机和死信队列和普通的没有区别（换了一个叫法）</li>\n<li>当消息称为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机路由到死信队列中</li>\n<li>消息成为死信的情况<ul>\n<li>消息TTL过期，消息到达超时时间未被消费</li>\n<li>队列达到最大长度（队列满了，无法再添加到mq中）</li>\n<li>消费者拒绝消息（basic.reject 或 basic.nack）并且requeue=false</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"延迟队列\"><a href=\"#延迟队列\" class=\"headerlink\" title=\"延迟队列\"></a>延迟队列</h1><h2 id=\"概念-7\"><a href=\"#概念-7\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>延时队列，首先，它是一种队列，队列意味着内部的元素是有序的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p>\n<p>其次，延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p>\n<p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><ol>\n<li>新用户注册成功后，7天后发送短信问候</li>\n<li>订单下单后，三十分钟未支付则自动取消订单</li>\n<li>用户发起退款，如果三天内没有被处理则通知相关的运营人员</li>\n</ol>\n<h2 id=\"实现延迟队列（TTL-死信队列）\"><a href=\"#实现延迟队列（TTL-死信队列）\" class=\"headerlink\" title=\"实现延迟队列（TTL + 死信队列）\"></a>实现延迟队列（TTL + 死信队列）</h2><h3 id=\"前提-1\"><a href=\"#前提-1\" class=\"headerlink\" title=\"前提\"></a>前提</h3><p>队列TTL：队列TTL，消息拥有统一的过期时间，一旦消息过期，就会成为死信。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间</p>\n<p>我们需要的效果是，消息拥有统一的过期时间，并且一旦消息过期，就会成为死信，所以使用队列TTL。</p>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023213601.png\" alt=\"TTL+死信队列实现延迟队列\"><br><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211023221932.png\" alt=\"TTL+死信队列实现延迟队列\"></p>\n<h3 id=\"生产者代码\"><a href=\"#生产者代码\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><p>spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明正常的队列（order.queue）和正常交换机（order.exchange） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.queue&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列绑定死信交换机 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;order.exchange.dlx&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定消息成为死信后的路由键 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;order.dlx.hello&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 指定队列消息的过期时间 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-message-ttl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10000&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.exchange&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;order.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;order.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明死信队列和死信交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order.exchange.dlx&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 指定绑定关系 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;order.dlx.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 队列TTL + 死信队列 = 延迟队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息在10秒后成为死信</span></span><br><span class=\"line\">        <span class=\"comment\">// 消息成为死信后，被死信队列接受到</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;order.exchange&quot;</span>, <span class=\"string\">&quot;order.msg&quot;</span>, <span class=\"string\">&quot;orderId:1,createTime:&quot;</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码\"><a href=\"#消费者代码\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">            监听器，指定监听的队列</span></span><br><span class=\"line\"><span class=\"comment\">            注意，当前是监听死信队列</span></span><br><span class=\"line\"><span class=\"comment\">        --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;order.queue.dlx&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DelayListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.oyr.rabbitmq.consumer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.rabbitmq.client.Channel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Message;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DlxListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;监听器消费消息：&quot;</span> + message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;body：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 消息在过期被死信队列接受到，最终被死信队列消费者消费</span></span><br><span class=\"line\">        <span class=\"comment\">// ack，拒绝消息，并且丢弃消息</span></span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-5\"><a href=\"#小结-5\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>rabbitMQ没有提供延迟队列功能，但是可以使用：TTL（队列TTL）+死信队列来实现延迟队列效果。</p>\n<h2 id=\"实现延迟队列（基于延迟插件）\"><a href=\"#实现延迟队列（基于延迟插件）\" class=\"headerlink\" title=\"实现延迟队列（基于延迟插件）\"></a>实现延迟队列（基于延迟插件）</h2><h3 id=\"前提-2\"><a href=\"#前提-2\" class=\"headerlink\" title=\"前提\"></a>前提</h3><p>上文TTL+死信队列实现的延迟队列，队列消息过期时间是统一的。<br>现在想实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡应该如何实现呢？</p>\n<p>思考：消息TTL + 死信队列是否能实现？</p>\n<blockquote>\n<p>答案是不能的。<br>消息TTL：消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。在这种情况下，过期的消息还可能继续存活，没有满足在指定时间要进行处理的情况。</p>\n</blockquote>\n<p>如何解决？答案：mq提供的延迟插件。</p>\n<h3 id=\"架构-1\"><a href=\"#架构-1\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p><img src=\"https://rong0624.gitee.io/images/MQ/RabbitMQ/20211024170444.png\" alt=\"基于延迟插件实现的延迟队列\"></p>\n<p>图解：</p>\n<blockquote>\n<p>生产者发送消息到延迟交换机中<br>延迟交换机在消息到达投递时间后，才将消息投递到对应的队列中</p>\n</blockquote>\n<p>注意：在自定义的延迟交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>\n<h3 id=\"延迟插件安装\"><a href=\"#延迟插件安装\" class=\"headerlink\" title=\"延迟插件安装\"></a>延迟插件安装</h3><p>1）下载rabbitmq_delayed_message_exchange插件</p>\n<blockquote>\n<p><a href=\"https://www.rabbitmq.com/community-plugins.html\">https://www.rabbitmq.com/community-plugins.html</a> </p>\n</blockquote>\n<p>2）将插件解压到RabbitMQ的插件目录</p>\n<blockquote>\n<p>cp ~/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins/</p>\n</blockquote>\n<p>3）安装插件，并重启rabbitmq</p>\n<blockquote>\n<p>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br>service rabbitmq-server restart</p>\n</blockquote>\n<h3 id=\"生产者代码-1\"><a href=\"#生产者代码-1\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><p>spring-rabbitmq-producer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义管理交换机、队列--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitAdmin管理组件</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitAdmin rabbitAdmin;</span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        String exchangeName = <span class=\"string\">&quot;delay.exchange&quot;</span>;</span><br><span class=\"line\">        String exchangeType = <span class=\"string\">&quot;x-delayed-message&quot;</span>; <span class=\"comment\">// 指定延迟交换机类型</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arg = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        arg.put(<span class=\"string\">&quot;x-delayed-type&quot;</span> , <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        Exchange delayExchange = <span class=\"keyword\">new</span> CustomExchange(exchangeName, exchangeType, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, arg);</span><br><span class=\"line\">        rabbitAdmin.declareExchange(delayExchange);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        String queueName = <span class=\"string\">&quot;delay.queue&quot;</span>;</span><br><span class=\"line\">        Queue queue = <span class=\"keyword\">new</span> Queue(queueName, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        rabbitAdmin.declareQueue(queue);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 声明绑定关系</span></span><br><span class=\"line\">        Binding binding = BindingBuilder.bind(queue).to(delayExchange).with(<span class=\"string\">&quot;delay.#&quot;</span>).noargs();</span><br><span class=\"line\">        rabbitAdmin.declareBinding(binding);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;delay.hello&quot;</span>, <span class=\"string\">&quot;boy，发送一条20过期时间消息，现在时间&quot;</span> + <span class=\"keyword\">new</span> Date(), (msg) -&gt; &#123;</span><br><span class=\"line\">            msg.getMessageProperties().setDelay(<span class=\"number\">20000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(exchangeName, <span class=\"string\">&quot;delay.hello&quot;</span>, <span class=\"string\">&quot;girl，发送一条5秒过期时间消息，现在时间&quot;</span> + <span class=\"keyword\">new</span> Date(), (msg) -&gt; &#123;</span><br><span class=\"line\">            msg.getMessageProperties().setDelay(<span class=\"number\">5000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i +<span class=\"number\">1</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码-1\"><a href=\"#消费者代码-1\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 手动ack确认</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听器，指定监听的队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;delay.queue&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;delayListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbitmq.consumer.DelayListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结-6\"><a href=\"#小结-6\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在当前方式下，实现在消息粒度上的 TTL。<br>第一条消息时间为20秒，第二条消息时间为5秒。消费者成功按时间顺序消费到消息，这里不展示了。</p>\n<h2 id=\"小结-7\"><a href=\"#小结-7\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>rabbitmq实现延迟队列有两种方式</p>\n<ul>\n<li>TTL（队列TTL） + 死信队列模式实现延迟队列</li>\n<li>延迟插件实现延迟队列（消息时间在延迟交换机上判断）</li>\n</ul>\n<h1 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h1><h2 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创<br>造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，<br>所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。</p>\n<h2 id=\"概念-8\"><a href=\"#概念-8\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>优先级队列，顾名思义，优先级高的具备优先消费的特权。</p>\n<blockquote>\n<p>1.RabbitMQ在3.5.0版本的时候实现了优先级队列。任何一个队列都可以通过客户端配置参数方式设置一个优先级(但是不能使用策略的方式配置这个参数)。当前优先级的最大值为：255。这个值最好在1到10之间<br>2.队列的优先级设置只能通过声明方式设定，不能通过策略方式修改某个队列<br>3.消息发布者可以发送一个优先级消息通过basic.properties数字越大表示优先级越高<br>4.所谓的优先级队列就是，当消费者阻塞的时候，对具有优先级的消息直接按照优先级排序操作，然后按照优先级在一个一个的发送给消费者，这里需要多个条件(优先级队列、优先级消息、消费者阻塞、并且server对消费者排序)</p>\n</blockquote>\n<h2 id=\"优先级队列实现\"><a href=\"#优先级队列实现\" class=\"headerlink\" title=\"优先级队列实现\"></a>优先级队列实现</h2><h3 id=\"生产者代码-2\"><a href=\"#生产者代码-2\" class=\"headerlink\" title=\"生产者代码\"></a>生产者代码</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义rabbitmq connectionFactory</span></span><br><span class=\"line\"><span class=\"comment\">        id：bean id</span></span><br><span class=\"line\"><span class=\"comment\">        host：mq服务地址</span></span><br><span class=\"line\"><span class=\"comment\">        port：mq服务端口</span></span><br><span class=\"line\"><span class=\"comment\">        username：用户名</span></span><br><span class=\"line\"><span class=\"comment\">        password：密码</span></span><br><span class=\"line\"><span class=\"comment\">     --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">publisher-returns</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        定义RabbitAdmin（管理交换机、队列）</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:admin</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;rabbitTemplate&quot;</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明交换机 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:topic-exchange</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;priority.exchange&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;priority.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;priority.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">rabbit:binding</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;priority.#&quot;</span> <span class=\"attr\">queue</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">rabbit:binding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:bindings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:topic-exchange</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明优先级队列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;priority.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;priority.queue&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 队列最大优先级设置为10 [当前优先级的最大值为：255。这个值最好在1到10之间] --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-max-priority&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">value-type</span>=<span class=\"string\">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明普通队列 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProducerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过rabbitTemplate发送消息</span></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">priorityTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级3，消息：&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 消息发送，指定优先级</span></span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i % <span class=\"number\">5</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级5，消息&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">5</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rabbitTemplate.convertAndSend(<span class=\"string\">&quot;priority.exchange&quot;</span>, <span class=\"string\">&quot;priority.hello&quot;</span>, <span class=\"string\">&quot;优先级1，消息&quot;</span> + i, (message) -&gt; &#123;</span><br><span class=\"line\">                    message.getMessageProperties().setPriority(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者代码-2\"><a href=\"#消费者代码-2\" class=\"headerlink\" title=\"消费者代码\"></a>消费者代码</h3><p>spring-rabbitmq-consumer.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:rabbit</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--加载配置文件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">&quot;classpath:rabbitmq.properties&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义rabbitmq connectionFactory --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:connection-factory</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.host&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">port</span>=<span class=\"string\">&quot;$&#123;rabbitmq.port&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">username</span>=<span class=\"string\">&quot;$&#123;rabbitmq.username&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">password</span>=<span class=\"string\">&quot;$&#123;rabbitmq.password&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                               <span class=\"attr\">virtual-host</span>=<span class=\"string\">&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        监听器容器</span></span><br><span class=\"line\"><span class=\"comment\">        connection-factory：连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">        acknowledge=&quot;manual&quot; 消息手动应答</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener-container</span> <span class=\"attr\">connection-factory</span>=<span class=\"string\">&quot;connectionFactory&quot;</span> <span class=\"attr\">acknowledge</span>=<span class=\"string\">&quot;manual&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听优先级队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;priority.queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;priorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 监听普通队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rabbit:listener</span> <span class=\"attr\">queue-names</span>=<span class=\"string\">&quot;test.priority.queue&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;testPriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:listener-container</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 监听器 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;priorityListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.PriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;testPriorityListener&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.rabbit.spring.listener.TestPriorityListener&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>优先级队列监听器（优先级消息只有在优先级队列下才是按优先级排序的）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;优先级队列消息：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>普通队列监听器（优先级消息在普通队列下是正常顺序的，先进先出）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestPriorityListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通队列消息：&quot;</span> + <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">        <span class=\"comment\">// 手动ack应答</span></span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"执行，查看结果\"><a href=\"#执行，查看结果\" class=\"headerlink\" title=\"执行，查看结果\"></a>执行，查看结果</h3><p>1）执行生产者，发送消息</p>\n<blockquote>\n<p>发送消息后，普通队列和优先级队列都会有20条消息</p>\n</blockquote>\n<p>2）启动消费者，监听消息</p>\n<blockquote>\n<p>优先级队列监听器，会发现消息根据优先级排序消费<br>普通队列监听器，会发现消息是正常顺序，按先进先出进行消费</p>\n</blockquote>\n<p>3）启动消费者，执行生产者再次发送消息</p>\n<blockquote>\n<p>发现，优先级监听器和普通队列监听器，消息消费顺序一致。<br>原因：优先级队列，其实就是就是在消息积压的时候进行按照优先级排序，如果是发一条消费一条就完全没有排序效果了。</p>\n</blockquote>\n<h2 id=\"小结-8\"><a href=\"#小结-8\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>优先级队列，队列需要设置x-max-priority参数</li>\n<li>优先级消息，消息需要设置priority参数</li>\n<li>优先级队列必须和优先级消息一起使用，才能发挥出效果，但是会消耗性能</li>\n<li>优先级队列必须在消费者繁忙的时候，才能对消息按照优先级排序</li>\n<li>非优先级队列发送优先级消息是不会排序的，所以向非优先级队列发送优先级是没有任何作用的</li>\n</ul>\n<h1 id=\"惰性队列\"><a href=\"#惰性队列\" class=\"headerlink\" title=\"惰性队列\"></a>惰性队列</h1><h2 id=\"概念-9\"><a href=\"#概念-9\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<br>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，<br>即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>\n<p>默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，<br>这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。<br>当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。<br>虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</p>\n<h2 id=\"惰性队列实现\"><a href=\"#惰性队列实现\" class=\"headerlink\" title=\"惰性队列实现\"></a>惰性队列实现</h2><p>队列具备两种模式：default 和 lazy。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。<br>lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置。<br>如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。<br>如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 声明惰性队列 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rabbit:queue</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;lazy.queue&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;lazy.queue&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 设置当前队列模式为惰性队列 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;x-queue-mode&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;lazy&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue-arguments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">rabbit:queue</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-9\"><a href=\"#小结-9\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>惰性队列，因为需要将消息存入磁盘中，减少了内存的开销，磁盘远远比内存大的，所以可以存储更多的消息。</li>\n<li>惰性队列，因为需要将消息存入磁盘中，在消费时再取出，需要操作io，所以性能上不如普通队列。</li>\n</ul>\n<h1 id=\"备份交换机\"><a href=\"#备份交换机\" class=\"headerlink\" title=\"备份交换机\"></a>备份交换机</h1>"},{"title":"ShardingSphere","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/分布式/链路追踪/SkyWalking.md","raw":"---\ntitle: ShardingSphere\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-ShardingSphere\ntags: \n   - ShardingSphere\n   - 中间件\n---","slug":"oyr/分布式/链路追踪/SkyWalking","published":1,"updated":"2021-10-27T02:51:15.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87s007acst7boq339ki","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MyCat","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/分布式/分库分表/MyCat.md","raw":"---\ntitle: MyCat\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: ory-MyCat\ntags: \n   - MyCat\n   - 中间件\n---","slug":"oyr/分布式/分库分表/MyCat","published":1,"updated":"2021-10-27T02:51:27.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckv9af87t007ecst741kg1reu","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"ckv9af85x0001cst7cro6hcuw","category_id":"ckv9af8610004cst75dizaxdv","_id":"ckv9af865000fcst797747smv"},{"post_id":"ckv9af8620007cst72rnrhpaa","category_id":"ckv9af864000acst7ducadx2i","_id":"ckv9af867000lcst7dmez0gfh"},{"post_id":"ckv9af8630008cst7b7rj82h0","category_id":"ckv9af865000gcst74ty512on","_id":"ckv9af869000scst7fbik73dw"},{"post_id":"ckv9af8630009cst7272s8pa8","category_id":"ckv9af865000gcst74ty512on","_id":"ckv9af86b000ycst7bze3hedx"},{"post_id":"ckv9af864000dcst784eh885u","category_id":"ckv9af865000gcst74ty512on","_id":"ckv9af86e0014cst75mt8gq1p"},{"post_id":"ckv9af865000ecst7bot331t1","category_id":"ckv9af865000gcst74ty512on","_id":"ckv9af86f0019cst7cr6k0j73"},{"post_id":"ckv9af866000icst7g9nl7qhl","category_id":"ckv9af86d0013cst7aq69b77n","_id":"ckv9af86g001fcst76rc16sjb"},{"post_id":"ckv9af866000kcst7bahgd2i5","category_id":"ckv9af86f001acst73bq77dn3","_id":"ckv9af86h001mcst7gwungb2u"},{"post_id":"ckv9af868000ocst72yks8d14","category_id":"ckv9af86g001hcst72crfckci","_id":"ckv9af86j001scst716w4ct1b"},{"post_id":"ckv9af869000qcst714zc3215","category_id":"ckv9af86g001hcst72crfckci","_id":"ckv9af86k001ycst738f80ceu"},{"post_id":"ckv9af86a000ucst7b34u7yrf","category_id":"ckv9af86g001hcst72crfckci","_id":"ckv9af86m0024cst7c9f48eig"},{"post_id":"ckv9af86a000wcst7d5a010c2","category_id":"ckv9af86g001hcst72crfckci","_id":"ckv9af86n0029cst76uvz2zbr"},{"post_id":"ckv9af86b0010cst75pqa3wh9","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86p002hcst70ouu9w1x"},{"post_id":"ckv9af86c0012cst7e2e7fz49","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86q002ocst7ajx1e5i6"},{"post_id":"ckv9af86e0016cst77ndk71bt","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86r002tcst7e97v5bv7"},{"post_id":"ckv9af86e0018cst7h5k3fc94","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86s002ycst7bysfhr4b"},{"post_id":"ckv9af86f001ccst75mh9fsji","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86u0034cst728t43lhc"},{"post_id":"ckv9af86g001ecst7basi2e9u","category_id":"ckv9af86m0023cst7gx5b9870","_id":"ckv9af86v0039cst73byweim3"},{"post_id":"ckv9af86g001gcst740670ypo","category_id":"ckv9af86u0033cst7glzp3ub0","_id":"ckv9af86v003ecst7e0oheu68"},{"post_id":"ckv9af86h001kcst7dosj8z1p","category_id":"ckv9af86v003bcst72ofh1md9","_id":"ckv9af86w003icst78go48ect"},{"post_id":"ckv9af86h001lcst799x7axeu","category_id":"ckv9af86v003fcst7df62cufh","_id":"ckv9af86w003ncst74dnt0ccn"},{"post_id":"ckv9af86i001pcst7cepu56nn","category_id":"ckv9af86w003kcst71ktk679e","_id":"ckv9af86x003rcst7a9h60000"},{"post_id":"ckv9af86i001qcst75ugrf9ul","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af86x003wcst73ur9h64e"},{"post_id":"ckv9af86j001ucst7a5q32ijx","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af86y0040cst72scca93j"},{"post_id":"ckv9af86k001wcst75c5e29ar","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af86y0043cst784ui58ua"},{"post_id":"ckv9af86l0021cst7bw2scdf5","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af86y0047cst78qqp1ayf"},{"post_id":"ckv9af86l0022cst7efuf4lln","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af86z004acst75xxednjf"},{"post_id":"ckv9af86m0026cst71x9tdcxg","category_id":"ckv9af86y0046cst78t1mdsk0","_id":"ckv9af86z004dcst7bv0q1sg2"},{"post_id":"ckv9af86n0028cst72g5pa9iu","category_id":"ckv9af86z004bcst7cr9sbwp4","_id":"ckv9af870004icst72dtdgnyt"},{"post_id":"ckv9af86o002dcst7bqujczfr","category_id":"ckv9af86z004ecst7a3d6g0x1","_id":"ckv9af870004ncst766anf3dj"},{"post_id":"ckv9af86o002fcst70w229pnh","category_id":"ckv9af86z004bcst7cr9sbwp4","_id":"ckv9af871004scst7g0rs7pez"},{"post_id":"ckv9af86p002jcst7hj76bzov","category_id":"ckv9af86z004bcst7cr9sbwp4","_id":"ckv9af872004vcst7hewzbiu2"},{"post_id":"ckv9af86p002lcst73si1c4s3","category_id":"ckv9af86z004bcst7cr9sbwp4","_id":"ckv9af872004zcst79s7kaecb"},{"post_id":"ckv9af86q002qcst70m712v56","category_id":"ckv9af871004ucst75g07hgdn","_id":"ckv9af8730053cst78rcnh4y9"},{"post_id":"ckv9af86r002rcst708bd3bn8","category_id":"ckv9af871004ucst75g07hgdn","_id":"ckv9af8730058cst7e6re64x5"},{"post_id":"ckv9af86r002vcst76kum3h94","category_id":"ckv9af871004ucst75g07hgdn","_id":"ckv9af874005bcst77gcp3uic"},{"post_id":"ckv9af86s002wcst79hag2hah","category_id":"ckv9af871004ucst75g07hgdn","_id":"ckv9af874005fcst7h5wm9prg"},{"post_id":"ckv9af86s0030cst7e76q84ka","category_id":"ckv9af874005acst72oz3fb7m","_id":"ckv9af874005icst7h1ll9jvd"},{"post_id":"ckv9af86t0032cst72nl9haqs","category_id":"ckv9af871004ucst75g07hgdn","_id":"ckv9af875005lcst720ye3uq4"},{"post_id":"ckv9af87d006qcst712qx0v12","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87p006wcst74ixf0b77"},{"post_id":"ckv9af87f006tcst7dfutfuzn","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87r0070cst7h5236uya"},{"post_id":"ckv9af87n006ucst70wxs4jii","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87r0073cst7hk87aman"},{"post_id":"ckv9af87c006pcst76vqifezr","category_id":"ckv9af87d006rcst79av7hwvs","_id":"ckv9af87s0077cst7btwc124k"},{"post_id":"ckv9af87o006vcst761ri5w5d","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87t007bcst7f7wdfzge"},{"post_id":"ckv9af87q006zcst70nb8esll","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87t007fcst75s8lb2tr"},{"post_id":"ckv9af87s0076cst7h79xf9f2","category_id":"ckv9af86w003ocst73x4g0hy0","_id":"ckv9af87u007icst741dr2hoj"},{"post_id":"ckv9af87r0072cst77uboa6gp","category_id":"ckv9af87s0078cst774o2dosw","_id":"ckv9af87u007ncst7c4c2cexi"},{"post_id":"ckv9af87s007acst7boq339ki","category_id":"ckv9af87s0078cst774o2dosw","_id":"ckv9af87v007rcst77otp9pp3"},{"post_id":"ckv9af87t007ecst741kg1reu","category_id":"ckv9af87u007mcst7fvpadj6y","_id":"ckv9af87v007vcst7cni23vat"}],"PostTag":[{"post_id":"ckv9af85x0001cst7cro6hcuw","tag_id":"ckv9af8620005cst71nimdogh","_id":"ckv9af864000ccst78toj4h3q"},{"post_id":"ckv9af8620007cst72rnrhpaa","tag_id":"ckv9af864000bcst702ll6wtm","_id":"ckv9af866000jcst7g4eybfso"},{"post_id":"ckv9af8630008cst7b7rj82h0","tag_id":"ckv9af866000hcst7e0ck6cof","_id":"ckv9af869000pcst7buaedtv0"},{"post_id":"ckv9af8630009cst7272s8pa8","tag_id":"ckv9af866000hcst7e0ck6cof","_id":"ckv9af86a000vcst74dyt4is7"},{"post_id":"ckv9af864000dcst784eh885u","tag_id":"ckv9af866000hcst7e0ck6cof","_id":"ckv9af86c0011cst762br1aqv"},{"post_id":"ckv9af865000ecst7bot331t1","tag_id":"ckv9af866000hcst7e0ck6cof","_id":"ckv9af86e0017cst72kzkee9u"},{"post_id":"ckv9af866000icst7g9nl7qhl","tag_id":"ckv9af86e0015cst7hkxc0989","_id":"ckv9af86f001dcst7evq075wo"},{"post_id":"ckv9af866000kcst7bahgd2i5","tag_id":"ckv9af86f001bcst78f8d9i81","_id":"ckv9af86h001jcst70zwc4dq1"},{"post_id":"ckv9af868000ocst72yks8d14","tag_id":"ckv9af86g001icst7a3632jfn","_id":"ckv9af86k001vcst79hhgg0c4"},{"post_id":"ckv9af868000ocst72yks8d14","tag_id":"ckv9af86i001ocst79ulseqhu","_id":"ckv9af86k001zcst7c5n36mcw"},{"post_id":"ckv9af869000qcst714zc3215","tag_id":"ckv9af86g001icst7a3632jfn","_id":"ckv9af86n0027cst74fysdtcx"},{"post_id":"ckv9af869000qcst714zc3215","tag_id":"ckv9af86i001ocst79ulseqhu","_id":"ckv9af86n002acst73v3w76c2"},{"post_id":"ckv9af86m0026cst71x9tdcxg","tag_id":"ckv9af8620005cst71nimdogh","_id":"ckv9af86o002ecst78jxj7xr6"},{"post_id":"ckv9af86a000ucst7b34u7yrf","tag_id":"ckv9af86g001icst7a3632jfn","_id":"ckv9af86p002kcst782u4h5q0"},{"post_id":"ckv9af86a000ucst7b34u7yrf","tag_id":"ckv9af86i001ocst79ulseqhu","_id":"ckv9af86q002mcst7hxoe4n41"},{"post_id":"ckv9af86a000wcst7d5a010c2","tag_id":"ckv9af86g001icst7a3632jfn","_id":"ckv9af86t0031cst74tvcgej0"},{"post_id":"ckv9af86a000wcst7d5a010c2","tag_id":"ckv9af86i001ocst79ulseqhu","_id":"ckv9af86u0035cst7990z57k9"},{"post_id":"ckv9af86a000wcst7d5a010c2","tag_id":"ckv9af86r002ucst7ecfaajix","_id":"ckv9af86u0038cst73fbvf3ka"},{"post_id":"ckv9af86b0010cst75pqa3wh9","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86v003acst787vu1qff"},{"post_id":"ckv9af86c0012cst7e2e7fz49","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86v003dcst71n3r8zf7"},{"post_id":"ckv9af86e0016cst77ndk71bt","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86w003hcst7ab8wajx8"},{"post_id":"ckv9af86e0018cst7h5k3fc94","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86w003lcst762h320bh"},{"post_id":"ckv9af86f001ccst75mh9fsji","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86w003pcst71ch21bfb"},{"post_id":"ckv9af86g001ecst7basi2e9u","tag_id":"ckv9af86s002zcst734c0dof7","_id":"ckv9af86x003tcst7hqy47yg4"},{"post_id":"ckv9af86g001gcst740670ypo","tag_id":"ckv9af86x003qcst74r7jaysd","_id":"ckv9af86x003xcst76dv7gqox"},{"post_id":"ckv9af86h001kcst7dosj8z1p","tag_id":"ckv9af86x003ucst7hg6t7761","_id":"ckv9af86y0041cst7ei65fw9i"},{"post_id":"ckv9af86h001lcst799x7axeu","tag_id":"ckv9af86x003ycst72oyu0m37","_id":"ckv9af86y0045cst7hpnpbk6b"},{"post_id":"ckv9af86i001pcst7cepu56nn","tag_id":"ckv9af86x003ycst72oyu0m37","_id":"ckv9af86z0049cst7dpv5hv29"},{"post_id":"ckv9af86i001qcst75ugrf9ul","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af870004gcst77b672hny"},{"post_id":"ckv9af86i001qcst75ugrf9ul","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af870004hcst7154h46vt"},{"post_id":"ckv9af86j001ucst7a5q32ijx","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af871004ocst73nuu7gto"},{"post_id":"ckv9af86j001ucst7a5q32ijx","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af871004pcst790ope06p"},{"post_id":"ckv9af86k001wcst75c5e29ar","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af872004wcst7hges262t"},{"post_id":"ckv9af86k001wcst75c5e29ar","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af872004xcst7cy2pdesu"},{"post_id":"ckv9af86l0021cst7bw2scdf5","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af8730054cst7h0aw8lxe"},{"post_id":"ckv9af86l0021cst7bw2scdf5","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af8730055cst78xbifs6y"},{"post_id":"ckv9af86l0022cst7efuf4lln","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af874005ccst74xow4r0s"},{"post_id":"ckv9af86l0022cst7efuf4lln","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af874005dcst72gx1hna6"},{"post_id":"ckv9af86n0028cst72g5pa9iu","tag_id":"ckv9af8730059cst7afxl3rh2","_id":"ckv9af875005jcst7e93q6jjc"},{"post_id":"ckv9af86n0028cst72g5pa9iu","tag_id":"ckv9af874005ecst7ff5t8ebp","_id":"ckv9af875005kcst78hmadr70"},{"post_id":"ckv9af86o002dcst7bqujczfr","tag_id":"ckv9af874005hcst74rj33yoe","_id":"ckv9af875005ocst7bl606lu8"},{"post_id":"ckv9af86o002dcst7bqujczfr","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af875005pcst769dgg4zg"},{"post_id":"ckv9af86o002fcst70w229pnh","tag_id":"ckv9af8730059cst7afxl3rh2","_id":"ckv9af875005scst74r4f8qzt"},{"post_id":"ckv9af86o002fcst70w229pnh","tag_id":"ckv9af874005ecst7ff5t8ebp","_id":"ckv9af876005tcst7ackb7zph"},{"post_id":"ckv9af86p002jcst7hj76bzov","tag_id":"ckv9af8730059cst7afxl3rh2","_id":"ckv9af876005wcst78imn3p9r"},{"post_id":"ckv9af86p002jcst7hj76bzov","tag_id":"ckv9af874005ecst7ff5t8ebp","_id":"ckv9af876005xcst7hqwphe16"},{"post_id":"ckv9af86p002lcst73si1c4s3","tag_id":"ckv9af8730059cst7afxl3rh2","_id":"ckv9af8760060cst72sb82pfx"},{"post_id":"ckv9af86p002lcst73si1c4s3","tag_id":"ckv9af874005ecst7ff5t8ebp","_id":"ckv9af8760061cst75wvdgf6b"},{"post_id":"ckv9af86q002qcst70m712v56","tag_id":"ckv9af876005zcst7fnlw1qeu","_id":"ckv9af8770064cst71p0949zg"},{"post_id":"ckv9af86q002qcst70m712v56","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af8770065cst7f40o97cs"},{"post_id":"ckv9af86r002rcst708bd3bn8","tag_id":"ckv9af876005zcst7fnlw1qeu","_id":"ckv9af8780068cst7c2ey4ni5"},{"post_id":"ckv9af86r002rcst708bd3bn8","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af8780069cst7gxm0aj12"},{"post_id":"ckv9af86r002vcst76kum3h94","tag_id":"ckv9af876005zcst7fnlw1qeu","_id":"ckv9af878006ccst7d2d729sq"},{"post_id":"ckv9af86r002vcst76kum3h94","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af878006dcst73bhlbb2s"},{"post_id":"ckv9af86s002wcst79hag2hah","tag_id":"ckv9af876005zcst7fnlw1qeu","_id":"ckv9af879006gcst71cv413yd"},{"post_id":"ckv9af86s002wcst79hag2hah","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af879006hcst7fuo559xt"},{"post_id":"ckv9af86s0030cst7e76q84ka","tag_id":"ckv9af878006fcst7hctk7fte","_id":"ckv9af879006kcst7bdvjejwv"},{"post_id":"ckv9af86s0030cst7e76q84ka","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af879006lcst70pngecpn"},{"post_id":"ckv9af86t0032cst72nl9haqs","tag_id":"ckv9af876005zcst7fnlw1qeu","_id":"ckv9af87b006ncst73fcuhhg7"},{"post_id":"ckv9af86t0032cst72nl9haqs","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87b006ocst7frjcgjrg"},{"post_id":"ckv9af87c006pcst76vqifezr","tag_id":"ckv9af87d006scst74ujs4mwl","_id":"ckv9af87q006ycst71s117lf2"},{"post_id":"ckv9af87c006pcst76vqifezr","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87r0071cst70qh6dxad"},{"post_id":"ckv9af87q006zcst70nb8esll","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87s0075cst74anx43n7"},{"post_id":"ckv9af87q006zcst70nb8esll","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87s0079cst7aecogy58"},{"post_id":"ckv9af87q006zcst70nb8esll","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87t007dcst7fl1jafrp"},{"post_id":"ckv9af87d006qcst712qx0v12","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87u007gcst7dlgqgymh"},{"post_id":"ckv9af87d006qcst712qx0v12","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87u007kcst7fwaafwk2"},{"post_id":"ckv9af87d006qcst712qx0v12","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87u007lcst77h0ig81i"},{"post_id":"ckv9af87s0076cst7h79xf9f2","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87v007pcst7gfeb3wav"},{"post_id":"ckv9af87s0076cst7h79xf9f2","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87v007qcst7bntg4qqn"},{"post_id":"ckv9af87s0076cst7h79xf9f2","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87v007tcst79hax9ajk"},{"post_id":"ckv9af87f006tcst7dfutfuzn","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87v007ucst75jaoeglk"},{"post_id":"ckv9af87f006tcst7dfutfuzn","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87v007xcst7any5593a"},{"post_id":"ckv9af87f006tcst7dfutfuzn","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87v007ycst77nzbhgmq"},{"post_id":"ckv9af87n006ucst70wxs4jii","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87v007zcst78jv3hd8j"},{"post_id":"ckv9af87n006ucst70wxs4jii","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87w0080cst7cppvfahg"},{"post_id":"ckv9af87n006ucst70wxs4jii","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87w0081cst72x1egs1f"},{"post_id":"ckv9af87o006vcst761ri5w5d","tag_id":"ckv9af86y0048cst7bkp2g2op","_id":"ckv9af87w0082cst7dfha9ag2"},{"post_id":"ckv9af87o006vcst761ri5w5d","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87w0083cst7g5a6d7la"},{"post_id":"ckv9af87o006vcst761ri5w5d","tag_id":"ckv9af87p006xcst708qrhcmu","_id":"ckv9af87w0084cst7fpmm7485"},{"post_id":"ckv9af87r0072cst77uboa6gp","tag_id":"ckv9af87u007ocst73ls9c12n","_id":"ckv9af87w0085cst7grwh049t"},{"post_id":"ckv9af87r0072cst77uboa6gp","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87w0086cst7feih19ji"},{"post_id":"ckv9af87s007acst7boq339ki","tag_id":"ckv9af87u007ocst73ls9c12n","_id":"ckv9af87w0087cst7ddea9pxv"},{"post_id":"ckv9af87s007acst7boq339ki","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87w0088cst7hmqo928m"},{"post_id":"ckv9af87t007ecst741kg1reu","tag_id":"ckv9af87v007wcst7aggl48nx","_id":"ckv9af87w0089cst783cg0ucg"},{"post_id":"ckv9af87t007ecst741kg1reu","tag_id":"ckv9af86z004ccst73m5te22a","_id":"ckv9af87w008acst70upecxy7"}],"Tag":[{"name":"Markdown","_id":"ckv9af8620005cst71nimdogh"},{"name":"DDD","_id":"ckv9af864000bcst702ll6wtm"},{"name":"es","_id":"ckv9af866000hcst7e0ck6cof"},{"name":"spring","_id":"ckv9af86e0015cst7hkxc0989"},{"name":"设计模式","_id":"ckv9af86f001bcst78f8d9i81"},{"name":"Dubbo","_id":"ckv9af86g001icst7a3632jfn"},{"name":"分布式","_id":"ckv9af86i001ocst79ulseqhu"},{"name":"面试","_id":"ckv9af86r002ucst7ecfaajix"},{"name":"并发编程","_id":"ckv9af86s002zcst734c0dof7"},{"name":"Hexo","_id":"ckv9af86x003qcst74r7jaysd"},{"name":"Feign","_id":"ckv9af86x003ucst7hg6t7761"},{"name":"java","_id":"ckv9af86x003ycst72oyu0m37"},{"name":"MQ","_id":"ckv9af86y0048cst7bkp2g2op"},{"name":"中间件","_id":"ckv9af86z004ccst73m5te22a"},{"name":"MySQL","_id":"ckv9af8730059cst7afxl3rh2"},{"name":"数据库","_id":"ckv9af874005ecst7ff5t8ebp"},{"name":"Nginx","_id":"ckv9af874005hcst74rj33yoe"},{"name":"Redis","_id":"ckv9af876005zcst7fnlw1qeu"},{"name":"分布式session","_id":"ckv9af878006fcst7hctk7fte"},{"name":"链路追踪","_id":"ckv9af87d006scst74ujs4mwl"},{"name":"RabbitMQ","_id":"ckv9af87p006xcst708qrhcmu"},{"name":"ShardingSphere","_id":"ckv9af87u007ocst73ls9c12n"},{"name":"MyCat","_id":"ckv9af87v007wcst7aggl48nx"}]}}