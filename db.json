{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"0be6d5855abd247eaf7b2536e235a9bfd7dbceda","modified":1625820895927},{"_id":"source/categories/index.md","hash":"d74dea876104aae5e86f128ddbc114701e5ff5b7","modified":1626085904000},{"_id":"source/about/index.md","hash":"08a1583c86bb1218a9d1a0cfc65bb3dd9325f55b","modified":1626085904000},{"_id":"source/tags/index.md","hash":"9c54d025494f9b8c74259a9cc61380809eac8719","modified":1626085904000},{"_id":"source/_posts/oyr/Dubbo/Dubbo-高级.md","hash":"44ab103e7f63bfe902125a73661bc47fdef9ca79","modified":1626085904000},{"_id":"source/_posts/oyr/Dubbo/Dubbo-基础.md","hash":"1675c12a688138d70ceff32e98d72c01d7de528d","modified":1630464397197},{"_id":"source/_posts/demo/MD.md","hash":"71c5f1481d0601305ca4ea0c57debec69ba33896","modified":1626160448474},{"_id":"source/_posts/oyr/Feign/Feign.md","hash":"abb4ab6671276f4f69068fbf979cf9b08f943def","modified":1626085904000},{"_id":"source/_posts/oyr/Hexo/Hexo常用命令.md","hash":"80b639261ac5fa37178198f40caab1e8e459b550","modified":1626085904000},{"_id":"source/_posts/oyr/MQ/AMQP.md","hash":"6e26b3b8b6a0bde4b472491f717e4d53dbcef33d","modified":1630464508938},{"_id":"source/_posts/oyr/MQ/ActiveMQ.md","hash":"3423c6c8ce4330c218f8b2c63b8bd868b371ca5f","modified":1630464497479},{"_id":"source/_posts/oyr/MQ/JMS.md","hash":"baea46180ee67e4296a3b8fdfb59bfe5fa6eeadf","modified":1630464523839},{"_id":"source/_posts/oyr/MQ/Kafka.md","hash":"2c9f8373587e90118846c0eceac2befd17e2bbba","modified":1626169781656},{"_id":"source/_posts/oyr/MQ/RabbitMQ.md","hash":"4d931b74fb2a5b5ef377c6e90945c68c0cac9f41","modified":1630464537240},{"_id":"source/_posts/oyr/MQ/消息中间件入门与简介.md","hash":"0dc6eefcf8ec248284765d5d8e0cf2194f63cccf","modified":1630464486606},{"_id":"source/_posts/oyr/Java/Java8新特性.md","hash":"9f82cb5ffd95fc8ed30d32e6c6437be6a35ee35f","modified":1630464423790},{"_id":"source/_posts/oyr/MySQL/MySQL-主从复制.md","hash":"c668200157105eb2b6ef7d8307f61ddced4c76eb","modified":1626169952239},{"_id":"source/_posts/oyr/MySQL/MySQL-事务日志.md","hash":"08624177cc3dd22e937284f80c8428c96734f7e7","modified":1626169810806},{"_id":"source/_posts/oyr/MySQL/MySQL-基础.md","hash":"686f011f6e9859b24fc838ad185e5afd3672b649","modified":1626169963841},{"_id":"source/_posts/oyr/MySQL/MySQL-日志系统.md","hash":"912adce2aa0b9c7ee377b774ebbef0e4d5ea97f2","modified":1630464560042},{"_id":"source/_posts/oyr/Nginx/Nginx.md","hash":"6fddd7e0ef96f7d57e03dc96f0012f023bcab934","modified":1626085904000},{"_id":"source/_posts/oyr/Redis/Redis-哨兵模式.md","hash":"7bb45a5bc33521583fa771bca66668a2da697021","modified":1626169963284},{"_id":"source/_posts/oyr/Redis/Redis-主从复制.md","hash":"c063a6394c4cf0fe4af875e5ff942ce2d478d51e","modified":1626169858878},{"_id":"source/_posts/oyr/Redis/Redis-数据过期策略.md","hash":"2c53fccd17832e6f92d912f78c3ee63afe1426ac","modified":1630464597660},{"_id":"source/_posts/oyr/Redis/Redis-基础.md","hash":"dc7a06e4cfafbe7ddd21e54ed0d0f9a9f2d70d8b","modified":1626169840017},{"_id":"source/_posts/oyr/Redis/Redis-穿透&雪崩&击穿.md","hash":"39d434c8a78087b804938a46dd05eb52a0780f55","modified":1626169821055},{"_id":"source/_posts/oyr/Redis/Redis-集群模式.md","hash":"c76d2f00d39d811a9e52674c8993b69f9566e66e","modified":1626169962272},{"_id":"source/_posts/lh/DDD/DDD领域模型设计.md","hash":"2b85c8c790082deb7e329c054ef0607b177bdb91","modified":1628586971444},{"_id":"source/_posts/lh/spring/注解编程.md","hash":"9e725994dce521cfb7d504d83631ce098a3fe9c9","modified":1630392697601},{"_id":"source/_posts/lh/并发编程/CAS.md","hash":"b6d2994bb817e95305cdc465f5d699f74eeadcbd","modified":1630464339283},{"_id":"source/_posts/lh/并发编程/volatile.md","hash":"17973ef5741849d2e67c53fb11112e1acd8490c7","modified":1630566526865},{"_id":"source/_posts/lh/并发编程/AQS.md","hash":"4908e2c952d15677e7569bb420af6a25b34c778f","modified":1630464326187},{"_id":"source/_posts/lh/并发编程/并发编程初讲.md","hash":"92c5f8519851dd6fe5f2e038cffc693561deed33","modified":1630464302553},{"_id":"source/_posts/lh/并发编程/线程池.md","hash":"1c4dd84e3614278ab62fc4da551cf60b5e272664","modified":1630464313477},{"_id":"source/_posts/lh/并发编程/锁相关.md","hash":"e1a1c836a3b7a74ee8b7dbbc620e43c2bbc82762","modified":1630464289150},{"_id":"source/_posts/lh/设计模式/设计模式初讲.md","hash":"b1e696d8a08eefed17cf234271b62dbe60185027","modified":1630464365676},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1626085904000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1626085904000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1626085904000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1626085904000},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1626085904000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1626085904000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1626085904000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1626085904000},{"_id":"themes/next/_config.yml","hash":"7f6756a6d26f6994c5ebfc88579c614f1755f2cd","modified":1626085904000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1626085904000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1626085904000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1626085904000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1626085904000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1626085904000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1626085904000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1626085904000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1626085904000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1626085904000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1626085904000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1626085904000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1626085904000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1626085904000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1626085904000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1626085904000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1626085904000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1626085904000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1626085904000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1626085904000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1626085904000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1626085904000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1626085904000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1626085904000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1626085904000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1626085904000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1626085904000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1626085904000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1626085904000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1626085904000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1626085904000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1626085904000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1626085904000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1626085904000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1626085904000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1626085904000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1626085904000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1626085904000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1626085904000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1626085904000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1626085904000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1626085904000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1626085904000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1626085904000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1626085904000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1626085904000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1626085904000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1626085904000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1626085904000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1626085904000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1626085904000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1626085904000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1626085904000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1626085904000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1626085904000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1626085904000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1626085904000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1626085904000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1626085904000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1626085904000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c4ec5822d644ddcedf2401837e6f6e6d3b63fbcd","modified":1626085904000},{"_id":"themes/next/layout/_macro/post.swig","hash":"71e4dc5a56cbc403d9785526f7719d824f4c8911","modified":1626085904000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1626085904000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1626085904000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ce2c1000be53443914517aa90c70f9b72c30a672","modified":1626085904000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1626085904000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1626085904000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1626085904000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1626085904000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1626085904000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1626085904000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1626085904000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1626085904000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1626085904000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1626085904000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1626085904000},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1626085904000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1626085904000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1626085904000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1626085904000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1626085904000},{"_id":"themes/next/scripts/filters/post.js","hash":"d86849559ae54a4098aef4e2ab9dc8f99a1d186c","modified":1626085904000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"22d77bd511fc7c1bbd12339d65004ed5bfb0713c","modified":1626085904000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1626085904000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1626085904000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1626085904000},{"_id":"themes/next/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1626085904000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1626085904000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1626085904000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1626085904000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1626085904000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1626085904000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1626085904000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1626085904000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1626085904000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1626085904000},{"_id":"themes/next/source/css/_colors.styl","hash":"19c836f367977fb712b9868f3281ff5d757a8d5c","modified":1626085904000},{"_id":"themes/next/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1626085904000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1626085904000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626085904000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1626085904000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1626085904000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1626085904000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1626085904000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1626085904000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1626085904000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1626085904000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1626085904000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1626085904000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1626085904000},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1626085904000},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1626085904000},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1626085904000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1626085904000},{"_id":"themes/next/source/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1626085904000},{"_id":"themes/next/source/js/utils.js","hash":"0343eb03ed76c0b030f7807b82a00772135ba463","modified":1626085904000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1626085904000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1626085904000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"12aeb9ee0d1d49d347f82a91e6bab568e1b59037","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"958e097790551c9520426a1233add03515034f35","modified":1626085904000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1626085904000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1626085904000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"12cd9adb0c33adc484201f9e8a4e64ccf3011bae","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1626085904000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1626085904000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1626085904000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"ec20ff43845723e0ac2a245047c7a7e5aead6e88","modified":1626085904000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1626085904000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1626085904000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1626085904000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1626085904000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1626085904000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1626085904000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1626085904000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1626085904000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1626085904000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1626085904000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1626085904000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1626085904000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"799fdf4f258a51d45d1e2b02fb59b337e46b5b3c","modified":1626085904000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dae390efcb5da9c021ad7f25fe2d39ff36938cc6","modified":1626085904000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1626085904000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1626085904000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1626085904000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"220da37051ed5dac9cf7bd126451f6aba4f94d21","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"5e644b1303ab6dcd1b65ee0fd6b91309b04ce64d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1626085904000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"89f76380091f1be49936c69bac02e984dae5ff87","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"66211794e4ed47e779ca81150cef588e0b4f2fc5","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1626085904000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1626085904000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9b3cce30c58e57b59e45d3f668a71a4129d3a8e4","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1626085904000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1626085904000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1626085904000},{"_id":"public/categories/index.html","hash":"d869b0ba108c9188f59789d4ebc67c3f72b08a1d","modified":1630566551017},{"_id":"public/about/index.html","hash":"47413ad99b4c419a441bb6dc9a3c54ff80967d49","modified":1630566551017},{"_id":"public/tags/index.html","hash":"d7b9af3a9adaaba5e21b9762563e456b79e19304","modified":1630566551017},{"_id":"public/2021/07/27/lh/DDD/DDD领域模型设计/index.html","hash":"71cd2af383934eb0cf3fa9d94daad7116c97fd3e","modified":1630566551017},{"_id":"public/2021/07/09/oyr/MQ/Kafka/index.html","hash":"2cbff1c089983931ed822e6070d53d9ac6094e42","modified":1630566551017},{"_id":"public/2021/07/08/hello-world/index.html","hash":"0b8e9f716cbdf3ce3974d6ae7716cf78310a8ca9","modified":1630566551017},{"_id":"public/2021/06/23/oyr/MySQL/MySQL-主从复制/index.html","hash":"d1e9ff31ac41934394e4f423933353f4f80c454a","modified":1630566551017},{"_id":"public/2021/06/23/oyr/Nginx/Nginx/index.html","hash":"e2af349d334116dee14b9bfb21b921ec5e60774f","modified":1630566551017},{"_id":"public/2021/06/20/oyr/Hexo/Hexo常用命令/index.html","hash":"54a7f2f672998620136eae45ef98e8052ce68d3e","modified":1630566551017},{"_id":"public/2020/06/23/oyr/Redis/Redis-集群模式/index.html","hash":"8c0e4bdc4a1c284986754cc940b592f2421a8d7c","modified":1630566551017},{"_id":"public/2020/06/22/oyr/Redis/Redis-哨兵模式/index.html","hash":"15f7462704823f9ff3605987ce2fb99dee181949","modified":1630566551017},{"_id":"public/2020/06/21/oyr/Redis/Redis-主从复制/index.html","hash":"11078251b416b6817320686aca737ce8493cf7e3","modified":1630566551017},{"_id":"public/archives/index.html","hash":"5ecdfd890f21c953e8ac8359a90778fbb94cf1da","modified":1630566551017},{"_id":"public/archives/page/2/index.html","hash":"a296c8b11f8451e21557645d01d571254b66ca20","modified":1630566551017},{"_id":"public/archives/page/3/index.html","hash":"a8410826c17dd6267acbf6b535d449366e604905","modified":1630566551017},{"_id":"public/archives/page/4/index.html","hash":"caf88a7e2e8e1e8fe6d4ae3aedfc758ffb461283","modified":1630566551017},{"_id":"public/archives/2020/index.html","hash":"01ed37cb56c1756868e027c600e17dfae7c5f53b","modified":1630566551017},{"_id":"public/archives/2020/06/index.html","hash":"9fe65d97deb87a169d25a4c91928a4d9b417d30c","modified":1630566551017},{"_id":"public/archives/2021/index.html","hash":"78df3826a8c6cbc1590ffeaf4655a09c9a6409b2","modified":1630566551017},{"_id":"public/archives/2021/page/2/index.html","hash":"b5d17b85a098f91cb65b91f8ed8c9355b6eabcc8","modified":1630566551017},{"_id":"public/archives/2021/page/3/index.html","hash":"279b573200d49f002c6d2dc55549fcd353c742bd","modified":1630566551017},{"_id":"public/archives/2021/06/index.html","hash":"124186cae3ef2e22a9001d616f5babc6db4d53c5","modified":1630566551017},{"_id":"public/archives/2021/06/page/2/index.html","hash":"fd306c0e1cfd9c01dd80530409dbc8158f347514","modified":1630566551017},{"_id":"public/archives/2021/07/index.html","hash":"208af73cf6ae159cf92af2818ab6dc769c5971d1","modified":1630566551017},{"_id":"public/archives/2021/08/index.html","hash":"7d021f4679f16a3830aef4f0cc0560ff63951827","modified":1630566551017},{"_id":"public/categories/MD/index.html","hash":"3f06195dcdae1f0d1ff50303b69333c166c38352","modified":1630566551017},{"_id":"public/categories/Dubbo/index.html","hash":"de6e6a0778eb0c86bf00d41e45646a0b025b99fb","modified":1630566551017},{"_id":"public/categories/HTTP-客户端/index.html","hash":"2fdeba6fb5d4762b39b4db88a3fbdfe1fcfa5053","modified":1630566551017},{"_id":"public/categories/Hexo/index.html","hash":"d96ce399097880770df663590c5e944652197a88","modified":1630566551017},{"_id":"public/categories/oyr-MQ/index.html","hash":"bb4977e99bd87f016e3a3ca713c7f3b446665a56","modified":1630566551017},{"_id":"public/categories/MQ/index.html","hash":"32efa481e32068e7fd0a2e65ed8c1fc97e8b8f7e","modified":1630566551017},{"_id":"public/categories/oyr-MySQL/index.html","hash":"d54c44e49c6f4ecbb0920eb7472eb2a50cd57e75","modified":1630566551017},{"_id":"public/categories/Java/index.html","hash":"2bc89411b7cf3bc31d3a353cd6f8a6279472028a","modified":1630566551017},{"_id":"public/categories/Nginx/index.html","hash":"162f5da0516ef13a08e9803b90cfcf87c3707278","modified":1630566551017},{"_id":"public/categories/oyr-Redis/index.html","hash":"31151702b32d81e1ed489049dcbe8950f663c074","modified":1630566551017},{"_id":"public/categories/DDD/index.html","hash":"a1ce37361837cc718e13d06694dba2df08f7faa5","modified":1630566551017},{"_id":"public/categories/spring/index.html","hash":"a6793ccc7c2543746d334180626fccaa1727ac4f","modified":1630566551017},{"_id":"public/categories/并发编程/index.html","hash":"6a3b90548983e5ca718a924645b0a42a29cb1d0f","modified":1630566551017},{"_id":"public/categories/设计模式/index.html","hash":"57093736951aa37fcea1ea002d575969d5dc2649","modified":1630566551017},{"_id":"public/tags/Markdown/index.html","hash":"92148eaaf431c3773321bda8fd8e33c5f0d09106","modified":1630566551017},{"_id":"public/tags/Dubbo/index.html","hash":"be9712edda8eb62114192773dd07a00f21b729d6","modified":1630566551017},{"_id":"public/tags/分布式/index.html","hash":"d5b79914e8c707e329fafcd51d3ff12866c0b5cf","modified":1630566551017},{"_id":"public/tags/Feign/index.html","hash":"84d4cf002b6572d312e69fb582e267751f8eec9f","modified":1630566551017},{"_id":"public/tags/Hexo/index.html","hash":"60fbe7d7b75876306bc92c04b5a17d8840dcce98","modified":1630566551017},{"_id":"public/tags/oyr-MQ/index.html","hash":"327b11e32a2787954ac9b730516dfb743ee2e4f9","modified":1630566551017},{"_id":"public/tags/中间件/index.html","hash":"7bac9774dc89a31c9a5d275d546d6e387b9a9a51","modified":1630566551017},{"_id":"public/tags/中间件/page/2/index.html","hash":"1399750a53ed384d309993b905659ce160625130","modified":1630566551017},{"_id":"public/tags/MQ/index.html","hash":"8be81f83aa7039a8eab9ea8165099b4776f71b07","modified":1630566551017},{"_id":"public/tags/oyr-MySQL/index.html","hash":"3fc210a8a14bbb2c3c13e5585b3a1f4c0933e1a3","modified":1630566551017},{"_id":"public/tags/数据库/index.html","hash":"63b76866c7aca9c16f2252349402c0c5bee03cc6","modified":1630566551017},{"_id":"public/tags/java/index.html","hash":"92171b5421bf442d52343fcfecdac594f95a7b75","modified":1630566551017},{"_id":"public/tags/Nginx/index.html","hash":"efcd79513e71313d5edca2d32a9aa4974b21ea64","modified":1630566551017},{"_id":"public/tags/oyr-Redis/index.html","hash":"a7ec62c810ce790f7e49bf0feb29d5f758b9c212","modified":1630566551017},{"_id":"public/tags/DDD/index.html","hash":"be3109004c4d20df119669a548d990095a1784fa","modified":1630566551017},{"_id":"public/tags/spring/index.html","hash":"a20cce1292a0d9d933e221ba38804834fbfb55a8","modified":1630566551017},{"_id":"public/tags/并发编程/index.html","hash":"1b1749b9bc0c3adf52a599292aad1a1de4a569f8","modified":1630566551017},{"_id":"public/tags/设计模式/index.html","hash":"bb8676fa03123e842254b575c7077425a979feb8","modified":1630566551017},{"_id":"public/2021/08/31/lh/spring/注解编程/index.html","hash":"e6877a48b782bd035f37f392e6df1aaae1fd9bfb","modified":1630566551017},{"_id":"public/2021/08/30/lh/并发编程/线程池/index.html","hash":"27709fd36c67768e0a764142a58a8bff695b4498","modified":1630566551017},{"_id":"public/2021/08/30/lh/并发编程/锁相关/index.html","hash":"6164fb99965ecd5e721cd4cbc107407896270ccf","modified":1630566551017},{"_id":"public/2021/08/27/lh/并发编程/AQS/index.html","hash":"d44d4a03b662d17157a64757f2c99fe59e727e43","modified":1630566551017},{"_id":"public/2021/08/11/lh/并发编程/CAS/index.html","hash":"5a0263d686209cdca2469eb4510967ae80158409","modified":1630566551017},{"_id":"public/2021/08/10/lh/并发编程/volatile/index.html","hash":"89d68133bc7fe8e4e78e4d8ff972e90519d986ed","modified":1630566551017},{"_id":"public/2021/08/10/lh/并发编程/并发编程初讲/index.html","hash":"615facd4b73d3a541941f7574b0a54b9ff7a5752","modified":1630566551017},{"_id":"public/2021/07/27/lh/设计模式/设计模式初讲/index.html","hash":"94512c3b00127ff03ad0f72dcdd2a6ac50170475","modified":1630566551017},{"_id":"public/2021/07/12/demo/MD/index.html","hash":"661497a3d1e7f010e1fc7ca5306edf1e512e1d7c","modified":1630566551017},{"_id":"public/2021/07/09/oyr/MQ/JMS/index.html","hash":"3392ef4b9b0619030ace7d54081d64fe71791163","modified":1630566551017},{"_id":"public/2021/07/08/oyr/Dubbo/Dubbo-高级/index.html","hash":"0389bc9cb71788edd0c3784efc7c9febf92e6cc9","modified":1630566551017},{"_id":"public/2021/06/25/oyr/Dubbo/Dubbo-基础/index.html","hash":"5c53f93db06c91383e024c17b1f36b0bd9e3987e","modified":1630566551017},{"_id":"public/2021/06/23/oyr/MySQL/MySQL-事务日志/index.html","hash":"4135fd8cdb89da4b02e3ef3858ce300f788e16c0","modified":1630566551017},{"_id":"public/2021/06/22/oyr/MQ/RabbitMQ/index.html","hash":"faf99b3eae878fd70ded90902861b429d132319b","modified":1630566551017},{"_id":"public/2021/06/22/oyr/MySQL/MySQL-日志系统/index.html","hash":"f96667853133bca8f5c98c0cf4a26130178b6bfa","modified":1630566551017},{"_id":"public/2021/06/21/oyr/MQ/AMQP/index.html","hash":"c555439f719dba5034b163217fc7cbce53eb6450","modified":1630566551017},{"_id":"public/2021/06/21/oyr/Redis/Redis-数据过期策略/index.html","hash":"95a0d75f9620d27dcdb8af0ecb5cc522a0be1760","modified":1630566551017},{"_id":"public/2021/06/20/oyr/Feign/Feign/index.html","hash":"be983367626c7dd33e827c5f887680f215ca7769","modified":1630566551017},{"_id":"public/2021/06/20/oyr/MQ/消息中间件入门与简介/index.html","hash":"bf807d2f6ccf7efb1eb362ea1538fbfe47d3a324","modified":1630566551017},{"_id":"public/2021/06/20/oyr/Java/Java8新特性/index.html","hash":"7d54de35d5b83370c8fb1dc4030bcc3f3484b957","modified":1630566551017},{"_id":"public/2021/06/20/oyr/MySQL/MySQL-基础/index.html","hash":"de8b406ed7e2ca80271f921dcc2847d8332bc24c","modified":1630566551017},{"_id":"public/2021/06/20/oyr/Redis/Redis-穿透&雪崩&击穿/index.html","hash":"736a2355f54a91c27725fc38da1564bec000dddb","modified":1630566551017},{"_id":"public/2021/06/15/oyr/MQ/ActiveMQ/index.html","hash":"ca376605482a2cd5b3727166950c41edd2674645","modified":1630566551017},{"_id":"public/2020/06/20/oyr/Redis/Redis-基础/index.html","hash":"23bb73822341492425122619ebb65e077b4cb664","modified":1630566551017},{"_id":"public/index.html","hash":"94c522707ef1fe52db94982657f3dd38e9eca288","modified":1630566551017},{"_id":"public/page/2/index.html","hash":"826a4696031bf5d3f493aee6e792d9674037a611","modified":1630566551017},{"_id":"public/page/3/index.html","hash":"b1d9311f1356880ebece3e14912345f9764e3cad","modified":1630566551017},{"_id":"public/page/4/index.html","hash":"5314bd1b3c229e78231e8f02d58767c48f3729cc","modified":1630566551017},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1630566551017},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1630566551017},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1630566551017},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1630566551017},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1630566551017},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1630566551017},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1630566551017},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1630566551017},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1630566551017},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1630566551017},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1630566551017},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1630566551017},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1630566551017},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1630566551017},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1630566551017},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1630566551017},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1630566551017},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1630566551017},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1630566551017},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1630566551017},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1630566551017},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1630566551017},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1630566551017},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1630566551017},{"_id":"public/js/utils.js","hash":"0343eb03ed76c0b030f7807b82a00772135ba463","modified":1630566551017},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1630566551017},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1630566551017},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1630566551017},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1630566551017},{"_id":"public/css/main.css","hash":"5a3f77ab2b79ea117e2bd4ea35f2e19c8d081aed","modified":1630566551017},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1630566551017},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1630566551017},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1630566551017},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1630566551017},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1630566551017}],"Category":[{"name":"MD","_id":"ckt2l835t0006hct77ejsdm3t"},{"name":"Dubbo","_id":"ckt2l835w000bhct73fr07xis"},{"name":"HTTP 客户端","_id":"ckt2l8360000lhct7g21b9k06"},{"name":"Hexo","_id":"ckt2l8363000thct76afxg76t"},{"name":"oyr-MQ","_id":"ckt2l8366000zhct74iyl2006"},{"name":"MQ","_id":"ckt2l836d001hhct71k6n1lqz"},{"name":"oyr-MySQL","_id":"ckt2l836i001yhct7f4l06tif"},{"name":"Java","_id":"ckt2l836j0025hct7forw4pzv"},{"name":"Nginx","_id":"ckt2l836l002ghct7gpei21f9"},{"name":"oyr-Redis","_id":"ckt2l836m002nhct76hm613qw"},{"name":"DDD","_id":"ckt2l836r003ghct7gu4e551w"},{"name":"spring","_id":"ckt2l836r003lhct734shgc2p"},{"name":"并发编程","_id":"ckt2l836s003qhct7gbtk7ywj"},{"name":"设计模式","_id":"ckt2l836v004dhct7a0e2b14h"}],"Data":[],"Page":[{"title":"分类","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\n---\n","date":"2021-07-13T06:36:39.574Z","updated":"2021-07-12T10:31:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckt2l835m0000hct73xz59su9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ntype: \"about\"\n---\n","date":"2021-07-13T06:36:39.572Z","updated":"2021-07-12T10:31:44.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckt2l835q0002hct7bimzhqas","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\n---\n","date":"2021-07-13T06:36:39.574Z","updated":"2021-07-12T10:31:44.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckt2l835s0004hct78xuzeftn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-07-08T09:05:48.553Z","updated":"2021-07-09T08:54:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835o0001hct7hbzebd4v","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Markdown 菜鸟教程","date":"2021-07-11T16:00:00.000Z","author":"lh","summary":"","_content":"\n# Markdown 描述 \nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n# Markdown 实操\n\n我展示的是一级标题\n================\n\n我展示的是二级标题\n----------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 。。。。\n\n## Markdown 段落\n段落换行是已 两个或以上空格+回车即可  \n开始新的一个段落\n\n## Markdown 字体  \n*斜体文本*  \n_斜体文本_ \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___  \n\n## 分隔线  \n可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  \n***  \n* * *  \n******  \n- - -  \n---------\n\n## 删除线  \n段落需要添加删除线 在文本两端添加 两个波浪线即可  \n~~当前版本1.0~~  \n\n## 下划线  \n使用与html相同的标签 u\n<u>下划线文本</u> \n\n## 脚注  \n脚注是对文本的补充说明  \n有一个 [234]\n\n\n[234]: 1231231233  \n\n## Markdown 列表  \n无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  \n* 第一列\n+ 第二列\n- 第三列   \n\n有序列表 \n\n","source":"_posts/demo/MD.md","raw":"---\ntitle: Markdown 菜鸟教程\ndate: 2021-07-12 00:00:00\nauthor: lh\nsummary: \"\"\ntags: Markdown\ncategories: MD\n---\n\n# Markdown 描述 \nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n# Markdown 实操\n\n我展示的是一级标题\n================\n\n我展示的是二级标题\n----------------\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 。。。。\n\n## Markdown 段落\n段落换行是已 两个或以上空格+回车即可  \n开始新的一个段落\n\n## Markdown 字体  \n*斜体文本*  \n_斜体文本_ \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___  \n\n## 分隔线  \n可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  \n***  \n* * *  \n******  \n- - -  \n---------\n\n## 删除线  \n段落需要添加删除线 在文本两端添加 两个波浪线即可  \n~~当前版本1.0~~  \n\n## 下划线  \n使用与html相同的标签 u\n<u>下划线文本</u> \n\n## 脚注  \n脚注是对文本的补充说明  \n有一个 [234]\n\n\n[234]: 1231231233  \n\n## Markdown 列表  \n无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  \n* 第一列\n+ 第二列\n- 第三列   \n\n有序列表 \n\n","slug":"demo/MD","published":1,"updated":"2021-07-13T07:14:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835r0003hct725631zr5","content":"<h1 id=\"Markdown-描述\"><a href=\"#Markdown-描述\" class=\"headerlink\" title=\"Markdown 描述\"></a>Markdown 描述</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 .md, .markdown。</p>\n<h1 id=\"Markdown-实操\"><a href=\"#Markdown-实操\" class=\"headerlink\" title=\"Markdown 实操\"></a>Markdown 实操</h1><h1 id=\"我展示的是一级标题\"><a href=\"#我展示的是一级标题\" class=\"headerlink\" title=\"我展示的是一级标题\"></a>我展示的是一级标题</h1><h2 id=\"我展示的是二级标题\"><a href=\"#我展示的是二级标题\" class=\"headerlink\" title=\"我展示的是二级标题\"></a>我展示的是二级标题</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"。。。。\"><a href=\"#。。。。\" class=\"headerlink\" title=\"。。。。\"></a>。。。。</h5><h2 id=\"Markdown-段落\"><a href=\"#Markdown-段落\" class=\"headerlink\" title=\"Markdown 段落\"></a>Markdown 段落</h2><p>段落换行是已 两个或以上空格+回车即可<br>开始新的一个段落</p>\n<h2 id=\"Markdown-字体\"><a href=\"#Markdown-字体\" class=\"headerlink\" title=\"Markdown 字体\"></a>Markdown 字体</h2><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em>  </p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  </p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>段落需要添加删除线 在文本两端添加 两个波浪线即可<br><del>当前版本1.0</del>  </p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>使用与html相同的标签 u<br><u>下划线文本</u> </p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明<br>有一个 <a href=\"1231231233\">234</a></p>\n<h2 id=\"Markdown-列表\"><a href=\"#Markdown-列表\" class=\"headerlink\" title=\"Markdown 列表\"></a>Markdown 列表</h2><p>无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  </p>\n<ul>\n<li>第一列</li>\n</ul>\n<ul>\n<li>第二列</li>\n</ul>\n<ul>\n<li>第三列   </li>\n</ul>\n<p>有序列表 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Markdown-描述\"><a href=\"#Markdown-描述\" class=\"headerlink\" title=\"Markdown 描述\"></a>Markdown 描述</h1><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>\n<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>\n<p>Markdown 编写的文档后缀为 .md, .markdown。</p>\n<h1 id=\"Markdown-实操\"><a href=\"#Markdown-实操\" class=\"headerlink\" title=\"Markdown 实操\"></a>Markdown 实操</h1><h1 id=\"我展示的是一级标题\"><a href=\"#我展示的是一级标题\" class=\"headerlink\" title=\"我展示的是一级标题\"></a>我展示的是一级标题</h1><h2 id=\"我展示的是二级标题\"><a href=\"#我展示的是二级标题\" class=\"headerlink\" title=\"我展示的是二级标题\"></a>我展示的是二级标题</h2><h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"。。。。\"><a href=\"#。。。。\" class=\"headerlink\" title=\"。。。。\"></a>。。。。</h5><h2 id=\"Markdown-段落\"><a href=\"#Markdown-段落\" class=\"headerlink\" title=\"Markdown 段落\"></a>Markdown 段落</h2><p>段落换行是已 两个或以上空格+回车即可<br>开始新的一个段落</p>\n<h2 id=\"Markdown-字体\"><a href=\"#Markdown-字体\" class=\"headerlink\" title=\"Markdown 字体\"></a>Markdown 字体</h2><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em>  </p>\n<h2 id=\"分隔线\"><a href=\"#分隔线\" class=\"headerlink\" title=\"分隔线\"></a>分隔线</h2><p>可以使用三个以上的 星号、减号、底线来构建一个分隔线 行内不能有其他内容（允许中间插入空格） 不然会破坏格式  </p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>段落需要添加删除线 在文本两端添加 两个波浪线即可<br><del>当前版本1.0</del>  </p>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>使用与html相同的标签 u<br><u>下划线文本</u> </p>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚注是对文本的补充说明<br>有一个 <a href=\"1231231233\">234</a></p>\n<h2 id=\"Markdown-列表\"><a href=\"#Markdown-列表\" class=\"headerlink\" title=\"Markdown 列表\"></a>Markdown 列表</h2><p>无序列表 用星号、加好或减号 作为列表标记 标记后面需要添加一个空格  </p>\n<ul>\n<li>第一列</li>\n</ul>\n<ul>\n<li>第二列</li>\n</ul>\n<ul>\n<li>第三列   </li>\n</ul>\n<p>有序列表 </p>\n"},{"title":"Dubbo基础","date":"2021-06-24T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://kubpang.gitee.io/sourceFile/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n## RPC\n\n什么叫PRC：  \nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n\nRPC原理：  \n![rpc通讯](https://kubpang.gitee.io/sourceFile/Dubbo/rpc通讯.png)  \n![rpc序列化](https://kubpang.gitee.io/sourceFile/Dubbo/rpc序列化.png)  \nRPC两个核心模块：通讯，序列化。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n# Dubbo Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：  \n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置  \n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多个  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### RMI协议\n\n采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：固定是dubbo，不要改  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置覆盖规则\n\n![属性配置覆盖规则](https://kubpang.gitee.io/sourceFile/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件覆盖规则\n\n![配置文件覆盖规则](https://kubpang.gitee.io/sourceFile/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://kubpang.gitee.io/sourceFile/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心页面.png)","source":"_posts/oyr/Dubbo/Dubbo-基础.md","raw":"---\ntitle: Dubbo基础\ndate: 2021-06-25 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: Dubbo\ntags: \n    - Dubbo\n    - 分布式\n---\n\n# 扩展知识\n\n## 什么是分布式系统\n\n分布式系统原理与泛型中定义：  \n分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。\n\n<!-- more -->\n\n## 发展演变\n\n![架构发展演变](https://kubpang.gitee.io/sourceFile/Dubbo/架构发展演变.png)\n\n单一应用架构：  \n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。\n\n垂直应用架构：  \n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。   \n此时，用于加速前端页面开发的 Web框架(MVC) 是关键。\n\n分布式服务架构：  \n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  \n此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。\n\n流动计算架构：  \n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 \n此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。\n\n## RPC\n\n什么叫PRC：  \nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n\nRPC原理：  \n![rpc通讯](https://kubpang.gitee.io/sourceFile/Dubbo/rpc通讯.png)  \n![rpc序列化](https://kubpang.gitee.io/sourceFile/Dubbo/rpc序列化.png)  \nRPC两个核心模块：通讯，序列化。\n\n# Dubbo入门\n\n## 简介\n\nDubbo 是一款高性能、轻量级的开源Java RPC框架。  \nDubbo 是分布式服务治理框架。\n\n提供了三大核心能力：  \n面向接口的远程方法调用  \n集群容错（容错与负债均衡）  \n服务自动注册与发现\n\n官网：http://dubbo.apache.org/\n\n## Dubbo能做什么\n\n问题:  \n服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)  \n各个服务之间依赖管理非常复杂  \n各个服务之间如何进行监控\n\n（1）面向接口的远程方法调用：  \n就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。\n\n（2）智能容错与负债均衡：  \n可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。\n\n（3）服务自动注册与发现：  \n不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。\n\n（4）服务监控：  \n监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。\n\n## Dubbo架构\n\n![dubbo架构图](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo架构图.png)  \n\n### 节点角色说明\n\n服务提供者（Provider）：  \n暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n服务消费者（Consumer）:   \n调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n注册中心（Registry）：  \n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n监控中心（Monitor）：  \n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n### 调用关系说明\n\n（1）服务容器负责启动，加载，运行服务提供者。  \n（2）服务提供者在启动时，向注册中心注册自己提供的服务。  \n（3）服务消费者在启动时，向注册中心订阅自己所需的服务。  \n（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  \n（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  \n（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n# Dubbo Hello world\n\n## 环境准备\n\nDubbo学习前必须掌握以下内容：  \nZookeeper的使用经验  \nSpring框架的使用经验  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11\n\n注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。\n\n## 提出需求\n\n某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；\n\n我们现在需要创建两个服务模块进行测试：  \n订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。  \norder-web（订单模块，web，服务消费者）  \nuser-service（用户模块，service，服务提供者）\n\n## 工程架构\n\n根据 dubbo《服务化最佳实践》 \n\n### 分包\n\n建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n\n如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n\n### 粒度\n\n服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。  \n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。  \n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n\n### 结构\n\nuser模块：  \nuser-api 提供接口  \nuser-impl 接口实现层，服务提供者\n\n\norder模块：  \norder-web：服务消费者\n\n## 服务提供者\n\nuser项目总览：  \n创建user项目，这是一个聚合工程。  \n创建user-api，这是user公共接口层（提供接口）。  \n创建user-imp，这是user接口的实现层（服务提供者）。\n\n### user-api（提供user公共接口）\n\n（1）用户地址DTO：\n```java\npublic class UserAddressDto implements Serializable {\n\n    private Integer id;\n    private String userId;\n    private String userAddress;\n    private String consignee;\n    private String phone;\n    private String isDefault;\n}\n```\n\n（2）用户地址接口定义\n```java\npublic interface UserService {\n    List<UserAddressDto> getUserAddress(String userId);\n}\n```\n\n### user-impl（接口实现，服务提供者）\n\n（1）pom.xml导入依赖：\n```xml\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!--\n        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n        dubbo 2.6以前的版本引入zkclient操作zookeeper\n        dubbo 2.6及以后的版本引入curator操作zookeeper\n        下面两个zk客户端根据dubbo版本2选1即可\n    -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）实现用户地址接口：\n```java\npublic class UserServiceImpl implements UserService {\n\n    public final static Map<String, List<UserAddressDto>> map;\n\n    static {\n        List<UserAddressDto> list1 = Stream.of(new UserAddressDto(1, \"1\", \"江西赣州\", \"欧阳\", \"152*****\", false),\n                new UserAddressDto(2, \"1\", \"广东深圳\", \"欧阳\", \"152*****\", true),\n                new UserAddressDto(1, \"1\", \"浙江上海\", \"欧阳\", \"152*****\", false))\n                .collect(Collectors.toList());\n        List<UserAddressDto> list2 = Stream.of(new UserAddressDto(3, \"2\", \"江西赣州\", \"东华\", \"152*****\", false),\n                new UserAddressDto(4, \"2\", \"广东深圳\", \"东华\", \"152*****\", true),\n                new UserAddressDto(5, \"2\", \"浙江上海\", \"东华\", \"152*****\", false))\n                .collect(Collectors.toList());\n\n        map = new HashMap<>();\n        map.put(\"1\", list1);\n        map.put(\"2\", list2);\n    }\n\n    @Override\n    public List<UserAddressDto> getUserAddress(String userId) {\n        return map.get(userId);\n    }\n\n}\n```\n\n（3）服务提供者配置：  \n新增provider.xml文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://code.alibabatech.com/schema/dubbo\n       http://code.alibabatech.com/schema/dubbo/dubbo.xsd \">\n\n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"user-provider\" />\n\n    <!-- 指定注册中心地址，使用zookeeper暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 用dubbo协议，将服务暴露在20880端口 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n\n    <!-- 声明需要暴露的服务接口 -->\n    <dubbo:service interface=\"com.oyr.user.service.UserService\"\n                   ref=\"userServiceImpl\" />\n\n    <!-- 将接口实现类提交到容器中 -->\n    <bean id=\"userServiceImpl\" class=\"com.oyr.user.service.impl.UserServiceImpl\" />\n</beans>\n```\n\n（4）启动服务提供者\n```java\npublic class Provider {\n\n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:provider.xml\");\n        System.in.read();\n    }\n\n}\n```\n注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。\n\n## 服务消费者\n\n（1）pom.xml导入依赖\n```xml\n<!-- 依赖user-api -->\n<dependency>\n    <groupId>com.oyr</groupId>\n    <artifactId>user-api</artifactId>\n    <version>${parent.version}</version>\n</dependency>\n\n<!-- dubbo -->\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.7</version>\n</dependency>\n<!--\n    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper\n    dubbo 2.6以前的版本引入zkclient操作zookeeper\n    dubbo 2.6及以后的版本引入curator操作zookeeper\n    下面两个zk客户端根据dubbo版本2选1即可\n-->\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>2.12.0</version>\n</dependency>\n```\n\n（2）服务消费者配置  \n新增consumer.xml文件\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 -->\n    <dubbo:application name=\"order-consumer\" />\n\n    <!-- 指定注册中心，通过注册中心发现服务提供者地址 -->\n    <dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" />\n\n    <!-- 生成远程服务代理，可以和本地bean一样使用userService -->\n    <dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" />\n\n</beans>\n```\n\n（3）启动消费者，尝试调用服务提供者\n```java\npublic class Consumer {\n\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:consumer.xml\");\n        UserService userService = context.getBean(UserService.class);\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。  \n说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。\n\n## 注解版\n\n@DubboComponentScan  \n使用dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n## Dubbo支持哪些协议\n\n### Dubbo协议\n\nDubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\n\n### Hessian协议\n\nHessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。\n\n基于Hessian的远程调用协议:\n连接个数：多连接  \n连接方式：短连接  \n传输协议：HTTP  \n传输方式：同步传输  \n序列化：Hessian二进制序列化  \n适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。  \n适用场景：页面传输，文件传输，或与原生hessian服务互操作\n\n### HTTP协议\n\n此协议采用 spring 的HttpInvoker的功能实现，\n\n基于HTTP的远程调用协议:  \n连接个数：多个  \n连接方式：长连接  \n连接协议：http  \n传输方式：同步传输  \n序列化：表单序列化  \n适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。  \n适用场景：需同时给应用程序和浏览器JS使用的服务。\n\n### RMI协议\n\n采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式\n\n基于RMI协议的远程调用协议:  \n连接个数：多连接  \n连接方式：短连接  \n传输协议：TCP  \n传输方式：同步传输\n序列化：Java标准二进制序列化  \n适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。  \n适用场景：常规远程服务方法调用，与原生RMI服务互操作\n\n# 整合Spring Boot\n\n基于hello world项目改造成spring boot项目。\n\n## 环境准备\n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nDubbo 2.7.7  \nZookeeper 3.4.11  \nSpring Boot 2.2.4.RELEASE\n\n## 服务提供者改造\n\nuser-api不改动，改动user-impl，以下改动都是user-impl的。\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>${parent.version}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）修改接口实现UserServiceImpl （类上加入DubboService）\n```java\n@DubboService // 暴露当前服务\npublic class UserServiceImpl implements UserService {\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n（4）修改启动类，并且启动服务提供者\n```java\n// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）\n@EnableDubbo\n@SpringBootApplication\npublic class Provider {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Provider.class, args);\n    }\n\n}\n```\n\n修改后，启动成功！！！\n\n## 服务消费者改造\n\n改动order-web（服务消费者）\n\n（1）pom.xml 导入依赖\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.2.4.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- 依赖user-api -->\n    <dependency>\n        <groupId>com.oyr</groupId>\n        <artifactId>user-api</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- dubbo -->\n    <dependency>\n        <groupId>org.apache.dubbo</groupId>\n        <artifactId>dubbo-spring-boot-starter</artifactId>\n        <version>2.7.7</version>\n    </dependency>\n    <!-- 操作zookeeper -->\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.12.0</version>\n    </dependency>\n</dependencies>\n```\n\n（2）新增controller\n```java\n@RestController\npublic class DubboController {\n\n    @DubboReference\n    private UserService userService;\n\n    @GetMapping(\"/dubbo\")\n    public void dubbo() {\n        List<UserAddressDto> result = userService.getUserAddress(\"1\");\n        result.forEach(System.out::println);\n    }\n\n}\n```\n\n（3）application.properties新增配置文件\n```properties\n#dubbo 配置\ndubbo.application.name=cms-wms\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.consumer.client=netty\ndubbo.consumer.check=false\n```\n\n（4）修改启动类\n```java\n@EnableDubbo // 开启dubbo，扫描dubbo注解\n@SpringBootApplication\npublic class Consumer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Consumer.class, args);\n    }\n\n}\n```\n\n（5）测试，尝试远程调用是否成功  \n\n访问http://localhost:8080/dubbo  \n后台成功打印出客户地址列表  \n远程调用成功！！！！\n\n## 配置解释\n\n@EnableDubbo（组合型注解）  \n开启dubbo，扫描dubbo注解。  \n里面有dubbo提供的DubboComponentScan注解，指定扫描的包。  \n会扫描当前包和子包下的@DubboService & @DubboReference并让其生效。\n\n@DubboService  \n使用dubbo提供的DubboService注解，指定服务提供者暴露该服务\n\n@DubboReference  \n使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务\n\n服务提供者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=user-provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20888\n```\n\n服务消费者配置：\n```properties\n#dubbo 配置\ndubbo.application.name=order-consumer\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=127.0.0.1:2181\ndubbo.protocol.name=dubbo\n```\n\n配置解释：  \ndubbo.application.nam：就是服务名，不能和其他服务提供者重复  \ndubbo.registry.protocol：指定注册中心协议  \ndubbo.registry.address：指定注册中心访问地址（地址加端口号）  \ndubbo.protocol.name：固定是dubbo，不要改  \ndubbo.protocol.port：指定服务提供者暴露的端口\n\n\n# Dubbo 配置详解\n\n注意：以下针对xml配置讲解，注解版差不多一致。\n\n## 重试次数\n\n失败自动重试：  \n当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置重试 -->\n<dubbo:provider retries=\"2\" />\n\n<!-- 提供者指定接口重试 -->\n<dubbo:service retries=\"2\" />\n\n<!-- 提供者指定接口某个方法设置重试 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" retries=\"2\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 服务消费者全局配置重试 -->\n<dubbo:consumer retries=\"2\" />\n\n<!-- 服务消费者指定接口设置重试 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" retries=\"2\"/>\n```\n\n## 超时时间\n\n由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。\n\n### 服务提供者\n\n```xml\n<!-- 提供者全局配置超时时间 -->\n<dubbo:provider timeout=\"5000\" />\n\n<!-- 提供者指定接口以及某个方法配置超时时间 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" timeout=\"5000\" >\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\" />\n</dubbo:service>\n```\n\n### 服务消费者\n\n```xml\n<!-- 消费者全局配置超时时间 -->\n<dubbo:consumer timeout=\"3000\"/>\n\n<!-- 消费者指定接口和某个方法配置超时时间 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" timeout=\"5000\">\n    <dubbo:method name=\"getUserAddress\" timeout=\"10000\"/>\n</dubbo:reference>\n```\n\n## 版本号\n\n当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n\n可以按照以下的步骤进行版本迁移：  \n在低压力时间段，先升级一半提供者为新版本  \n再将所有消费者升级为新版本  \n然后将剩下的一半提供者升级为新版本\n\n```xml\n老版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务提供者配置：\n<dubbo:service interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n老版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"1.0.0\" />\n\n新版本服务消费者配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"2.0.0\" />\n\n如果不需要区分版本，可以按照以下的方式配置：\n<dubbo:reference id=\"barService\" interface=\"com.foo.BarService\" version=\"*\" />\n```\n\n## 配置原则\n\nDubbo推荐在Provider上尽量多配置Consumer端属性。  \n1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等  \n2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的\n\n## 属性配置覆盖规则\n\n![属性配置覆盖规则](https://kubpang.gitee.io/sourceFile/Dubbo/属性配置覆盖规则.png)\n\n1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先 \n2）Consumer端配置优于 Provider配置\n3）最后是Dubbo Hard Code的配置值（见配置文档）\n\n## 配置文件覆盖规则\n\n![配置文件覆盖规则](https://kubpang.gitee.io/sourceFile/Dubbo/配置文件覆盖规则.png)\n\n1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。  \n2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。  \n3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。\n\n# Dubbo-Admin监控中心\n\n## 监控中心简介\n\n监控中心：\n图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。\n\n监控中心：\n是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。\n\n## 搭建监控中心\n\n注意：dubbo-admin有多种启动方式  \n通过jar包方式启动，jar包形式。  \n通过war包方式启动，依赖tomcat容器。  \n通过导入eclipse或idea启动\n\n最新的dubbo-admin是前后端分离的（新版本），可以看教程：  \nhttps://blog.csdn.net/muriyue6/article/details/109304584\n\n**注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）**\n\n下载dubbo-admin项目：https://github.com/apache/incubator-dubbo-ops\n![incubator-dubbo-ops](https://kubpang.gitee.io/sourceFile/Dubbo/incubator-dubbo-ops.png)\n\n### war包启动\n\n1）先准备好dubbo-admin项目\n\n2）准备好tomcat，将dubbo-admin放到webapps目录下\n\n3）修改dubbo.properties文件内容\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root123\n# 指定guest账号密码\ndubbo.admin.guest.password=guest123\n```\n\n4）启动tomcat测试，尝试访问监控中心  \n在tomcat下，bin目录，通过startup.bat启动tomcat。  \n访问http://localhost:8080/dubbo-admin  \n![dubbo监控中心登录页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心登录页面.png)  \n注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。  \n![dubbo监控中心页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心页面.png)  \n最后成功进入监控中心界面！！！\n\n### jar包启动\n\n1）先准备好dubbo-admin项目\n\n2）修改application.properties配置\n```properties\n# 指定注册中心地址\ndubbo.registry.address=zookeeper://120.25.217.122:2181\n# 指定root账号密码\ndubbo.admin.root.password=root\n# 指定guest账号密码\ndubbo.admin.guest.password=guest\n```\n\n3）打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n4）运行dubbo-admin.jar，尝试访问监控中心  \njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar  \n使用root/root登录  \n![dubbo监控中心页面](https://kubpang.gitee.io/sourceFile/Dubbo/dubbo监控中心页面.png)","slug":"oyr/Dubbo/Dubbo-基础","published":1,"updated":"2021-09-01T02:46:37.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835s0005hct78hziett1","content":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><p>什么叫PRC：<br>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<p>RPC原理：<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc通讯\"><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"><br>RPC两个核心模块：通讯，序列化。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h1 id=\"Dubbo-Hello-world\"><a href=\"#Dubbo-Hello-world\" class=\"headerlink\" title=\"Dubbo Hello world\"></a>Dubbo Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多个<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：固定是dubbo，不要改<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置覆盖规则\"><a href=\"#属性配置覆盖规则\" class=\"headerlink\" title=\"属性配置覆盖规则\"></a>属性配置覆盖规则</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置覆盖规则\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件覆盖规则\"><a href=\"#配置文件覆盖规则\" class=\"headerlink\" title=\"配置文件覆盖规则\"></a>配置文件覆盖规则</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件覆盖规则\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是分布式系统\"><a href=\"#什么是分布式系统\" class=\"headerlink\" title=\"什么是分布式系统\"></a>什么是分布式系统</h2><p>分布式系统原理与泛型中定义：<br>分布式系统是n多个计算机的集合，这些计算机对用户来说就像单个相关系统</p>\n<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应用，分布式服务架构以及流动计算架构势在必行，需要一个治理系统确保架构有条不紊的演进。</p>","more":"<h2 id=\"发展演变\"><a href=\"#发展演变\" class=\"headerlink\" title=\"发展演变\"></a>发展演变</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.png\" alt=\"架构发展演变\"></p>\n<p>单一应用架构：<br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</p>\n<p>垂直应用架构：<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 <br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p>\n<p>分布式服务架构：<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</p>\n<p>流动计算架构：<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 <br>此时，用于 提高机器利用率的资源调度和治理中心(SOA) 是关键。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><p>什么叫PRC：<br>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>\n<p>RPC原理：<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/rpc%E9%80%9A%E8%AE%AF.png\" alt=\"rpc通讯\"><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/rpc%E5%BA%8F%E5%88%97%E5%8C%96.png\" alt=\"rpc序列化\"><br>RPC两个核心模块：通讯，序列化。</p>\n<h1 id=\"Dubbo入门\"><a href=\"#Dubbo入门\" class=\"headerlink\" title=\"Dubbo入门\"></a>Dubbo入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架。<br>Dubbo 是分布式服务治理框架。</p>\n<p>提供了三大核心能力：<br>面向接口的远程方法调用<br>集群容错（容错与负债均衡）<br>服务自动注册与发现</p>\n<p>官网：<a href=\"http://dubbo.apache.org/\">http://dubbo.apache.org/</a></p>\n<h2 id=\"Dubbo能做什么\"><a href=\"#Dubbo能做什么\" class=\"headerlink\" title=\"Dubbo能做什么\"></a>Dubbo能做什么</h2><p>问题:<br>服务的URL管理非常困难(rmi://、http:*、)、F5负载均衡器的单点压力(硬件成本)<br>各个服务之间依赖管理非常复杂<br>各个服务之间如何进行监控</p>\n<p>（1）面向接口的远程方法调用：<br>就像调用本地方法一样调用远程方法，只需简单  配置，没有任何API侵入。</p>\n<p>（2）智能容错与负债均衡：<br>可在内网替代F5等硬件负鞭均衡器，降低成本，减少单点。</p>\n<p>（3）服务自动注册与发现：<br>不再需要写死服务提供方地址，基于注册中心查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<p>（4）服务监控：<br>监控消费者与提供者的累计调用次数和调用时间，提供数据可以分析瓶颈。</p>\n<h2 id=\"Dubbo架构\"><a href=\"#Dubbo架构\" class=\"headerlink\" title=\"Dubbo架构\"></a>Dubbo架构</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE.png\" alt=\"dubbo架构图\">  </p>\n<h3 id=\"节点角色说明\"><a href=\"#节点角色说明\" class=\"headerlink\" title=\"节点角色说明\"></a>节点角色说明</h3><p>服务提供者（Provider）：<br>暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n<p>服务消费者（Consumer）:<br>调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n<p>注册中心（Registry）：<br>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>\n<p>监控中心（Monitor）：<br>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>\n<h3 id=\"调用关系说明\"><a href=\"#调用关系说明\" class=\"headerlink\" title=\"调用关系说明\"></a>调用关系说明</h3><p>（1）服务容器负责启动，加载，运行服务提供者。<br>（2）服务提供者在启动时，向注册中心注册自己提供的服务。<br>（3）服务消费者在启动时，向注册中心订阅自己所需的服务。<br>（4）注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>（5）服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>（6）服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n<h1 id=\"Dubbo-Hello-world\"><a href=\"#Dubbo-Hello-world\" class=\"headerlink\" title=\"Dubbo Hello world\"></a>Dubbo Hello world</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>Dubbo学习前必须掌握以下内容：<br>Zookeeper的使用经验<br>Spring框架的使用经验<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具</p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11</p>\n<p>注册中心选型，我们使用zookeeper当注册中心，需要提前安装好，这里就不演示了。</p>\n<h2 id=\"提出需求\"><a href=\"#提出需求\" class=\"headerlink\" title=\"提出需求\"></a>提出需求</h2><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>\n<p>我们现在需要创建两个服务模块进行测试：<br>订单服务模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。<br>order-web（订单模块，web，服务消费者）<br>user-service（用户模块，service，服务提供者）</p>\n<h2 id=\"工程架构\"><a href=\"#工程架构\" class=\"headerlink\" title=\"工程架构\"></a>工程架构</h2><p>根据 dubbo《服务化最佳实践》 </p>\n<h3 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a>分包</h3><p>建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>\n<p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>\n<h3 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h3><p>服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。<br>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。<br>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>user模块：<br>user-api 提供接口<br>user-impl 接口实现层，服务提供者</p>\n<p>order模块：<br>order-web：服务消费者</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>user项目总览：<br>创建user项目，这是一个聚合工程。<br>创建user-api，这是user公共接口层（提供接口）。<br>创建user-imp，这是user接口的实现层（服务提供者）。</p>\n<h3 id=\"user-api（提供user公共接口）\"><a href=\"#user-api（提供user公共接口）\" class=\"headerlink\" title=\"user-api（提供user公共接口）\"></a>user-api（提供user公共接口）</h3><p>（1）用户地址DTO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAddressDto</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userAddress;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String consignee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String isDefault;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）用户地址接口定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"user-impl（接口实现，服务提供者）\"><a href=\"#user-impl（接口实现，服务提供者）\" class=\"headerlink\" title=\"user-impl（接口实现，服务提供者）\"></a>user-impl（接口实现，服务提供者）</h3><p>（1）pom.xml导入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">        下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）实现用户地址接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;UserAddressDto&gt;&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list1 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">2</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;欧阳&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; list2 = Stream.of(<span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">3</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;江西赣州&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">4</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;广东深圳&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">true</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> UserAddressDto(<span class=\"number\">5</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;浙江上海&quot;</span>, <span class=\"string\">&quot;东华&quot;</span>, <span class=\"string\">&quot;152*****&quot;</span>, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;1&quot;</span>, list1);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;2&quot;</span>, list2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;UserAddressDto&gt; <span class=\"title\">getUserAddress</span><span class=\"params\">(String userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）服务提供者配置：<br>新增provider.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd &quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;user-provider&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心地址，使用zookeeper暴露服务地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用dubbo协议，将服务暴露在20880端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dubbo&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;20880&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                   <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 将接口实现类提交到容器中 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.oyr.user.service.impl.UserServiceImpl&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:provider.xml&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：服务提供者不要关闭，服务消费者需要调用服务提供者，如果服务提供者不存在，那么服务消费者会报错。</p>\n<h2 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h2><p>（1）pom.xml导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6以前的版本引入zkclient操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    dubbo 2.6及以后的版本引入curator操作zookeeper</span></span><br><span class=\"line\"><span class=\"comment\">    下面两个zk客户端根据dubbo版本2选1即可</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）服务消费者配置<br>新增consumer.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:dubbo</span>=<span class=\"string\">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 消费方应用名，用于计算依赖关系，不要与提供方一样 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;order-consumer&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定注册中心，通过注册中心发现服务提供者地址 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;zookeeper&quot;</span> <span class=\"attr\">address</span>=<span class=\"string\">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）启动消费者，尝试调用服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ClassPathXmlApplicationContext context =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">&quot;classpath:consumer.xml&quot;</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在order-web（服务消费者），调用user（服务提供者）的UserService.getUserAddress方法，成功打印出用户地址列表信息，调用成功。<br>说明服务提供者（order-web）成功消费服务提供者（user），远程调用成功。</p>\n<h2 id=\"注解版\"><a href=\"#注解版\" class=\"headerlink\" title=\"注解版\"></a>注解版</h2><p>@DubboComponentScan<br>使用dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<h2 id=\"Dubbo支持哪些协议\"><a href=\"#Dubbo支持哪些协议\" class=\"headerlink\" title=\"Dubbo支持哪些协议\"></a>Dubbo支持哪些协议</h2><h3 id=\"Dubbo协议\"><a href=\"#Dubbo协议\" class=\"headerlink\" title=\"Dubbo协议\"></a>Dubbo协议</h3><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>\n<h3 id=\"Hessian协议\"><a href=\"#Hessian协议\" class=\"headerlink\" title=\"Hessian协议\"></a>Hessian协议</h3><p>Hessian协议用于集成Hessian的服务，Hessian底层采用Http通讯，采用Servlet暴露服务，Dubbo缺省内嵌Jetty作为服务器实现。Hessian是Caucho开源的一个RPC框架：<a href=\"http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./\">http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a></p>\n<p>基于Hessian的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：Hessian二进制序列化<br>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。<br>适用场景：页面传输，文件传输，或与原生hessian服务互操作</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>此协议采用 spring 的HttpInvoker的功能实现，</p>\n<p>基于HTTP的远程调用协议:<br>连接个数：多个<br>连接方式：长连接<br>连接协议：http<br>传输方式：同步传输<br>序列化：表单序列化<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器JS使用的服务。</p>\n<h3 id=\"RMI协议\"><a href=\"#RMI协议\" class=\"headerlink\" title=\"RMI协议\"></a>RMI协议</h3><p>采用JDK标准的java.rmi.*实现，采用阻塞式短连接和JDK标准序列化方式</p>\n<p>基于RMI协议的远程调用协议:<br>连接个数：多连接<br>连接方式：短连接<br>传输协议：TCP<br>传输方式：同步传输<br>序列化：Java标准二进制序列化<br>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<br>适用场景：常规远程服务方法调用，与原生RMI服务互操作</p>\n<h1 id=\"整合Spring-Boot\"><a href=\"#整合Spring-Boot\" class=\"headerlink\" title=\"整合Spring Boot\"></a>整合Spring Boot</h1><p>基于hello world项目改造成spring boot项目。</p>\n<h2 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>Dubbo 2.7.7<br>Zookeeper 3.4.11<br>Spring Boot 2.2.4.RELEASE</p>\n<h2 id=\"服务提供者改造\"><a href=\"#服务提供者改造\" class=\"headerlink\" title=\"服务提供者改造\"></a>服务提供者改造</h2><p>user-api不改动，改动user-impl，以下改动都是user-impl的。</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;parent.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改接口实现UserServiceImpl （类上加入DubboService）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DubboService</span> <span class=\"comment\">// 暴露当前服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类，并且启动服务提供者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启Dubbo，扫描Dubbo注解（扫描当前包和子包内容）</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDubbo</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Provider.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改后，启动成功！！！</p>\n<h2 id=\"服务消费者改造\"><a href=\"#服务消费者改造\" class=\"headerlink\" title=\"服务消费者改造\"></a>服务消费者改造</h2><p>改动order-web（服务消费者）</p>\n<p>（1）pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 依赖user-api --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.oyr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>user-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- dubbo --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 操作zookeeper --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-recipes<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）新增controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DubboReference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/dubbo&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dubbo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;UserAddressDto&gt; result = userService.getUserAddress(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">        result.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）application.properties新增配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">cms-wms</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.client</span>=<span class=\"string\">netty</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.consumer.check</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）修改启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableDubbo</span> <span class=\"comment\">// 开启dubbo，扫描dubbo注解</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Consumer.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（5）测试，尝试远程调用是否成功  </p>\n<p>访问<a href=\"http://localhost:8080/dubbo\">http://localhost:8080/dubbo</a><br>后台成功打印出客户地址列表<br>远程调用成功！！！！</p>\n<h2 id=\"配置解释\"><a href=\"#配置解释\" class=\"headerlink\" title=\"配置解释\"></a>配置解释</h2><p>@EnableDubbo（组合型注解）<br>开启dubbo，扫描dubbo注解。<br>里面有dubbo提供的DubboComponentScan注解，指定扫描的包。<br>会扫描当前包和子包下的@DubboService &amp; @DubboReference并让其生效。</p>\n<p>@DubboService<br>使用dubbo提供的DubboService注解，指定服务提供者暴露该服务</p>\n<p>@DubboReference<br>使用dubbo提供的DubboReference注解，指定服务消费者引用远程服务</p>\n<p>服务提供者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">user-provider</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20888</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#dubbo 配置</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">order-consumer</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.protocol</span>=<span class=\"string\">zookeeper</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br></pre></td></tr></table></figure>\n\n<p>配置解释：<br>dubbo.application.nam：就是服务名，不能和其他服务提供者重复<br>dubbo.registry.protocol：指定注册中心协议<br>dubbo.registry.address：指定注册中心访问地址（地址加端口号）<br>dubbo.protocol.name：固定是dubbo，不要改<br>dubbo.protocol.port：指定服务提供者暴露的端口</p>\n<h1 id=\"Dubbo-配置详解\"><a href=\"#Dubbo-配置详解\" class=\"headerlink\" title=\"Dubbo 配置详解\"></a>Dubbo 配置详解</h1><p>注意：以下针对xml配置讲解，注解版差不多一致。</p>\n<h2 id=\"重试次数\"><a href=\"#重试次数\" class=\"headerlink\" title=\"重试次数\"></a>重试次数</h2><p>失败自动重试：<br>当出现失败，重试其他服务提供者服务器，重试会带来更长的延迟，可通过’retries=2’来设置重试次数（不含第一次），’retries=-1’表示不进行重试。</p>\n<h3 id=\"服务提供者-1\"><a href=\"#服务提供者-1\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口某个方法设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-1\"><a href=\"#服务消费者-1\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者全局配置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 服务消费者指定接口设置重试 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超时时间\"><a href=\"#超时时间\" class=\"headerlink\" title=\"超时时间\"></a>超时时间</h2><p>由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。</p>\n<h3 id=\"服务提供者-2\"><a href=\"#服务提供者-2\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 提供者指定接口以及某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务消费者-2\"><a href=\"#服务消费者-2\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者全局配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 消费者指定接口和某个方法配置超时时间 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;10000&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>\n<p>可以按照以下的步骤进行版本迁移：<br>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务提供者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">老版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">新版本服务消费者配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;2.0.0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果不需要区分版本，可以按照以下的方式配置：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;barService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.foo.BarService&quot;</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置原则\"><a href=\"#配置原则\" class=\"headerlink\" title=\"配置原则\"></a>配置原则</h2><p>Dubbo推荐在Provider上尽量多配置Consumer端属性。<br>1）作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等<br>2）在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</p>\n<h2 id=\"属性配置覆盖规则\"><a href=\"#属性配置覆盖规则\" class=\"headerlink\" title=\"属性配置覆盖规则\"></a>属性配置覆盖规则</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"属性配置覆盖规则\"></p>\n<p>1）方法级配置别优于接口级别，接口级别优于全局配置，即小Scope优先<br>2）Consumer端配置优于 Provider配置<br>3）最后是Dubbo Hard Code的配置值（见配置文档）</p>\n<h2 id=\"配置文件覆盖规则\"><a href=\"#配置文件覆盖规则\" class=\"headerlink\" title=\"配置文件覆盖规则\"></a>配置文件覆盖规则</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99.png\" alt=\"配置文件覆盖规则\"></p>\n<p>1）JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>2）XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>3）Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>\n<h1 id=\"Dubbo-Admin监控中心\"><a href=\"#Dubbo-Admin监控中心\" class=\"headerlink\" title=\"Dubbo-Admin监控中心\"></a>Dubbo-Admin监控中心</h1><h2 id=\"监控中心简介\"><a href=\"#监控中心简介\" class=\"headerlink\" title=\"监控中心简介\"></a>监控中心简介</h2><p>监控中心：<br>图形化的访问管理页面，安装时需要指定注册中心的地址，即可从注册中心中获取到所以的提供者和消费者进行配置管理，并且可以监控与分析提供者与消费者中的远程调用。</p>\n<p>监控中心：<br>是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控测试程序，不过这个监控即使不装也不影响使用。</p>\n<h2 id=\"搭建监控中心\"><a href=\"#搭建监控中心\" class=\"headerlink\" title=\"搭建监控中心\"></a>搭建监控中心</h2><p>注意：dubbo-admin有多种启动方式<br>通过jar包方式启动，jar包形式。<br>通过war包方式启动，依赖tomcat容器。<br>通过导入eclipse或idea启动</p>\n<p>最新的dubbo-admin是前后端分离的（新版本），可以看教程：<br><a href=\"https://blog.csdn.net/muriyue6/article/details/109304584\">https://blog.csdn.net/muriyue6/article/details/109304584</a></p>\n<p><strong>注意：当前讲解的是前后端不分离的dubbo-admin搭建方式（老版本）</strong></p>\n<p>下载dubbo-admin项目：<a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/incubator-dubbo-ops.png\" alt=\"incubator-dubbo-ops\"></p>\n<h3 id=\"war包启动\"><a href=\"#war包启动\" class=\"headerlink\" title=\"war包启动\"></a>war包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）准备好tomcat，将dubbo-admin放到webapps目录下</p>\n<p>3）修改dubbo.properties文件内容</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root123</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest123</span></span><br></pre></td></tr></table></figure>\n\n<p>4）启动tomcat测试，尝试访问监控中心<br>在tomcat下，bin目录，通过startup.bat启动tomcat。<br>访问<a href=\"http://localhost:8080/dubbo-admin\">http://localhost:8080/dubbo-admin</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心登录页面\"><br>注意：登录时遇到需要密码来登录，密码设置在dubbo.properties文件中设置。<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"><br>最后成功进入监控中心界面！！！</p>\n<h3 id=\"jar包启动\"><a href=\"#jar包启动\" class=\"headerlink\" title=\"jar包启动\"></a>jar包启动</h3><p>1）先准备好dubbo-admin项目</p>\n<p>2）修改application.properties配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://120.25.217.122:2181</span></span><br><span class=\"line\"><span class=\"comment\"># 指定root账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.root.password</span>=<span class=\"string\">root</span></span><br><span class=\"line\"><span class=\"comment\"># 指定guest账号密码</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.admin.guest.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n\n<p>3）打包dubbo-admin<br>mvn clean package -Dmaven.test.skip=true</p>\n<p>4）运行dubbo-admin.jar，尝试访问监控中心<br>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar<br>使用root/root登录<br><img src=\"https://kubpang.gitee.io/sourceFile/Dubbo/dubbo%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83%E9%A1%B5%E9%9D%A2.png\" alt=\"dubbo监控中心页面\"></p>"},{"title":"Dubbo高级","date":"2021-07-07T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。\n\n<!-- more -->\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群模式配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")\nUserService userService;\n```\n\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n# Dubbo原理\n\n## RPC原理\n\n## Dubbo原理\n\n","source":"_posts/oyr/Dubbo/Dubbo-高级.md","raw":"---\ntitle: Dubbo高级\ndate: 2021-07-8 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: Dubbo\ntags: \n    - Dubbo\n    - 分布式\n---\n\n# Dubbo 高可用\n\n## 集群\n\nDubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。\n\n<!-- more -->\n\n## 集群容错\n\n集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n\n### 集群容错\n\n```\nFailover Cluster\n失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\"2\" 来设置重试次数(不含第一次)。\n\n重试次数配置如下：\n<dubbo:service retries=\"2\" />\n或\n<dubbo:reference retries=\"2\" />\n或\n<dubbo:reference>\n    <dubbo:method name=\"findFoo\" retries=\"2\" />\n</dubbo:reference>\n\nFailfast Cluster\n快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\nFailsafe Cluster\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\nFailback Cluster\n失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\nForking Cluster\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\nBroadcast Cluster\n广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n```\n\n### 集群模式配置\n\n按照以下示例在服务提供方和消费方配置集群模式\n```\n<dubbo:service cluster=\"failsafe\" />\n或\n<dubbo:reference cluster=\"failsafe\" />\n```\n\n## 负债均衡策略\n\n集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n\n### 负载均衡策略\n\n```\nRandom LoadBalance\n随机均衡算法，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n权重轮循均衡算法，按公约后的权重设置轮循比率。\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\nLeastActive LoadBalance\n最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key=\"hash.arguments\" value=\"0,1\" />\n缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key=\"hash.nodes\" value=\"320\" />\n```\n\n### 负债均衡配置\n\n负债均衡配置很简单。\n服务端和客户端都可以配置服务级别或者方法级别的策略。\n\n服务提供者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:provider loadbalance=\"roundrobin\" />\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" loadbalance=\"roundrobin\" >\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:service>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:service interface=\"com.oyr.user.service.UserService\" ref=\"userServiceImpl\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:service>\n```\n\n服务消费者：\n```xml\n<!-- 全局配置负债均衡 -->\n<dubbo:consumer timeout=\"3000\" loadbalance=\"roundrobin\"/>\n\n<!-- 接口级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" loadbalance=\"roundrobin\">\n    <dubbo:method name=\"getUserAddress\" />\n</dubbo:reference>\n\n<!-- 方法级别配置负债均衡 -->\n<dubbo:reference id=\"userService\" interface=\"com.oyr.user.service.UserService\" >\n    <dubbo:method name=\"getUserAddress\" loadbalance=\"roundrobin\" />\n</dubbo:reference>\n```\n\n## 注册中心宕机与Dubbo直连\n\n### 注册中心宕机问题\n\n在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。\n\n健壮性  \n监控中心宕掉不影响使用，只是丢失部分采样数据  \n数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务  \n注册中心对等集群，任意一台宕掉后，将自动切换到另一台  \n注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯  \n服务提供者无状态，任意一台宕掉后，不影响使用  \n服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复\n\n### 直连模式\n\n注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。  \n点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n\nxml配置方式：\n```xml\n<dubbo:reference id=\"userService\" \n    interface=\"com.zang.gmall.service.UserService\" url=\"dubbo://localhost:20880\" />\n```\n\n注解方式：\n```java\n@Reference(url = \"127.0.0.1:20880\")\nUserService userService;\n```\n\n# Hystrix 断路器\n\n## 服务降级\n\n服务降级概念：  \n当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。\n\n## 服务熔断\n\n服务熔断概念：  \n我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。\n\n同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。\n\n服务熔断机制和服务降级是一起使用。\n\n# Dubbo原理\n\n## RPC原理\n\n## Dubbo原理\n\n","slug":"oyr/Dubbo/Dubbo-高级","published":1,"updated":"2021-07-12T10:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835u0008hct7a08v2gcr","content":"<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式配置\"><a href=\"#集群模式配置\" class=\"headerlink\" title=\"集群模式配置\"></a>集群模式配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span></span><br><span class=\"line\">UserService userService;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h1 id=\"Dubbo原理\"><a href=\"#Dubbo原理\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h1><h2 id=\"RPC原理\"><a href=\"#RPC原理\" class=\"headerlink\" title=\"RPC原理\"></a>RPC原理</h2><h2 id=\"Dubbo原理-1\"><a href=\"#Dubbo原理-1\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h2>","site":{"data":{}},"excerpt":"<h1 id=\"Dubbo-高可用\"><a href=\"#Dubbo-高可用\" class=\"headerlink\" title=\"Dubbo 高可用\"></a>Dubbo 高可用</h1><h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><p>Dubbo集群很简单，只是需要对服务提供者的配置文件进行修改，配置文件中的application.name相同，Dubbo则会认为是同一集群。</p>","more":"<h2 id=\"集群容错\"><a href=\"#集群容错\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h2><p>集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<h3 id=\"集群容错-1\"><a href=\"#集群容错-1\" class=\"headerlink\" title=\"集群容错\"></a>集群容错</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failover Cluster</span><br><span class=\"line\">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</span><br><span class=\"line\"></span><br><span class=\"line\">重试次数配置如下：</span><br><span class=\"line\">&lt;dubbo:service retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Failfast Cluster</span><br><span class=\"line\">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</span><br><span class=\"line\"></span><br><span class=\"line\">Failsafe Cluster</span><br><span class=\"line\">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Failback Cluster</span><br><span class=\"line\">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Forking Cluster</span><br><span class=\"line\">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</span><br><span class=\"line\"></span><br><span class=\"line\">Broadcast Cluster</span><br><span class=\"line\">广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式配置\"><a href=\"#集群模式配置\" class=\"headerlink\" title=\"集群模式配置\"></a>集群模式配置</h3><p>按照以下示例在服务提供方和消费方配置集群模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</span><br><span class=\"line\">或</span><br><span class=\"line\">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负债均衡策略\"><a href=\"#负债均衡策略\" class=\"headerlink\" title=\"负债均衡策略\"></a>负债均衡策略</h2><p>集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<h3 id=\"负载均衡策略\"><a href=\"#负载均衡策略\" class=\"headerlink\" title=\"负载均衡策略\"></a>负载均衡策略</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random LoadBalance</span><br><span class=\"line\">随机均衡算法，按权重设置随机概率。</span><br><span class=\"line\">在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</span><br><span class=\"line\"></span><br><span class=\"line\">RoundRobin LoadBalance</span><br><span class=\"line\">权重轮循均衡算法，按公约后的权重设置轮循比率。</span><br><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br><span class=\"line\"></span><br><span class=\"line\">LeastActive LoadBalance</span><br><span class=\"line\">最少活跃调用数均衡算法，相同活跃数的随机，活跃数指调用前后计数差。</span><br><span class=\"line\">使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsistentHash LoadBalance</span><br><span class=\"line\">一致性 Hash均衡算法，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</span><br><span class=\"line\">缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br><span class=\"line\">缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"负债均衡配置\"><a href=\"#负债均衡配置\" class=\"headerlink\" title=\"负债均衡配置\"></a>负债均衡配置</h3><p>负债均衡配置很简单。<br>服务端和客户端都可以配置服务级别或者方法级别的策略。</p>\n<p>服务提供者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userServiceImpl&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>服务消费者：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 全局配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;3000&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 接口级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 方法级别配置负债均衡 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.oyr.user.service.UserService&quot;</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dubbo:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;getUserAddress&quot;</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注册中心宕机与Dubbo直连\"><a href=\"#注册中心宕机与Dubbo直连\" class=\"headerlink\" title=\"注册中心宕机与Dubbo直连\"></a>注册中心宕机与Dubbo直连</h2><h3 id=\"注册中心宕机问题\"><a href=\"#注册中心宕机问题\" class=\"headerlink\" title=\"注册中心宕机问题\"></a>注册中心宕机问题</h3><p>在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种。</p>\n<p>健壮性<br>监控中心宕掉不影响使用，只是丢失部分采样数据<br>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务<br>注册中心对等集群，任意一台宕掉后，将自动切换到另一台<br>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯<br>服务提供者无状态，任意一台宕掉后，不影响使用<br>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>\n<h3 id=\"直连模式\"><a href=\"#直连模式\" class=\"headerlink\" title=\"直连模式\"></a>直连模式</h3><p>注册中心的作用在于保存服务提供者的位置信息，我们可以完全可以绕过注册中心——采用dubbo直连，即在服务消费方配置服务提供方的位置信息。<br>点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>\n<p>xml配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">interface</span>=<span class=\"string\">&quot;com.zang.gmall.service.UserService&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;dubbo://localhost:20880&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注解方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Reference(url = &quot;127.0.0.1:20880&quot;)</span></span><br><span class=\"line\">UserService userService;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Hystrix-断路器\"><a href=\"#Hystrix-断路器\" class=\"headerlink\" title=\"Hystrix 断路器\"></a>Hystrix 断路器</h1><h2 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h2><p>服务降级概念：<br>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级（返回一个友好提示给客户端，不去执行主业务逻辑，调用fallBack本地方法），以此释放服务器资源以保证核心任务的正常运行。</p>\n<h2 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h2><p>服务熔断概念：<br>我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。</p>\n<p>同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务调用慢或者有大量超时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>\n<p>服务熔断机制和服务降级是一起使用。</p>\n<h1 id=\"Dubbo原理\"><a href=\"#Dubbo原理\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h1><h2 id=\"RPC原理\"><a href=\"#RPC原理\" class=\"headerlink\" title=\"RPC原理\"></a>RPC原理</h2><h2 id=\"Dubbo原理-1\"><a href=\"#Dubbo原理-1\" class=\"headerlink\" title=\"Dubbo原理\"></a>Dubbo原理</h2>"},{"title":"Feign","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 简介\n\nFeign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。  \nFeign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。  \nFeign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。\n\n## 为什么选择Feign?\n\n你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。  \n你也可以直接使用 Apache HttpClient 来实现。  \n但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。\n\n## Feign工作机制\n\nFeign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。  \n然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。\n\n## 版本兼容性\n\nFeign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。\n对于需要兼容 JDK 6 的用户，请使用 Feign 9.x\n\n## 功能概述\n\n这是一张包含 feign 提供的当前关键功能的地图：  \n![feign功能概述](https://rong0624.github.io/images/Feign/)\n\n# Feign使用简介\n\n## ","source":"_posts/oyr/Feign/Feign.md","raw":"---\ntitle: Feign\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: HTTP 客户端\ntags: Feign\n---\n\n# 简介\n\nFeign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。  \nFeign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。  \nFeign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。\n\n## 为什么选择Feign?\n\n你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。  \n你也可以直接使用 Apache HttpClient 来实现。  \n但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。\n\n## Feign工作机制\n\nFeign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。  \n然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。\n\n## 版本兼容性\n\nFeign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。\n对于需要兼容 JDK 6 的用户，请使用 Feign 9.x\n\n## 功能概述\n\n这是一张包含 feign 提供的当前关键功能的地图：  \n![feign功能概述](https://rong0624.github.io/images/Feign/)\n\n# Feign使用简介\n\n## ","slug":"oyr/Feign/Feign","published":1,"updated":"2021-07-12T10:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835v0009hct73wp85j3y","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。<br>Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。<br>Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。</p>\n<h2 id=\"为什么选择Feign\"><a href=\"#为什么选择Feign\" class=\"headerlink\" title=\"为什么选择Feign?\"></a>为什么选择Feign?</h2><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。<br>你也可以直接使用 Apache HttpClient 来实现。<br>但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p>\n<h2 id=\"Feign工作机制\"><a href=\"#Feign工作机制\" class=\"headerlink\" title=\"Feign工作机制\"></a>Feign工作机制</h2><p>Feign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。<br>然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p>\n<h2 id=\"版本兼容性\"><a href=\"#版本兼容性\" class=\"headerlink\" title=\"版本兼容性\"></a>版本兼容性</h2><p>Feign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。<br>对于需要兼容 JDK 6 的用户，请使用 Feign 9.x</p>\n<h2 id=\"功能概述\"><a href=\"#功能概述\" class=\"headerlink\" title=\"功能概述\"></a>功能概述</h2><p>这是一张包含 feign 提供的当前关键功能的地图：<br><img src=\"https://rong0624.github.io/images/Feign/\" alt=\"feign功能概述\"></p>\n<h1 id=\"Feign使用简介\"><a href=\"#Feign使用简介\" class=\"headerlink\" title=\"Feign使用简介\"></a>Feign使用简介</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit、JAXRS-2.0和WebSocket。<br>Feign最初是为了降低统一绑定Denominator到HTTP API的复杂度，不区分是否支持Restful。<br>Feign旨在通过最少的资源和代码来实现和HTTP API的连接。通过可定制的解码器和错误处理，可以编写任意的HTTP API。</p>\n<h2 id=\"为什么选择Feign\"><a href=\"#为什么选择Feign\" class=\"headerlink\" title=\"为什么选择Feign?\"></a>为什么选择Feign?</h2><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。<br>你也可以直接使用 Apache HttpClient 来实现。<br>但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p>\n<h2 id=\"Feign工作机制\"><a href=\"#Feign工作机制\" class=\"headerlink\" title=\"Feign工作机制\"></a>Feign工作机制</h2><p>Feign通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。<br>然而这也限制了Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p>\n<h2 id=\"版本兼容性\"><a href=\"#版本兼容性\" class=\"headerlink\" title=\"版本兼容性\"></a>版本兼容性</h2><p>Feign 10.x 及以上版本基于 Java 8 构建，应该适用于 Java 9、10 和 11。<br>对于需要兼容 JDK 6 的用户，请使用 Feign 9.x</p>\n<h2 id=\"功能概述\"><a href=\"#功能概述\" class=\"headerlink\" title=\"功能概述\"></a>功能概述</h2><p>这是一张包含 feign 提供的当前关键功能的地图：<br><img src=\"https://rong0624.github.io/images/Feign/\" alt=\"feign功能概述\"></p>\n<h1 id=\"Feign使用简介\"><a href=\"#Feign使用简介\" class=\"headerlink\" title=\"Feign使用简介\"></a>Feign使用简介</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"Hexo常用命令.md","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","source":"_posts/oyr/Hexo/Hexo常用命令.md","raw":"---\ntitle: Hexo常用命令.md\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: Hexo\ncategories: Hexo\n---\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!-- more -->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)","slug":"oyr/Hexo/Hexo常用命令","published":1,"updated":"2021-07-12T10:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835v000ahct72qmk15uk","content":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<span id=\"more\"></span>\n\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"AMQP","date":"2021-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# 2.AMQP模型\n\n## 2.1.AMQP模型\n\n![AMQP模型](https://kubpang.gitee.io/sourceFile/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 2.2.工作过程\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n***\n\n# Exchange交换机\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://kubpang.gitee.io/sourceFile/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n* 1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件\n* 2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端\n* 3）分发系统使用它来广播各种状态和配置更新\n* 4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://kubpang.gitee.io/sourceFile/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://kubpang.gitee.io/sourceFile/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# 消费者\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n***\n\n# 消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","source":"_posts/oyr/MQ/AMQP.md","raw":"---\ntitle: AMQP\ndate: 2021-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: oyr-MQ\ncategories: oyr-MQ\n---\n\n# AMQP是什么\n\nAMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。\n\n在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。\n\n***\n\n<!-- more -->\n\n# 2.AMQP模型\n\n## 2.1.AMQP模型\n\n![AMQP模型](https://kubpang.gitee.io/sourceFile/MQ/amqp模型.png)\n\n1）Broker  \n表示消息队列服务器实体（一个进程）。  \n一个server，接受客户端的连接，上线AMQP实体服务。  \n\n2）Connection  \n连接  \n应用程序与broker的网络连接，TCP/IP套接字连接。  \n\n3）Channel  \n消息通道  \n几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个  \nChannel，每个Channel代表一个会话任务。\n\n4）Message  \n消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）> ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等\n\n5）Exchange  \n交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。\n\n6）Queue  \n消息队列，存储消息，用于发送给消费者。  \n它是消息的容器，也是消息的终点。一个消息可以投入多个队列。  \n消息一直在队列里面，等待消费者连接到这个队列将其取走。\n\n7）Binding  \n绑定，消息队列和交换器之间的关联。  \n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\n\n8）Routing Key  \n路由关键字  \n一个消息头，交换机可以用这个消息头决定如何路由某条消息。\n\n9）Publisher  \n消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。\n\n10）Consumer  \n消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。\n\n11）Virtual Host  \n虚拟主机\n\n***\n\n## 2.2.工作过程\n\n生产者发布消息流程：  \n1、生产者和Broker建立TCP连接。  \n2、生产者和Broker建立通道。  \n3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。  \n4、Exchange将消息转发到指定的Queue（队列）  \n\n消费者消费消息流程：  \n1、消费者和Broker建立TCP连接  \n2、消费者和Broker建立通道  \n3、消费者监听指定的Queue（队列）  \n4、当有消息到达Queue时Broker默认将消息推送给消费者。  \n5、消费者接收到消息。  \n6、ack回复  \n\n***\n\n# Exchange交换机\n\n## 默认交换机（default exchange）\n\n默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。\n\n它有一个特殊属性使得它对于简单应用特别有用处：\n那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。\n\n举个栗子：当你声明了一个名为\"search-indexing-online\"的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为\"search-indexing-online\"。因此，当携带着名为\"search-indexing-online\"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为\"search-indexing-online\"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。\n\n***\n\n## 直连交换机（direct exchange）\n\n直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。\n\n下面介绍它是如何工作的：  \n1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）  \n2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。\n\n直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。  \n比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。\n\n直连型交换机图例：  \n![直连交换机图解](https://kubpang.gitee.io/sourceFile/MQ/直连交换机图解.png)\n\n当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。\n\n如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。\n\n***\n\n## 扇型交换机（funout exchange）\n\n扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。\n\n因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：\n* 1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件\n* 2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端\n* 3）分发系统使用它来广播各种状态和配置更新\n* 4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）\n\n扇型交换机图例：  \n![扇型交换机图解](https://kubpang.gitee.io/sourceFile/MQ/扇型交换机图解.png)\n\n上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。\n\n***\n\n## 主题交换机（topic exchanges）\n\n主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。\n\n主题交换机规则：  \n前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.  \n而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  \n\n它的约定是：  \n1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）   \n2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.> nyse”、“nyse.vmw”、“quick.> orange.rabbit”  \n3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串\n\n主题交换机图例：  \n![主题交换机图解](https://kubpang.gitee.io/sourceFile/MQ/主题交换机图解.png)\n\n当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。\n\n***\n\n### 使用场景\n\n主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。\n\n使用案例：  \n1）分发有关于特定地理位置的数据，例如销售点  \n2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务  \n3）股票价格更新（以及其他类型的金融数据更新）  \n4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）  \n5）云端的不同种类服务的协调  \n6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。\n\n***\n\n## 头交换机（headers exchanges）\n\n有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。\n\n我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是\"x-match\"参数。当\"x-match\"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当\"x-match\"设置为“all”的时候，就需要消息头的所有值都匹配成功。\n\n头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。\n\n***\n\n# Queue队列\n\nAMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。\n\n## 队列属性\n\n队列跟交换机共享某些属性，但是队列也有一些另外的属性。  \n1）Name  \n2）Durable（消息代理重启后，队列依旧存在）  \n3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）  \n4）Auto-delete（当最后一个消费者退订后即被删除）  \n5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  \n\n***\n\n## 队列创建\n\n队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。\n\n***\n\n## 队列名称\n\n队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。\n以\"amq.\"开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。\n\n***\n\n## 队列持久化\n\n持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。  \n持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。\n\n***\n\n# Binding绑定\n\n绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。\n\n打个比方：  \n队列（queue）是我们想要去的位于纽约的目的地  \n交换机（exchange）是JFK机场  \n绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条  \n拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  \n\n如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。\n\n**最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。**\n\n***\n\n# 消费者\n\n消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。\n\n在AMQP 0-9-1 模型中，有两种途径可以达到此目的：  \n1）将消息投递给应用 (\"push API\")  \n2）应用根据需要主动获取消息 (\"pull API\")\n\n使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。\n\n每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。\n\n***\n\n# 消息机制\n\n## 消息属性\n\nAMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。\n\n例如：  \n1）Content type（内容类型）  \n2）Content encoding（内容编码）  \n3）Routing key（路由键）  \n4）Delivery mode (persistent or not)  \n5）投递模式（持久化 或 非持久化）  \n6）Message priority（消息优先权）  \n7）Message publishing timestamp（消息发布的时间戳）  \n8）Expiration period（消息有效期）  \n9）Publisher application id（发布应用的 ID）  \n\n有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。\n\n***\n\n## 消息主体\nAMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。\n\n消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。\n\n***\n\n## 消息持久化\n\n消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。\n\n简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。\n\n***\n\n## 消息确认\n\n消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？\n\nAMQP 0-9-1 规范给我们两种建议：  \n1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)  \n2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。\n\n***\n\n## 拒绝消息\n\n当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。\n\n当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。\n\n当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。\n\n***\n\n## 预取消息\n\n在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）\n\n注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。\n\n***\n\n# 其他\n\n## 连接\n\nAMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。\n\n***\n\n## 通道\n\n有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。\n\n在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。\n\n一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。\n\n***\n\n## 虚拟主机\n\n为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。\n\n***\n\n# 参考资料\n\nhttp://rabbitmq.mr-ping.com/  \nhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html","slug":"oyr/MQ/AMQP","published":1,"updated":"2021-09-01T02:48:28.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835x000ehct7348i0i76","content":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h1 id=\"2-AMQP模型\"><a href=\"#2-AMQP模型\" class=\"headerlink\" title=\"2.AMQP模型\"></a>2.AMQP模型</h1><h2 id=\"2-1-AMQP模型\"><a href=\"#2-1-AMQP模型\" class=\"headerlink\" title=\"2.1.AMQP模型\"></a>2.1.AMQP模型</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"2-2-工作过程\"><a href=\"#2-2-工作过程\" class=\"headerlink\" title=\"2.2.工作过程\"></a>2.2.工作过程</h2><p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<hr>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：</p>\n<ul>\n<li>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li>\n<li>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li>\n<li>3）分发系统使用它来广播各种状态和配置更新</li>\n<li>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</li>\n</ul>\n<p>扇型交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<hr>\n<h1 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h1><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>\n<p>在异步通讯中，消息不会立刻到达接收方，而是被存放到一个容器中，当满足一定的条件之后，消息会被容器发送给接收方，这个容器即消息队列，而完成这个功能需要双方和容器以及其中的各个组件遵守统一的约定和规则，AMQP就是这样的一种协议，消息发送与接受的双方遵守这个协议可以实现异步通讯。这个协议约定了消息的格式和工作方式。</p>\n<hr>","more":"<h1 id=\"2-AMQP模型\"><a href=\"#2-AMQP模型\" class=\"headerlink\" title=\"2.AMQP模型\"></a>2.AMQP模型</h1><h2 id=\"2-1-AMQP模型\"><a href=\"#2-1-AMQP模型\" class=\"headerlink\" title=\"2.1.AMQP模型\"></a>2.1.AMQP模型</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/amqp%E6%A8%A1%E5%9E%8B.png\" alt=\"AMQP模型\"></p>\n<p>1）Broker<br>表示消息队列服务器实体（一个进程）。<br>一个server，接受客户端的连接，上线AMQP实体服务。  </p>\n<p>2）Connection<br>连接<br>应用程序与broker的网络连接，TCP/IP套接字连接。  </p>\n<p>3）Channel<br>消息通道<br>几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对多个<br>Channel，每个Channel代表一个会话任务。</p>\n<p>4）Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）&gt; ，priority（相对于其他消优先权），delivery-mode（指出该消息可能需要持久性存储）等</p>\n<p>5）Exchange<br>交换机，用来接受生产者发送的消息，并将这些消息路由转发到某个队列。</p>\n<p>6）Queue<br>消息队列，存储消息，用于发送给消费者。<br>它是消息的容器，也是消息的终点。一个消息可以投入多个队列。<br>消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>\n<p>7）Binding<br>绑定，消息队列和交换器之间的关联。<br>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>\n<p>8）Routing Key<br>路由关键字<br>一个消息头，交换机可以用这个消息头决定如何路由某条消息。</p>\n<p>9）Publisher<br>消息生产者，是一个向交换器发布消息的客户端应用程序（进程）。</p>\n<p>10）Consumer<br>消息消费者，是一个从消息队列中取得消息的客户端应用程序（进程）。</p>\n<p>11）Virtual Host<br>虚拟主机</p>\n<hr>\n<h2 id=\"2-2-工作过程\"><a href=\"#2-2-工作过程\" class=\"headerlink\" title=\"2.2.工作过程\"></a>2.2.工作过程</h2><p>生产者发布消息流程：<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道发送消息给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）  </p>\n<p>消费者消费消息流程：<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。<br>6、ack回复  </p>\n<hr>\n<h1 id=\"Exchange交换机\"><a href=\"#Exchange交换机\" class=\"headerlink\" title=\"Exchange交换机\"></a>Exchange交换机</h1><h2 id=\"默认交换机（default-exchange）\"><a href=\"#默认交换机（default-exchange）\" class=\"headerlink\" title=\"默认交换机（default exchange）\"></a>默认交换机（default exchange）</h2><p>默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。</p>\n<p>它有一个特殊属性使得它对于简单应用特别有用处：<br>那就是每新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。</p>\n<p>举个栗子：当你声明了一个名为”search-indexing-online”的队列，AMQP代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为”search-indexing-online”。因此，当携带着名为”search-indexing-online”的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为”search-indexing-online”的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。</p>\n<hr>\n<h2 id=\"直连交换机（direct-exchange）\"><a href=\"#直连交换机（direct-exchange）\" class=\"headerlink\" title=\"直连交换机（direct exchange）\"></a>直连交换机（direct exchange）</h2><p>直连交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。</p>\n<p>下面介绍它是如何工作的：<br>1）将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）<br>2）当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。</p>\n<p>直连交换机经常用来循环分发任务给多个消费者（我们称之为轮询）。<br>比如说有3个消费者，4个任务。分别分发每个消费者一个任务后，第4个任务又分发给了第一个消费者。综上，我们很容易得出一个结论：在AMQP 0-9-1中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。</p>\n<p>直连型交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%9B%B4%E8%BF%9E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"直连交换机图解\"></p>\n<p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列。</p>\n<p>如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p>\n<hr>\n<h2 id=\"扇型交换机（funout-exchange）\"><a href=\"#扇型交换机（funout-exchange）\" class=\"headerlink\" title=\"扇型交换机（funout exchange）\"></a>扇型交换机（funout exchange）</h2><p>扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。</p>\n<p>因为扇型交换机投递消息会拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：</p>\n<ul>\n<li>1）大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件</li>\n<li>2）体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端</li>\n<li>3）分发系统使用它来广播各种状态和配置更新</li>\n<li>4）在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP没有内置presence的概念，因此XMPP可能会是个更好的选择）</li>\n</ul>\n<p>扇型交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%89%87%E5%9E%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"扇型交换机图解\"></p>\n<p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p>\n<hr>\n<h2 id=\"主题交换机（topic-exchanges）\"><a href=\"#主题交换机（topic-exchanges）\" class=\"headerlink\" title=\"主题交换机（topic exchanges）\"></a>主题交换机（topic exchanges）</h2><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>\n<p>主题交换机规则：<br>前面提到的 direct 规则是严格意义上的匹配，换言之 Routing Key 必须与 Binding Key 相匹配的时候才将消息传送给 Queue.<br>而Topic 的路由规则是一种模糊匹配，可以通过通配符满足一部分规则就可以传送。  </p>\n<p>它的约定是：<br>1）binding key 中可以存在两种特殊字符 “” 与“#”，用于做模糊匹配，其中 “” 用于匹配一个单词，“#”用于匹配多个单词（可以是零个）<br>2）routing key 为一个句点号 “.” 分隔的字符串（我们将被句点号 “. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.&gt; nyse”、“nyse.vmw”、“quick.&gt; orange.rabbit”<br>3）binding key 与 routing key 一样也是句点号 “.” 分隔的字符串</p>\n<p>主题交换机图例：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9B%BE%E8%A7%A3.png\" alt=\"主题交换机图解\"></p>\n<p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p>\n<hr>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。</p>\n<p>使用案例：<br>1）分发有关于特定地理位置的数据，例如销售点<br>2）由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务<br>3）股票价格更新（以及其他类型的金融数据更新）<br>4）涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）<br>5）云端的不同种类服务的协调<br>6）分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。</p>\n<hr>\n<h2 id=\"头交换机（headers-exchanges）\"><a href=\"#头交换机（headers-exchanges）\" class=\"headerlink\" title=\"头交换机（headers exchanges）\"></a>头交换机（headers exchanges）</h2><p>有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</p>\n<p>我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是”x-match”参数。当”x-match”设置为“any”时，消息头的任意一个值被匹配就可以满足条件，而当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功。</p>\n<p>头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。</p>\n<hr>\n<h1 id=\"Queue队列\"><a href=\"#Queue队列\" class=\"headerlink\" title=\"Queue队列\"></a>Queue队列</h1><p>AMQP中的队列（Queue）跟其他消息队列或任务队列中的队列是很相似的，它们存储着即将被应用消费掉的消息。</p>\n<h2 id=\"队列属性\"><a href=\"#队列属性\" class=\"headerlink\" title=\"队列属性\"></a>队列属性</h2><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。<br>1）Name<br>2）Durable（消息代理重启后，队列依旧存在）<br>3）Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）<br>4）Auto-delete（当最后一个消费者退订后即被删除）<br>5）Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）  </p>\n<hr>\n<h2 id=\"队列创建\"><a href=\"#队列创建\" class=\"headerlink\" title=\"队列创建\"></a>队列创建</h2><p>队列在声明（declare）后才能被使用。如果一个队列尚不存在，声明一个队列会创建它。如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为406的通道级异常就会被抛出。</p>\n<hr>\n<h2 id=\"队列名称\"><a href=\"#队列名称\" class=\"headerlink\" title=\"队列名称\"></a>队列名称</h2><p>队列的名字可以由应用（application）来取，也可以让消息代理（broker）直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生成队列名，需要给队列的name参数赋值一个空字符串：在同一个通道（channel）的后续的方法（method）中，我们可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。<br>以”amq.”开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403 (ACCESS_REFUSED)错误会被抛出。</p>\n<hr>\n<h2 id=\"队列持久化\"><a href=\"#队列持久化\" class=\"headerlink\" title=\"队列持久化\"></a>队列持久化</h2><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。<br>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>\n<hr>\n<h1 id=\"Binding绑定\"><a href=\"#Binding绑定\" class=\"headerlink\" title=\"Binding绑定\"></a>Binding绑定</h1><p>绑定（Binding）是交换机（exchange）将消息（message）路由给队列（queue）所需遵循的规则。如果要指示交换机“E”将消息路由给队列“Q”，那么“Q”就需要与“E”进行绑定。绑定操作需要定义一个可选的路由键（routing key）属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。</p>\n<p>打个比方：<br>队列（queue）是我们想要去的位于纽约的目的地<br>交换机（exchange）是JFK机场<br>绑定（binding）就是JFK机场到目的地的路线。能够到达目的地的路线可以是一条或者多条<br>拥有了交换机这个中间层，很多由发布者直接到队列难以实现的路由方案能够得以实现，并且避免了应用开发者的许多重复劳动。  </p>\n<p>如果AMQP的消息无法路由到队列（例如，发送到的交换机没有绑定队列），消息会被就地销毁或者返还给发布者。如何处理取决于发布者设置的消息属性。</p>\n<p><strong>最终解释：绑定是消息队列和交换器之间的关联，绑定是交换器和消息队列连接起来的路由规则。</strong></p>\n<hr>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。</p>\n<p>在AMQP 0-9-1 模型中，有两种途径可以达到此目的：<br>1）将消息投递给应用 (“push API”)<br>2）应用根据需要主动获取消息 (“pull API”)</p>\n<p>使用push API，应用（application）需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，我们可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者（当独享消费者存在时，其他消费者即被排除在外）。</p>\n<p>每个消费者（订阅者）都有一个叫做消费者标签的标识符。它可以被用来退订消息。消费者标签实际上是一个字符串。</p>\n<hr>\n<h1 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h1><h2 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h2><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。</p>\n<p>例如：<br>1）Content type（内容类型）<br>2）Content encoding（内容编码）<br>3）Routing key（路由键）<br>4）Delivery mode (persistent or not)<br>5）投递模式（持久化 或 非持久化）<br>6）Message priority（消息优先权）<br>7）Message publishing timestamp（消息发布的时间戳）<br>8）Expiration period（消息有效期）<br>9）Publisher application id（发布应用的 ID）  </p>\n<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>\n<hr>\n<h2 id=\"消息主体\"><a href=\"#消息主体\" class=\"headerlink\" title=\"消息主体\"></a>消息主体</h2><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>\n<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>\n<hr>\n<h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>\n<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>\n<hr>\n<h2 id=\"消息确认\"><a href=\"#消息确认\" class=\"headerlink\" title=\"消息确认\"></a>消息确认</h2><p>消费者应用（Consumer applications）用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？</p>\n<p>AMQP 0-9-1 规范给我们两种建议：<br>1）自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>2）显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）</p>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于“拒绝消息（Rejecting Messages）”的原因处理失败了（或者未能在此时完成）。</p>\n<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>\n<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>\n<hr>\n<h2 id=\"预取消息\"><a href=\"#预取消息\" class=\"headerlink\" title=\"预取消息\"></a>预取消息</h2><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（？？？例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>\n<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>\n<hr>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>AMQP连接通常是长连接。AMQP是一个使用TCP提供可靠投递的应用层协议。AMQP使用认证机制并且提供TLS（SSL）保护。当一个应用不再需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>\n<hr>\n<h2 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h2><p>有些应用需要与AMQP代理建立多个连接。无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道（channels）来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。</p>\n<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道（channel）是很常见的，并且这些通道不能被线程/进程共享。</p>\n<p>一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。</p>\n<hr>\n<h2 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟Web servers虚拟主机概念非常相似，这为AMQP实体提供了完全隔离的环境。当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://rabbitmq.mr-ping.com/\">http://rabbitmq.mr-ping.com/</a><br><a href=\"https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\">https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html</a></p>"},{"title":"ActiveMQ","date":"2021-06-14T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# ActiveMQ基础\n\n## 简介\n\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。  \nActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。  \n尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。\n\n## 特点\n\n1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议  \n2）完全支持JMS客户端和Message Broker中的企业集成模式  \n3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标  \n4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息  \n5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置  \n6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计  \n7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递  \n8）可以用作内存JMS提供程序，非常适合单元测试JMS  \n9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输  \n10）使用JDBC和高性能日志支持非常快速的持久性\n\n# ActiveMQ的安装\n\n# ActiveMQ的消息形式\n\n对于消息的传递有两种类型：  \n1）点对点（p2p），即一个生产者和一个消费者一一对应；  \n2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；  \n如图所示：  \n![ActiveMQ的消息类型](https://kubpang.gitee.io/sourceFile/MQ/ActiveMQ/ActiveMQ的消息类型.png)\n\nJMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。\n* StreamMessage -- Java原始值的数据流\n* MapMessage -- 一套名称-值对\n* TextMessage -- 一个字符串对象\n* ObjectMessage -- 一个序列化的 Java对象\n* BytesMessage -- 一个字节的数据流\n\n# ActiveMQ的使用\n\n导入maven依赖：\n```xml\n<!-- activemq依赖的jar -->\n<dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-all</artifactId>\n    <version>5.11.2</version>\n</dependency>\n```\n\n## Queue\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testQueueProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t//brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。\n\t\t//参数：队列的名称。\n\t\tQueue queue = session.createQueue(\"test-queue\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(queue);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*TextMessage message = new ActiveMQTextMessage();\n\t\tmessage.setText(\"hello activeMq,this is my first test.\");*/\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my first test.\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n## Topic\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testTopicProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t// brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。\n\t\t// 参数：话题的名称。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(topic);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*\n\t\t * TextMessage message = new ActiveMQTextMessage(); message.setText(\n\t\t * \"hello activeMq,this is my first test.\");\n\t\t */\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my topic test\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n消费者：接收消息。\n\n使用步骤：\n第一步：创建一个ConnectionFactory对象。  \n第二步：从ConnectionFactory对象中获得一个Connection对象。  \n第三步：开启连接。调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。  \n第六步：使用Session对象创建一个Consumer对象。  \n第七步：接收消息。  \n第八步：打印消息。  \n第九步：关闭资源\n\n```java\n    @Test\n\tpublic void testTopicConsumer() throws Exception {\n\t\t// 第一步：创建一个ConnectionFactory对象。\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：从ConnectionFactory对象中获得一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接。调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Consumer对象。\n\t\tMessageConsumer consumer = session.createConsumer(topic);\n\t\t// 第七步：接收消息。\n\t\tconsumer.setMessageListener(new MessageListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onMessage(Message message) {\n\t\t\t\ttry {\n\t\t\t\t\tTextMessage textMessage = (TextMessage) message;\n\t\t\t\t\tString text = null;\n\t\t\t\t\t// 取消息的内容\n\t\t\t\t\ttext = textMessage.getText();\n\t\t\t\t\t// 第八步：打印消息。\n\t\t\t\t\tSystem.out.println(text);\n\t\t\t\t} catch (JMSException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"topic的消费端03。。。。。\");\n\t\t// 等待键盘输入\n\t\tSystem.in.read();\n\t\t// 第九步：关闭资源\n\t\tconsumer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n# ActiveMQ消息数据持久化\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\n两种选择：非持久性模式/持久性模式  \n1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。  \n2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\nPERSISTENT：\n指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\n\nNON_PERSISTENT:\n不要求JMS provider持久保存消息\n\n在消息提供者设置消息持久化：`producer.setDeliveryMode(DeliveryMode.PERSISTENT);`\n\n# JMS可靠消息机制\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了。   \n消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。  \n改参数有三个可选值：\n1. Session.AUTO_ACKNOWLEDGE：自动签收  \n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n2. Session.CLIENT_ACKNOWLEDGE：手动签收  \n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n3. Session.DUPS_ACKNOWLEDGE：  \n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n4. 带事物的session：  \n完成操作后需要手动的commit\n\n","source":"_posts/oyr/MQ/ActiveMQ.md","raw":"---\ntitle: ActiveMQ\ndate: 2021-06-15 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MQ\ntags: \n\t- oyr-MQ\n\t- 中间件\n---\n\n# ActiveMQ基础\n\n## 简介\n\nActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。  \nActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。  \n尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。\n\n## 特点\n\n1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议  \n2）完全支持JMS客户端和Message Broker中的企业集成模式  \n3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标  \n4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息  \n5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置  \n6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计  \n7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递  \n8）可以用作内存JMS提供程序，非常适合单元测试JMS  \n9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输  \n10）使用JDBC和高性能日志支持非常快速的持久性\n\n# ActiveMQ的安装\n\n# ActiveMQ的消息形式\n\n对于消息的传递有两种类型：  \n1）点对点（p2p），即一个生产者和一个消费者一一对应；  \n2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；  \n如图所示：  \n![ActiveMQ的消息类型](https://kubpang.gitee.io/sourceFile/MQ/ActiveMQ/ActiveMQ的消息类型.png)\n\nJMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。\n* StreamMessage -- Java原始值的数据流\n* MapMessage -- 一套名称-值对\n* TextMessage -- 一个字符串对象\n* ObjectMessage -- 一个序列化的 Java对象\n* BytesMessage -- 一个字节的数据流\n\n# ActiveMQ的使用\n\n导入maven依赖：\n```xml\n<!-- activemq依赖的jar -->\n<dependency>\n    <groupId>org.apache.activemq</groupId>\n    <artifactId>activemq-all</artifactId>\n    <version>5.11.2</version>\n</dependency>\n```\n\n## Queue\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testQueueProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t//brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。\n\t\t//参数：队列的名称。\n\t\tQueue queue = session.createQueue(\"test-queue\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(queue);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*TextMessage message = new ActiveMQTextMessage();\n\t\tmessage.setText(\"hello activeMq,this is my first test.\");*/\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my first test.\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n## Topic\n\n### Producer\n\n生产者：发布消息。\n\n使用步骤：  \n第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。  \n第二步：使用ConnectionFactory对象创建一个Connection对象。  \n第三步：开启连接，调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。  \n第六步：使用Session对象创建一个Producer对象。  \n第七步：创建一个Message对象，创建一个TextMessage对象。  \n第八步：使用Producer对象发送消息。  \n第九步：关闭资源。\n\n```java\n    @Test\n\tpublic void testTopicProducer() throws Exception {\n\t\t// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。\n\t\t// brokerURL服务器的ip及端口号\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：使用ConnectionFactory对象创建一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接，调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\t// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。\n\t\t// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。\n\t\t// 参数：话题的名称。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Producer对象。\n\t\tMessageProducer producer = session.createProducer(topic);\n\t\t// 第七步：创建一个Message对象，创建一个TextMessage对象。\n\t\t/*\n\t\t * TextMessage message = new ActiveMQTextMessage(); message.setText(\n\t\t * \"hello activeMq,this is my first test.\");\n\t\t */\n\t\tTextMessage textMessage = session.createTextMessage(\"hello activeMq,this is my topic test\");\n\t\t// 第八步：使用Producer对象发送消息。\n\t\tproducer.send(textMessage);\n\t\t// 第九步：关闭资源。\n\t\tproducer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n### Consumer\n\n消费者：接收消息。\n\n使用步骤：\n第一步：创建一个ConnectionFactory对象。  \n第二步：从ConnectionFactory对象中获得一个Connection对象。  \n第三步：开启连接。调用Connection对象的start方法。  \n第四步：使用Connection对象创建一个Session对象。  \n第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。  \n第六步：使用Session对象创建一个Consumer对象。  \n第七步：接收消息。  \n第八步：打印消息。  \n第九步：关闭资源\n\n```java\n    @Test\n\tpublic void testTopicConsumer() throws Exception {\n\t\t// 第一步：创建一个ConnectionFactory对象。\n\t\tConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.168:61616\");\n\t\t// 第二步：从ConnectionFactory对象中获得一个Connection对象。\n\t\tConnection connection = connectionFactory.createConnection();\n\t\t// 第三步：开启连接。调用Connection对象的start方法。\n\t\tconnection.start();\n\t\t// 第四步：使用Connection对象创建一个Session对象。\n\t\tSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t\t// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。\n\t\tTopic topic = session.createTopic(\"test-topic\");\n\t\t// 第六步：使用Session对象创建一个Consumer对象。\n\t\tMessageConsumer consumer = session.createConsumer(topic);\n\t\t// 第七步：接收消息。\n\t\tconsumer.setMessageListener(new MessageListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onMessage(Message message) {\n\t\t\t\ttry {\n\t\t\t\t\tTextMessage textMessage = (TextMessage) message;\n\t\t\t\t\tString text = null;\n\t\t\t\t\t// 取消息的内容\n\t\t\t\t\ttext = textMessage.getText();\n\t\t\t\t\t// 第八步：打印消息。\n\t\t\t\t\tSystem.out.println(text);\n\t\t\t\t} catch (JMSException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"topic的消费端03。。。。。\");\n\t\t// 等待键盘输入\n\t\tSystem.in.read();\n\t\t// 第九步：关闭资源\n\t\tconsumer.close();\n\t\tsession.close();\n\t\tconnection.close();\n\t}\n```\n\n# ActiveMQ消息数据持久化\n\n场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？\n\n两种选择：非持久性模式/持久性模式  \n1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；\n程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。  \n2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；\n程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。\n\nPERSISTENT：\n指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\n\nNON_PERSISTENT:\n不要求JMS provider持久保存消息\n\n在消息提供者设置消息持久化：`producer.setDeliveryMode(DeliveryMode.PERSISTENT);`\n\n# JMS可靠消息机制\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了。   \n消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。\n\n在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。  \n改参数有三个可选值：\n1. Session.AUTO_ACKNOWLEDGE：自动签收  \n当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。\n2. Session.CLIENT_ACKNOWLEDGE：手动签收  \n客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。\n3. Session.DUPS_ACKNOWLEDGE：  \n该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true\n4. 带事物的session：  \n完成操作后需要手动的commit\n\n","slug":"oyr/MQ/ActiveMQ","published":1,"updated":"2021-09-01T02:48:17.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835x000fhct717jp8fs2","content":"<h1 id=\"ActiveMQ基础\"><a href=\"#ActiveMQ基础\" class=\"headerlink\" title=\"ActiveMQ基础\"></a>ActiveMQ基础</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。<br>ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。<br>尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议<br>2）完全支持JMS客户端和Message Broker中的企业集成模式<br>3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标<br>4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息<br>5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置<br>6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计<br>7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递<br>8）可以用作内存JMS提供程序，非常适合单元测试JMS<br>9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输<br>10）使用JDBC和高性能日志支持非常快速的持久性</p>\n<h1 id=\"ActiveMQ的安装\"><a href=\"#ActiveMQ的安装\" class=\"headerlink\" title=\"ActiveMQ的安装\"></a>ActiveMQ的安装</h1><h1 id=\"ActiveMQ的消息形式\"><a href=\"#ActiveMQ的消息形式\" class=\"headerlink\" title=\"ActiveMQ的消息形式\"></a>ActiveMQ的消息形式</h1><p>对于消息的传递有两种类型：<br>1）点对点（p2p），即一个生产者和一个消费者一一对应；<br>2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；<br>如图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/ActiveMQ/ActiveMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.png\" alt=\"ActiveMQ的消息类型\"></p>\n<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>\n<ul>\n<li>StreamMessage – Java原始值的数据流</li>\n<li>MapMessage – 一套名称-值对</li>\n<li>TextMessage – 一个字符串对象</li>\n<li>ObjectMessage – 一个序列化的 Java对象</li>\n<li>BytesMessage – 一个字节的数据流</li>\n</ul>\n<h1 id=\"ActiveMQ的使用\"><a href=\"#ActiveMQ的使用\" class=\"headerlink\" title=\"ActiveMQ的使用\"></a>ActiveMQ的使用</h1><p>导入maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- activemq依赖的jar --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.activemq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activemq-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.11.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><h3 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testQueueProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">//brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：队列的名称。</span></span><br><span class=\"line\">\tQueue queue = session.createQueue(<span class=\"string\">&quot;test-queue&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(queue);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*TextMessage message = new ActiveMQTextMessage();</span></span><br><span class=\"line\"><span class=\"comment\">\tmessage.setText(&quot;hello activeMq,this is my first test.&quot;);*/</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my first test.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h3 id=\"Producer-1\"><a href=\"#Producer-1\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">// brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 参数：话题的名称。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * TextMessage message = new ActiveMQTextMessage(); message.setText(</span></span><br><span class=\"line\"><span class=\"comment\">\t * &quot;hello activeMq,this is my first test.&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my topic test&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p>消费者：接收消息。</p>\n<p>使用步骤：<br>第一步：创建一个ConnectionFactory对象。<br>第二步：从ConnectionFactory对象中获得一个Connection对象。<br>第三步：开启连接。调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。<br>第六步：使用Session对象创建一个Consumer对象。<br>第七步：接收消息。<br>第八步：打印消息。<br>第九步：关闭资源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicConsumer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建一个ConnectionFactory对象。</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：从ConnectionFactory对象中获得一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接。调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Consumer对象。</span></span><br><span class=\"line\">\tMessageConsumer consumer = session.createConsumer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：接收消息。</span></span><br><span class=\"line\">\tconsumer.setMessageListener(<span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTextMessage textMessage = (TextMessage) message;</span><br><span class=\"line\">\t\t\t\tString text = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 取消息的内容</span></span><br><span class=\"line\">\t\t\t\ttext = textMessage.getText();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 第八步：打印消息。</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(text);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (JMSException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;topic的消费端03。。。。。&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待键盘输入</span></span><br><span class=\"line\">\tSystem.in.read();</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源</span></span><br><span class=\"line\">\tconsumer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ActiveMQ消息数据持久化\"><a href=\"#ActiveMQ消息数据持久化\" class=\"headerlink\" title=\"ActiveMQ消息数据持久化\"></a>ActiveMQ消息数据持久化</h1><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>两种选择：非持久性模式/持久性模式<br>1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。<br>2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</p>\n<p>PERSISTENT：<br>指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</p>\n<p>NON_PERSISTENT:<br>不要求JMS provider持久保存消息</p>\n<p>在消息提供者设置消息持久化：<code>producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></p>\n<h1 id=\"JMS可靠消息机制\"><a href=\"#JMS可靠消息机制\" class=\"headerlink\" title=\"JMS可靠消息机制\"></a>JMS可靠消息机制</h1><p>JMS消息只有在被确认之后，才认为已经被成功的消费了。<br>消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。<br>改参数有三个可选值：</p>\n<ol>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n<li>带事物的session：<br>完成操作后需要手动的commit</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ActiveMQ基础\"><a href=\"#ActiveMQ基础\" class=\"headerlink\" title=\"ActiveMQ基础\"></a>ActiveMQ基础</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。<br>ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。<br>尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1）支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议<br>2）完全支持JMS客户端和Message Broker中的企业集成模式<br>3）支持许多高级功能，如消息组，虚拟目标，通配符和复合目标<br>4）完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息<br>5）Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置<br>6）专为高性能集群，客户端 - 服务器，基于对等的通信而设计<br>7）CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递<br>8）可以用作内存JMS提供程序，非常适合单元测试JMS<br>9）支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输<br>10）使用JDBC和高性能日志支持非常快速的持久性</p>\n<h1 id=\"ActiveMQ的安装\"><a href=\"#ActiveMQ的安装\" class=\"headerlink\" title=\"ActiveMQ的安装\"></a>ActiveMQ的安装</h1><h1 id=\"ActiveMQ的消息形式\"><a href=\"#ActiveMQ的消息形式\" class=\"headerlink\" title=\"ActiveMQ的消息形式\"></a>ActiveMQ的消息形式</h1><p>对于消息的传递有两种类型：<br>1）点对点（p2p），即一个生产者和一个消费者一一对应；<br>2）发布/订阅，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收；<br>如图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/ActiveMQ/ActiveMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.png\" alt=\"ActiveMQ的消息类型\"></p>\n<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>\n<ul>\n<li>StreamMessage – Java原始值的数据流</li>\n<li>MapMessage – 一套名称-值对</li>\n<li>TextMessage – 一个字符串对象</li>\n<li>ObjectMessage – 一个序列化的 Java对象</li>\n<li>BytesMessage – 一个字节的数据流</li>\n</ul>\n<h1 id=\"ActiveMQ的使用\"><a href=\"#ActiveMQ的使用\" class=\"headerlink\" title=\"ActiveMQ的使用\"></a>ActiveMQ的使用</h1><p>导入maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- activemq依赖的jar --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.activemq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>activemq-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.11.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><h3 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testQueueProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">//brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">//第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">//参数：队列的名称。</span></span><br><span class=\"line\">\tQueue queue = session.createQueue(<span class=\"string\">&quot;test-queue&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(queue);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*TextMessage message = new ActiveMQTextMessage();</span></span><br><span class=\"line\"><span class=\"comment\">\tmessage.setText(&quot;hello activeMq,this is my first test.&quot;);*/</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my first test.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h3 id=\"Producer-1\"><a href=\"#Producer-1\" class=\"headerlink\" title=\"Producer\"></a>Producer</h3><p>生产者：发布消息。</p>\n<p>使用步骤：<br>第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>第二步：使用ConnectionFactory对象创建一个Connection对象。<br>第三步：开启连接，调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。<br>第六步：使用Session对象创建一个Producer对象。<br>第七步：创建一个Message对象，创建一个TextMessage对象。<br>第八步：使用Producer对象发送消息。<br>第九步：关闭资源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicProducer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。</span></span><br><span class=\"line\">\t<span class=\"comment\">// brokerURL服务器的ip及端口号</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：使用ConnectionFactory对象创建一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接，调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 参数：话题的名称。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Producer对象。</span></span><br><span class=\"line\">\tMessageProducer producer = session.createProducer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：创建一个Message对象，创建一个TextMessage对象。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * TextMessage message = new ActiveMQTextMessage(); message.setText(</span></span><br><span class=\"line\"><span class=\"comment\">\t * &quot;hello activeMq,this is my first test.&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tTextMessage textMessage = session.createTextMessage(<span class=\"string\">&quot;hello activeMq,this is my topic test&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第八步：使用Producer对象发送消息。</span></span><br><span class=\"line\">\tproducer.send(textMessage);</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源。</span></span><br><span class=\"line\">\tproducer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Consumer-1\"><a href=\"#Consumer-1\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><p>消费者：接收消息。</p>\n<p>使用步骤：<br>第一步：创建一个ConnectionFactory对象。<br>第二步：从ConnectionFactory对象中获得一个Connection对象。<br>第三步：开启连接。调用Connection对象的start方法。<br>第四步：使用Connection对象创建一个Session对象。<br>第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。<br>第六步：使用Session对象创建一个Consumer对象。<br>第七步：接收消息。<br>第八步：打印消息。<br>第九步：关闭资源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopicConsumer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 第一步：创建一个ConnectionFactory对象。</span></span><br><span class=\"line\">\tConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(<span class=\"string\">&quot;tcp://192.168.25.168:61616&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第二步：从ConnectionFactory对象中获得一个Connection对象。</span></span><br><span class=\"line\">\tConnection connection = connectionFactory.createConnection();</span><br><span class=\"line\">\t<span class=\"comment\">// 第三步：开启连接。调用Connection对象的start方法。</span></span><br><span class=\"line\">\tconnection.start();</span><br><span class=\"line\">\t<span class=\"comment\">// 第四步：使用Connection对象创建一个Session对象。</span></span><br><span class=\"line\">\tSession session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class=\"line\">\t<span class=\"comment\">// 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。</span></span><br><span class=\"line\">\tTopic topic = session.createTopic(<span class=\"string\">&quot;test-topic&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 第六步：使用Session对象创建一个Consumer对象。</span></span><br><span class=\"line\">\tMessageConsumer consumer = session.createConsumer(topic);</span><br><span class=\"line\">\t<span class=\"comment\">// 第七步：接收消息。</span></span><br><span class=\"line\">\tconsumer.setMessageListener(<span class=\"keyword\">new</span> MessageListener() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTextMessage textMessage = (TextMessage) message;</span><br><span class=\"line\">\t\t\t\tString text = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 取消息的内容</span></span><br><span class=\"line\">\t\t\t\ttext = textMessage.getText();</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 第八步：打印消息。</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(text);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (JMSException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;topic的消费端03。。。。。&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待键盘输入</span></span><br><span class=\"line\">\tSystem.in.read();</span><br><span class=\"line\">\t<span class=\"comment\">// 第九步：关闭资源</span></span><br><span class=\"line\">\tconsumer.close();</span><br><span class=\"line\">\tsession.close();</span><br><span class=\"line\">\tconnection.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ActiveMQ消息数据持久化\"><a href=\"#ActiveMQ消息数据持久化\" class=\"headerlink\" title=\"ActiveMQ消息数据持久化\"></a>ActiveMQ消息数据持久化</h1><p>场景问题：服务器断电重启，未被消费的消息是否会在重启之后被继续消费？</p>\n<p>两种选择：非持久性模式/持久性模式<br>1）非持久性模式：服务器断电(关闭)之后，使用非持久性模式时，没有被消费的消息不会继续消费全部丢失；<br>程序会报一个连接关闭异常停止运行，继续启动服务器运行程序，不会接收任何消息。<br>2）持久性模式：服务器断电(关闭)后，使用持久性模式时，没有被消费的消息会继续消费；<br>程序也会报连接关闭异常，但再次启动服务器和程序后，接收方还能继续原来的消息再次接收。</p>\n<p>PERSISTENT：<br>指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失</p>\n<p>NON_PERSISTENT:<br>不要求JMS provider持久保存消息</p>\n<p>在消息提供者设置消息持久化：<code>producer.setDeliveryMode(DeliveryMode.PERSISTENT);</code></p>\n<h1 id=\"JMS可靠消息机制\"><a href=\"#JMS可靠消息机制\" class=\"headerlink\" title=\"JMS可靠消息机制\"></a>JMS可靠消息机制</h1><p>JMS消息只有在被确认之后，才认为已经被成功的消费了。<br>消息的成功消费通常包含三个阶段：客户接收消息，客户处理消息和消息被确认。</p>\n<p>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。<br>改参数有三个可选值：</p>\n<ol>\n<li>Session.AUTO_ACKNOWLEDGE：自动签收<br>当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li>\n<li>Session.CLIENT_ACKNOWLEDGE：手动签收<br>客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息，将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li>\n<li>Session.DUPS_ACKNOWLEDGE：<br>该选择只是会话迟钝的确认消息的提交。如果JMS Provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li>\n<li>带事物的session：<br>完成操作后需要手动的commit</li>\n</ol>\n"},{"title":"JMS","date":"2021-07-08T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# JMS是什么\n\nJMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。  \nJava消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。\n\nJMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n<!-- more -->\n\n# JMS体系架构\n\nJMS由以下元素组成。\n\n1）JMS提供者   \n连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。\n\n2）JMS客户   \n生产或消费消息的基于Java的应用程序或对象。\n\n3）JMS生产者   \n创建并发送消息的JMS客户。\n\n4）JMS消费者   \n接收消息的JMS客户。\n\n5）JMS消息   \n包括可以在JMS客户之间传递的数据的对象\n\n6）JMS队列   \n一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。\n\n7）JMS主题 \n一种支持发送消息给多个订阅者的机制。\n\n# JMS消息模型\n\n## JMS消息模型\n\n1）Point-to-Point(P2P)  \n2）Publish/Subscribe(Pub/Sub)\n\n在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。\n\n## P2P（点对点）\n\n![P2P模式](https://kubpang.gitee.io/sourceFile/MQ/jms/397872-20170315231815541-1387998695.jpeg)\n\n### 涉及的概念\n\n1）消息队列(Queue)    \n2）提供者(Sender)  \n3）消费者(Receiver)  \n4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\n### P2P的特点\n\n1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)  \n2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列  \n3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。  \n4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。  \n5）消费者在成功接收消息之后需向队列应答成功  \n\n**注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。**\n\n## Pub/Sub（发布/订阅模式）\n\n![Pub/Sub模式](https://kubpang.gitee.io/sourceFile/MQ/jms/)\n\n### 涉及的概念\n\n1）主题（Topic）  \n2）发布者（Publisher）  \n3）订阅者（Subscriber）  \n4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\n### Pub/Sub的特点\n\n1）每个消息可以有多个消费者。  \n2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。  \n3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。  \n4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。  \n5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。  \n6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。\n\n**如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型**\n\n# JMS 应用程序接口\n\n1. ConnectionFactory 接口(连接工厂)\n    - 创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂\n    - 分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。\n2. Destination 接口(目标)\n    - Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。\n    - 是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;\n    - 对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。\n    - 所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。\n3. Connection 接口(连接)\n    - Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。\n    - Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。\n4. Session 接口(会话)\n    - Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。\n    - 由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。\n    - 可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。\n    - 同样，也分QueueSession和TopicSession。\n5. MessageProducer 接口(消息的生产者)\n    - 消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。\n    - 同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。\n6. MessageConsumer 接口(消息消费者)\n    - 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。\n    - 可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。\n    - 当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。\n7. Message 接口（消息）\n    - 是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。\n    - 一个消息有三个主要部分：\n        - 1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。\n        - 2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。\n        - 3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。\n    - 消息接口非常灵活，并提供了许多方式来定制消息的内容。\n8. MessageListener\n    - 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。\n    - EJB中的MDB（Message-Driven Bean）就是一种MessageListener。\n\n![JMS 应用程序接口](https://kubpang.gitee.io/sourceFile/MQ/jms/20170215230025420.png)\n\n# 参考资料\n\nhttps://www.cnblogs.com/molao-doing/articles/6557305.html","source":"_posts/oyr/MQ/JMS.md","raw":"---\ntitle: JMS\ndate: 2021-07-09 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MQ\ntags: \n    - oyr-MQ\n    - 中间件\n---\n\n# JMS是什么\n\nJMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。  \nJava消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。\n\nJMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n<!-- more -->\n\n# JMS体系架构\n\nJMS由以下元素组成。\n\n1）JMS提供者   \n连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。\n\n2）JMS客户   \n生产或消费消息的基于Java的应用程序或对象。\n\n3）JMS生产者   \n创建并发送消息的JMS客户。\n\n4）JMS消费者   \n接收消息的JMS客户。\n\n5）JMS消息   \n包括可以在JMS客户之间传递的数据的对象\n\n6）JMS队列   \n一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。\n\n7）JMS主题 \n一种支持发送消息给多个订阅者的机制。\n\n# JMS消息模型\n\n## JMS消息模型\n\n1）Point-to-Point(P2P)  \n2）Publish/Subscribe(Pub/Sub)\n\n在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。\n\n## P2P（点对点）\n\n![P2P模式](https://kubpang.gitee.io/sourceFile/MQ/jms/397872-20170315231815541-1387998695.jpeg)\n\n### 涉及的概念\n\n1）消息队列(Queue)    \n2）提供者(Sender)  \n3）消费者(Receiver)  \n4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\n### P2P的特点\n\n1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)  \n2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列  \n3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。  \n4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。  \n5）消费者在成功接收消息之后需向队列应答成功  \n\n**注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。**\n\n## Pub/Sub（发布/订阅模式）\n\n![Pub/Sub模式](https://kubpang.gitee.io/sourceFile/MQ/jms/)\n\n### 涉及的概念\n\n1）主题（Topic）  \n2）发布者（Publisher）  \n3）订阅者（Subscriber）  \n4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\n### Pub/Sub的特点\n\n1）每个消息可以有多个消费者。  \n2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。  \n3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。  \n4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。  \n5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。  \n6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。\n\n**如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型**\n\n# JMS 应用程序接口\n\n1. ConnectionFactory 接口(连接工厂)\n    - 创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂\n    - 分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。\n2. Destination 接口(目标)\n    - Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。\n    - 是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;\n    - 对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。\n    - 所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。\n3. Connection 接口(连接)\n    - Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。\n    - Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。\n4. Session 接口(会话)\n    - Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。\n    - 由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。\n    - 可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。\n    - 同样，也分QueueSession和TopicSession。\n5. MessageProducer 接口(消息的生产者)\n    - 消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。\n    - 同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。\n6. MessageConsumer 接口(消息消费者)\n    - 消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。\n    - 可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。\n    - 当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。\n7. Message 接口（消息）\n    - 是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。\n    - 一个消息有三个主要部分：\n        - 1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。\n        - 2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。\n        - 3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。\n    - 消息接口非常灵活，并提供了许多方式来定制消息的内容。\n8. MessageListener\n    - 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。\n    - EJB中的MDB（Message-Driven Bean）就是一种MessageListener。\n\n![JMS 应用程序接口](https://kubpang.gitee.io/sourceFile/MQ/jms/20170215230025420.png)\n\n# 参考资料\n\nhttps://www.cnblogs.com/molao-doing/articles/6557305.html","slug":"oyr/MQ/JMS","published":1,"updated":"2021-09-01T02:48:43.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l835z000jhct7dp206vwl","content":"<h1 id=\"JMS是什么\"><a href=\"#JMS是什么\" class=\"headerlink\" title=\"JMS是什么\"></a>JMS是什么</h1><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>\n<p>JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JMS体系架构\"><a href=\"#JMS体系架构\" class=\"headerlink\" title=\"JMS体系架构\"></a>JMS体系架构</h1><p>JMS由以下元素组成。</p>\n<p>1）JMS提供者<br>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p>\n<p>2）JMS客户<br>生产或消费消息的基于Java的应用程序或对象。</p>\n<p>3）JMS生产者<br>创建并发送消息的JMS客户。</p>\n<p>4）JMS消费者<br>接收消息的JMS客户。</p>\n<p>5）JMS消息<br>包括可以在JMS客户之间传递的数据的对象</p>\n<p>6）JMS队列<br>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p>\n<p>7）JMS主题<br>一种支持发送消息给多个订阅者的机制。</p>\n<h1 id=\"JMS消息模型\"><a href=\"#JMS消息模型\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h1><h2 id=\"JMS消息模型-1\"><a href=\"#JMS消息模型-1\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h2><p>1）Point-to-Point(P2P)<br>2）Publish/Subscribe(Pub/Sub)</p>\n<p>在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。</p>\n<h2 id=\"P2P（点对点）\"><a href=\"#P2P（点对点）\" class=\"headerlink\" title=\"P2P（点对点）\"></a>P2P（点对点）</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/397872-20170315231815541-1387998695.jpeg\" alt=\"P2P模式\"></p>\n<h3 id=\"涉及的概念\"><a href=\"#涉及的概念\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）消息队列(Queue)<br>2）提供者(Sender)<br>3）消费者(Receiver)<br>4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<h3 id=\"P2P的特点\"><a href=\"#P2P的特点\" class=\"headerlink\" title=\"P2P的特点\"></a>P2P的特点</h3><p>1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列<br>3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。<br>4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。<br>5）消费者在成功接收消息之后需向队列应答成功  </p>\n<p><strong>注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</strong></p>\n<h2 id=\"Pub-Sub（发布-订阅模式）\"><a href=\"#Pub-Sub（发布-订阅模式）\" class=\"headerlink\" title=\"Pub/Sub（发布/订阅模式）\"></a>Pub/Sub（发布/订阅模式）</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/\" alt=\"Pub/Sub模式\"></p>\n<h3 id=\"涉及的概念-1\"><a href=\"#涉及的概念-1\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）主题（Topic）<br>2）发布者（Publisher）<br>3）订阅者（Subscriber）<br>4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<h3 id=\"Pub-Sub的特点\"><a href=\"#Pub-Sub的特点\" class=\"headerlink\" title=\"Pub/Sub的特点\"></a>Pub/Sub的特点</h3><p>1）每个消息可以有多个消费者。<br>2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。<br>3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。<br>4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。<br>5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。<br>6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。</p>\n<p><strong>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</strong></p>\n<h1 id=\"JMS-应用程序接口\"><a href=\"#JMS-应用程序接口\" class=\"headerlink\" title=\"JMS 应用程序接口\"></a>JMS 应用程序接口</h1><ol>\n<li>ConnectionFactory 接口(连接工厂)<ul>\n<li>创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂</li>\n<li>分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</li>\n</ul>\n</li>\n<li>Destination 接口(目标)<ul>\n<li>Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。</li>\n<li>是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;</li>\n<li>对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</li>\n<li>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</li>\n</ul>\n</li>\n<li>Connection 接口(连接)<ul>\n<li>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。</li>\n<li>Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</li>\n</ul>\n</li>\n<li>Session 接口(会话)<ul>\n<li>Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。</li>\n<li>由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。</li>\n<li>可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。</li>\n<li>同样，也分QueueSession和TopicSession。</li>\n</ul>\n</li>\n<li>MessageProducer 接口(消息的生产者)<ul>\n<li>消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。</li>\n<li>同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</li>\n</ul>\n</li>\n<li>MessageConsumer 接口(消息消费者)<ul>\n<li>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。</li>\n<li>可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。</li>\n<li>当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</li>\n</ul>\n</li>\n<li>Message 接口（消息）<ul>\n<li>是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。</li>\n<li>一个消息有三个主要部分：<ul>\n<li>1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。</li>\n<li>2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。</li>\n<li>3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>MessageListener<ul>\n<li>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。</li>\n<li>EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/20170215230025420.png\" alt=\"JMS 应用程序接口\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/molao-doing/articles/6557305.html\">https://www.cnblogs.com/molao-doing/articles/6557305.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JMS是什么\"><a href=\"#JMS是什么\" class=\"headerlink\" title=\"JMS是什么\"></a>JMS是什么</h1><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM，Message oriented Middleware）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>\n<p>JMS允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>","more":"<h1 id=\"JMS体系架构\"><a href=\"#JMS体系架构\" class=\"headerlink\" title=\"JMS体系架构\"></a>JMS体系架构</h1><p>JMS由以下元素组成。</p>\n<p>1）JMS提供者<br>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</p>\n<p>2）JMS客户<br>生产或消费消息的基于Java的应用程序或对象。</p>\n<p>3）JMS生产者<br>创建并发送消息的JMS客户。</p>\n<p>4）JMS消费者<br>接收消息的JMS客户。</p>\n<p>5）JMS消息<br>包括可以在JMS客户之间传递的数据的对象</p>\n<p>6）JMS队列<br>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</p>\n<p>7）JMS主题<br>一种支持发送消息给多个订阅者的机制。</p>\n<h1 id=\"JMS消息模型\"><a href=\"#JMS消息模型\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h1><h2 id=\"JMS消息模型-1\"><a href=\"#JMS消息模型-1\" class=\"headerlink\" title=\"JMS消息模型\"></a>JMS消息模型</h2><p>1）Point-to-Point(P2P)<br>2）Publish/Subscribe(Pub/Sub)</p>\n<p>在JMS API出现之前，大部分产品使用“点对点”和“发布/订阅”中的任一方式来进行消息通讯。JMS定义了这两种消息发送模型的规范，它们相互独立。任何JMS的提供者可以实现其中的一种或两种模型，这是它们自己的选择。JMS规范提供了通用接口保证我们基于JMS API编写的程序适用于任何一种模型。</p>\n<h2 id=\"P2P（点对点）\"><a href=\"#P2P（点对点）\" class=\"headerlink\" title=\"P2P（点对点）\"></a>P2P（点对点）</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/397872-20170315231815541-1387998695.jpeg\" alt=\"P2P模式\"></p>\n<h3 id=\"涉及的概念\"><a href=\"#涉及的概念\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）消息队列(Queue)<br>2）提供者(Sender)<br>3）消费者(Receiver)<br>4）每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<h3 id=\"P2P的特点\"><a href=\"#P2P的特点\" class=\"headerlink\" title=\"P2P的特点\"></a>P2P的特点</h3><p>1）每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>2）提供者和消费者之间在时间上没有依赖性，也就是说当提供者发送了消息之后，不管消费者有没有正在运行，它不会影响到消息被发送到队列<br>3）每条消息仅会传送给一个消费者。可能会有多个消费者在一个队列中侦听，但是每个队列中的消息只能被队列中的一个消费者所消费。<br>4）消息存在先后顺序。一个队列会按照消息服务器将消息放入队列中的顺序，把它们传送给消费者。当已被消费时，就会从队列头部将它们删除（除非使用了消息优先级）。<br>5）消费者在成功接收消息之后需向队列应答成功  </p>\n<p><strong>注意：如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</strong></p>\n<h2 id=\"Pub-Sub（发布-订阅模式）\"><a href=\"#Pub-Sub（发布-订阅模式）\" class=\"headerlink\" title=\"Pub/Sub（发布/订阅模式）\"></a>Pub/Sub（发布/订阅模式）</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/\" alt=\"Pub/Sub模式\"></p>\n<h3 id=\"涉及的概念-1\"><a href=\"#涉及的概念-1\" class=\"headerlink\" title=\"涉及的概念\"></a>涉及的概念</h3><p>1）主题（Topic）<br>2）发布者（Publisher）<br>3）订阅者（Subscriber）<br>4）客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<h3 id=\"Pub-Sub的特点\"><a href=\"#Pub-Sub的特点\" class=\"headerlink\" title=\"Pub/Sub的特点\"></a>Pub/Sub的特点</h3><p>1）每个消息可以有多个消费者。<br>2）发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。<br>3）为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。<br>4）每条消息都会传送给称为订阅者的多个消息消费者。订阅者有许多类型，包括持久型、非持久型和动态型。<br>5）发布者通常不会知道、也意识不到哪一个订阅者正在接收主题消息。<br>6）消息被推送给消费者，这意味着消息会传送给消费者，而无须请求。</p>\n<p><strong>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</strong></p>\n<h1 id=\"JMS-应用程序接口\"><a href=\"#JMS-应用程序接口\" class=\"headerlink\" title=\"JMS 应用程序接口\"></a>JMS 应用程序接口</h1><ol>\n<li>ConnectionFactory 接口(连接工厂)<ul>\n<li>创建Connection对象的工厂，根据消息类型的不同，用户将使用队列连接工厂，或者主题连接工厂</li>\n<li>分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</li>\n</ul>\n</li>\n<li>Destination 接口(目标)<ul>\n<li>Destination是一个包装了消息目标标识符的被管对象，消息目标是指消息发布和接收的地点，或者是队列，或者是主题。</li>\n<li>是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;</li>\n<li>对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</li>\n<li>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</li>\n</ul>\n</li>\n<li>Connection 接口(连接)<ul>\n<li>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。</li>\n<li>Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</li>\n</ul>\n</li>\n<li>Session 接口(会话)<ul>\n<li>Session是我们操作消息的接口。表示一个单线程的上下文，用于发送和接收消息。</li>\n<li>由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。</li>\n<li>可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。</li>\n<li>同样，也分QueueSession和TopicSession。</li>\n</ul>\n</li>\n<li>MessageProducer 接口(消息的生产者)<ul>\n<li>消息生产者由Session创建，并用于将消息发送到Destination。消费者可以同步地（阻塞模式），或异步（非阻塞）接收队列和主题类型的消息。</li>\n<li>同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</li>\n</ul>\n</li>\n<li>MessageConsumer 接口(消息消费者)<ul>\n<li>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。</li>\n<li>可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。</li>\n<li>当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</li>\n</ul>\n</li>\n<li>Message 接口（消息）<ul>\n<li>是在消费者和生产者之间传送的对象，也就是说从一个应用程序创送到另一个应用程序。</li>\n<li>一个消息有三个主要部分：<ul>\n<li>1、消息头（必须）：包含用于识别和为消息寻找路由的操作设置。</li>\n<li>2、一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。</li>\n<li>3、一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>消息接口非常灵活，并提供了许多方式来定制消息的内容。</li>\n</ul>\n</li>\n<li>MessageListener<ul>\n<li>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。</li>\n<li>EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/jms/20170215230025420.png\" alt=\"JMS 应用程序接口\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cnblogs.com/molao-doing/articles/6557305.html\">https://www.cnblogs.com/molao-doing/articles/6557305.html</a></p>"},{"title":"Kafka","date":"2021-07-08T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/MQ/Kafka.md","raw":"---\ntitle: Kafka\ndate: 2021-07-09 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: MQ\ntags: \n    - MQ\n    - 中间件\n---\n","slug":"oyr/MQ/Kafka","published":1,"updated":"2021-07-13T09:49:41.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l8360000khct776qn11mw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RabbitMQ","date":"2021-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# RabbitMQ下载与安装\n\n## Linux下安装\n\n### 环境准备\n\n环境相关：  \nlinux（CentOS 7.5）  \nerlang 22.x  \nrabbitmq 3.7.18\n\n<!-- more -->\n\nErlang rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\n\nRabbitmq rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\n\n### 安装Erlang\n\n![erlang版本信息](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang版本.png)   \n下载erlang时需要注意，要和rabbitmq版本兼容.\n\n1）erlang rpm下载：\nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\nerlang-22.0.7-1.el7.x86_64.rpm\n\n2）rpm上传到系统中，安装erlang \nrpm -Uvh erlang-solutions-2.0-1.noarch.rpm \nyum install -y erlang\n\n3）查看erlang版本\nerl -v  \n![erlang版本](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang查看版本.png)   \n显示这样代表安装成功\n\n### 安装socat\n\n安装Erlang后直接安装RabbitMQ，需要安装socat。\n\n安装socat：  \nyum install -y socat\n\n### 安装RabbitMQ\n\n1）rabbitmq rpm下载  \nhttps://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\nrabbitmq-server-3.7.18-1.el7.noarch.rpm \n\n2）rpm上传到系统中，并安装rabbitmq   \nrpm -Uvh rabbitmq-server-3.7.18-1.el7.noarch.rpm   \nyum install rabbitmq-server -y\n\n3）启动服务并测试  \n启动服务：  \nsystemctl start rabbitmq-server \n\n查看服务状态，如图：  \nsystemctl status rabbitmq-server.service \n\n4）常用命令\n```\n# 启动服务 \nsystemctl start rabbitmq-server \n\n# 查看服务状态\nsystemctl status rabbitmq-server.service \n\n# 开机自启动 \nsystemctl enable rabbitmq-server \n\n# 停止服务 \nsystemctl stop rabbitmq-server\n```\n\n## Windos下安装\n\n## Mac下安装\n\n# RabbitMQ管理界面\n\n# 入门案例\n\n## 快速入门（hello world）\n\n实现功能：  \n1）生产者发送消息，也就是要发送消息的程序  \n2）消费者消费消息，会一直等待消息到来。  \n3）mq接受到消息后，发送给消费者\n\n如图：  \n![快速入门图](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/快速入门图.png)\n\n### 环境准备\n\n在学习RabbitMQ前必须掌握以下内容：  \n熟悉使用Java  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具  \n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nRabbitMQ 3.7.18\n\n### 创建一个Maven工程\n\n这里就不演示了，设置maven工程打包方式为jar包。\n\n### 导入依赖\n\npom.xml 导入依赖\n```xml\n```\n\n### 生产者发布消息\n\n### 消费者消费消息（监听并消费消息）\n\n### 启动测试\n\n\n# RabbitMQ消息模型\n\n## 简介\n\nRabbitMQ提供了6种消息模型。但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。但其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。\n\n![消息模型](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/消息模型.png)\n\n1）基本消息模式  \n2）工作模式  \n3）发布订阅模式  \n4）路由模式  \n5）主题模式  \n6）RPC模式\n\n## 基本模式\n\n## 工作模式\n\n## 订阅模式-Direct\n\n## 订阅模式-Fanout\n\n## 订阅模式-Topic\n\n# 整合SpringBoot\n\n## 订阅模式-Direct \n\n## 订阅模式-Fanout\n\n## 订阅模式-Topic\n\nRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。\n\nRabbitMQ官方地址：\nhttp://www.rabbitmq.com\n\nRabbitMQ是一个开源的遵循 AMQP协议实现的基于 Erlang语言编写，支持多种客户端（语言），用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征入门及安装。","source":"_posts/oyr/MQ/RabbitMQ.md","raw":"---\ntitle: RabbitMQ\ndate: 2021-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MQ\ntags: \n    - oyr-MQ\n    - 中间件\n---\n\n# RabbitMQ下载与安装\n\n## Linux下安装\n\n### 环境准备\n\n环境相关：  \nlinux（CentOS 7.5）  \nerlang 22.x  \nrabbitmq 3.7.18\n\n<!-- more -->\n\nErlang rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\n\nRabbitmq rpm下载：  \nhttps://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\n\n### 安装Erlang\n\n![erlang版本信息](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang版本.png)   \n下载erlang时需要注意，要和rabbitmq版本兼容.\n\n1）erlang rpm下载：\nhttps://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\nerlang-22.0.7-1.el7.x86_64.rpm\n\n2）rpm上传到系统中，安装erlang \nrpm -Uvh erlang-solutions-2.0-1.noarch.rpm \nyum install -y erlang\n\n3）查看erlang版本\nerl -v  \n![erlang版本](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang查看版本.png)   \n显示这样代表安装成功\n\n### 安装socat\n\n安装Erlang后直接安装RabbitMQ，需要安装socat。\n\n安装socat：  \nyum install -y socat\n\n### 安装RabbitMQ\n\n1）rabbitmq rpm下载  \nhttps://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\nrabbitmq-server-3.7.18-1.el7.noarch.rpm \n\n2）rpm上传到系统中，并安装rabbitmq   \nrpm -Uvh rabbitmq-server-3.7.18-1.el7.noarch.rpm   \nyum install rabbitmq-server -y\n\n3）启动服务并测试  \n启动服务：  \nsystemctl start rabbitmq-server \n\n查看服务状态，如图：  \nsystemctl status rabbitmq-server.service \n\n4）常用命令\n```\n# 启动服务 \nsystemctl start rabbitmq-server \n\n# 查看服务状态\nsystemctl status rabbitmq-server.service \n\n# 开机自启动 \nsystemctl enable rabbitmq-server \n\n# 停止服务 \nsystemctl stop rabbitmq-server\n```\n\n## Windos下安装\n\n## Mac下安装\n\n# RabbitMQ管理界面\n\n# 入门案例\n\n## 快速入门（hello world）\n\n实现功能：  \n1）生产者发送消息，也就是要发送消息的程序  \n2）消费者消费消息，会一直等待消息到来。  \n3）mq接受到消息后，发送给消费者\n\n如图：  \n![快速入门图](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/快速入门图.png)\n\n### 环境准备\n\n在学习RabbitMQ前必须掌握以下内容：  \n熟悉使用Java  \n熟悉使用Maven进行项目构建和依赖管理  \n熟练使用eclipse或Idea开发工具  \n\n环境约束：  \nJdk8  \nMaven3.x  \nIdea2019  \nRabbitMQ 3.7.18\n\n### 创建一个Maven工程\n\n这里就不演示了，设置maven工程打包方式为jar包。\n\n### 导入依赖\n\npom.xml 导入依赖\n```xml\n```\n\n### 生产者发布消息\n\n### 消费者消费消息（监听并消费消息）\n\n### 启动测试\n\n\n# RabbitMQ消息模型\n\n## 简介\n\nRabbitMQ提供了6种消息模型。但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。但其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。\n\n![消息模型](https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/消息模型.png)\n\n1）基本消息模式  \n2）工作模式  \n3）发布订阅模式  \n4）路由模式  \n5）主题模式  \n6）RPC模式\n\n## 基本模式\n\n## 工作模式\n\n## 订阅模式-Direct\n\n## 订阅模式-Fanout\n\n## 订阅模式-Topic\n\n# 整合SpringBoot\n\n## 订阅模式-Direct \n\n## 订阅模式-Fanout\n\n## 订阅模式-Topic\n\nRabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。\n\nRabbitMQ官方地址：\nhttp://www.rabbitmq.com\n\nRabbitMQ是一个开源的遵循 AMQP协议实现的基于 Erlang语言编写，支持多种客户端（语言），用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征入门及安装。","slug":"oyr/MQ/RabbitMQ","published":1,"updated":"2021-09-01T02:48:57.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l8361000ohct7fy18e9mp","content":"<h1 id=\"RabbitMQ下载与安装\"><a href=\"#RabbitMQ下载与安装\" class=\"headerlink\" title=\"RabbitMQ下载与安装\"></a>RabbitMQ下载与安装</h1><h2 id=\"Linux下安装\"><a href=\"#Linux下安装\" class=\"headerlink\" title=\"Linux下安装\"></a>Linux下安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>环境相关：<br>linux（CentOS 7.5）<br>erlang 22.x<br>rabbitmq 3.7.18</p>\n<span id=\"more\"></span>\n\n<p>Erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18</a></p>\n<p>Rabbitmq rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\">https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3</a></p>\n<h3 id=\"安装Erlang\"><a href=\"#安装Erlang\" class=\"headerlink\" title=\"安装Erlang\"></a>安装Erlang</h3><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本信息\"><br>下载erlang时需要注意，要和rabbitmq版本兼容.</p>\n<p>1）erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18</a><br>erlang-22.0.7-1.el7.x86_64.rpm</p>\n<p>2）rpm上传到系统中，安装erlang<br>rpm -Uvh erlang-solutions-2.0-1.noarch.rpm<br>yum install -y erlang</p>\n<p>3）查看erlang版本<br>erl -v<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本\"><br>显示这样代表安装成功</p>\n<h3 id=\"安装socat\"><a href=\"#安装socat\" class=\"headerlink\" title=\"安装socat\"></a>安装socat</h3><p>安装Erlang后直接安装RabbitMQ，需要安装socat。</p>\n<p>安装socat：<br>yum install -y socat</p>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><p>1）rabbitmq rpm下载<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\">https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3</a><br>rabbitmq-server-3.7.18-1.el7.noarch.rpm </p>\n<p>2）rpm上传到系统中，并安装rabbitmq<br>rpm -Uvh rabbitmq-server-3.7.18-1.el7.noarch.rpm<br>yum install rabbitmq-server -y</p>\n<p>3）启动服务并测试<br>启动服务：<br>systemctl start rabbitmq-server </p>\n<p>查看服务状态，如图：<br>systemctl status rabbitmq-server.service </p>\n<p>4）常用命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启动服务 </span><br><span class=\"line\">systemctl start rabbitmq-server </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">systemctl status rabbitmq-server.service </span><br><span class=\"line\"></span><br><span class=\"line\"># 开机自启动 </span><br><span class=\"line\">systemctl enable rabbitmq-server </span><br><span class=\"line\"></span><br><span class=\"line\"># 停止服务 </span><br><span class=\"line\">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Windos下安装\"><a href=\"#Windos下安装\" class=\"headerlink\" title=\"Windos下安装\"></a>Windos下安装</h2><h2 id=\"Mac下安装\"><a href=\"#Mac下安装\" class=\"headerlink\" title=\"Mac下安装\"></a>Mac下安装</h2><h1 id=\"RabbitMQ管理界面\"><a href=\"#RabbitMQ管理界面\" class=\"headerlink\" title=\"RabbitMQ管理界面\"></a>RabbitMQ管理界面</h1><h1 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h1><h2 id=\"快速入门（hello-world）\"><a href=\"#快速入门（hello-world）\" class=\"headerlink\" title=\"快速入门（hello world）\"></a>快速入门（hello world）</h2><p>实现功能：<br>1）生产者发送消息，也就是要发送消息的程序<br>2）消费者消费消息，会一直等待消息到来。<br>3）mq接受到消息后，发送给消费者</p>\n<p>如图：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%9B%BE.png\" alt=\"快速入门图\"></p>\n<h3 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>在学习RabbitMQ前必须掌握以下内容：<br>熟悉使用Java<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具  </p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>RabbitMQ 3.7.18</p>\n<h3 id=\"创建一个Maven工程\"><a href=\"#创建一个Maven工程\" class=\"headerlink\" title=\"创建一个Maven工程\"></a>创建一个Maven工程</h3><p>这里就不演示了，设置maven工程打包方式为jar包。</p>\n<h3 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h3><p>pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者发布消息\"><a href=\"#生产者发布消息\" class=\"headerlink\" title=\"生产者发布消息\"></a>生产者发布消息</h3><h3 id=\"消费者消费消息（监听并消费消息）\"><a href=\"#消费者消费消息（监听并消费消息）\" class=\"headerlink\" title=\"消费者消费消息（监听并消费消息）\"></a>消费者消费消息（监听并消费消息）</h3><h3 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h3><h1 id=\"RabbitMQ消息模型\"><a href=\"#RabbitMQ消息模型\" class=\"headerlink\" title=\"RabbitMQ消息模型\"></a>RabbitMQ消息模型</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitMQ提供了6种消息模型。但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。但其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.png\" alt=\"消息模型\"></p>\n<p>1）基本消息模式<br>2）工作模式<br>3）发布订阅模式<br>4）路由模式<br>5）主题模式<br>6）RPC模式</p>\n<h2 id=\"基本模式\"><a href=\"#基本模式\" class=\"headerlink\" title=\"基本模式\"></a>基本模式</h2><h2 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h2><h2 id=\"订阅模式-Direct\"><a href=\"#订阅模式-Direct\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h2><h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h2 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><h1 id=\"整合SpringBoot\"><a href=\"#整合SpringBoot\" class=\"headerlink\" title=\"整合SpringBoot\"></a>整合SpringBoot</h1><h2 id=\"订阅模式-Direct-1\"><a href=\"#订阅模式-Direct-1\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h2><h2 id=\"订阅模式-Fanout-1\"><a href=\"#订阅模式-Fanout-1\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h2 id=\"订阅模式-Topic-1\"><a href=\"#订阅模式-Topic-1\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p>\n<p>RabbitMQ官方地址：<br><a href=\"http://www.rabbitmq.com/\">http://www.rabbitmq.com</a></p>\n<p>RabbitMQ是一个开源的遵循 AMQP协议实现的基于 Erlang语言编写，支持多种客户端（语言），用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征入门及安装。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RabbitMQ下载与安装\"><a href=\"#RabbitMQ下载与安装\" class=\"headerlink\" title=\"RabbitMQ下载与安装\"></a>RabbitMQ下载与安装</h1><h2 id=\"Linux下安装\"><a href=\"#Linux下安装\" class=\"headerlink\" title=\"Linux下安装\"></a>Linux下安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>环境相关：<br>linux（CentOS 7.5）<br>erlang 22.x<br>rabbitmq 3.7.18</p>","more":"<p>Erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18</a></p>\n<p>Rabbitmq rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\">https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3</a></p>\n<h3 id=\"安装Erlang\"><a href=\"#安装Erlang\" class=\"headerlink\" title=\"安装Erlang\"></a>安装Erlang</h3><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本信息\"><br>下载erlang时需要注意，要和rabbitmq版本兼容.</p>\n<p>1）erlang rpm下载：<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18\">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.18</a><br>erlang-22.0.7-1.el7.x86_64.rpm</p>\n<p>2）rpm上传到系统中，安装erlang<br>rpm -Uvh erlang-solutions-2.0-1.noarch.rpm<br>yum install -y erlang</p>\n<p>3）查看erlang版本<br>erl -v<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/erlang%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png\" alt=\"erlang版本\"><br>显示这样代表安装成功</p>\n<h3 id=\"安装socat\"><a href=\"#安装socat\" class=\"headerlink\" title=\"安装socat\"></a>安装socat</h3><p>安装Erlang后直接安装RabbitMQ，需要安装socat。</p>\n<p>安装socat：<br>yum install -y socat</p>\n<h3 id=\"安装RabbitMQ\"><a href=\"#安装RabbitMQ\" class=\"headerlink\" title=\"安装RabbitMQ\"></a>安装RabbitMQ</h3><p>1）rabbitmq rpm下载<br><a href=\"https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3\">https://github.com/rabbitmq/rabbitmq-server/tags?after=v3.8.0-rc.3</a><br>rabbitmq-server-3.7.18-1.el7.noarch.rpm </p>\n<p>2）rpm上传到系统中，并安装rabbitmq<br>rpm -Uvh rabbitmq-server-3.7.18-1.el7.noarch.rpm<br>yum install rabbitmq-server -y</p>\n<p>3）启动服务并测试<br>启动服务：<br>systemctl start rabbitmq-server </p>\n<p>查看服务状态，如图：<br>systemctl status rabbitmq-server.service </p>\n<p>4）常用命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启动服务 </span><br><span class=\"line\">systemctl start rabbitmq-server </span><br><span class=\"line\"></span><br><span class=\"line\"># 查看服务状态</span><br><span class=\"line\">systemctl status rabbitmq-server.service </span><br><span class=\"line\"></span><br><span class=\"line\"># 开机自启动 </span><br><span class=\"line\">systemctl enable rabbitmq-server </span><br><span class=\"line\"></span><br><span class=\"line\"># 停止服务 </span><br><span class=\"line\">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Windos下安装\"><a href=\"#Windos下安装\" class=\"headerlink\" title=\"Windos下安装\"></a>Windos下安装</h2><h2 id=\"Mac下安装\"><a href=\"#Mac下安装\" class=\"headerlink\" title=\"Mac下安装\"></a>Mac下安装</h2><h1 id=\"RabbitMQ管理界面\"><a href=\"#RabbitMQ管理界面\" class=\"headerlink\" title=\"RabbitMQ管理界面\"></a>RabbitMQ管理界面</h1><h1 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h1><h2 id=\"快速入门（hello-world）\"><a href=\"#快速入门（hello-world）\" class=\"headerlink\" title=\"快速入门（hello world）\"></a>快速入门（hello world）</h2><p>实现功能：<br>1）生产者发送消息，也就是要发送消息的程序<br>2）消费者消费消息，会一直等待消息到来。<br>3）mq接受到消息后，发送给消费者</p>\n<p>如图：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%9B%BE.png\" alt=\"快速入门图\"></p>\n<h3 id=\"环境准备-1\"><a href=\"#环境准备-1\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>在学习RabbitMQ前必须掌握以下内容：<br>熟悉使用Java<br>熟悉使用Maven进行项目构建和依赖管理<br>熟练使用eclipse或Idea开发工具  </p>\n<p>环境约束：<br>Jdk8<br>Maven3.x<br>Idea2019<br>RabbitMQ 3.7.18</p>\n<h3 id=\"创建一个Maven工程\"><a href=\"#创建一个Maven工程\" class=\"headerlink\" title=\"创建一个Maven工程\"></a>创建一个Maven工程</h3><p>这里就不演示了，设置maven工程打包方式为jar包。</p>\n<h3 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h3><p>pom.xml 导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者发布消息\"><a href=\"#生产者发布消息\" class=\"headerlink\" title=\"生产者发布消息\"></a>生产者发布消息</h3><h3 id=\"消费者消费消息（监听并消费消息）\"><a href=\"#消费者消费消息（监听并消费消息）\" class=\"headerlink\" title=\"消费者消费消息（监听并消费消息）\"></a>消费者消费消息（监听并消费消息）</h3><h3 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h3><h1 id=\"RabbitMQ消息模型\"><a href=\"#RabbitMQ消息模型\" class=\"headerlink\" title=\"RabbitMQ消息模型\"></a>RabbitMQ消息模型</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>RabbitMQ提供了6种消息模型。但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。但其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/RabbitMQ/%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.png\" alt=\"消息模型\"></p>\n<p>1）基本消息模式<br>2）工作模式<br>3）发布订阅模式<br>4）路由模式<br>5）主题模式<br>6）RPC模式</p>\n<h2 id=\"基本模式\"><a href=\"#基本模式\" class=\"headerlink\" title=\"基本模式\"></a>基本模式</h2><h2 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h2><h2 id=\"订阅模式-Direct\"><a href=\"#订阅模式-Direct\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h2><h2 id=\"订阅模式-Fanout\"><a href=\"#订阅模式-Fanout\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h2 id=\"订阅模式-Topic\"><a href=\"#订阅模式-Topic\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><h1 id=\"整合SpringBoot\"><a href=\"#整合SpringBoot\" class=\"headerlink\" title=\"整合SpringBoot\"></a>整合SpringBoot</h1><h2 id=\"订阅模式-Direct-1\"><a href=\"#订阅模式-Direct-1\" class=\"headerlink\" title=\"订阅模式-Direct\"></a>订阅模式-Direct</h2><h2 id=\"订阅模式-Fanout-1\"><a href=\"#订阅模式-Fanout-1\" class=\"headerlink\" title=\"订阅模式-Fanout\"></a>订阅模式-Fanout</h2><h2 id=\"订阅模式-Topic-1\"><a href=\"#订阅模式-Topic-1\" class=\"headerlink\" title=\"订阅模式-Topic\"></a>订阅模式-Topic</h2><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p>\n<p>RabbitMQ官方地址：<br><a href=\"http://www.rabbitmq.com/\">http://www.rabbitmq.com</a></p>\n<p>RabbitMQ是一个开源的遵循 AMQP协议实现的基于 Erlang语言编写，支持多种客户端（语言），用于在分布式系统中存储消息，转发消息，具有高可用，高可扩性，易用性等特征入门及安装。</p>"},{"title":"消息中间件入门与简介","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://kubpang.gitee.io/sourceFile/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### JMS协议\n\nJMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。\n\n特性：  \n1）可靠的消息处理  \n2）消息的持久化支持  \n3）跨平台跨语言支持差\n\n支持MQ：ActiveMQ\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://kubpang.gitee.io/sourceFile/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://kubpang.gitee.io/sourceFile/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://kubpang.gitee.io/sourceFile/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://kubpang.gitee.io/sourceFile/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://kubpang.gitee.io/sourceFile/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://kubpang.gitee.io/sourceFile/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","source":"_posts/oyr/MQ/消息中间件入门与简介.md","raw":"---\ntitle: 消息中间件入门与简介\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ntags: oyr-MQ\ncategories: oyr-MQ\n---\n\n# 什么是中间件\n\n## 什么是中间件\n\n我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。\n\n中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来\n\n***\n\n<!-- more -->\n\n## 中间件特点\n\n为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。\n\n![中间件特点](https://kubpang.gitee.io/sourceFile/MQ/中间件特点.png)\n\n也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：  \n（1）满足大量应用的需要  \n（2）运行于多种硬件和 OS平台  \n（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互  \n（4）支持标准的协议  \n（5）支持标准的接口\n\n由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。\n\n简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。\n\n***\n\n## 常见中间件\n\n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/常见中间件.png)\n\n***\n\n## 学习中间件的方式和技巧\n\n1）理解中间件在项目架构中的作用，以及各中间件的底层实现  \n2）可以使用一些类比的生活概念去理解中间件  \n3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用  \n4）尝试用 java技术去实现中间件的原理  \n5）静下来去思考中间件在项目中设计的和使用的原因  \n6）如果找到对应的代替总结方案  \n7）尝试编写博文总结类同中间件技术的对比和使用场景  \n8）学会查看中间件的源码以及开源项目和博文\n\n***\n\n# 什么是消息中间件\n\n## 什么是消息中间件\n\n消息中间件：\n是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。\n\n***\n\n## 为什么需要使用消息中间件\n具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。\n\n***\n\n## 消息中间件功能与组成\n\n### 功能\n\n消息中间件：\n是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。\n\nMQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq消息队列图解1.png)\n\n谁来生产消息，存储消息和消费消息呢？  \n生产者生产消息，MQ存储消息，消费者消费消息  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq消息队列图解2.png)\n\n### 核心组成部分\n\n消息中间件的核心组成部分：  \n消息的协议   \n消息的持久化机制   \n消息的分发策略   \n消息的高可用  \n高可靠消息的容错机制\n\n\n## 消息中间件应用场景\n\n参考：https://www.jianshu.com/p/3fed7e963a2d\n\n***\n\n### 异步通信\n\n异步通信：（异步处理）    \n当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。\n\n案例讲解：  \n假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/并行执行.png)\n\n生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。\n\n按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。  \n过程如下图所示：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/异步执行.png)\n\n### 系统解耦\n\n系统解耦：降低系统之间的耦合度。\n\n案例讲解：\n首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统耦合.png)\n\n那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统耦合2.png)\n\n我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/系统解耦.png)\n\n### 流量削峰\n\n流量消峰：\n针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.\n\n案例讲解：\n假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰1.png)\n\n那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰2.png)\n\n但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：  \n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/流量削峰3.png)\n\n## 常见的消息中间件\n\nActiveMQ，RabbitMQ，Kafka，RocketMQ\n\n***\n\n# 消息队列协议\n\n## 什么是协议\n\n![常见中间件](https://kubpang.gitee.io/sourceFile/MQ/mq协议.png)\n\n所谓协议是指：  \n1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流  \n2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高  \n3）协议对数据格式和计算机之间交换数据都必须严格遵守规范\n\n***\n\n## 网络协议的三要素\n\n1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序  \n2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应  \n3）时序：时序是对事件发生顺序的详细说明\n\n比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：  \n1）语法：http规定了请求报文和响应报文的格式  \n2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）  \n3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）\n\n***\n\n## 常见的消息中间件协议\n\n消息中间件采用的不是 http协议。  \n常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议\n\n***\n\n### JMS协议\n\nJMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。\n\n特性：  \n1）可靠的消息处理  \n2）消息的持久化支持  \n3）跨平台跨语言支持差\n\n支持MQ：ActiveMQ\n\n### AMQP协议\n\nAMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n\n特性：  \n1）分布式事务支持  \n2）消息的持久化支持  \n3）高性能和高可靠的消息处理优势\n\n支持MQ：RabbitMQ\n\n### MQTT协议\n\nMQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。\n\n特点：  \n1）轻量  \n2）结构简单  \n3）传输快，不支持事务  \n4）没有持久化设计\n\n支持MQ：RabbitMQ\n\n### Kafka协议\n\nKafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）无事务支持  \n4）有持久化设计\n\n代表MQ：Kafka\n\n### OpenMessage协议\n\nOpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。\n\n特点：  \n1）结构简单  \n2）解析速度快  \n3）支持事务和持久化设计\n\n支持MQ：RocketMQ\n\n## 为什么消息中间件不使用 http协议\n\n为什么消息中间件不使用 http协议？  \n1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速  \n2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。\n\n***\n\n# 消息队列持久化\n\n## 持久化\n\n简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。  \n![消息持久化图片](https://kubpang.gitee.io/sourceFile/MQ/消息持久化.png)\n\n***\n\n## 常见MQ的持久化方式\n\nActiveMQ：支持文件存储，支持数据库\n\nRabbitMQ & Kafka & RocketMQ：支持文件存储\n\n***\n\n# 消息的分发策略\n\n## 场景分析\n\n场景分析一：  \n![消息分发1](https://kubpang.gitee.io/sourceFile/MQ/消息分发1.png)  \n比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。\n\n场景分析二：  \n![消息分发2](https://kubpang.gitee.io/sourceFile/MQ/消息分发2.png)  \n在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。\n\n## 消息的分发策略\n\nMQ消息队列有如下几个角色  \n1）生产者  \n2）存储消息  \n3）消费者\n\n那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。\n\n![消息分发策略](https://kubpang.gitee.io/sourceFile/MQ/消息分发策略.png)  \n\n***\n\n# 消息队列高可用和高可靠\n\n## 什么是高可用机制\n\n所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力\n当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。\n\n### 集群模式一\n\nMaster-slave主从同步部署方式  \n![集群模式1](https://kubpang.gitee.io/sourceFile/MQ/集群模式一.png)  \n解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。\n\n### 集群模式二\n\nMaster-slave与 Broker-cluster组合的方案  \n![集群模式1](https://kubpang.gitee.io/sourceFile/MQ/集群模式二.png)  \n解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。\n\n**注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。**\n\n\n## 什么是高可靠机制\n\n所谓高可靠是指：  \n系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。\n\n如何保证中间件消息的可靠性呢，可以从两个方面考虑：  \n1）消息的传输：通过协议来保证系统间数据解析的正确性  \n2）消息的存储区可靠：通过持久化来保证消息的可靠性\n\n注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。","slug":"oyr/MQ/消息中间件入门与简介","published":1,"updated":"2021-09-01T02:48:06.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l8362000qhct76w4lagqa","content":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"JMS协议\"><a href=\"#JMS协议\" class=\"headerlink\" title=\"JMS协议\"></a>JMS协议</h3><p>JMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。</p>\n<p>特性：<br>1）可靠的消息处理<br>2）消息的持久化支持<br>3）跨平台跨语言支持差</p>\n<p>支持MQ：ActiveMQ</p>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是中间件\"><a href=\"#什么是中间件\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h1><h2 id=\"什么是中间件-1\"><a href=\"#什么是中间件-1\" class=\"headerlink\" title=\"什么是中间件\"></a>什么是中间件</h2><p>我国企业从20世纪80年代开始就逐渐进行信息化建设，由于方法和体系的不成熟，以及企业业务的市场需求的不断变化，一个企业可能同时运行着多个不同的业务系统，这些系统可能基于不同的操作系统、不同的数据库、异构的网络环境。现在的问题是，如何把这些信息系统结合成一个有机地协同工作的整体，真正实现企业跨平台、分布式应用。中间件便是解决之道，它用自己的复杂换取了企业应用的简单。</p>\n<p>中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。人们在使用中间件时，往往是一组中间件集成在一起，构成一个平台（包括开发平台和运行平台），但在这组中间件中必须要有一个通信中间件，即中间件+平台+通信，这个定义也限定了只有用于分布式系统中才能称为中间件，同时还可以把它与支撑软件和使用软件区分开来</p>\n<hr>","more":"<h2 id=\"中间件特点\"><a href=\"#中间件特点\" class=\"headerlink\" title=\"中间件特点\"></a>中间件特点</h2><p>为解决分布异构问题，人们提出了中间件（middleware)的概念。中间件是位于平台（硬件和操作系统）和应用之间的通用服务，如下图所示，这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口的协议规范的多种实现。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%89%B9%E7%82%B9.png\" alt=\"中间件特点\"></p>\n<p>也很难给中间件一个严格的定义，但中间件应具有如下的一些特点：<br>（1）满足大量应用的需要<br>（2）运行于多种硬件和 OS平台<br>（3）支持分布计算，提供跨网络、硬件和 OS平台的透明性的应用或服务的交互<br>（4）支持标准的协议<br>（5）支持标准的接口</p>\n<p>由于标准接口对于可移植性和标准协议对于互操作性的重要性，中间件已成为许多标准化工作的主要部分。对于应用软件开发，中间件远比操作系统和网络服务更为重要，中间件提供的程序接口定义了一个相对稳定的高层应用环境，不管底层的计算机硬件和系统软件怎样更新换代，只要将中间件升级更新，并保持中间件对外的接口定义不变，应用软件几乎不需任何修改，从而保护了企业在应用软件开发和维护中的重大投资。</p>\n<p>简单说：中间件有个很大的特点，是脱离于具体设计目标，而具备提供普遍独立功能需求的模块。这使得中间件一定是可替换的。如果一个系统设计中，中间件时不可替代的，不是架构、框架设计有问题，那么就是这个中间件，在别处可能是个中间件，在这个系统内是引擎。</p>\n<hr>\n<h2 id=\"常见中间件\"><a href=\"#常见中间件\" class=\"headerlink\" title=\"常见中间件\"></a>常见中间件</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6.png\" alt=\"常见中间件\"></p>\n<hr>\n<h2 id=\"学习中间件的方式和技巧\"><a href=\"#学习中间件的方式和技巧\" class=\"headerlink\" title=\"学习中间件的方式和技巧\"></a>学习中间件的方式和技巧</h2><p>1）理解中间件在项目架构中的作用，以及各中间件的底层实现<br>2）可以使用一些类比的生活概念去理解中间件<br>3）使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用<br>4）尝试用 java技术去实现中间件的原理<br>5）静下来去思考中间件在项目中设计的和使用的原因<br>6）如果找到对应的代替总结方案<br>7）尝试编写博文总结类同中间件技术的对比和使用场景<br>8）学会查看中间件的源码以及开源项目和博文</p>\n<hr>\n<h1 id=\"什么是消息中间件\"><a href=\"#什么是消息中间件\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h1><h2 id=\"什么是消息中间件-1\"><a href=\"#什么是消息中间件-1\" class=\"headerlink\" title=\"什么是消息中间件\"></a>什么是消息中间件</h2><p>消息中间件：<br>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信。</p>\n<hr>\n<h2 id=\"为什么需要使用消息中间件\"><a href=\"#为什么需要使用消息中间件\" class=\"headerlink\" title=\"为什么需要使用消息中间件\"></a>为什么需要使用消息中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担，中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>\n<hr>\n<h2 id=\"消息中间件功能与组成\"><a href=\"#消息中间件功能与组成\" class=\"headerlink\" title=\"消息中间件功能与组成\"></a>消息中间件功能与组成</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>消息中间件：<br>是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务。</p>\n<p>MQ消息队列：负责数据的接受，存储和传递，所以性能要高于普通服务和技术。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A31.png\" alt=\"常见中间件\"></p>\n<p>谁来生产消息，存储消息和消费消息呢？<br>生产者生产消息，MQ存储消息，消费者消费消息<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9B%BE%E8%A7%A32.png\" alt=\"常见中间件\"></p>\n<h3 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h3><p>消息中间件的核心组成部分：<br>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用<br>高可靠消息的容错机制</p>\n<h2 id=\"消息中间件应用场景\"><a href=\"#消息中间件应用场景\" class=\"headerlink\" title=\"消息中间件应用场景\"></a>消息中间件应用场景</h2><p>参考：<a href=\"https://www.jianshu.com/p/3fed7e963a2d\">https://www.jianshu.com/p/3fed7e963a2d</a></p>\n<hr>\n<h3 id=\"异步通信\"><a href=\"#异步通信\" class=\"headerlink\" title=\"异步通信\"></a>异步通信</h3><p>异步通信：（异步处理）<br>当有些业务不想也不需要立即处理，消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p>\n<p>案例讲解：<br>假设有一个系统调用链路为A调用B耗时20ms，B调用C耗时20ms，而C调用D需要2s，这样下来整个调用需要耗时2040ms。但实际上A调用B，B调用C只需要40ms，而D系统的引入直接导致系统性能下降约50倍。此时我们应该考虑将D系统的调用抽离出来，做一个异步调用。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<p>生活中有一个很形象的例子。我们点一杯奶茶，下单、付款、通知商家制作都很快，然而到匹配外卖小哥配送这个过程很慢。作为用户来说，匹配外卖小哥这个过程延迟一些时间是可以接受的，只要我能快速下单成功，并且在一定时间范围内安排快递小哥送货即可。</p>\n<p>按照上面的思路，系统A到系统B再到系统C就直接结束了，然后系统C再将消息发送到消息中间件中，系统D从消息中间件里取消息进行消费，这样子我们系统的性能就提高了接近50倍。<br>过程如下图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png\" alt=\"常见中间件\"></p>\n<h3 id=\"系统解耦\"><a href=\"#系统解耦\" class=\"headerlink\" title=\"系统解耦\"></a>系统解耦</h3><p>系统解耦：降低系统之间的耦合度。</p>\n<p>案例讲解：<br>首先假设有一个核心系统A，其能产生核心数据供下游服务（系统B和系统C）使用。此时最易想到的办法就是A直接把数据发送给B和C，流程如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，此时假设又有D、E、F、G等多个系统也需要使用核心数据，此时流程图如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%882.png\" alt=\"常见中间件\"></p>\n<p>我们可以想象一下，假设有上百个系统都需要系统A的核心数据，此时负责系统A的工程师将是崩溃的，一旦有系统加入，A系统就需要修改代码，将数据发送到新加入的系统。反之，如果有系统不再需要A发送数据，那么A系统又得修改代码不再向其发送数据。这样的架构设计耦合度太高了，我们就可以引入消息中间件来实现系统之间的解耦。即核心系统A生产核心数据，然后将核心数据发送到消息中间件，下游消费系统根据自身需求从中间件里获取消息进行消费，当不再需要数据时就不取消息进即可，这样系统之间耦合度就大大降低了。具体流程图如下：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6.png\" alt=\"常见中间件\"></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p>流量消峰：<br>针对某一时间段的大量用户访问产生的大量流量，进行延缓，层层过滤，遵从 “最后落地到数据库的请求数要尽量少”的原则.</p>\n<p>案例讲解：<br>假设有一个系统，正常时间也就每秒几百个请求，部署在一个8核16G的机器上，运行起来轻松加愉快。然而突然由于搞一个活动，高峰期请求数达到了几千，出现了瞬时流量高峰，此时最易想到的是加机器，部署个10台机器，也能扛住此时的高并发。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B01.png\" alt=\"常见中间件\"></p>\n<p>那么问题来了，瞬时流量每天也就那么几十分钟，过后就是正常的每秒几百请求，我们如果部署10台机器，那么平均下来没台机器的请求数也就每秒几十次，这样是不是有点太浪费资源了呢？大部分时候，每秒几百请求，一台机器就能够扛住了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那几十分钟有用，别的时候都是浪费资源的。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B02.png\" alt=\"常见中间件\"></p>\n<p>但是如果仅仅部署一台机器，瞬间高峰就会击垮系统，因为单台机器是不能扛住每秒几千次请求的。这时我们就可以考虑引入消息中间件，进行流量削峰。我们可以部署一层消息队列在机器前面，平时正常的每秒几百次请求，机器就正常的消费消息即可，一旦流量高峰到达时，大量消息会堆积在消息队列里面，机器只需要按照自己的最大负荷从消息队列里面消费，等流量高峰过了，慢慢地队列里面的消息也消费完毕了。此时达到了一个削峰填谷的作用。具体如图所示：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B03.png\" alt=\"常见中间件\"></p>\n<h2 id=\"常见的消息中间件\"><a href=\"#常见的消息中间件\" class=\"headerlink\" title=\"常见的消息中间件\"></a>常见的消息中间件</h2><p>ActiveMQ，RabbitMQ，Kafka，RocketMQ</p>\n<hr>\n<h1 id=\"消息队列协议\"><a href=\"#消息队列协议\" class=\"headerlink\" title=\"消息队列协议\"></a>消息队列协议</h1><h2 id=\"什么是协议\"><a href=\"#什么是协议\" class=\"headerlink\" title=\"什么是协议\"></a>什么是协议</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/mq%E5%8D%8F%E8%AE%AE.png\" alt=\"常见中间件\"></p>\n<p>所谓协议是指：<br>1）计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流<br>2）和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高<br>3）协议对数据格式和计算机之间交换数据都必须严格遵守规范</p>\n<hr>\n<h2 id=\"网络协议的三要素\"><a href=\"#网络协议的三要素\" class=\"headerlink\" title=\"网络协议的三要素\"></a>网络协议的三要素</h2><p>1）语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序<br>2）语义：语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应<br>3）时序：时序是对事件发生顺序的详细说明</p>\n<p>比如我 MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作，以及消费者消费消息的动作，消费完毕的相应结构和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解：大家每天都在接触的http请求协议：<br>1）语法：http规定了请求报文和响应报文的格式<br>2）语义：客户端主动发起请求称之为请求（这是一种定义，同时你发起的是 post/get请求）<br>3）时序：一个请求对应一个响应（一定先有请求在有响应，这个是时序）</p>\n<hr>\n<h2 id=\"常见的消息中间件协议\"><a href=\"#常见的消息中间件协议\" class=\"headerlink\" title=\"常见的消息中间件协议\"></a>常见的消息中间件协议</h2><p>消息中间件采用的不是 http协议。<br>常见的消息中间件协议有：JSM、AMQP、Kafka，OpenMessage，OpenWire，MQTT协议</p>\n<hr>\n<h3 id=\"JMS协议\"><a href=\"#JMS协议\" class=\"headerlink\" title=\"JMS协议\"></a>JMS协议</h3><p>JMS：（全称：Java Message Service）Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。这是java定义的api，是不可跨语言，是不可跨平台的。</p>\n<p>特性：<br>1）可靠的消息处理<br>2）消息的持久化支持<br>3）跨平台跨语言支持差</p>\n<p>支持MQ：ActiveMQ</p>\n<h3 id=\"AMQP协议\"><a href=\"#AMQP协议\" class=\"headerlink\" title=\"AMQP协议\"></a>AMQP协议</h3><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p>\n<p>特性：<br>1）分布式事务支持<br>2）消息的持久化支持<br>3）高性能和高可靠的消息处理优势</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h3><p>MQTT：（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分。</p>\n<p>特点：<br>1）轻量<br>2）结构简单<br>3）传输快，不支持事务<br>4）没有持久化设计</p>\n<p>支持MQ：RabbitMQ</p>\n<h3 id=\"Kafka协议\"><a href=\"#Kafka协议\" class=\"headerlink\" title=\"Kafka协议\"></a>Kafka协议</h3><p>Kafka协议：是基于TCP/IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）无事务支持<br>4）有持久化设计</p>\n<p>代表MQ：Kafka</p>\n<h3 id=\"OpenMessage协议\"><a href=\"#OpenMessage协议\" class=\"headerlink\" title=\"OpenMessage协议\"></a>OpenMessage协议</h3><p>OpenMessage协议：是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准。</p>\n<p>特点：<br>1）结构简单<br>2）解析速度快<br>3）支持事务和持久化设计</p>\n<p>支持MQ：RocketMQ</p>\n<h2 id=\"为什么消息中间件不使用-http协议\"><a href=\"#为什么消息中间件不使用-http协议\" class=\"headerlink\" title=\"为什么消息中间件不使用 http协议\"></a>为什么消息中间件不使用 http协议</h2><p>为什么消息中间件不使用 http协议？<br>1）因为 http请求报文头和响应报文头是比较复杂的，包含了Cookie，数据的加密解密，窗台吗，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速<br>2）大部分情况下 http大部分都是短链接，在实际的交互过程中，一个请求到响应都很有可能会中断，中断以后就不会执行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取信息的过程，出现问题和故障要对数据或消息执行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p>\n<hr>\n<h1 id=\"消息队列持久化\"><a href=\"#消息队列持久化\" class=\"headerlink\" title=\"消息队列持久化\"></a>消息队列持久化</h1><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>简单来说就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"消息持久化图片\"></p>\n<hr>\n<h2 id=\"常见MQ的持久化方式\"><a href=\"#常见MQ的持久化方式\" class=\"headerlink\" title=\"常见MQ的持久化方式\"></a>常见MQ的持久化方式</h2><p>ActiveMQ：支持文件存储，支持数据库</p>\n<p>RabbitMQ &amp; Kafka &amp; RocketMQ：支持文件存储</p>\n<hr>\n<h1 id=\"消息的分发策略\"><a href=\"#消息的分发策略\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h1><h2 id=\"场景分析\"><a href=\"#场景分析\" class=\"headerlink\" title=\"场景分析\"></a>场景分析</h2><p>场景分析一：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%911.png\" alt=\"消息分发1\"><br>比如我在 APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被哪个系统或者哪些服务器或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>\n<p>场景分析二：<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%912.png\" alt=\"消息分发2\"><br>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费 MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持：出现问题和故障的情况下，消息不丢失还可以进行重发消息策略的机制。</p>\n<h2 id=\"消息的分发策略-1\"><a href=\"#消息的分发策略-1\" class=\"headerlink\" title=\"消息的分发策略\"></a>消息的分发策略</h2><p>MQ消息队列有如下几个角色<br>1）生产者<br>2）存储消息<br>3）消费者</p>\n<p>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢？一般获取数据的方式无外乎推（push）或者拉（pull）两种方式，典型的 git就有推拉机制，我们发送的 http请求就是一种典型的拉取数据库数据返回的过程。而消息队列 MQ是一种推送的过程，而这些推机制会使用到很多的业务场景也有很多对应推机制策略。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5.png\" alt=\"消息分发策略\">  </p>\n<hr>\n<h1 id=\"消息队列高可用和高可靠\"><a href=\"#消息队列高可用和高可靠\" class=\"headerlink\" title=\"消息队列高可用和高可靠\"></a>消息队列高可用和高可靠</h1><h2 id=\"什么是高可用机制\"><a href=\"#什么是高可用机制\" class=\"headerlink\" title=\"什么是高可用机制\"></a>什么是高可用机制</h2><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力<br>当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件（CPU，内存，磁盘）的极限，一台消息服务器你已经无法满足业务的需求，所以消息中间件必须支持集群部署，来达到高可用的目的。</p>\n<h3 id=\"集群模式一\"><a href=\"#集群模式一\" class=\"headerlink\" title=\"集群模式一\"></a>集群模式一</h3><p>Master-slave主从同步部署方式<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%80.png\" alt=\"集群模式1\"><br>解释：这种模式写入消息同样在 Master主节点上，但是主节点会同步数据到 slave节点形成副本，和 zookeeper或者 redis主从机制很雷同。这样可以达到负载均衡的效果，如果消费者有多个这样就可以去不同的节点进行消费，消息的拷贝和同步会占用很大的带宽和网络资源。</p>\n<h3 id=\"集群模式二\"><a href=\"#集群模式二\" class=\"headerlink\" title=\"集群模式二\"></a>集群模式二</h3><p>Master-slave与 Broker-cluster组合的方案<br><img src=\"https://kubpang.gitee.io/sourceFile/MQ/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%BA%8C.png\" alt=\"集群模式1\"><br>解释：如果你插入的数据是 broker-1中国，元数据信息会存储数据的相关描述和记录存放的位置（队列）。它会对描述信息也就是元数据信息进行同步，如果消费者在 broker-2中进行消费，发现自己节点没有对应的信息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景：比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他回去联系其他的黄牛询问，如果有就返回。</p>\n<p><strong>注意：实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。</strong></p>\n<h2 id=\"什么是高可靠机制\"><a href=\"#什么是高可靠机制\" class=\"headerlink\" title=\"什么是高可靠机制\"></a>什么是高可靠机制</h2><p>所谓高可靠是指：<br>系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为：高可靠。</p>\n<p>如何保证中间件消息的可靠性呢，可以从两个方面考虑：<br>1）消息的传输：通过协议来保证系统间数据解析的正确性<br>2）消息的存储区可靠：通过持久化来保证消息的可靠性</p>\n<p>注意：在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>"},{"title":"MySQL-主从复制","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 主从复制是什么\n\n主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。  \n主机（master）以写为主，备机（slave）以读为主。\n\n# 应用场景\n\n1）读写分离（提高性能，多从可以提高查询速度）  \n2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）\n\n# ","source":"_posts/oyr/MySQL/MySQL-主从复制.md","raw":"---\ntitle: MySQL-主从复制\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MySQL\ntags: \n\t- oyr-MySQL\n\t- 数据库\n---\n\n# 主从复制是什么\n\n主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。  \n主机（master）以写为主，备机（slave）以读为主。\n\n# 应用场景\n\n1）读写分离（提高性能，多从可以提高查询速度）  \n2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）\n\n# ","slug":"oyr/MySQL/MySQL-主从复制","published":1,"updated":"2021-07-13T09:52:32.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l8363000vhct7gzfb5mkd","content":"<h1 id=\"主从复制是什么\"><a href=\"#主从复制是什么\" class=\"headerlink\" title=\"主从复制是什么\"></a>主从复制是什么</h1><p>主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。<br>主机（master）以写为主，备机（slave）以读为主。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>1）读写分离（提高性能，多从可以提高查询速度）<br>2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"主从复制是什么\"><a href=\"#主从复制是什么\" class=\"headerlink\" title=\"主从复制是什么\"></a>主从复制是什么</h1><p>主从复制：主机数据更新后，根据配置和策略自动同步数据到备机上。<br>主机（master）以写为主，备机（slave）以读为主。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>1）读写分离（提高性能，多从可以提高查询速度）<br>2）容灾恢复（数据备份，防止服务器宕机导致的数据丢失）</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"Java8新特性","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Java8新特性简介\n\n1）速度更快  \n2）代码更少（增加了新的语法Lambda表达式）  \n3）强大的Stream API  \n4）便于并行  \n5）最大化减少空指针异常 Optional\n\n**其中 Lambda 表达式与 Stream API 最为核心的。**\n\n<!-- more -->\n\n# Lambda表达式\n\n## 什么是Lambda 表达式\n\nLambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。  \nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。  \n使用 Lambda 表达式可以使代码变的更加简洁紧凑。\n\n## Lambda 表达式\n\nLambda 表达式的基础语法：  \nJava8中引入了一个新操作符：“->”该操作符被称为剪头操作符或 Lambda 操作符。\n\n箭头操作符将 Lambda 表达式拆分成两部分：  \n左侧：指定了 Lambda 表达式需要的所有参数。  \n右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。  \n列如：(parameters) -> expression 或 (parameters) ->{ statements; }\n\n特征：  \n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。  \n可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。  \n可选的大括号：如果主体包含了一个语句，就不需要使用大括号。  \n可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n上联：左右遇一括号省  \n下联：左侧推断类型省  \n横批：能省则省\n\n## 语法\n\n1）语法格式一：无参，无返回值\n```java\nRunnable runnable = () -> System.out.println(\"hello lambda!!!\");\n```\n\n2）语法格式二：有一个参数，并且无返回值\n```java\nConsumer<String> consumer = (x) -> System.out.println(x);\n```\n\n3）语法格式三：若只有一个参数，小括号可以省略不写\n```java\nConsumer<String> consumer = x -> System.out.println(x);\n```\n\n4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"开始比较\");\n    return Integer.compare(x, y);\n};\n```\n\n5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n\n（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’\n```java\nComparator<Integer> comparator = (Integer x, Integer y) -> Integer.compare(x, y);\n```\n\n## Lambda表达式需要“函数式接口”的支持\n\n详情看：函数式接口\n\n# 函数式接口\n\n## 什么是函数式接口？\n\n函数式接口：  \n接口中只有一个抽象方法的接口，称为函数式接口。  \n可以使用注解 @FunctionalInterface 修饰。\n\n```java\n@FunctionalInterface    // 表示这是函数式接口\npublic interface MyFun {\n\n    String getValue(String str);\n\n    String test();多一个方法就报错\n\n}\n```\n\n## Java8 内置的四大核心函数式接口\n\n1）Consumer<T>：消费型接口  \nVoid accept(T t)\n\n2）Supplier<T>：供给型接口  \nT get();\n\n3）Function<T, R>：函数型接口  \nR apply(T t);\n\n4）Predicate<T>：断言型接口  \nBoolean test(T t);\n\n## 其他接口\n\n![其他函数式接口](https://kubpang.gitee.io/sourceFile/Java/JDK/其他函数式接口.png)\n\n# 方法引用与构造函数引用\n\n## 方法引用\n\n方法引用：  \n若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”  \n（可以理解为方法引用是Lambda表达式的另外一种表现方式）  \n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n\n### 语法\n\n方法引用三种语法格式：  \n```\n第一种：实例对象::实例方法名  \n\n第二种：类::静态方法名  \n\n第三种：类::实例方法名\n```\n\n注意：  \n（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。  \n（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。\n\n### 案例\n\n```java\n// 方法引用：对象::方法名\npublic void test1() {\n    Consumer<String> con1 = x -> System.out.println(x);\n    Consumer<String> con2 = System.out::print;\n\n    User user = new User();\n    Supplier<String> sup1 = () -> user.getName();\n    Supplier<String> sup2 = user::getName;\n}\n\n// 方法引用：类名::静态方法名\npublic void test2() {\n    Comparator<Integer> com1 = (x, y) -> Integer.compare(x, y);\n    Comparator<Integer> com2 = Integer::compare;\n}\n\n// 方法引用：类名：实例方法名\npublic void test3() {\n    BiPredicate<String, String> bp1 = (x, y) -> x.equals(y);\n    BiPredicate<String, String> bp2 = String::equals;\n}\n```\n\n## 构造器引用\n\n### 语法\n\n语法格式：Class :: method\n\n注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。\n\n### 案例\n\n```java\n// 构造器引用：类名::new\npublic void test4() {\n    // 对应函数式接口的抽象方法，当前调用无参构造\n    Supplier<User> su1 = () -> new User();\n    Supplier<User> su2 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器\n    Function<Integer, User> fun1 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器\n    BiFunction<String, Integer, User> fun2 = User::new;\n}\n```\n\n# Stream API\n\n## 了解Stream API\n\nJava8中有两大最为重要的改变：   \n第一个是Lambda表达式；  \n第二个则是Stream API（java.util.stream.*）；  \n\nStream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。  \n使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。\n\n## 什么是Stream\n\n流（Stream）到底是什么呢？  \n是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。  \n“集合讲的是数据，流讲的是计算！！！”\n\n注意：  \n1）Stream 自己不会存储元素  \n2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream  \n3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）\n\n## Stream的三个操作步骤\n\n1）创建Stream  \n一个数据源（如：集合，数组），获取一个流\n\n2）中间操作  \n一个中间操作链，对数据源的数据进行处理（过滤，映射）\n\n3）终止操作（终端操作，返回结果）  \n一个终止操作，执行中间操作链，并且产生结果\n\n流程图：  \n![Stream操作流程图](https://kubpang.gitee.io/sourceFile/Java/JDK/Stream操作流程图.png)\n\n## 创建Stream\n\n### 集合创建Stream\n\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：  \ndefault Stream<E> stream() : 返回一个顺序流  \ndefault Stream<E> parallelStream() : 返回一个并行流\n\n案例：\n```java\n@Test\npublic void test1() {\n    // List Set 继承至 Collection\n    all.stream().forEach(System.out::println);\n    all.parallelStream().forEach(System.out::println);\n    map.values().stream().forEach(System.out::println);\n}\n```\n\n### 数组创建Stream\n\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流：  \nstatic <T> Stream<T> stream(T[] array): 返回一个流。\n\n重载形式，能够处理对应基本类型的数组： \npublic static IntStream stream(int[] array) \npublic static LongStream stream(long[] array)\npublic static DoubleStream stream(double[] array)\n\n案例：\n```java\n@Test\npublic void test2() {\n    int[] intArr = {1, 2, 3, 4};\n    String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n    Arrays.stream(intArr).forEach(System.out::println);\n    Arrays.stream(strArr).forEach(System.out::println);\n}\n```\n\n### 值创建Stream\n\n可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：  \npublic static<T> Stream<T> of(T... values) : 返回一个流\n\n案例：\n```java\npublic void test3() {\n    Stream.of(\"a\", \"b\", \"c\", \"d\").forEach(System.out::println);\n    Stream.of(\"a\", \"b\", \"c\", \"d\").parallel().forEach(System.out::println);\n    Stream.of(new User(50, \"张三\"),\n            new User(60, \"李四\"),\n            new User(11, \"王五\")).forEach(System.out::println);\n}\n```\n\n### 函数创建Stream（无限流）\n\n可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 \n迭代：  \npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);\n\n生成：  \npublic static<T> Stream<T> generate(Supplier<T> s);\n\n## Stream的中间操作\n\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!  \n而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。\n\n### 筛选与切片\n\nfilter(Predicate p)：接收Lambda，从Stream流中排除某些元素。\n\ndistinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。\n\nlimit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。\n\nskip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。\n\n案例：\n```java\n@Test\npublic void test1() {\n    all.stream().filter(user -> user.getAge() > 10).forEach(System.out::println);\n    all.stream().distinct().forEach(System.out::println);\n    all.stream().limit(10).forEach(System.out::println);\n    all.stream().skip(10).forEach(System.out::println);\n    all.stream().distinct()\n            .filter(user -> user.getAge() > 10)\n            .limit(10)\n            .skip(5)\n            .forEach(System.out::println);\n}\n```\n\n### 映射\n\nmap(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nflatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。\n\n```java\npublic void test2() {\n    all.stream().map(user -> user.getName())\n                .forEach(System.out::println);\n    all.stream().flatMap(user -> Stream.of(user.getName()))\n            .forEach(System.out::println);\n}\n```\n\n### 排序\n\nsorted()：自然排序，使用Comparable默认排序。\n\nsorted(Comparator comparator)：定制排序，使用Comparator。\n\n```java\npublic void test3() {\n    List<String> strings = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"zzz\");\n    strings.stream()\n            .sorted()\n            .forEach(System.out::println);\n\n    all.stream().sorted((x, y) -> {\n        if (x.getAge().equals(y.getAge())) {\n            return x.getName().compareTo(y.getName());\n        }\n        return x.getAge().compareTo(y.getAge());\n    }).forEach(System.out::println);\n}\n```\n\n## Stream的终止操作\n\n### 查找与匹配\n\nFind查找：  \nfindFirst() ：返回第一个元素   \nfindAny() ：返回当前流中的任意元素  \ncount() ：返回流中元素总个数  \nmax(Comparator c) ：返回流中最大值  \nmin(Comparator c) ：返回流中最小值  \n\nMatch匹配：  \nallMatch(Predicate p) ：检查是否匹配所有元素   \nanyMatch(Predicate p) ：检查是否至少匹配一个元素   \nnoneMatch(Predicate p) ：检查是否没有匹配所有元素\n\nFinal 查找案例：\n```java\n@Test\npublic void test2() {\n    Optional<User> firstOptional = all.stream().findFirst();\n    Optional<User> anyOptional = all.stream().findAny();\n    long count = all.stream().count();\n    Optional<User> maxOptional = all.stream().max(Comparator.comparing(User::getAge));\n    Optional<Integer> minOptional = all.stream().map(User::getAge).min(Integer::compareTo);\n    System.out.println(firstOptional.get());\n    System.out.println(anyOptional.get());\n    System.out.println(count);\n    System.out.println(maxOptional.get());\n    System.out.println(minOptional.get());\n}\n```\n\nMatch 匹配Demo：\n```java\n@Test\npublic void test3() {\n    boolean allMatch = all.stream().allMatch(x -> UserStatus.A == x.getStatus());\n    boolean anyMatch = all.stream().anyMatch(x -> UserStatus.B == (x.getStatus()));\n    boolean noneMatch = all.stream().noneMatch(x -> UserStatus.A == x.getStatus());\n    System.out.println(allMatch);\n    System.out.println(anyMatch);\n    System.out.println(noneMatch);\n}\n```\n\n### 规约\n\nreduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。\n\nreduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。\n\n```java\n@Test\npublic void reduceTest() {\n    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -> {\n        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);\n        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);\n        return o.add(n);\n    });\n    System.out.println(reduce);\n}\n```\n\n### 收集\n\ncollect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。\n\nCollector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：  \n![常见收集器方法](https://kubpang.gitee.io/sourceFile/Java/JDK/常见收集器方法.png)\n\n案例：\n```java\npublic void test1() {\n    // 转collection\n    Set<User> set = all.stream().collect(Collectors.toSet());\n    List<Integer> list = all.stream().map(User::getId).collect(Collectors.toList());\n    // 转map\n    Map<String, User> map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));\n    // 转map，处理key相同的元素\n    Map<String, User> map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -> x));\n    // 根据属性分组\n    Map<String, List<User>> sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));\n}\n```\n\n# 并行流 与 串行流\n\n# 新时间日期API\n\n在旧版的java中，日期时间API存在诸多问题，其中有：  \n1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一  \n2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。  \n3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。\n\n**因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。**\n\nJava8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：  \nLocal（本地）  简化了日期的处理，没有时区的问题。  \nZoned（时区）  通过制定的时区处理日期时间。  \n新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n\n## 常用类简介\n\nInstat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\nPeriod：用于计算日期间隔  \nDuration：用于计算时间间隔  \n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime\n\nZoneld：时区  \nZonedDateTime：表示日期+时间+时区值\n\nDateTimeFormatter：用于日期时间的格式化\n\n## 本地化日期时间API\n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime\n\n公共API：  \nnow()：静态方法，根据当前时间创建对象。  \nof()：静态方法，根据指定的日期/时间创建对象。\n\nLocalDate 与 LocalDateTime公共API：  \ngetYear()：获取年份  \ngetMonth()：获取月份，返回一个Month的枚举  \ngetMonthValue()：获取月份  \ngetDayOfMonth()：获取当前月份天数【1-31】  \ngetDayOfYear()：获取当前年份天数【1-366】  \ngetDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举  \nplus()：添加一个 Duration 或 Period  \nminus()：删除一个 Duration 或 Period\nplusDays(); plusWeeks(); plusMonths(); plusYears()：  \n向当前对象，新增几天，几周，几月，几年。\nminusDays(); minusWeeks(); minusMonths(); minusYears()：  \n向当前对象，减去几天，几周，几月，几年。\nwithDayOfMonth()：修改当前月的天数  \nwithDayOfYear()：修改当前年的天数\n\nLocalTime 与 LocalDateTime公共API：  \ngetHour()：获取小时  \ngetMinute()：获取分钟  \ngetSecond()：获取秒\n\n## 时区日期时间API\n\n## Instant 时间戳\n\nJava8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\n如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。\n\n用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n\nInstant API方法：  \ngetEpochSecond()：获取秒数  \ntoEpochMilli()：获取毫秒数  \ngetNano()：获取纳秒数  \nSystem.currentTimeMillis()：获取时间戳，毫秒级别。\n\n```java\nInstant instant = Instant.now();\n// 获取秒数\nlong currentSecond = instant.getEpochSecond();\n// 获取毫秒数\nlong currentMilli = instant.toEpochMilli();\n// 时间戳\nlong currentTimeMilli = System.currentTimeMillis();\nSystem.out.println(currentSecond);\nSystem.out.println(currentMilli);\nSystem.out.println(instant);\nSystem.out.println(currentTimeMilli);\n```\n\n## Period 日期间隔\n\nJava8新提供Period来表示一个日期段，日期间隔。\n\nPeriod API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Period实例  \ngetYears();\t\t\t获取这段日期的相隔年数  \ngetMonths(); \t\t获取单纯月份比较，相隔几月  \ngetDays(); \t\t\t获取单纯天数比较，相隔几天\n\n```java\n// 1999-06-24\nLocalDate from = LocalDate.of(1999, Month.MAY, 24);\n// 2020-08-20\nLocalDate to = LocalDate.of(2020, Month.JULY, 20);\n\nPeriod period = Period.between(from, to);\nint years = period.getYears(); // 这段日期的相隔年数\nint months = period.getMonths(); // 单纯月份比较，相隔几月\nint days = period.getDays(); // 单纯天数比较，相隔几天\n```\n\n## Duration 时间间隔\n\nJava8新提供Duration来表示一个时间段，时间间隔。\n\nDuration API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Duration实例  \ntoDays()：\t\t获取这段时间的天数  \ntoHours()：\t\t获取这段时间的小时  \ntoMinutes()：\t\t获取这段时间的分钟数  \ngetSeconds()：\t获取这段时间的秒数  \ntoMillis()：\t\t获取这段时间的毫秒数  \ntoNanos()：\t\t获取这段时间的纳秒数\n\n```java\n@Test\npublic void durationTest() {\n    // 1999-06-24 00:00:00\n    LocalDateTime from = LocalDateTime.of(1999, Month.MAY, 24, 0, 0, 0);\n    // 2020-08-20 00:00:00\n    LocalDateTime to = LocalDateTime.of(2020, Month.JULY, 20, 0, 0, 0);\n\n    Duration duration = Duration.between(from, to);\n\n    long days = duration.toDays();// 这段时间的天数\n    long hours = duration.toHours();// 这段时间的小时\n    long minutes  = duration.toMinutes();// 这段时间的分钟数\n    long seconds = duration.getSeconds();// 这段时间的秒数\n    long milliSeconds = duration.toMillis();// 这段时间的毫秒数\n    long nanos = duration.toNanos();// 这段时间的纳秒数\n\n    System.out.println(days);\n    System.out.println(hours);\n    System.out.println(minutes);\n    System.out.println(seconds);\n    System.out.println(milliSeconds);\n    System.out.println(nanos);\n}\n```\n\n## 解析与格式化\n\n格式化时间：  \nJava8新提供DateTimeFormatter来格式化时间。\n\n解析时间：  \n使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。\n\n格式化时间demo：\n```java\nLocalDateTime now = LocalDateTime.now();\nString s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);\nString s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = formatter.format(now);\n```\n\n解析时间Demo：\n```java\nLocalDate localDate = LocalDate.parse(\"2020-10-01\");\nLocalDateTime localDateTime = LocalDateTime.parse(\"2020-10-01T15:15:15\");\nLocalDateTime copyLocalDateTime = LocalDateTime.parse(\"2020-10-01 15:15:15\", DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));\n```\n\n# 接口中的默认方法 与 静态方法\n\n## 默认方法\n\nJava8新增了接口的默认方法。  \n简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n\n为什么要有这个特性：  \n首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。  \n然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。\n\n接口默认方法语法格式：\n```java\npublic interface MyInterface {\n\n    default String getStr() {\n        return \"hello interface default method\";\n    }\n\n}\n```\n\n## 默认方法的问题\n\n如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：\n\n接口冲突：\n如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。\n\n类优先原则：\n如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。\n\n接口冲突案例：\n```java\npublic interface Dog {\n\n    default void call() {\n        System.out.println(\"我是狗，汪汪汪\");\n    }\n\n}\n\npublic interface Cat {\n\n    default void call() {\n        System.out.println(\"我是猫，喵喵喵\");\n    }\n\n}\n\npublic class Demo implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n\n    @Override\n    public void call() {\n        Dog.super.call();\n        Cat.super.call();\n        System.out.println(\"我是demo\");\n    }\n}\n```\n\n类优先原则：\n```java\npublic abstract class BaseClass {\n\n    public void call() {\n        System.out.println(\"我是baseClass\");\n    }\n\n}\n\npublic class Demo extends BaseClass implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n    \n}\n```\n\n## 静态方法\n\nJava8的另一个特性是接口可以声明（并且可以提供实现）静态方法。\n\n接口静态方法语法格式：\n```java\npublic interface MyInterface {\n\n    static String getStr() {\n        return \"hello interface static method\";\n    }\n\n}\n```\n\n# Optional 类\n\n## Optional 类简介\n\nOptional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。\n\nOptional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。\n\nOptional 类的引入，可以很好的解决空指针异常。\nOptional 类可以很好的判断一个值存在或者不存在。\n\n## 常用方法\n\n```\nOptional.get()               获取Optional容器包含的值，如果值为null，抛出异常\n\nOptional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常\nOptional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例\nOptional .empty()\t\t\t创建一个空的Optional 实例\n\nOptional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false\nOrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t\nOrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值\nMap(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()\nflatMap(function f)\t\t\t与map类型，要求返回Optional\n```\n\n案例：\n```java\n    @Test\n    public void methodDemo() {\n        // optional.of创建optional实例，t不能为空，为null，抛出异常\n        Optional<Integer> integerOptional = Optional.of(1);\n        // optional.ofNullable创建optional实例，t如果为空，返回一个空的optional\n        Optional<User> userOptional = Optional.ofNullable(null);\n        // optional.empty创建一个空值得optional实例\n        Optional<Object> empty = Optional.empty();\n\n\n    //        // get，optional如果值为空，抛出异常\n    //        integerOptional.get();\n    //        userOptional.get();\n    //        empty.get();\n\n        System.out.println(userOptional.isPresent());\n\n        // 如果值不为空，则返回，如果为空，则返回给定的值\n        Integer integer = integerOptional.orElse(3);\n        User user = userOptional.orElse(new User());\n        Object o = empty.orElse(new BigDecimal(\"100\"));\n\n        System.out.println(integer);\n        System.out.println(user);\n        System.out.println(o);\n    }\n```","source":"_posts/oyr/Java/Java8新特性.md","raw":"---\ntitle: Java8新特性\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: Java\ntags: \n    - java\n---\n\n# Java8新特性简介\n\n1）速度更快  \n2）代码更少（增加了新的语法Lambda表达式）  \n3）强大的Stream API  \n4）便于并行  \n5）最大化减少空指针异常 Optional\n\n**其中 Lambda 表达式与 Stream API 最为核心的。**\n\n<!-- more -->\n\n# Lambda表达式\n\n## 什么是Lambda 表达式\n\nLambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。  \nLambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。  \n使用 Lambda 表达式可以使代码变的更加简洁紧凑。\n\n## Lambda 表达式\n\nLambda 表达式的基础语法：  \nJava8中引入了一个新操作符：“->”该操作符被称为剪头操作符或 Lambda 操作符。\n\n箭头操作符将 Lambda 表达式拆分成两部分：  \n左侧：指定了 Lambda 表达式需要的所有参数。  \n右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。  \n列如：(parameters) -> expression 或 (parameters) ->{ statements; }\n\n特征：  \n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。  \n可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。  \n可选的大括号：如果主体包含了一个语句，就不需要使用大括号。  \n可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n上联：左右遇一括号省  \n下联：左侧推断类型省  \n横批：能省则省\n\n## 语法\n\n1）语法格式一：无参，无返回值\n```java\nRunnable runnable = () -> System.out.println(\"hello lambda!!!\");\n```\n\n2）语法格式二：有一个参数，并且无返回值\n```java\nConsumer<String> consumer = (x) -> System.out.println(x);\n```\n\n3）语法格式三：若只有一个参数，小括号可以省略不写\n```java\nConsumer<String> consumer = x -> System.out.println(x);\n```\n\n4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"开始比较\");\n    return Integer.compare(x, y);\n};\n```\n\n5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n\n（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’\n```java\nComparator<Integer> comparator = (Integer x, Integer y) -> Integer.compare(x, y);\n```\n\n## Lambda表达式需要“函数式接口”的支持\n\n详情看：函数式接口\n\n# 函数式接口\n\n## 什么是函数式接口？\n\n函数式接口：  \n接口中只有一个抽象方法的接口，称为函数式接口。  \n可以使用注解 @FunctionalInterface 修饰。\n\n```java\n@FunctionalInterface    // 表示这是函数式接口\npublic interface MyFun {\n\n    String getValue(String str);\n\n    String test();多一个方法就报错\n\n}\n```\n\n## Java8 内置的四大核心函数式接口\n\n1）Consumer<T>：消费型接口  \nVoid accept(T t)\n\n2）Supplier<T>：供给型接口  \nT get();\n\n3）Function<T, R>：函数型接口  \nR apply(T t);\n\n4）Predicate<T>：断言型接口  \nBoolean test(T t);\n\n## 其他接口\n\n![其他函数式接口](https://kubpang.gitee.io/sourceFile/Java/JDK/其他函数式接口.png)\n\n# 方法引用与构造函数引用\n\n## 方法引用\n\n方法引用：  \n若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”  \n（可以理解为方法引用是Lambda表达式的另外一种表现方式）  \n方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n\n### 语法\n\n方法引用三种语法格式：  \n```\n第一种：实例对象::实例方法名  \n\n第二种：类::静态方法名  \n\n第三种：类::实例方法名\n```\n\n注意：  \n（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。  \n（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。\n\n### 案例\n\n```java\n// 方法引用：对象::方法名\npublic void test1() {\n    Consumer<String> con1 = x -> System.out.println(x);\n    Consumer<String> con2 = System.out::print;\n\n    User user = new User();\n    Supplier<String> sup1 = () -> user.getName();\n    Supplier<String> sup2 = user::getName;\n}\n\n// 方法引用：类名::静态方法名\npublic void test2() {\n    Comparator<Integer> com1 = (x, y) -> Integer.compare(x, y);\n    Comparator<Integer> com2 = Integer::compare;\n}\n\n// 方法引用：类名：实例方法名\npublic void test3() {\n    BiPredicate<String, String> bp1 = (x, y) -> x.equals(y);\n    BiPredicate<String, String> bp2 = String::equals;\n}\n```\n\n## 构造器引用\n\n### 语法\n\n语法格式：Class :: method\n\n注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。\n\n### 案例\n\n```java\n// 构造器引用：类名::new\npublic void test4() {\n    // 对应函数式接口的抽象方法，当前调用无参构造\n    Supplier<User> su1 = () -> new User();\n    Supplier<User> su2 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器\n    Function<Integer, User> fun1 = User::new;\n\n    // 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器\n    BiFunction<String, Integer, User> fun2 = User::new;\n}\n```\n\n# Stream API\n\n## 了解Stream API\n\nJava8中有两大最为重要的改变：   \n第一个是Lambda表达式；  \n第二个则是Stream API（java.util.stream.*）；  \n\nStream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。  \n使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。\n\n## 什么是Stream\n\n流（Stream）到底是什么呢？  \n是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。  \n“集合讲的是数据，流讲的是计算！！！”\n\n注意：  \n1）Stream 自己不会存储元素  \n2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream  \n3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）\n\n## Stream的三个操作步骤\n\n1）创建Stream  \n一个数据源（如：集合，数组），获取一个流\n\n2）中间操作  \n一个中间操作链，对数据源的数据进行处理（过滤，映射）\n\n3）终止操作（终端操作，返回结果）  \n一个终止操作，执行中间操作链，并且产生结果\n\n流程图：  \n![Stream操作流程图](https://kubpang.gitee.io/sourceFile/Java/JDK/Stream操作流程图.png)\n\n## 创建Stream\n\n### 集合创建Stream\n\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法：  \ndefault Stream<E> stream() : 返回一个顺序流  \ndefault Stream<E> parallelStream() : 返回一个并行流\n\n案例：\n```java\n@Test\npublic void test1() {\n    // List Set 继承至 Collection\n    all.stream().forEach(System.out::println);\n    all.parallelStream().forEach(System.out::println);\n    map.values().stream().forEach(System.out::println);\n}\n```\n\n### 数组创建Stream\n\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流：  \nstatic <T> Stream<T> stream(T[] array): 返回一个流。\n\n重载形式，能够处理对应基本类型的数组： \npublic static IntStream stream(int[] array) \npublic static LongStream stream(long[] array)\npublic static DoubleStream stream(double[] array)\n\n案例：\n```java\n@Test\npublic void test2() {\n    int[] intArr = {1, 2, 3, 4};\n    String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n    Arrays.stream(intArr).forEach(System.out::println);\n    Arrays.stream(strArr).forEach(System.out::println);\n}\n```\n\n### 值创建Stream\n\n可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：  \npublic static<T> Stream<T> of(T... values) : 返回一个流\n\n案例：\n```java\npublic void test3() {\n    Stream.of(\"a\", \"b\", \"c\", \"d\").forEach(System.out::println);\n    Stream.of(\"a\", \"b\", \"c\", \"d\").parallel().forEach(System.out::println);\n    Stream.of(new User(50, \"张三\"),\n            new User(60, \"李四\"),\n            new User(11, \"王五\")).forEach(System.out::println);\n}\n```\n\n### 函数创建Stream（无限流）\n\n可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 \n迭代：  \npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);\n\n生成：  \npublic static<T> Stream<T> generate(Supplier<T> s);\n\n## Stream的中间操作\n\n多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!  \n而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。\n\n### 筛选与切片\n\nfilter(Predicate p)：接收Lambda，从Stream流中排除某些元素。\n\ndistinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。\n\nlimit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。\n\nskip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。\n\n案例：\n```java\n@Test\npublic void test1() {\n    all.stream().filter(user -> user.getAge() > 10).forEach(System.out::println);\n    all.stream().distinct().forEach(System.out::println);\n    all.stream().limit(10).forEach(System.out::println);\n    all.stream().skip(10).forEach(System.out::println);\n    all.stream().distinct()\n            .filter(user -> user.getAge() > 10)\n            .limit(10)\n            .skip(5)\n            .forEach(System.out::println);\n}\n```\n\n### 映射\n\nmap(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\nflatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。\n\n```java\npublic void test2() {\n    all.stream().map(user -> user.getName())\n                .forEach(System.out::println);\n    all.stream().flatMap(user -> Stream.of(user.getName()))\n            .forEach(System.out::println);\n}\n```\n\n### 排序\n\nsorted()：自然排序，使用Comparable默认排序。\n\nsorted(Comparator comparator)：定制排序，使用Comparator。\n\n```java\npublic void test3() {\n    List<String> strings = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"zzz\");\n    strings.stream()\n            .sorted()\n            .forEach(System.out::println);\n\n    all.stream().sorted((x, y) -> {\n        if (x.getAge().equals(y.getAge())) {\n            return x.getName().compareTo(y.getName());\n        }\n        return x.getAge().compareTo(y.getAge());\n    }).forEach(System.out::println);\n}\n```\n\n## Stream的终止操作\n\n### 查找与匹配\n\nFind查找：  \nfindFirst() ：返回第一个元素   \nfindAny() ：返回当前流中的任意元素  \ncount() ：返回流中元素总个数  \nmax(Comparator c) ：返回流中最大值  \nmin(Comparator c) ：返回流中最小值  \n\nMatch匹配：  \nallMatch(Predicate p) ：检查是否匹配所有元素   \nanyMatch(Predicate p) ：检查是否至少匹配一个元素   \nnoneMatch(Predicate p) ：检查是否没有匹配所有元素\n\nFinal 查找案例：\n```java\n@Test\npublic void test2() {\n    Optional<User> firstOptional = all.stream().findFirst();\n    Optional<User> anyOptional = all.stream().findAny();\n    long count = all.stream().count();\n    Optional<User> maxOptional = all.stream().max(Comparator.comparing(User::getAge));\n    Optional<Integer> minOptional = all.stream().map(User::getAge).min(Integer::compareTo);\n    System.out.println(firstOptional.get());\n    System.out.println(anyOptional.get());\n    System.out.println(count);\n    System.out.println(maxOptional.get());\n    System.out.println(minOptional.get());\n}\n```\n\nMatch 匹配Demo：\n```java\n@Test\npublic void test3() {\n    boolean allMatch = all.stream().allMatch(x -> UserStatus.A == x.getStatus());\n    boolean anyMatch = all.stream().anyMatch(x -> UserStatus.B == (x.getStatus()));\n    boolean noneMatch = all.stream().noneMatch(x -> UserStatus.A == x.getStatus());\n    System.out.println(allMatch);\n    System.out.println(anyMatch);\n    System.out.println(noneMatch);\n}\n```\n\n### 规约\n\nreduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。\n\nreduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。\n\n```java\n@Test\npublic void reduceTest() {\n    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -> {\n        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);\n        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);\n        return o.add(n);\n    });\n    System.out.println(reduce);\n}\n```\n\n### 收集\n\ncollect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。\n\nCollector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：  \n![常见收集器方法](https://kubpang.gitee.io/sourceFile/Java/JDK/常见收集器方法.png)\n\n案例：\n```java\npublic void test1() {\n    // 转collection\n    Set<User> set = all.stream().collect(Collectors.toSet());\n    List<Integer> list = all.stream().map(User::getId).collect(Collectors.toList());\n    // 转map\n    Map<String, User> map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));\n    // 转map，处理key相同的元素\n    Map<String, User> map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -> x));\n    // 根据属性分组\n    Map<String, List<User>> sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));\n}\n```\n\n# 并行流 与 串行流\n\n# 新时间日期API\n\n在旧版的java中，日期时间API存在诸多问题，其中有：  \n1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一  \n2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。  \n3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。\n\n**因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。**\n\nJava8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：  \nLocal（本地）  简化了日期的处理，没有时区的问题。  \nZoned（时区）  通过制定的时区处理日期时间。  \n新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n\n## 常用类简介\n\nInstat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\nPeriod：用于计算日期间隔  \nDuration：用于计算时间间隔  \n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime\n\nZoneld：时区  \nZonedDateTime：表示日期+时间+时区值\n\nDateTimeFormatter：用于日期时间的格式化\n\n## 本地化日期时间API\n\nLocalDate：表示日期  \nLcalTime：表示时间  \nLocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime\n\n公共API：  \nnow()：静态方法，根据当前时间创建对象。  \nof()：静态方法，根据指定的日期/时间创建对象。\n\nLocalDate 与 LocalDateTime公共API：  \ngetYear()：获取年份  \ngetMonth()：获取月份，返回一个Month的枚举  \ngetMonthValue()：获取月份  \ngetDayOfMonth()：获取当前月份天数【1-31】  \ngetDayOfYear()：获取当前年份天数【1-366】  \ngetDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举  \nplus()：添加一个 Duration 或 Period  \nminus()：删除一个 Duration 或 Period\nplusDays(); plusWeeks(); plusMonths(); plusYears()：  \n向当前对象，新增几天，几周，几月，几年。\nminusDays(); minusWeeks(); minusMonths(); minusYears()：  \n向当前对象，减去几天，几周，几月，几年。\nwithDayOfMonth()：修改当前月的天数  \nwithDayOfYear()：修改当前年的天数\n\nLocalTime 与 LocalDateTime公共API：  \ngetHour()：获取小时  \ngetMinute()：获取分钟  \ngetSecond()：获取秒\n\n## 时区日期时间API\n\n## Instant 时间戳\n\nJava8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）\n如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。\n\n用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n\nInstant API方法：  \ngetEpochSecond()：获取秒数  \ntoEpochMilli()：获取毫秒数  \ngetNano()：获取纳秒数  \nSystem.currentTimeMillis()：获取时间戳，毫秒级别。\n\n```java\nInstant instant = Instant.now();\n// 获取秒数\nlong currentSecond = instant.getEpochSecond();\n// 获取毫秒数\nlong currentMilli = instant.toEpochMilli();\n// 时间戳\nlong currentTimeMilli = System.currentTimeMillis();\nSystem.out.println(currentSecond);\nSystem.out.println(currentMilli);\nSystem.out.println(instant);\nSystem.out.println(currentTimeMilli);\n```\n\n## Period 日期间隔\n\nJava8新提供Period来表示一个日期段，日期间隔。\n\nPeriod API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Period实例  \ngetYears();\t\t\t获取这段日期的相隔年数  \ngetMonths(); \t\t获取单纯月份比较，相隔几月  \ngetDays(); \t\t\t获取单纯天数比较，相隔几天\n\n```java\n// 1999-06-24\nLocalDate from = LocalDate.of(1999, Month.MAY, 24);\n// 2020-08-20\nLocalDate to = LocalDate.of(2020, Month.JULY, 20);\n\nPeriod period = Period.between(from, to);\nint years = period.getYears(); // 这段日期的相隔年数\nint months = period.getMonths(); // 单纯月份比较，相隔几月\nint days = period.getDays(); // 单纯天数比较，相隔几天\n```\n\n## Duration 时间间隔\n\nJava8新提供Duration来表示一个时间段，时间间隔。\n\nDuration API方法：  \nBetween(from, to)：\t获取两个日期的间隔，返回Duration实例  \ntoDays()：\t\t获取这段时间的天数  \ntoHours()：\t\t获取这段时间的小时  \ntoMinutes()：\t\t获取这段时间的分钟数  \ngetSeconds()：\t获取这段时间的秒数  \ntoMillis()：\t\t获取这段时间的毫秒数  \ntoNanos()：\t\t获取这段时间的纳秒数\n\n```java\n@Test\npublic void durationTest() {\n    // 1999-06-24 00:00:00\n    LocalDateTime from = LocalDateTime.of(1999, Month.MAY, 24, 0, 0, 0);\n    // 2020-08-20 00:00:00\n    LocalDateTime to = LocalDateTime.of(2020, Month.JULY, 20, 0, 0, 0);\n\n    Duration duration = Duration.between(from, to);\n\n    long days = duration.toDays();// 这段时间的天数\n    long hours = duration.toHours();// 这段时间的小时\n    long minutes  = duration.toMinutes();// 这段时间的分钟数\n    long seconds = duration.getSeconds();// 这段时间的秒数\n    long milliSeconds = duration.toMillis();// 这段时间的毫秒数\n    long nanos = duration.toNanos();// 这段时间的纳秒数\n\n    System.out.println(days);\n    System.out.println(hours);\n    System.out.println(minutes);\n    System.out.println(seconds);\n    System.out.println(milliSeconds);\n    System.out.println(nanos);\n}\n```\n\n## 解析与格式化\n\n格式化时间：  \nJava8新提供DateTimeFormatter来格式化时间。\n\n解析时间：  \n使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。\n\n格式化时间demo：\n```java\nLocalDateTime now = LocalDateTime.now();\nString s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);\nString s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = formatter.format(now);\n```\n\n解析时间Demo：\n```java\nLocalDate localDate = LocalDate.parse(\"2020-10-01\");\nLocalDateTime localDateTime = LocalDateTime.parse(\"2020-10-01T15:15:15\");\nLocalDateTime copyLocalDateTime = LocalDateTime.parse(\"2020-10-01 15:15:15\", DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));\n```\n\n# 接口中的默认方法 与 静态方法\n\n## 默认方法\n\nJava8新增了接口的默认方法。  \n简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n\n为什么要有这个特性：  \n首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。  \n然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。\n\n接口默认方法语法格式：\n```java\npublic interface MyInterface {\n\n    default String getStr() {\n        return \"hello interface default method\";\n    }\n\n}\n```\n\n## 默认方法的问题\n\n如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：\n\n接口冲突：\n如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。\n\n类优先原则：\n如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。\n\n接口冲突案例：\n```java\npublic interface Dog {\n\n    default void call() {\n        System.out.println(\"我是狗，汪汪汪\");\n    }\n\n}\n\npublic interface Cat {\n\n    default void call() {\n        System.out.println(\"我是猫，喵喵喵\");\n    }\n\n}\n\npublic class Demo implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n\n    @Override\n    public void call() {\n        Dog.super.call();\n        Cat.super.call();\n        System.out.println(\"我是demo\");\n    }\n}\n```\n\n类优先原则：\n```java\npublic abstract class BaseClass {\n\n    public void call() {\n        System.out.println(\"我是baseClass\");\n    }\n\n}\n\npublic class Demo extends BaseClass implements Dog, Cat {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.call();\n    }\n    \n}\n```\n\n## 静态方法\n\nJava8的另一个特性是接口可以声明（并且可以提供实现）静态方法。\n\n接口静态方法语法格式：\n```java\npublic interface MyInterface {\n\n    static String getStr() {\n        return \"hello interface static method\";\n    }\n\n}\n```\n\n# Optional 类\n\n## Optional 类简介\n\nOptional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。\n\nOptional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。\n\nOptional 类的引入，可以很好的解决空指针异常。\nOptional 类可以很好的判断一个值存在或者不存在。\n\n## 常用方法\n\n```\nOptional.get()               获取Optional容器包含的值，如果值为null，抛出异常\n\nOptional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常\nOptional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例\nOptional .empty()\t\t\t创建一个空的Optional 实例\n\nOptional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false\nOrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t\nOrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值\nMap(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()\nflatMap(function f)\t\t\t与map类型，要求返回Optional\n```\n\n案例：\n```java\n    @Test\n    public void methodDemo() {\n        // optional.of创建optional实例，t不能为空，为null，抛出异常\n        Optional<Integer> integerOptional = Optional.of(1);\n        // optional.ofNullable创建optional实例，t如果为空，返回一个空的optional\n        Optional<User> userOptional = Optional.ofNullable(null);\n        // optional.empty创建一个空值得optional实例\n        Optional<Object> empty = Optional.empty();\n\n\n    //        // get，optional如果值为空，抛出异常\n    //        integerOptional.get();\n    //        userOptional.get();\n    //        empty.get();\n\n        System.out.println(userOptional.isPresent());\n\n        // 如果值不为空，则返回，如果为空，则返回给定的值\n        Integer integer = integerOptional.orElse(3);\n        User user = userOptional.orElse(new User());\n        Object o = empty.orElse(new BigDecimal(\"100\"));\n\n        System.out.println(integer);\n        System.out.println(user);\n        System.out.println(o);\n    }\n```","slug":"oyr/Java/Java8新特性","published":1,"updated":"2021-09-01T02:47:03.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l8364000whct72iafhchl","content":"<h1 id=\"Java8新特性简介\"><a href=\"#Java8新特性简介\" class=\"headerlink\" title=\"Java8新特性简介\"></a>Java8新特性简介</h1><p>1）速度更快<br>2）代码更少（增加了新的语法Lambda表达式）<br>3）强大的Stream API<br>4）便于并行<br>5）最大化减少空指针异常 Optional</p>\n<p><strong>其中 Lambda 表达式与 Stream API 最为核心的。</strong></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"什么是Lambda-表达式\"><a href=\"#什么是Lambda-表达式\" class=\"headerlink\" title=\"什么是Lambda 表达式\"></a>什么是Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>Lambda 表达式的基础语法：<br>Java8中引入了一个新操作符：“-&gt;”该操作符被称为剪头操作符或 Lambda 操作符。</p>\n<p>箭头操作符将 Lambda 表达式拆分成两部分：<br>左侧：指定了 Lambda 表达式需要的所有参数。<br>右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。<br>列如：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<p>特征：<br>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>\n<p>上联：左右遇一括号省<br>下联：左侧推断类型省<br>横批：能省则省</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>1）语法格式一：无参，无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable runnable = () -&gt; System.out.println(<span class=\"string\">&quot;hello lambda!!!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>2）语法格式二：有一个参数，并且无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>3）语法格式三：若只有一个参数，小括号可以省略不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;开始比较&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda表达式需要“函数式接口”的支持\"><a href=\"#Lambda表达式需要“函数式接口”的支持\" class=\"headerlink\" title=\"Lambda表达式需要“函数式接口”的支持\"></a>Lambda表达式需要“函数式接口”的支持</h2><p>详情看：函数式接口</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式接口？\"><a href=\"#什么是函数式接口？\" class=\"headerlink\" title=\"什么是函数式接口？\"></a>什么是函数式接口？</h2><p>函数式接口：<br>接口中只有一个抽象方法的接口，称为函数式接口。<br>可以使用注解 @FunctionalInterface 修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span>    <span class=\"comment\">// 表示这是函数式接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFun</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getValue</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;多一个方法就报错</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java8-内置的四大核心函数式接口\"><a href=\"#Java8-内置的四大核心函数式接口\" class=\"headerlink\" title=\"Java8 内置的四大核心函数式接口\"></a>Java8 内置的四大核心函数式接口</h2><p>1）Consumer<T>：消费型接口<br>Void accept(T t)</p>\n<p>2）Supplier<T>：供给型接口<br>T get();</p>\n<p>3）Function&lt;T, R&gt;：函数型接口<br>R apply(T t);</p>\n<p>4）Predicate<T>：断言型接口<br>Boolean test(T t);</p>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png\" alt=\"其他函数式接口\"></p>\n<h1 id=\"方法引用与构造函数引用\"><a href=\"#方法引用与构造函数引用\" class=\"headerlink\" title=\"方法引用与构造函数引用\"></a>方法引用与构造函数引用</h1><h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用：<br>若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”<br>（可以理解为方法引用是Lambda表达式的另外一种表现方式）<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>方法引用三种语法格式：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：实例对象::实例方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第二种：类::静态方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第三种：类::实例方法名</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。<br>（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法引用：对象::方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);</span><br><span class=\"line\">    Consumer&lt;String&gt; con2 = System.out::print;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup1 = () -&gt; user.getName();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup2 = user::getName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名::静态方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名：实例方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y);</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>语法格式：Class :: method</p>\n<p>注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造器引用：类名::new</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用无参构造</span></span><br><span class=\"line\">    Supplier&lt;User&gt; su1 = () -&gt; <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;User&gt; su2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器</span></span><br><span class=\"line\">    Function&lt;Integer, User&gt; fun1 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器</span></span><br><span class=\"line\">    BiFunction&lt;String, Integer, User&gt; fun2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><h2 id=\"了解Stream-API\"><a href=\"#了解Stream-API\" class=\"headerlink\" title=\"了解Stream API\"></a>了解Stream API</h2><p>Java8中有两大最为重要的改变：<br>第一个是Lambda表达式；<br>第二个则是Stream API（java.util.stream.*）；  </p>\n<p>Stream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。<br>使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。</p>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>流（Stream）到底是什么呢？<br>是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！！！”</p>\n<p>注意：<br>1）Stream 自己不会存储元素<br>2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream<br>3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）</p>\n<h2 id=\"Stream的三个操作步骤\"><a href=\"#Stream的三个操作步骤\" class=\"headerlink\" title=\"Stream的三个操作步骤\"></a>Stream的三个操作步骤</h2><p>1）创建Stream<br>一个数据源（如：集合，数组），获取一个流</p>\n<p>2）中间操作<br>一个中间操作链，对数据源的数据进行处理（过滤，映射）</p>\n<p>3）终止操作（终端操作，返回结果）<br>一个终止操作，执行中间操作链，并且产生结果</p>\n<p>流程图：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/Stream%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"Stream操作流程图\"></p>\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><h3 id=\"集合创建Stream\"><a href=\"#集合创建Stream\" class=\"headerlink\" title=\"集合创建Stream\"></a>集合创建Stream</h3><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：<br>default Stream<E> stream() : 返回一个顺序流<br>default Stream<E> parallelStream() : 返回一个并行流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// List Set 继承至 Collection</span></span><br><span class=\"line\">    all.stream().forEach(System.out::println);</span><br><span class=\"line\">    all.parallelStream().forEach(System.out::println);</span><br><span class=\"line\">    map.values().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组创建Stream\"><a href=\"#数组创建Stream\" class=\"headerlink\" title=\"数组创建Stream\"></a>数组创建Stream</h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<br>static <T> Stream<T> stream(T[] array): 返回一个流。</p>\n<p>重载形式，能够处理对应基本类型的数组：<br>public static IntStream stream(int[] array)<br>public static LongStream stream(long[] array)<br>public static DoubleStream stream(double[] array)</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] intArr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    String[] strArr = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>&#125;;</span><br><span class=\"line\">    Arrays.stream(intArr).forEach(System.out::println);</span><br><span class=\"line\">    Arrays.stream(strArr).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值创建Stream\"><a href=\"#值创建Stream\" class=\"headerlink\" title=\"值创建Stream\"></a>值创建Stream</h3><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：<br>public static<T> Stream<T> of(T… values) : 返回一个流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).parallel().forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"keyword\">new</span> User(<span class=\"number\">50</span>, <span class=\"string\">&quot;张三&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">60</span>, <span class=\"string\">&quot;李四&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">11</span>, <span class=\"string\">&quot;王五&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数创建Stream（无限流）\"><a href=\"#函数创建Stream（无限流）\" class=\"headerlink\" title=\"函数创建Stream（无限流）\"></a>函数创建Stream（无限流）</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。<br>迭代：<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);</p>\n<p>生成：<br>public static<T> Stream<T> generate(Supplier<T> s);</p>\n<h2 id=\"Stream的中间操作\"><a href=\"#Stream的中间操作\" class=\"headerlink\" title=\"Stream的中间操作\"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!<br>而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。</p>\n<h3 id=\"筛选与切片\"><a href=\"#筛选与切片\" class=\"headerlink\" title=\"筛选与切片\"></a>筛选与切片</h3><p>filter(Predicate p)：接收Lambda，从Stream流中排除某些元素。</p>\n<p>distinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。</p>\n<p>limit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。</p>\n<p>skip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    all.stream().limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().skip(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct()</span><br><span class=\"line\">            .filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .skip(<span class=\"number\">5</span>)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>map(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>\n<p>flatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().map(user -&gt; user.getName())</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    all.stream().flatMap(user -&gt; Stream.of(user.getName()))</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>sorted()：自然排序，使用Comparable默认排序。</p>\n<p>sorted(Comparator comparator)：定制排序，使用Comparator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;ddd&quot;</span>, <span class=\"string\">&quot;zzz&quot;</span>);</span><br><span class=\"line\">    strings.stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    all.stream().sorted((x, y) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.getAge().equals(y.getAge())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x.getName().compareTo(y.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.getAge().compareTo(y.getAge());</span><br><span class=\"line\">    &#125;).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的终止操作\"><a href=\"#Stream的终止操作\" class=\"headerlink\" title=\"Stream的终止操作\"></a>Stream的终止操作</h2><h3 id=\"查找与匹配\"><a href=\"#查找与匹配\" class=\"headerlink\" title=\"查找与匹配\"></a>查找与匹配</h3><p>Find查找：<br>findFirst() ：返回第一个元素<br>findAny() ：返回当前流中的任意元素<br>count() ：返回流中元素总个数<br>max(Comparator c) ：返回流中最大值<br>min(Comparator c) ：返回流中最小值  </p>\n<p>Match匹配：<br>allMatch(Predicate p) ：检查是否匹配所有元素<br>anyMatch(Predicate p) ：检查是否至少匹配一个元素<br>noneMatch(Predicate p) ：检查是否没有匹配所有元素</p>\n<p>Final 查找案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Optional&lt;User&gt; firstOptional = all.stream().findFirst();</span><br><span class=\"line\">    Optional&lt;User&gt; anyOptional = all.stream().findAny();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> count = all.stream().count();</span><br><span class=\"line\">    Optional&lt;User&gt; maxOptional = all.stream().max(Comparator.comparing(User::getAge));</span><br><span class=\"line\">    Optional&lt;Integer&gt; minOptional = all.stream().map(User::getAge).min(Integer::compareTo);</span><br><span class=\"line\">    System.out.println(firstOptional.get());</span><br><span class=\"line\">    System.out.println(anyOptional.get());</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\">    System.out.println(maxOptional.get());</span><br><span class=\"line\">    System.out.println(minOptional.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Match 匹配Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> allMatch = all.stream().allMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> anyMatch = all.stream().anyMatch(x -&gt; UserStatus.B == (x.getStatus()));</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> noneMatch = all.stream().noneMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"规约\"><a href=\"#规约\" class=\"headerlink\" title=\"规约\"></a>规约</h3><p>reduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。</p>\n<p>reduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reduceTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -&gt; &#123;</span><br><span class=\"line\">        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.add(n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h3><p>collect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。</p>\n<p>Collector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/%E5%B8%B8%E8%A7%81%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B9%E6%B3%95.png\" alt=\"常见收集器方法\"></p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 转collection</span></span><br><span class=\"line\">    Set&lt;User&gt; set = all.stream().collect(Collectors.toSet());</span><br><span class=\"line\">    List&lt;Integer&gt; list = all.stream().map(User::getId).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// 转map</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));</span><br><span class=\"line\">    <span class=\"comment\">// 转map，处理key相同的元素</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -&gt; x));</span><br><span class=\"line\">    <span class=\"comment\">// 根据属性分组</span></span><br><span class=\"line\">    Map&lt;String, List&lt;User&gt;&gt; sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"并行流-与-串行流\"><a href=\"#并行流-与-串行流\" class=\"headerlink\" title=\"并行流 与 串行流\"></a>并行流 与 串行流</h1><h1 id=\"新时间日期API\"><a href=\"#新时间日期API\" class=\"headerlink\" title=\"新时间日期API\"></a>新时间日期API</h1><p>在旧版的java中，日期时间API存在诸多问题，其中有：<br>1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一<br>2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。<br>3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</p>\n<p><strong>因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。</strong></p>\n<p>Java8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：<br>Local（本地）  简化了日期的处理，没有时区的问题。<br>Zoned（时区）  通过制定的时区处理日期时间。<br>新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>\n<h2 id=\"常用类简介\"><a href=\"#常用类简介\" class=\"headerlink\" title=\"常用类简介\"></a>常用类简介</h2><p>Instat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>Period：用于计算日期间隔<br>Duration：用于计算时间间隔  </p>\n<p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime</p>\n<p>Zoneld：时区<br>ZonedDateTime：表示日期+时间+时区值</p>\n<p>DateTimeFormatter：用于日期时间的格式化</p>\n<h2 id=\"本地化日期时间API\"><a href=\"#本地化日期时间API\" class=\"headerlink\" title=\"本地化日期时间API\"></a>本地化日期时间API</h2><p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime</p>\n<p>公共API：<br>now()：静态方法，根据当前时间创建对象。<br>of()：静态方法，根据指定的日期/时间创建对象。</p>\n<p>LocalDate 与 LocalDateTime公共API：<br>getYear()：获取年份<br>getMonth()：获取月份，返回一个Month的枚举<br>getMonthValue()：获取月份<br>getDayOfMonth()：获取当前月份天数【1-31】<br>getDayOfYear()：获取当前年份天数【1-366】<br>getDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举<br>plus()：添加一个 Duration 或 Period<br>minus()：删除一个 Duration 或 Period<br>plusDays(); plusWeeks(); plusMonths(); plusYears()：<br>向当前对象，新增几天，几周，几月，几年。<br>minusDays(); minusWeeks(); minusMonths(); minusYears()：<br>向当前对象，减去几天，几周，几月，几年。<br>withDayOfMonth()：修改当前月的天数<br>withDayOfYear()：修改当前年的天数</p>\n<p>LocalTime 与 LocalDateTime公共API：<br>getHour()：获取小时<br>getMinute()：获取分钟<br>getSecond()：获取秒</p>\n<h2 id=\"时区日期时间API\"><a href=\"#时区日期时间API\" class=\"headerlink\" title=\"时区日期时间API\"></a>时区日期时间API</h2><h2 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h2><p>Java8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。</p>\n<p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。</p>\n<p>Instant API方法：<br>getEpochSecond()：获取秒数<br>toEpochMilli()：获取毫秒数<br>getNano()：获取纳秒数<br>System.currentTimeMillis()：获取时间戳，毫秒级别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant instant = Instant.now();</span><br><span class=\"line\"><span class=\"comment\">// 获取秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentSecond = instant.getEpochSecond();</span><br><span class=\"line\"><span class=\"comment\">// 获取毫秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentMilli = instant.toEpochMilli();</span><br><span class=\"line\"><span class=\"comment\">// 时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentTimeMilli = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(currentSecond);</span><br><span class=\"line\">System.out.println(currentMilli);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\">System.out.println(currentTimeMilli);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Period-日期间隔\"><a href=\"#Period-日期间隔\" class=\"headerlink\" title=\"Period 日期间隔\"></a>Period 日期间隔</h2><p>Java8新提供Period来表示一个日期段，日期间隔。</p>\n<p>Period API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Period实例<br>getYears();            获取这段日期的相隔年数<br>getMonths();         获取单纯月份比较，相隔几月<br>getDays();             获取单纯天数比较，相隔几天</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1999-06-24</span></span><br><span class=\"line\">LocalDate from = LocalDate.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2020-08-20</span></span><br><span class=\"line\">LocalDate to = LocalDate.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Period period = Period.between(from, to);</span><br><span class=\"line\"><span class=\"keyword\">int</span> years = period.getYears(); <span class=\"comment\">// 这段日期的相隔年数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> months = period.getMonths(); <span class=\"comment\">// 单纯月份比较，相隔几月</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> days = period.getDays(); <span class=\"comment\">// 单纯天数比较，相隔几天</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Duration-时间间隔\"><a href=\"#Duration-时间间隔\" class=\"headerlink\" title=\"Duration 时间间隔\"></a>Duration 时间间隔</h2><p>Java8新提供Duration来表示一个时间段，时间间隔。</p>\n<p>Duration API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Duration实例<br>toDays()：        获取这段时间的天数<br>toHours()：        获取这段时间的小时<br>toMinutes()：        获取这段时间的分钟数<br>getSeconds()：    获取这段时间的秒数<br>toMillis()：        获取这段时间的毫秒数<br>toNanos()：        获取这段时间的纳秒数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">durationTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1999-06-24 00:00:00</span></span><br><span class=\"line\">    LocalDateTime from = LocalDateTime.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2020-08-20 00:00:00</span></span><br><span class=\"line\">    LocalDateTime to = LocalDateTime.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Duration duration = Duration.between(from, to);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> days = duration.toDays();<span class=\"comment\">// 这段时间的天数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> hours = duration.toHours();<span class=\"comment\">// 这段时间的小时</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> minutes  = duration.toMinutes();<span class=\"comment\">// 这段时间的分钟数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> seconds = duration.getSeconds();<span class=\"comment\">// 这段时间的秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> milliSeconds = duration.toMillis();<span class=\"comment\">// 这段时间的毫秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = duration.toNanos();<span class=\"comment\">// 这段时间的纳秒数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(days);</span><br><span class=\"line\">    System.out.println(hours);</span><br><span class=\"line\">    System.out.println(minutes);</span><br><span class=\"line\">    System.out.println(seconds);</span><br><span class=\"line\">    System.out.println(milliSeconds);</span><br><span class=\"line\">    System.out.println(nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析与格式化\"><a href=\"#解析与格式化\" class=\"headerlink\" title=\"解析与格式化\"></a>解析与格式化</h2><p>格式化时间：<br>Java8新提供DateTimeFormatter来格式化时间。</p>\n<p>解析时间：<br>使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。</p>\n<p>格式化时间demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">String s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);</span><br><span class=\"line\">String s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);</span><br><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">String format = formatter.format(now);</span><br></pre></td></tr></table></figure>\n\n<p>解析时间Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate localDate = LocalDate.parse(<span class=\"string\">&quot;2020-10-01&quot;</span>);</span><br><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01T15:15:15&quot;</span>);</span><br><span class=\"line\">LocalDateTime copyLocalDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01 15:15:15&quot;</span>, DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"接口中的默认方法-与-静态方法\"><a href=\"#接口中的默认方法-与-静态方法\" class=\"headerlink\" title=\"接口中的默认方法 与 静态方法\"></a>接口中的默认方法 与 静态方法</h1><h2 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h2><p>Java8新增了接口的默认方法。<br>简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>\n<p>为什么要有这个特性：<br>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。<br>然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。</p>\n<p>接口默认方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface default method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认方法的问题\"><a href=\"#默认方法的问题\" class=\"headerlink\" title=\"默认方法的问题\"></a>默认方法的问题</h2><p>如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p>\n<p>接口冲突：<br>如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。</p>\n<p>类优先原则：<br>如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。</p>\n<p>接口冲突案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是狗，汪汪汪&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是猫，喵喵喵&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dog.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        Cat.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是demo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类优先原则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是baseClass&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>Java8的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>\n<p>接口静态方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface static method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Optional-类\"><a href=\"#Optional-类\" class=\"headerlink\" title=\"Optional 类\"></a>Optional 类</h1><h2 id=\"Optional-类简介\"><a href=\"#Optional-类简介\" class=\"headerlink\" title=\"Optional 类简介\"></a>Optional 类简介</h2><p>Optional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。</p>\n<p>Optional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。</p>\n<p>Optional 类的引入，可以很好的解决空指针异常。<br>Optional 类可以很好的判断一个值存在或者不存在。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional.get()               获取Optional容器包含的值，如果值为null，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常</span><br><span class=\"line\">Optional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例</span><br><span class=\"line\">Optional .empty()\t\t\t创建一个空的Optional 实例</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false</span><br><span class=\"line\">OrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t</span><br><span class=\"line\">OrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值</span><br><span class=\"line\">Map(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()</span><br><span class=\"line\">flatMap(function f)\t\t\t与map类型，要求返回Optional</span><br></pre></td></tr></table></figure>\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// optional.of创建optional实例，t不能为空，为null，抛出异常</span></span><br><span class=\"line\">    Optional&lt;Integer&gt; integerOptional = Optional.of(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.ofNullable创建optional实例，t如果为空，返回一个空的optional</span></span><br><span class=\"line\">    Optional&lt;User&gt; userOptional = Optional.ofNullable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.empty创建一个空值得optional实例</span></span><br><span class=\"line\">    Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        // get，optional如果值为空，抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//        integerOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        userOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        empty.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(userOptional.isPresent());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果值不为空，则返回，如果为空，则返回给定的值</span></span><br><span class=\"line\">    Integer integer = integerOptional.orElse(<span class=\"number\">3</span>);</span><br><span class=\"line\">    User user = userOptional.orElse(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">    Object o = empty.orElse(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;100&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(integer);</span><br><span class=\"line\">    System.out.println(user);</span><br><span class=\"line\">    System.out.println(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Java8新特性简介\"><a href=\"#Java8新特性简介\" class=\"headerlink\" title=\"Java8新特性简介\"></a>Java8新特性简介</h1><p>1）速度更快<br>2）代码更少（增加了新的语法Lambda表达式）<br>3）强大的Stream API<br>4）便于并行<br>5）最大化减少空指针异常 Optional</p>\n<p><strong>其中 Lambda 表达式与 Stream API 最为核心的。</strong></p>","more":"<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><h2 id=\"什么是Lambda-表达式\"><a href=\"#什么是Lambda-表达式\" class=\"headerlink\" title=\"什么是Lambda 表达式\"></a>什么是Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，一个匿名函数，它是推动 Java 8 发布的最重要新特性。<br>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>Lambda 表达式的基础语法：<br>Java8中引入了一个新操作符：“-&gt;”该操作符被称为剪头操作符或 Lambda 操作符。</p>\n<p>箭头操作符将 Lambda 表达式拆分成两部分：<br>左侧：指定了 Lambda 表达式需要的所有参数。<br>右侧：指定了 Lambda 体，即 Lambda 表达式所需执行的功能。<br>列如：(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<p>特征：<br>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>\n<p>上联：左右遇一括号省<br>下联：左侧推断类型省<br>横批：能省则省</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>1）语法格式一：无参，无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable runnable = () -&gt; System.out.println(<span class=\"string\">&quot;hello lambda!!!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>2）语法格式二：有一个参数，并且无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>3）语法格式三：若只有一个参数，小括号可以省略不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>4）语法格式四：有两个以上参数，有返回值，并且Lambda体中有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;开始比较&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>5）语法格式五：若Lambda体中只有一条语句，return和大括号都可不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<p>（6）语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为jvm通过上下文推断出，数据类型，即‘类型推断’</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lambda表达式需要“函数式接口”的支持\"><a href=\"#Lambda表达式需要“函数式接口”的支持\" class=\"headerlink\" title=\"Lambda表达式需要“函数式接口”的支持\"></a>Lambda表达式需要“函数式接口”的支持</h2><p>详情看：函数式接口</p>\n<h1 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h1><h2 id=\"什么是函数式接口？\"><a href=\"#什么是函数式接口？\" class=\"headerlink\" title=\"什么是函数式接口？\"></a>什么是函数式接口？</h2><p>函数式接口：<br>接口中只有一个抽象方法的接口，称为函数式接口。<br>可以使用注解 @FunctionalInterface 修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span>    <span class=\"comment\">// 表示这是函数式接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyFun</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getValue</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;多一个方法就报错</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java8-内置的四大核心函数式接口\"><a href=\"#Java8-内置的四大核心函数式接口\" class=\"headerlink\" title=\"Java8 内置的四大核心函数式接口\"></a>Java8 内置的四大核心函数式接口</h2><p>1）Consumer<T>：消费型接口<br>Void accept(T t)</p>\n<p>2）Supplier<T>：供给型接口<br>T get();</p>\n<p>3）Function&lt;T, R&gt;：函数型接口<br>R apply(T t);</p>\n<p>4）Predicate<T>：断言型接口<br>Boolean test(T t);</p>\n<h2 id=\"其他接口\"><a href=\"#其他接口\" class=\"headerlink\" title=\"其他接口\"></a>其他接口</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png\" alt=\"其他函数式接口\"></p>\n<h1 id=\"方法引用与构造函数引用\"><a href=\"#方法引用与构造函数引用\" class=\"headerlink\" title=\"方法引用与构造函数引用\"></a>方法引用与构造函数引用</h1><h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用：<br>若 Lambda 体中的内容有方法已经实现了，我们可以使用“方法引用”<br>（可以理解为方法引用是Lambda表达式的另外一种表现方式）<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>方法引用三种语法格式：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：实例对象::实例方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第二种：类::静态方法名  </span><br><span class=\"line\"></span><br><span class=\"line\">第三种：类::实例方法名</span><br></pre></td></tr></table></figure>\n\n<p>注意：<br>（1）Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的参数列表和返回值保持一致。<br>（2）若Lambda 参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用类::实例方法名。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法引用：对象::方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);</span><br><span class=\"line\">    Consumer&lt;String&gt; con2 = System.out::print;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup1 = () -&gt; user.getName();</span><br><span class=\"line\">    Supplier&lt;String&gt; sup2 = user::getName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名::静态方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法引用：类名：实例方法名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y);</span><br><span class=\"line\">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造器引用\"><a href=\"#构造器引用\" class=\"headerlink\" title=\"构造器引用\"></a>构造器引用</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>语法格式：Class :: method</p>\n<p>注意：需要调用的构造器的参数列表与返回值，要与函数式接口中的抽象方法的参数列表与返回值保持一致。</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造器引用：类名::new</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用无参构造</span></span><br><span class=\"line\">    Supplier&lt;User&gt; su1 = () -&gt; <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    Supplier&lt;User&gt; su2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为integer类型的构造器</span></span><br><span class=\"line\">    Function&lt;Integer, User&gt; fun1 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对应函数式接口的抽象方法，当前调用参数为string,integer的构造器</span></span><br><span class=\"line\">    BiFunction&lt;String, Integer, User&gt; fun2 = User::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Stream-API\"><a href=\"#Stream-API\" class=\"headerlink\" title=\"Stream API\"></a>Stream API</h1><h2 id=\"了解Stream-API\"><a href=\"#了解Stream-API\" class=\"headerlink\" title=\"了解Stream API\"></a>了解Stream API</h2><p>Java8中有两大最为重要的改变：<br>第一个是Lambda表达式；<br>第二个则是Stream API（java.util.stream.*）；  </p>\n<p>Stream API是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找，过滤，映射数据等操作。<br>使用Stream API对集合数据进行操作，就类似使用SQL执行的数据库查询。也可以使用Stream API来执行并行操作。简而言之，Stream API提供了一种高效且易于使用的处理数据的方式。</p>\n<h2 id=\"什么是Stream\"><a href=\"#什么是Stream\" class=\"headerlink\" title=\"什么是Stream\"></a>什么是Stream</h2><p>流（Stream）到底是什么呢？<br>是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！！！”</p>\n<p>注意：<br>1）Stream 自己不会存储元素<br>2）Stream 不会改变源对象。相反，它会返回一个持有结果的新Stream<br>3）Stream 操作是延迟执行的。这意味着它会等到需要结果的时候才执行（懒加载概念）</p>\n<h2 id=\"Stream的三个操作步骤\"><a href=\"#Stream的三个操作步骤\" class=\"headerlink\" title=\"Stream的三个操作步骤\"></a>Stream的三个操作步骤</h2><p>1）创建Stream<br>一个数据源（如：集合，数组），获取一个流</p>\n<p>2）中间操作<br>一个中间操作链，对数据源的数据进行处理（过滤，映射）</p>\n<p>3）终止操作（终端操作，返回结果）<br>一个终止操作，执行中间操作链，并且产生结果</p>\n<p>流程图：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/Stream%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"Stream操作流程图\"></p>\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><h3 id=\"集合创建Stream\"><a href=\"#集合创建Stream\" class=\"headerlink\" title=\"集合创建Stream\"></a>集合创建Stream</h3><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：<br>default Stream<E> stream() : 返回一个顺序流<br>default Stream<E> parallelStream() : 返回一个并行流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// List Set 继承至 Collection</span></span><br><span class=\"line\">    all.stream().forEach(System.out::println);</span><br><span class=\"line\">    all.parallelStream().forEach(System.out::println);</span><br><span class=\"line\">    map.values().stream().forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组创建Stream\"><a href=\"#数组创建Stream\" class=\"headerlink\" title=\"数组创建Stream\"></a>数组创建Stream</h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：<br>static <T> Stream<T> stream(T[] array): 返回一个流。</p>\n<p>重载形式，能够处理对应基本类型的数组：<br>public static IntStream stream(int[] array)<br>public static LongStream stream(long[] array)<br>public static DoubleStream stream(double[] array)</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] intArr = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    String[] strArr = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>&#125;;</span><br><span class=\"line\">    Arrays.stream(intArr).forEach(System.out::println);</span><br><span class=\"line\">    Arrays.stream(strArr).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值创建Stream\"><a href=\"#值创建Stream\" class=\"headerlink\" title=\"值创建Stream\"></a>值创建Stream</h3><p>可以使用静态方法 Stream.of(), 通过显示值创建一个流，它可以接收任意数量的参数：<br>public static<T> Stream<T> of(T… values) : 返回一个流</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;d&quot;</span>).parallel().forEach(System.out::println);</span><br><span class=\"line\">    Stream.of(<span class=\"keyword\">new</span> User(<span class=\"number\">50</span>, <span class=\"string\">&quot;张三&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">60</span>, <span class=\"string\">&quot;李四&quot;</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> User(<span class=\"number\">11</span>, <span class=\"string\">&quot;王五&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数创建Stream（无限流）\"><a href=\"#函数创建Stream（无限流）\" class=\"headerlink\" title=\"函数创建Stream（无限流）\"></a>函数创建Stream（无限流）</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。<br>迭代：<br>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f);</p>\n<p>生成：<br>public static<T> Stream<T> generate(Supplier<T> s);</p>\n<h2 id=\"Stream的中间操作\"><a href=\"#Stream的中间操作\" class=\"headerlink\" title=\"Stream的中间操作\"></a>Stream的中间操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理!<br>而在终止操作时一次性全部处理，称为“惰性求值”（类似mybtais的懒加载，redis的惰性删除，只有最后使用时才会真正执行）。</p>\n<h3 id=\"筛选与切片\"><a href=\"#筛选与切片\" class=\"headerlink\" title=\"筛选与切片\"></a>筛选与切片</h3><p>filter(Predicate p)：接收Lambda，从Stream流中排除某些元素。</p>\n<p>distinct()：筛选，通过Stream流所生成元素的 hashCode() 和 equals() 去除重复元素。</p>\n<p>limit(long maxSize)：截断Stream流，使其返回元素不超过指定数量。</p>\n<p>skip(long n)：跳过元素，返回扔掉前n个元素的流，若流中元素不足n个，则返回一个空流。与limit(n) 互补。</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct().forEach(System.out::println);</span><br><span class=\"line\">    all.stream().limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().skip(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\">    all.stream().distinct()</span><br><span class=\"line\">            .filter(user -&gt; user.getAge() &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">            .limit(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .skip(<span class=\"number\">5</span>)</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>map(Function mapper)：接受一个函数（lambda）作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>\n<p>flatMap(Function mapper)：接受一个函数（lambda）作为参数，将流中每个元素都转成一个流，然后把全部流连成一个流返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    all.stream().map(user -&gt; user.getName())</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    all.stream().flatMap(user -&gt; Stream.of(user.getName()))</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>sorted()：自然排序，使用Comparable默认排序。</p>\n<p>sorted(Comparator comparator)：定制排序，使用Comparator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">&quot;ccc&quot;</span>, <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;ddd&quot;</span>, <span class=\"string\">&quot;zzz&quot;</span>);</span><br><span class=\"line\">    strings.stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">    all.stream().sorted((x, y) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.getAge().equals(y.getAge())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x.getName().compareTo(y.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.getAge().compareTo(y.getAge());</span><br><span class=\"line\">    &#125;).forEach(System.out::println);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的终止操作\"><a href=\"#Stream的终止操作\" class=\"headerlink\" title=\"Stream的终止操作\"></a>Stream的终止操作</h2><h3 id=\"查找与匹配\"><a href=\"#查找与匹配\" class=\"headerlink\" title=\"查找与匹配\"></a>查找与匹配</h3><p>Find查找：<br>findFirst() ：返回第一个元素<br>findAny() ：返回当前流中的任意元素<br>count() ：返回流中元素总个数<br>max(Comparator c) ：返回流中最大值<br>min(Comparator c) ：返回流中最小值  </p>\n<p>Match匹配：<br>allMatch(Predicate p) ：检查是否匹配所有元素<br>anyMatch(Predicate p) ：检查是否至少匹配一个元素<br>noneMatch(Predicate p) ：检查是否没有匹配所有元素</p>\n<p>Final 查找案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Optional&lt;User&gt; firstOptional = all.stream().findFirst();</span><br><span class=\"line\">    Optional&lt;User&gt; anyOptional = all.stream().findAny();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> count = all.stream().count();</span><br><span class=\"line\">    Optional&lt;User&gt; maxOptional = all.stream().max(Comparator.comparing(User::getAge));</span><br><span class=\"line\">    Optional&lt;Integer&gt; minOptional = all.stream().map(User::getAge).min(Integer::compareTo);</span><br><span class=\"line\">    System.out.println(firstOptional.get());</span><br><span class=\"line\">    System.out.println(anyOptional.get());</span><br><span class=\"line\">    System.out.println(count);</span><br><span class=\"line\">    System.out.println(maxOptional.get());</span><br><span class=\"line\">    System.out.println(minOptional.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Match 匹配Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> allMatch = all.stream().allMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> anyMatch = all.stream().anyMatch(x -&gt; UserStatus.B == (x.getStatus()));</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> noneMatch = all.stream().noneMatch(x -&gt; UserStatus.A == x.getStatus());</span><br><span class=\"line\">    System.out.println(allMatch);</span><br><span class=\"line\">    System.out.println(anyMatch);</span><br><span class=\"line\">    System.out.println(noneMatch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"规约\"><a href=\"#规约\" class=\"headerlink\" title=\"规约\"></a>规约</h3><p>reduce(T iden, BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值。返回T。</p>\n<p>reduce(BinaryOperator b) ： 可以将流中元素反复结合起来，得到一个值，返回Optional<T>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reduceTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    BigDecimal reduce = all.stream().map(User::getAmount).reduce(BigDecimal.ZERO, (o, n) -&gt; &#123;</span><br><span class=\"line\">        o = Optional.ofNullable(o).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        n = Optional.ofNullable(n).orElse(BigDecimal.ZERO);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o.add(n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h3><p>collect(Collector c) ：将流转换为其他形式，接受一个Collector接口的实现，用于给Stream中元素做汇总操作。</p>\n<p>Collector 接口中方法的实现决定了如何对流执行收集操作（如：收集到List，Set，Map）。但是Collectors 实现类提供了很多静态方法，可以方便的创建常见收集器实例，具体方法与实例如下表：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/JDK/%E5%B8%B8%E8%A7%81%E6%94%B6%E9%9B%86%E5%99%A8%E6%96%B9%E6%B3%95.png\" alt=\"常见收集器方法\"></p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 转collection</span></span><br><span class=\"line\">    Set&lt;User&gt; set = all.stream().collect(Collectors.toSet());</span><br><span class=\"line\">    List&lt;Integer&gt; list = all.stream().map(User::getId).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// 转map</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map = all.stream().collect(Collectors.toMap(User::getSex, Function.identity()));</span><br><span class=\"line\">    <span class=\"comment\">// 转map，处理key相同的元素</span></span><br><span class=\"line\">    Map&lt;String, User&gt; map2 = all.stream().collect(Collectors.toMap(User::getSex, Function.identity(), (x, y) -&gt; x));</span><br><span class=\"line\">    <span class=\"comment\">// 根据属性分组</span></span><br><span class=\"line\">    Map&lt;String, List&lt;User&gt;&gt; sexMap = all.stream().collect(Collectors.groupingBy(User::getSex));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"并行流-与-串行流\"><a href=\"#并行流-与-串行流\" class=\"headerlink\" title=\"并行流 与 串行流\"></a>并行流 与 串行流</h1><h1 id=\"新时间日期API\"><a href=\"#新时间日期API\" class=\"headerlink\" title=\"新时间日期API\"></a>新时间日期API</h1><p>在旧版的java中，日期时间API存在诸多问题，其中有：<br>1）非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变得，这是java日期类最大的问题之一<br>2）设计很差，java的日期/时间类的定义并不一致，在 java.util 和 java.sql 的包中都要日期类，此外用于格式化和解析的类在java.text包中定义。Java.utail.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身是一个非常糟糕的设计。<br>3）时区处理麻烦，日期类并不提供国际化，没有时区支持，因此java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</p>\n<p><strong>因此：Java8 通过发布新的Date-time API（JSR 310）来进一步加强对日期与时间的处理。</strong></p>\n<p>Java8 在 java.Time 包下提供了很多新的API。以下两个比较重要的API：<br>Local（本地）  简化了日期的处理，没有时区的问题。<br>Zoned（时区）  通过制定的时区处理日期时间。<br>新的java.time包覆盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>\n<h2 id=\"常用类简介\"><a href=\"#常用类简介\" class=\"headerlink\" title=\"常用类简介\"></a>常用类简介</h2><p>Instat：用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>Period：用于计算日期间隔<br>Duration：用于计算时间间隔  </p>\n<p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期+时间，相当于 LocalDate + LocalTime</p>\n<p>Zoneld：时区<br>ZonedDateTime：表示日期+时间+时区值</p>\n<p>DateTimeFormatter：用于日期时间的格式化</p>\n<h2 id=\"本地化日期时间API\"><a href=\"#本地化日期时间API\" class=\"headerlink\" title=\"本地化日期时间API\"></a>本地化日期时间API</h2><p>LocalDate：表示日期<br>LcalTime：表示时间<br>LocalDateTime：表示日期和时间，相当于 LocalDate + LocalTime</p>\n<p>公共API：<br>now()：静态方法，根据当前时间创建对象。<br>of()：静态方法，根据指定的日期/时间创建对象。</p>\n<p>LocalDate 与 LocalDateTime公共API：<br>getYear()：获取年份<br>getMonth()：获取月份，返回一个Month的枚举<br>getMonthValue()：获取月份<br>getDayOfMonth()：获取当前月份天数【1-31】<br>getDayOfYear()：获取当前年份天数【1-366】<br>getDayOfWeek()：获取星期几，返回一个DayOfWeek的枚举<br>plus()：添加一个 Duration 或 Period<br>minus()：删除一个 Duration 或 Period<br>plusDays(); plusWeeks(); plusMonths(); plusYears()：<br>向当前对象，新增几天，几周，几月，几年。<br>minusDays(); minusWeeks(); minusMonths(); minusYears()：<br>向当前对象，减去几天，几周，几月，几年。<br>withDayOfMonth()：修改当前月的天数<br>withDayOfYear()：修改当前年的天数</p>\n<p>LocalTime 与 LocalDateTime公共API：<br>getHour()：获取小时<br>getMinute()：获取分钟<br>getSecond()：获取秒</p>\n<h2 id=\"时区日期时间API\"><a href=\"#时区日期时间API\" class=\"headerlink\" title=\"时区日期时间API\"></a>时区日期时间API</h2><h2 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h2><p>Java8新提供Instant获取秒数，用于表示时间上的一个点，表示一个时间戳（精确到纳秒）<br>如果只是为了获取秒数或毫秒数，可以使用System.currentTimeMillis()。</p>\n<p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。</p>\n<p>Instant API方法：<br>getEpochSecond()：获取秒数<br>toEpochMilli()：获取毫秒数<br>getNano()：获取纳秒数<br>System.currentTimeMillis()：获取时间戳，毫秒级别。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Instant instant = Instant.now();</span><br><span class=\"line\"><span class=\"comment\">// 获取秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentSecond = instant.getEpochSecond();</span><br><span class=\"line\"><span class=\"comment\">// 获取毫秒数</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentMilli = instant.toEpochMilli();</span><br><span class=\"line\"><span class=\"comment\">// 时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> currentTimeMilli = System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(currentSecond);</span><br><span class=\"line\">System.out.println(currentMilli);</span><br><span class=\"line\">System.out.println(instant);</span><br><span class=\"line\">System.out.println(currentTimeMilli);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Period-日期间隔\"><a href=\"#Period-日期间隔\" class=\"headerlink\" title=\"Period 日期间隔\"></a>Period 日期间隔</h2><p>Java8新提供Period来表示一个日期段，日期间隔。</p>\n<p>Period API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Period实例<br>getYears();            获取这段日期的相隔年数<br>getMonths();         获取单纯月份比较，相隔几月<br>getDays();             获取单纯天数比较，相隔几天</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1999-06-24</span></span><br><span class=\"line\">LocalDate from = LocalDate.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2020-08-20</span></span><br><span class=\"line\">LocalDate to = LocalDate.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Period period = Period.between(from, to);</span><br><span class=\"line\"><span class=\"keyword\">int</span> years = period.getYears(); <span class=\"comment\">// 这段日期的相隔年数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> months = period.getMonths(); <span class=\"comment\">// 单纯月份比较，相隔几月</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> days = period.getDays(); <span class=\"comment\">// 单纯天数比较，相隔几天</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Duration-时间间隔\"><a href=\"#Duration-时间间隔\" class=\"headerlink\" title=\"Duration 时间间隔\"></a>Duration 时间间隔</h2><p>Java8新提供Duration来表示一个时间段，时间间隔。</p>\n<p>Duration API方法：<br>Between(from, to)：    获取两个日期的间隔，返回Duration实例<br>toDays()：        获取这段时间的天数<br>toHours()：        获取这段时间的小时<br>toMinutes()：        获取这段时间的分钟数<br>getSeconds()：    获取这段时间的秒数<br>toMillis()：        获取这段时间的毫秒数<br>toNanos()：        获取这段时间的纳秒数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">durationTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1999-06-24 00:00:00</span></span><br><span class=\"line\">    LocalDateTime from = LocalDateTime.of(<span class=\"number\">1999</span>, Month.MAY, <span class=\"number\">24</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2020-08-20 00:00:00</span></span><br><span class=\"line\">    LocalDateTime to = LocalDateTime.of(<span class=\"number\">2020</span>, Month.JULY, <span class=\"number\">20</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Duration duration = Duration.between(from, to);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> days = duration.toDays();<span class=\"comment\">// 这段时间的天数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> hours = duration.toHours();<span class=\"comment\">// 这段时间的小时</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> minutes  = duration.toMinutes();<span class=\"comment\">// 这段时间的分钟数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> seconds = duration.getSeconds();<span class=\"comment\">// 这段时间的秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> milliSeconds = duration.toMillis();<span class=\"comment\">// 这段时间的毫秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanos = duration.toNanos();<span class=\"comment\">// 这段时间的纳秒数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(days);</span><br><span class=\"line\">    System.out.println(hours);</span><br><span class=\"line\">    System.out.println(minutes);</span><br><span class=\"line\">    System.out.println(seconds);</span><br><span class=\"line\">    System.out.println(milliSeconds);</span><br><span class=\"line\">    System.out.println(nanos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解析与格式化\"><a href=\"#解析与格式化\" class=\"headerlink\" title=\"解析与格式化\"></a>解析与格式化</h2><p>格式化时间：<br>Java8新提供DateTimeFormatter来格式化时间。</p>\n<p>解析时间：<br>使用时间类LocalDate、LocalTime自带的parse()方法进行解析时间。</p>\n<p>格式化时间demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">String s1 = DateTimeFormatter.BASIC_ISO_DATE.format(now);</span><br><span class=\"line\">String s2 = DateTimeFormatter.ISO_DATE_TIME.format(now);</span><br><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">String format = formatter.format(now);</span><br></pre></td></tr></table></figure>\n\n<p>解析时间Demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDate localDate = LocalDate.parse(<span class=\"string\">&quot;2020-10-01&quot;</span>);</span><br><span class=\"line\">LocalDateTime localDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01T15:15:15&quot;</span>);</span><br><span class=\"line\">LocalDateTime copyLocalDateTime = LocalDateTime.parse(<span class=\"string\">&quot;2020-10-01 15:15:15&quot;</span>, DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"接口中的默认方法-与-静态方法\"><a href=\"#接口中的默认方法-与-静态方法\" class=\"headerlink\" title=\"接口中的默认方法 与 静态方法\"></a>接口中的默认方法 与 静态方法</h1><h2 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h2><p>Java8新增了接口的默认方法。<br>简单说：默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>\n<p>为什么要有这个特性：<br>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。java8之前的集合框架没有foreach方法，通常能想到的解决方法是在jdk里给相关的接口添加新的方法及实现。<br>然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。所以引进的默认方法，目的是为了解决接口的修改与现有的实现不兼容问题。</p>\n<p>接口默认方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface default method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认方法的问题\"><a href=\"#默认方法的问题\" class=\"headerlink\" title=\"默认方法的问题\"></a>默认方法的问题</h2><p>如果一个接口定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p>\n<p>接口冲突：<br>如果一个接口提供了一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否默认方法），一个类实现了这两个接口，那么必须覆盖该方法来解决冲突。</p>\n<p>类优先原则：<br>如果一个接口提供了一个默认方法，而父类又定义了一个同名的方法时，在子类中，那么接口中具有相同名称和参数的默认方法会被忽略，生效的是父类的同名方法。</p>\n<p>接口冲突案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是狗，汪汪汪&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是猫，喵喵喵&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Dog.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        Cat.<span class=\"keyword\">super</span>.call();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是demo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类优先原则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是baseClass&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dog</span>, <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>Java8的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>\n<p>接口静态方法语法格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello interface static method&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Optional-类\"><a href=\"#Optional-类\" class=\"headerlink\" title=\"Optional 类\"></a>Optional 类</h1><h2 id=\"Optional-类简介\"><a href=\"#Optional-类简介\" class=\"headerlink\" title=\"Optional 类简介\"></a>Optional 类简介</h2><p>Optional 类（java.util.Optional）是一个可以为null的容器对象，如果值存在则isPresent()方法会返回true，调用get方法会返回该对象。</p>\n<p>Optional 类是个容器：它可以保存类型T的值，或者仅仅保存null。Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测。</p>\n<p>Optional 类的引入，可以很好的解决空指针异常。<br>Optional 类可以很好的判断一个值存在或者不存在。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional.get()               获取Optional容器包含的值，如果值为null，抛出异常</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .of(T t)  \t\t\t根据t创建Optional 实例，如果t为null，抛出空指针异常</span><br><span class=\"line\">Optional.ofNullable(T t)\t\t若t不为空，创建Optional 实例，否则返回空的Optional 实例</span><br><span class=\"line\">Optional .empty()\t\t\t创建一个空的Optional 实例</span><br><span class=\"line\"></span><br><span class=\"line\">Optional .isPresent() \t\t判断是否包含值，包含返回true，否则返回false</span><br><span class=\"line\">OrElse(T t)\t\t\t\t如果调用对象包含值，返回该值，否则返回t</span><br><span class=\"line\">OrElseGet(supplier s)\t\t如果调用对象包含值，返回该值，否则返回s获取的值</span><br><span class=\"line\">Map(function f)\t\t\t有值对其处理返回处理后的Optional，否则返回Optional.empty()</span><br><span class=\"line\">flatMap(function f)\t\t\t与map类型，要求返回Optional</span><br></pre></td></tr></table></figure>\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// optional.of创建optional实例，t不能为空，为null，抛出异常</span></span><br><span class=\"line\">    Optional&lt;Integer&gt; integerOptional = Optional.of(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.ofNullable创建optional实例，t如果为空，返回一个空的optional</span></span><br><span class=\"line\">    Optional&lt;User&gt; userOptional = Optional.ofNullable(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// optional.empty创建一个空值得optional实例</span></span><br><span class=\"line\">    Optional&lt;Object&gt; empty = Optional.empty();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        // get，optional如果值为空，抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//        integerOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        userOptional.get();</span></span><br><span class=\"line\"><span class=\"comment\">//        empty.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(userOptional.isPresent());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果值不为空，则返回，如果为空，则返回给定的值</span></span><br><span class=\"line\">    Integer integer = integerOptional.orElse(<span class=\"number\">3</span>);</span><br><span class=\"line\">    User user = userOptional.orElse(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">    Object o = empty.orElse(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;100&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(integer);</span><br><span class=\"line\">    System.out.println(user);</span><br><span class=\"line\">    System.out.println(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"MySQL-事务日志","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# MySQL 事务日志（redolog & undolog）\n\nInnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\n\n1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。  \n2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。\n\n<!-- more -->\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。  \n用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n## redo log的基本概念\n\nredo log包含两部分：  \n一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；  \n二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；\n\n在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。\n\n## redo log（重做日志） vs bin log（二进制日志）\n\n// TODO\n\nredo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。\n\n### 产生的地方不一样\n\nbin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。  \nredo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。\n\n### 记录的内容不同\n\nbin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。  \nredo log是物理日志，记录该数据页更新的内容。\n\n### 写入的方式不同\n\nbin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。  \nredo log是循环写，日志空间大小固定。\n\n# undo log（回滚日志）\n\n## 定义\n\nredo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。    \n保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。  \n同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。\n\nundo log 和 redo log记录的物理日志不一样，它是逻辑日志。  \n可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。  \n有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。\n\n**undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。\n另外，undo log也会产生redo log，因为undo log也要实现持久性保护。**\n\n**保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。**\n\n***\n\n## \n\n\n","source":"_posts/oyr/MySQL/MySQL-事务日志.md","raw":"---\ntitle: MySQL-事务日志\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MySQL\ntags: \n\t- oyr-MySQL\n\t- 数据库\n---\n\n# MySQL 事务日志（redolog & undolog）\n\nInnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。\n\n1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。  \n2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。\n\n<!-- more -->\n\n# redo log（重做日志）\n\n## 定义\n\nredo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。  \n用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性\n\nMySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。\n\n***\n\n## redo log的基本概念\n\nredo log包含两部分：  \n一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；  \n二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；\n\n在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。\n\n## redo log（重做日志） vs bin log（二进制日志）\n\n// TODO\n\nredo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。\n\n### 产生的地方不一样\n\nbin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。  \nredo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。\n\n### 记录的内容不同\n\nbin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。  \nredo log是物理日志，记录该数据页更新的内容。\n\n### 写入的方式不同\n\nbin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。  \nredo log是循环写，日志空间大小固定。\n\n# undo log（回滚日志）\n\n## 定义\n\nredo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。    \n保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。  \n同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。\n\nundo log 和 redo log记录的物理日志不一样，它是逻辑日志。  \n可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。  \n有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。\n\n**undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。\n另外，undo log也会产生redo log，因为undo log也要实现持久性保护。**\n\n**保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。**\n\n***\n\n## \n\n\n","slug":"oyr/MySQL/MySQL-事务日志","published":1,"updated":"2021-07-13T09:50:10.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l83660010hct71l6s7186","content":"<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>InnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。</p>\n<p>1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。<br>2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。<br>用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h2 id=\"redo-log的基本概念\"><a href=\"#redo-log的基本概念\" class=\"headerlink\" title=\"redo log的基本概念\"></a>redo log的基本概念</h2><p>redo log包含两部分：<br>一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；<br>二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；</p>\n<p>在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>\n<h2 id=\"redo-log（重做日志）-vs-bin-log（二进制日志）\"><a href=\"#redo-log（重做日志）-vs-bin-log（二进制日志）\" class=\"headerlink\" title=\"redo log（重做日志） vs bin log（二进制日志）\"></a>redo log（重做日志） vs bin log（二进制日志）</h2><p>// TODO</p>\n<p>redo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。</p>\n<h3 id=\"产生的地方不一样\"><a href=\"#产生的地方不一样\" class=\"headerlink\" title=\"产生的地方不一样\"></a>产生的地方不一样</h3><p>bin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。<br>redo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。</p>\n<h3 id=\"记录的内容不同\"><a href=\"#记录的内容不同\" class=\"headerlink\" title=\"记录的内容不同\"></a>记录的内容不同</h3><p>bin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。<br>redo log是物理日志，记录该数据页更新的内容。</p>\n<h3 id=\"写入的方式不同\"><a href=\"#写入的方式不同\" class=\"headerlink\" title=\"写入的方式不同\"></a>写入的方式不同</h3><p>bin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。<br>redo log是循环写，日志空间大小固定。</p>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。<br>保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。<br>同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>\n<p>undo log 和 redo log记录的物理日志不一样，它是逻辑日志。<br>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<p>当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。<br>有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>\n<p><strong>undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。<br>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</strong></p>\n<p><strong>保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</strong></p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>InnoDB事务日志包括 redo log 和 undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。</p>\n<p>1）redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样，他用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。用来保证事务的持久性。<br>2）undo log用来回滚行记录到某个版本。undo log一般是逻辑日志，记录每行记录进行修改。用来保证事务的原子性以及InnoDB的MVCC。</p>","more":"<h1 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的物理日志，也叫重做日志，提供前滚操作。是InnoDB存储引擎的事务日志。<br>用来保证事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性</p>\n<p>MySQL 每执行一条 SQL 更新语句，不是每次数据更改都立刻写到磁盘，而是先将记录写到 redo log 里面，并更新内存（这时内存与磁盘的数据不一致，将这种有差异的数据称为脏页），一段时间后，再一次性将多个操作记录写到到磁盘上，这样可以减少磁盘 io 成本，提高操作速度。先写日志，再写磁盘，这就是 MySQL 里经常说到的 WAL 技术，即 Write-Ahead Logging，又叫预写日志。MySQL 通过 WAL 技术保证事务的持久性。</p>\n<hr>\n<h2 id=\"redo-log的基本概念\"><a href=\"#redo-log的基本概念\" class=\"headerlink\" title=\"redo log的基本概念\"></a>redo log的基本概念</h2><p>redo log包含两部分：<br>一个是内存中的日志缓存（redo log buffer），该部分日志是易失性的；<br>二是磁盘上的重做日志文件（redo log file），该部分日志是持久的；</p>\n<p>在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>\n<h2 id=\"redo-log（重做日志）-vs-bin-log（二进制日志）\"><a href=\"#redo-log（重做日志）-vs-bin-log（二进制日志）\" class=\"headerlink\" title=\"redo log（重做日志） vs bin log（二进制日志）\"></a>redo log（重做日志） vs bin log（二进制日志）</h2><p>// TODO</p>\n<p>redo log 和 bin log是不同的日志文件，虽然bin log也记录了InnoDB表的很多重做，也能实现重做的功能，但它们之间有很大的区别。</p>\n<h3 id=\"产生的地方不一样\"><a href=\"#产生的地方不一样\" class=\"headerlink\" title=\"产生的地方不一样\"></a>产生的地方不一样</h3><p>bin log是在MySQL服务层产生的，不管是什么存储引擎，对数据库进行了修改都会记录bin log。<br>redo log是在InnoDB存储引擎产生的，记录该存储引擎中表的修改，存储引擎在服务层下层，所以bin log 优先于redo log被记录。</p>\n<h3 id=\"记录的内容不同\"><a href=\"#记录的内容不同\" class=\"headerlink\" title=\"记录的内容不同\"></a>记录的内容不同</h3><p>bin log是逻辑日志，记录的是这个这个语句的原始逻辑，比如“给id=2这一行的c字段加1”。<br>redo log是物理日志，记录该数据页更新的内容。</p>\n<h3 id=\"写入的方式不同\"><a href=\"#写入的方式不同\" class=\"headerlink\" title=\"写入的方式不同\"></a>写入的方式不同</h3><p>bin log是追加写，写到一定大小的时候会更换下一个文件，不会回覆盖。<br>redo log是循环写，日志空间大小固定。</p>\n<h1 id=\"undo-log（回滚日志）\"><a href=\"#undo-log（回滚日志）\" class=\"headerlink\" title=\"undo log（回滚日志）\"></a>undo log（回滚日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>redo log 是 MySQL 的逻辑日志，也叫回滚日志，提供回滚操作。是InnoDB存储引擎的事务日志。<br>保存事务发生之前数据的一个版本，用于回滚，保证事务的原子性。<br>同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>\n<p>undo log 和 redo log记录的物理日志不一样，它是逻辑日志。<br>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<p>当rollback（事务回滚）时，就可以从undo log中的逻辑记录读取到相应的内容进行回滚。<br>有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取某一行被其他事务锁定时，他可以从undo log中分析出该行记录以前是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>\n<p><strong>undo log是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。<br>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</strong></p>\n<p><strong>保存了事务发送之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</strong></p>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"Nginx","date":"2021-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Nginx/Nginx.md","raw":"---\ntitle: Nginx\ndate: 2021-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: Nginx\ntags: \n   - Nginx\n   - 中间件\n---","slug":"oyr/Nginx/Nginx","published":1,"updated":"2021-07-12T10:31:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l83670012hct7ednu2lyk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Redis-主从复制","date":"2020-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Redis/Redis-主从复制.md","raw":"---\ntitle: Redis-主从复制\ndate: 2020-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---","slug":"oyr/Redis/Redis-主从复制","published":1,"updated":"2021-07-13T09:50:58.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l83690016hct7apj066o0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL-日志系统","date":"2021-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# MySQL日志分类\n\n注意：  \n设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。  \n如果想要当前会话生效通过set sesison进行设置。\n\n## 日志分类\n\nMysql有7种日志文件，分别是：  \n1）errorlog（错误日志）  \n2）generallog（普通日志）  \n3）slow query log（慢查询日志）  \n4）binlog（二进制日志）  \n5）relaylog（中继日志）  \n6）redolog（重做日志）  \n7）undolog（回滚日志）\n\n***\n\n<!-- more -->\n\n## 重要日志\n\nslow query log：慢查询日志  \nundolog-redolog：事务日志（innoDB存储引擎日志）  \nbinlog：二进制日志（server层日志）  \nrelaylog：中继日志（主从复制）\n\n***\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://kubpang.gitee.io/sourceFile/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://kubpang.gitee.io/sourceFile/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\n\nbin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  \n\n**用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。**\n\n***\n\n## 应用场景\n\n1）数据恢复  \n做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。\n2）mysql主从复制  \n做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看是否启动bin log 日志\nshow variables like 'log_bin';\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n2）查看binlog的目录  \nshow global variables like \"%log_bin%\";\n\n\n3）查看主库的日志文件，以及position信息\nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       314 |\n| mysql-bin.000002 |       639 |\n+------------------+-----------+\n2 rows in set (0.00 sec)\n```\n\n4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000002 |      639 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;  \n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n6）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 开启bin log\n\n注意：mysql 8.0 版本之前，默认不开启，建议开启。\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://kubpang.gitee.io/sourceFile/MySQL/1624350274231.jpg)\n\n***\n\n## bin log 的写入时机\n\n对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。\n\nsync_binlog参数讲解：  \n1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；  \n2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。  \n3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。\n\n如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。\n\n在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。\n\n***\n\n## bin log 文件以及扩展\n\n二进制日志包含两种文件：  \n* 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n* 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\nbinlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  \n* 魔数：0xfe62696e对应的是0xfebin； \n* Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；\n* 第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；\n* 其余的Event按照第一个Event的格式版本写入；\n* 最后一个Event用于说明下一个binlog文件；\n* binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表\n\n当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：\n* MySQL服务器停止或重启时\n* 使用 flush logs 命令；\n* 当 binlog 文件大小超过 max_binlog_size 变量的值时；\n\nmax_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。\n\n注意：bin log与数据库文件在同目录中。  \n\n***\n\n## bin log 的日志格式\n\n记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：\n* STATEMENT：基于SQL语句的复制（statement-based replication, SBR）\n* ROW：基于行的复制（row-based replication, RBR）\n* MIXED：混合模式复制（mixed-based replication, MBR）\n\n**注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。**\n\n### Statement\n\n每一条会修改数据的sql都会记录在binlog中\n\n优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。\n\n缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。\n\n### Row\n\n5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。\n\n优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.\n\n缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。\n\n注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。\n\n### Mixed\n\n从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。  \n在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\n\n### bin log企业模式的选择\n\n互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；\n用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；\n用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；\n\n## 查看二进制日志文件\n\nbin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\nmysqlbinlog 使用语法：\n```bash\n# mysqlbinlog 的执行格式\nmysqlbinlog [options] log_file ...\n-s                          以精简的方式显示日志内容\n-v                          以详细的方式显示日志内容\n-d=数据库名                  只显示指定数据库的日志内容\n-o=n                        忽略日志中前n行MySQL命令\n-r=file                     将指定内容写入指定文件\n--start-datetime  \n                            显示指定时间范围内的日志内容\n--stop-datetime         \n\n--start-position        \n                            显示指定位置间隔内的日志内容\n--stop-position     \n\n# 查看bin-log二进制文件（shell方式）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003\n\n# 查看bin-log二进制文件（带查询条件）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\\n    --start-datetime=\"2019-03-01 00:00:00\"  \\\n    --stop-datetime=\"2019-03-10 00:00:00\"   \\\n    --start-position=\"5000\"    \\\n    --stop-position=\"20000\"\n```\n\n查看二进制日志文件：mysqlbinlog -v --base64-output=decode-rows mysql-bin.000002 \n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n```\n解释：  \n* position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始\n* timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）\n* server id: 服务器标识（1）\n* end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）\n* thread_id: 执行该事件的线程id （thread_id=2）\n* exec_time: 事件执行的花费时间\n* error_code: 错误码，0意味着没有发生错误\n* type：事件类型Query\n\n### 命令查看\n\nmysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\n// TODO\n\n# MySQL 事务日志（redolog & undolog）\n\n请看MySQL事务日志分析博客","source":"_posts/oyr/MySQL/MySQL-日志系统.md","raw":"---\ntitle: MySQL-日志系统\ndate: 2021-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MySQL\ntags: \n\t- oyr-MySQL\n\t- 数据库\n---\n\n# MySQL日志分类\n\n注意：  \n设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。  \n如果想要当前会话生效通过set sesison进行设置。\n\n## 日志分类\n\nMysql有7种日志文件，分别是：  \n1）errorlog（错误日志）  \n2）generallog（普通日志）  \n3）slow query log（慢查询日志）  \n4）binlog（二进制日志）  \n5）relaylog（中继日志）  \n6）redolog（重做日志）  \n7）undolog（回滚日志）\n\n***\n\n<!-- more -->\n\n## 重要日志\n\nslow query log：慢查询日志  \nundolog-redolog：事务日志（innoDB存储引擎日志）  \nbinlog：二进制日志（server层日志）  \nrelaylog：中继日志（主从复制）\n\n***\n\n# error log（错误日志）\n\n## 定义\n\nerror log 是 MySQL 的错误日志。  \n主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。  \n和其他的日志不同，MySQL的error日志必须开启，无法关闭。\n\n**注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。**\n\n***\n\n## 设置错误日志\n\n查看当前的错误日志文件  \n没有设置错误日志文件，默认指定了一个的错误日志文件\n```\nmysql> show variables like 'log_error';\n+---------------+----------------------+\n| Variable_name | Value                |\n+---------------+----------------------+\n| log_error     | ./VM-16-4-centos.err |\n+---------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n命令：\n```sql\nshow variables like 'log_error'; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件\nset global log_error = '/var/lib/mysql/error.log'; #设置错误日志文件\n```\n\n修改配置文件：  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlog-error='/var/lib/mysql/error.log'\n```\n\n当前通过修改配置文件指定错误配置文件，重启服务配置生效  \n可以看到当启动服务后，打印出Starting MySQL.Logging to '/var/lib/mysql/error.log'  \n这代表设置成功！\n```\n[root@VM-16-4-centos mysql]# service mysql stop\nShutting down MySQL. SUCCESS! \n[root@VM-16-4-centos mysql]# service mysql start\nStarting MySQL.Logging to '/var/lib/mysql/error.log'.\n. SUCCESS! \n```\n\n查看错误日志文件：  \n发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log \n210621 18:35:41 [Note] Plugin 'FEDERATED' is disabled.\n210621 18:35:41 InnoDB: The InnoDB memory heap is disabled\n210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins\n210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11\n210621 18:35:41 InnoDB: Using Linux native AIO\n210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M\n210621 18:35:41 InnoDB: Completed initialization of buffer pool\n210621 18:35:41 InnoDB: highest supported file format is Barracuda.\n210621 18:35:41  InnoDB: Waiting for the background threads to start\n210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913\n210621 18:35:42 [Note] Server hostname (bind-address): '0.0.0.0'; port: 3306\n210621 18:35:42 [Note]   - '0.0.0.0' resolves to '0.0.0.0';\n210621 18:35:42 [Note] Server socket created on IP: '0.0.0.0'.\n210621 18:35:42 [Note] Event Scheduler: Loaded 0 events\n210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.\nVersion: '5.5.62'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  MySQL Community Server (GPL)\n```\n\n***\n\n# general log（普通日志）\n\n## 定义\n\ngeneral log 是 MySQL 的普通日志。  \n主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。\n\n**注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，\n如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。\n只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。**\n\n***\n\n## 相关参数\n\n普通日志相关参数：\n* general_log：是否开启普通日志\n* general_log_file：普通日志文件的存放路径\n\n***\n\n## 开启普通日志\n\n查看普通日志的当前配置\n```\nmysql> show variables like '%general_log%';\n+------------------+-----------------------------------+\n| Variable_name    | Value                             |\n+------------------+-----------------------------------+\n| general_log      | OFF                               |\n| general_log_file | /var/lib/mysql/VM-16-4-centos.log |\n+------------------+-----------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%general_log%'; #查看普通日志是否开启\nshow variables like '%general_log_file%'; #查看普通日志文件的存放路径\n\nset global general_log=1; #开启普通日志\nset global general_log_file='/var/lib/mysql/general.log'; #指定普通日志文件的存放路径\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\ngeneral_log=1\ngeneral_log_file=/var/lib/mysql/general.log\n```\n\n当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。  \n结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。\n```\n[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log \n/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:\nTcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock\nTime                 Id Command    Argument\n210621 21:51:45\t    1 Connect\troot@localhost on \n\t\t    1 Connect\tAccess denied for user 'root'@'localhost' (using password: NO)\n210621 21:52:01\t    2 Connect\troot@localhost on \n\t\t    2 Query\tselect @@version_comment limit 1\n210621 21:52:51\t    2 Query\tSELECT DATABASE()\n\t\t    2 Init DB\ttest\n210621 21:53:00\t    2 Query\tselect * from a\n210621 21:53:03\t    2 Query\tselect * from a\n```\n\n***\n\n## 普通日志文件处理\n\n//TODO\n\n***\n\n\n# slow query log（慢查询日志）\n\n## 定义\n\nslow query log 是 MySQL 的慢查询日志。  \n主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。\n\n**注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。**  \n\n***\n\n## 相关参数\n\n以下是慢查询日志相关的参数：\n* slow_query_log：慢查询日志是否开启\n* slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。\n* long_query_time：设置慢查询的时间阈值，默认阈值是10s。\n* log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n* slow_queries：记录当前慢查询sql条数\n\n***\n\n## 开启慢查询日志\n\n查看慢查询日志的当前配置.  \n默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+----------------------------------------+\n| Variable_name       | Value                                  |\n+---------------------+----------------------------------------+\n| slow_query_log      | OFF                                    |\n| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |\n+---------------------+----------------------------------------+\n2 rows in set (0.00 sec)\n```\n\n命令：\n``` sql\nshow variables like '%slow_query_log%'; #查看是否开启\nshow variables like '%slow_query_log_file%'; #查看慢查询日志文件的存放路径\n\nset global slow_query_log=1; #设置开启慢查询日志\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/atguigu-slow.log\n```\n\n***\n\n## 什么 sql 会被记录到慢查询日志\n\n问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？  \n答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。\n\n### 记录响应时间超过阀值的sql语句\n\n时间阈值是由 long_query_time 控制的.  \nlong_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。\n\n命令：\n```sql\nshow variables LIKE 'long_query_time%'; #查看long_query_time的值\nset global long_query_time=5; #设置查询超过5秒则算慢查询sql\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld]\nlong_query_time=5\n```\n\n### 记录没有使用索引的查询语句\n\nlog_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。\n\n命令：\n```sql\nshow variables like '%log_queries_not_using_indexes%'; #查看值\nset global log_queries_not_using_indexes=1; #设置开启记录没有使用索引的查询语句\n```\n\n修改配置文件：（永久开启）  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\nlog_queries_not_using_indexes=1\n```\n\n## 慢查询 sql 案例\n\n``` sql\nset global slow_query_log=1; #设置开启慢查询日志\nset global long_query_time=3; #设置查询超过3秒则算慢查询sql（注意，这里是全局命令设置，需要重新连接才生效）\n\nselect sleep(4) #模拟一次查询，查询耗时4秒\nshow global status like '%slow_queries%'; #查询当前慢查询sql条数命令\n```\n\n去mysql的data目录下找到慢查询日志文件：  \n我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log  \n![慢查询日志图片](https://kubpang.gitee.io/sourceFile/MySQL/1624261484667.jpg)\n\n可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。\n\n***\n\n## 日志查询分析器（mysqldumpslow）\n\n日志查询分析器的体现：  \n在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。  \n![日志查询分析器帮助信息图片](https://kubpang.gitee.io/sourceFile/MySQL/日志查询分析器使用.jpg)\n\nmysqldumpslow --help  查看mysqldumpslow的帮助信息\n* s：表示按照何种方式排序\n* c：访问次数\n* l：锁定时间\n* r：返回记录\n* t：查询时间\n* al：平均锁定时间\n* ar：平均返回记录数\n* at：平均查询时间\n* t：即为返回前面多少条数据\n* g：后边搭配一个正则匹配模式，大小写不敏感。\n\n分析器常用的方式：\n``` sql\n#得到返回数据集最多的10个SQL\nmysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log\n\n#得到访问次数最多的10个SQL\nmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log\n\n#得到按照时间排序的前10条里面含有左连接的查询sql\nmysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log\n\n#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况\nmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n```\n\n***\n\n# bin log（二进制日志）\n\n## 定义\n\nbin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。  \n主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  \n\n**用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。**\n\n***\n\n## 应用场景\n\n1）数据恢复  \n做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。\n2）mysql主从复制  \n做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  \n\n***\n\n## 二进制日志文件常用操作命令\n\n1）查看是否启动bin log 日志\nshow variables like 'log_bin';\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n2）查看binlog的目录  \nshow global variables like \"%log_bin%\";\n\n\n3）查看主库的日志文件，以及position信息\nshow master logs;\n```\nmysql> show master logs;\n+------------------+-----------+\n| Log_name         | File_size |\n+------------------+-----------+\n| mysql-bin.000001 |       314 |\n| mysql-bin.000002 |       639 |\n+------------------+-----------+\n2 rows in set (0.00 sec)\n```\n\n4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。  \nshow master status;\n```\nmysql> show master status;\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000002 |      639 |              |                  |\n+------------------+----------+--------------+------------------+\n1 row in set (0.00 sec)\n```\n\n5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;  \nflush logs;  \n注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；\n\n6）重置（清空）所有bin log日志;  \nreset master;\n\n***\n\n## 开启bin log\n\n注意：mysql 8.0 版本之前，默认不开启，建议开启。\n\n查看二进制日志的当前配置：  \n可以看到，二进制日志默认是不开启的\n```\nmysql> show variables like 'log_bin';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| log_bin       | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n修改配置文件：(永久开启)  \n修改 my.cnf 文件，在 [mysqld] 下增加或修改参数\n```\n[mysqld] \nlog-bin=mysql-bin\nserver-id=001\n```\n\n修改配置文件后，重启服务配置生效  \n查看 bin log 日志文件  \n![bin log 日志文件](https://kubpang.gitee.io/sourceFile/MySQL/1624350274231.jpg)\n\n***\n\n## bin log 的写入时机\n\n对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。\n\nsync_binlog参数讲解：  \n1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；  \n2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。  \n3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。\n\n如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。\n\n在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。\n\n***\n\n## bin log 文件以及扩展\n\n二进制日志包含两种文件：  \n* 二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  \n* 二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件\n\nbinlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  \n* 魔数：0xfe62696e对应的是0xfebin； \n* Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；\n* 第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；\n* 其余的Event按照第一个Event的格式版本写入；\n* 最后一个Event用于说明下一个binlog文件；\n* binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表\n\n当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：\n* MySQL服务器停止或重启时\n* 使用 flush logs 命令；\n* 当 binlog 文件大小超过 max_binlog_size 变量的值时；\n\nmax_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。\n\n注意：bin log与数据库文件在同目录中。  \n\n***\n\n## bin log 的日志格式\n\n记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：\n* STATEMENT：基于SQL语句的复制（statement-based replication, SBR）\n* ROW：基于行的复制（row-based replication, RBR）\n* MIXED：混合模式复制（mixed-based replication, MBR）\n\n**注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。**\n\n### Statement\n\n每一条会修改数据的sql都会记录在binlog中\n\n优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。\n\n缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。\n\n### Row\n\n5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。\n\n优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.\n\n缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。\n\n注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。\n\n### Mixed\n\n从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。  \n在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。\n\n### bin log企业模式的选择\n\n互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；\n用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；\n用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；\n\n## 查看二进制日志文件\n\nbin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  \n\n### mysqlbinlog 工具查看\n\nmysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。  \n在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上\"--no-defaults\"选项\n\nmysqlbinlog 使用语法：\n```bash\n# mysqlbinlog 的执行格式\nmysqlbinlog [options] log_file ...\n-s                          以精简的方式显示日志内容\n-v                          以详细的方式显示日志内容\n-d=数据库名                  只显示指定数据库的日志内容\n-o=n                        忽略日志中前n行MySQL命令\n-r=file                     将指定内容写入指定文件\n--start-datetime  \n                            显示指定时间范围内的日志内容\n--stop-datetime         \n\n--start-position        \n                            显示指定位置间隔内的日志内容\n--stop-position     \n\n# 查看bin-log二进制文件（shell方式）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003\n\n# 查看bin-log二进制文件（带查询条件）\nmysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\\n    --start-datetime=\"2019-03-01 00:00:00\"  \\\n    --stop-datetime=\"2019-03-10 00:00:00\"   \\\n    --start-position=\"5000\"    \\\n    --stop-position=\"20000\"\n```\n\n查看二进制日志文件：mysqlbinlog -v --base64-output=decode-rows mysql-bin.000002 \n```\n# at 391\n#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0\nSET TIMESTAMP=1624352800/*!*/;\ninsert into admin_info values(1, \"admin\", 100) #执行的sql\n/*!*/;\n```\n解释：  \n* position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始\n* timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）\n* server id: 服务器标识（1）\n* end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）\n* thread_id: 执行该事件的线程id （thread_id=2）\n* exec_time: 事件执行的花费时间\n* error_code: 错误码，0意味着没有发生错误\n* type：事件类型Query\n\n### 命令查看\n\nmysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息  \n介绍一种更为方便的查询命令 show bin log events\n\n命令解析 show bin log events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];    \n参数解析：  \na、IN 'log_name':指定要查询的bin log文件名（不指定就是第一个bin log文件  \nb、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）  \nc、LIMIT【offset】：偏移量(不指定就是0)  \nd、row_count :查询总条数（不指定就是所有行）  \n\nshow bin log events查询：\n```\nmysql> show bin log events in'mysql-bin.000002';\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |\n| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |\n| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |\n| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |\n| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, \"admin\", 100)                     |\n| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |\n| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |\n+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+\n7 rows in set (0.00 sec)\n```\n\n***\n\n## 利用二进制日志恢复数据\n\n// TODO\n\n***\n\n# relay log（中继日志）\n\n## 定义\n\n// TODO\n\n# MySQL 事务日志（redolog & undolog）\n\n请看MySQL事务日志分析博客","slug":"oyr/MySQL/MySQL-日志系统","published":1,"updated":"2021-09-01T02:49:20.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836a0019hct75yyqge6u","content":"<h1 id=\"MySQL日志分类\"><a href=\"#MySQL日志分类\" class=\"headerlink\" title=\"MySQL日志分类\"></a>MySQL日志分类</h1><p>注意：<br>设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。<br>如果想要当前会话生效通过set sesison进行设置。</p>\n<h2 id=\"日志分类\"><a href=\"#日志分类\" class=\"headerlink\" title=\"日志分类\"></a>日志分类</h2><p>Mysql有7种日志文件，分别是：<br>1）errorlog（错误日志）<br>2）generallog（普通日志）<br>3）slow query log（慢查询日志）<br>4）binlog（二进制日志）<br>5）relaylog（中继日志）<br>6）redolog（重做日志）<br>7）undolog（回滚日志）</p>\n<hr>\n<span id=\"more\"></span>\n\n<h2 id=\"重要日志\"><a href=\"#重要日志\" class=\"headerlink\" title=\"重要日志\"></a>重要日志</h2><p>slow query log：慢查询日志<br>undolog-redolog：事务日志（innoDB存储引擎日志）<br>binlog：二进制日志（server层日志）<br>relaylog：中继日志（主从复制）</p>\n<hr>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>\n<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  </p>\n<p><strong>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</strong></p>\n<hr>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>1）数据恢复<br>做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。<br>2）mysql主从复制<br>做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  </p>\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看是否启动bin log 日志<br>show variables like ‘log_bin’;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看binlog的目录<br>show global variables like “%log_bin%”;</p>\n<p>3）查看主库的日志文件，以及position信息<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       314 |</span><br><span class=\"line\">| mysql-bin.000002 |       639 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      639 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;<br>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>6）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"开启bin-log\"><a href=\"#开启bin-log\" class=\"headerlink\" title=\"开启bin log\"></a>开启bin log</h2><p>注意：mysql 8.0 版本之前，默认不开启，建议开启。</p>\n<p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"bin-log-的写入时机\"><a href=\"#bin-log-的写入时机\" class=\"headerlink\" title=\"bin log 的写入时机\"></a>bin log 的写入时机</h2><p>对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。</p>\n<p>sync_binlog参数讲解：<br>1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；<br>2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。<br>3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。</p>\n<p>如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。</p>\n<p>在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。</p>\n<hr>\n<h2 id=\"bin-log-文件以及扩展\"><a href=\"#bin-log-文件以及扩展\" class=\"headerlink\" title=\"bin log 文件以及扩展\"></a>bin log 文件以及扩展</h2><p>二进制日志包含两种文件：  </p>\n<ul>\n<li>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  </li>\n<li>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</li>\n</ul>\n<p>binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  </p>\n<ul>\n<li>魔数：0xfe62696e对应的是0xfebin； </li>\n<li>Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；</li>\n<li>第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；</li>\n<li>其余的Event按照第一个Event的格式版本写入；</li>\n<li>最后一个Event用于说明下一个binlog文件；</li>\n<li>binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表</li>\n</ul>\n<p>当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：</p>\n<ul>\n<li>MySQL服务器停止或重启时</li>\n<li>使用 flush logs 命令；</li>\n<li>当 binlog 文件大小超过 max_binlog_size 变量的值时；</li>\n</ul>\n<p>max_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。</p>\n<p>注意：bin log与数据库文件在同目录中。  </p>\n<hr>\n<h2 id=\"bin-log-的日志格式\"><a href=\"#bin-log-的日志格式\" class=\"headerlink\" title=\"bin log 的日志格式\"></a>bin log 的日志格式</h2><p>记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：</p>\n<ul>\n<li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li>\n<li>ROW：基于行的复制（row-based replication, RBR）</li>\n<li>MIXED：混合模式复制（mixed-based replication, MBR）</li>\n</ul>\n<p><strong>注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。</strong></p>\n<h3 id=\"Statement\"><a href=\"#Statement\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><p>每一条会修改数据的sql都会记录在binlog中</p>\n<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p>\n<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。</p>\n<h3 id=\"Row\"><a href=\"#Row\" class=\"headerlink\" title=\"Row\"></a>Row</h3><p>5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>\n<p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p>\n<p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p>\n<p>注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。</p>\n<h3 id=\"Mixed\"><a href=\"#Mixed\" class=\"headerlink\" title=\"Mixed\"></a>Mixed</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>\n<h3 id=\"bin-log企业模式的选择\"><a href=\"#bin-log企业模式的选择\" class=\"headerlink\" title=\"bin log企业模式的选择\"></a>bin log企业模式的选择</h3><p>互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；<br>用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；<br>用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；</p>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>mysqlbinlog 使用语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysqlbinlog 的执行格式</span></span><br><span class=\"line\">mysqlbinlog [options] log_file ...</span><br><span class=\"line\">-s                          以精简的方式显示日志内容</span><br><span class=\"line\">-v                          以详细的方式显示日志内容</span><br><span class=\"line\">-d=数据库名                  只显示指定数据库的日志内容</span><br><span class=\"line\">-o=n                        忽略日志中前n行MySQL命令</span><br><span class=\"line\">-r=file                     将指定内容写入指定文件</span><br><span class=\"line\">--start-datetime  </span><br><span class=\"line\">                            显示指定时间范围内的日志内容</span><br><span class=\"line\">--stop-datetime         </span><br><span class=\"line\"></span><br><span class=\"line\">--start-position        </span><br><span class=\"line\">                            显示指定位置间隔内的日志内容</span><br><span class=\"line\">--stop-position     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（shell方式）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（带查询条件）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\</span><br><span class=\"line\">    --start-datetime=<span class=\"string\">&quot;2019-03-01 00:00:00&quot;</span>  \\</span><br><span class=\"line\">    --stop-datetime=<span class=\"string\">&quot;2019-03-10 00:00:00&quot;</span>   \\</span><br><span class=\"line\">    --start-position=<span class=\"string\">&quot;5000&quot;</span>    \\</span><br><span class=\"line\">    --stop-position=<span class=\"string\">&quot;20000&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>查看二进制日志文件：mysqlbinlog -v –base64-output=decode-rows mysql-bin.000002 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br></pre></td></tr></table></figure>\n<p>解释：  </p>\n<ul>\n<li>position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始</li>\n<li>timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）</li>\n<li>server id: 服务器标识（1）</li>\n<li>end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）</li>\n<li>thread_id: 执行该事件的线程id （thread_id=2）</li>\n<li>exec_time: 事件执行的花费时间</li>\n<li>error_code: 错误码，0意味着没有发生错误</li>\n<li>type：事件类型Query</li>\n</ul>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>// TODO</p>\n<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>请看MySQL事务日志分析博客</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"MySQL日志分类\"><a href=\"#MySQL日志分类\" class=\"headerlink\" title=\"MySQL日志分类\"></a>MySQL日志分类</h1><p>注意：<br>设置系统参数方式修改，需要重新连接一个会话，如mysql重启即失效，如果要永久存在则需要修改配置文件。<br>如果想要当前会话生效通过set sesison进行设置。</p>\n<h2 id=\"日志分类\"><a href=\"#日志分类\" class=\"headerlink\" title=\"日志分类\"></a>日志分类</h2><p>Mysql有7种日志文件，分别是：<br>1）errorlog（错误日志）<br>2）generallog（普通日志）<br>3）slow query log（慢查询日志）<br>4）binlog（二进制日志）<br>5）relaylog（中继日志）<br>6）redolog（重做日志）<br>7）undolog（回滚日志）</p>\n<hr>","more":"<h2 id=\"重要日志\"><a href=\"#重要日志\" class=\"headerlink\" title=\"重要日志\"></a>重要日志</h2><p>slow query log：慢查询日志<br>undolog-redolog：事务日志（innoDB存储引擎日志）<br>binlog：二进制日志（server层日志）<br>relaylog：中继日志（主从复制）</p>\n<hr>\n<h1 id=\"error-log（错误日志）\"><a href=\"#error-log（错误日志）\" class=\"headerlink\" title=\"error log（错误日志）\"></a>error log（错误日志）</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>error log 是 MySQL 的错误日志。<br>主要记录 MySQL 服务实例每次启动，停止的详细信息，以及 MySQL 实例运行过程中产生的警告或者错误信息。<br>和其他的日志不同，MySQL的error日志必须开启，无法关闭。</p>\n<p><strong>注意：默认情况下，错误日志的文件名为：主机名.err。 但 error 日志并不会记录所有的错误信息，只有MySQL服务实例运行过程中发声的关键错误（critical）才会被记录下来。</strong></p>\n<hr>\n<h2 id=\"设置错误日志\"><a href=\"#设置错误日志\" class=\"headerlink\" title=\"设置错误日志\"></a>设置错误日志</h2><p>查看当前的错误日志文件<br>没有设置错误日志文件，默认指定了一个的错误日志文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_error&#x27;;</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| Variable_name | Value                |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">| log_error     | ./VM-16-4-centos.err |</span><br><span class=\"line\">+---------------+----------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;log_error&#x27;</span>; #查看当前的错误日志文件，如果没有指定，默认有一个错误日志文件</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_error <span class=\"operator\">=</span> <span class=\"string\">&#x27;/var/lib/mysql/error.log&#x27;</span>; #设置错误日志文件</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">log-error=&#x27;/var/lib/mysql/error.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定错误配置文件，重启服务配置生效<br>可以看到当启动服务后，打印出Starting MySQL.Logging to ‘/var/lib/mysql/error.log’<br>这代表设置成功！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql stop</span><br><span class=\"line\">Shutting down MySQL. SUCCESS! </span><br><span class=\"line\">[root@VM-16-4-centos mysql]# service mysql start</span><br><span class=\"line\">Starting MySQL.Logging to &#x27;/var/lib/mysql/error.log&#x27;.</span><br><span class=\"line\">. SUCCESS! </span><br></pre></td></tr></table></figure>\n\n<p>查看错误日志文件：<br>发现 mysql 实例启动的日志【验证了错误日志会记录实例每次启动，停止的详细信息】</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/error.log </span><br><span class=\"line\">210621 18:35:41 [Note] Plugin &#x27;FEDERATED&#x27; is disabled.</span><br><span class=\"line\">210621 18:35:41 InnoDB: The InnoDB memory heap is disabled</span><br><span class=\"line\">210621 18:35:41 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class=\"line\">210621 18:35:41 InnoDB: Compressed tables use zlib 1.2.11</span><br><span class=\"line\">210621 18:35:41 InnoDB: Using Linux native AIO</span><br><span class=\"line\">210621 18:35:41 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class=\"line\">210621 18:35:41 InnoDB: Completed initialization of buffer pool</span><br><span class=\"line\">210621 18:35:41 InnoDB: highest supported file format is Barracuda.</span><br><span class=\"line\">210621 18:35:41  InnoDB: Waiting for the background threads to start</span><br><span class=\"line\">210621 18:35:42 InnoDB: 5.5.62 started; log sequence number 1598913</span><br><span class=\"line\">210621 18:35:42 [Note] Server hostname (bind-address): &#x27;0.0.0.0&#x27;; port: 3306</span><br><span class=\"line\">210621 18:35:42 [Note]   - &#x27;0.0.0.0&#x27; resolves to &#x27;0.0.0.0&#x27;;</span><br><span class=\"line\">210621 18:35:42 [Note] Server socket created on IP: &#x27;0.0.0.0&#x27;.</span><br><span class=\"line\">210621 18:35:42 [Note] Event Scheduler: Loaded 0 events</span><br><span class=\"line\">210621 18:35:42 [Note] /usr/sbin/mysqld: ready for connections.</span><br><span class=\"line\">Version: &#x27;5.5.62&#x27;  socket: &#x27;/var/lib/mysql/mysql.sock&#x27;  port: 3306  MySQL Community Server (GPL)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"general-log（普通日志）\"><a href=\"#general-log（普通日志）\" class=\"headerlink\" title=\"general log（普通日志）\"></a>general log（普通日志）</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>general log 是 MySQL 的普通日志。<br>主要记录 MySQL 服务实例所有的操作，如：select，update，insert，delete等操作，无论操作是否成功执行都会记录。还记录 MySQL 客户端与 MySQL 服务端连接及断开的相关信息，无论连接成功还是失败。</p>\n<p><strong>注意：由于普通日志几乎记录了MySQL的所有操作，对于数据访问频繁的数据库服务器而言，<br>如果开启MySQL的普通查询日志将会大幅度的降低数据库的性能，因此建议关闭普通查询日志。<br>只有在特殊时期，如需要追踪某些特殊的查询日志，可以临时打开普通的查询日志。</strong></p>\n<hr>\n<h2 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>普通日志相关参数：</p>\n<ul>\n<li>general_log：是否开启普通日志</li>\n<li>general_log_file：普通日志文件的存放路径</li>\n</ul>\n<hr>\n<h2 id=\"开启普通日志\"><a href=\"#开启普通日志\" class=\"headerlink\" title=\"开启普通日志\"></a>开启普通日志</h2><p>查看普通日志的当前配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| Variable_name    | Value                             |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">| general_log      | OFF                               |</span><br><span class=\"line\">| general_log_file | /var/lib/mysql/VM-16-4-centos.log |</span><br><span class=\"line\">+------------------+-----------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log%&#x27;</span>; #查看普通日志是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%general_log_file%&#x27;</span>; #查看普通日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #开启普通日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> general_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;/var/lib/mysql/general.log&#x27;</span>; #指定普通日志文件的存放路径</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">general_log=1</span><br><span class=\"line\">general_log_file=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>\n\n<p>当前通过修改配置文件指定普通日志配置，重启服务后查看普通日志。<br>结论：可以看到，普通日志记录了客户端登录，查询数据库，查询表的所有操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-16-4-centos mysql]# cat /var/lib/mysql/general.log </span><br><span class=\"line\">/usr/sbin/mysqld, Version: 5.5.62-log (MySQL Community Server (GPL)). started with:</span><br><span class=\"line\">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class=\"line\">Time                 Id Command    Argument</span><br><span class=\"line\">210621 21:51:45\t    1 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    1 Connect\tAccess denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)</span><br><span class=\"line\">210621 21:52:01\t    2 Connect\troot@localhost on </span><br><span class=\"line\">\t\t    2 Query\tselect @@version_comment limit 1</span><br><span class=\"line\">210621 21:52:51\t    2 Query\tSELECT DATABASE()</span><br><span class=\"line\">\t\t    2 Init DB\ttest</span><br><span class=\"line\">210621 21:53:00\t    2 Query\tselect * from a</span><br><span class=\"line\">210621 21:53:03\t    2 Query\tselect * from a</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"普通日志文件处理\"><a href=\"#普通日志文件处理\" class=\"headerlink\" title=\"普通日志文件处理\"></a>普通日志文件处理</h2><p>//TODO</p>\n<hr>\n<h1 id=\"slow-query-log（慢查询日志）\"><a href=\"#slow-query-log（慢查询日志）\" class=\"headerlink\" title=\"slow query log（慢查询日志）\"></a>slow query log（慢查询日志）</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>slow query log 是 MySQL 的慢查询日志。<br>主要记录 MySQL 中【响应时间超过阀值的sql语句】 或【没有使用索引】的查询语句。</p>\n<p><strong>注意：慢查询日志与普通查询日志不同，区别在于：慢查询日志只包含成功执行过的查询语句。</strong>  </p>\n<hr>\n<h2 id=\"相关参数-1\"><a href=\"#相关参数-1\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h2><p>以下是慢查询日志相关的参数：</p>\n<ul>\n<li>slow_query_log：慢查询日志是否开启</li>\n<li>slow_query_log_file：慢查询日志文件的存放路径，如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log。</li>\n<li>long_query_time：设置慢查询的时间阈值，默认阈值是10s。</li>\n<li>log_quries_not_using_indexes：是否将不适用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</li>\n<li>slow_queries：记录当前慢查询sql条数</li>\n</ul>\n<hr>\n<h2 id=\"开启慢查询日志\"><a href=\"#开启慢查询日志\" class=\"headerlink\" title=\"开启慢查询日志\"></a>开启慢查询日志</h2><p>查看慢查询日志的当前配置.<br>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| Variable_name       | Value                                  |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">| slow_query_log      | OFF                                    |</span><br><span class=\"line\">| slow_query_log_file | /var/lib/mysql/VM-16-4-centos-slow.log |</span><br><span class=\"line\">+---------------------+----------------------------------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>; #查看是否开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log_file%&#x27;</span>; #查看慢查询日志文件的存放路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">slow_query_log=1</span><br><span class=\"line\">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么-sql-会被记录到慢查询日志\"><a href=\"#什么-sql-会被记录到慢查询日志\" class=\"headerlink\" title=\"什么 sql 会被记录到慢查询日志\"></a>什么 sql 会被记录到慢查询日志</h2><p>问：开启慢查询日志后，什么 sql 会被记录到慢查询日志里面呢？<br>答：慢查询日志主要记录【响应时间超过阀值的sql语句】或【没有使用索引】的查询语句。</p>\n<h3 id=\"记录响应时间超过阀值的sql语句\"><a href=\"#记录响应时间超过阀值的sql语句\" class=\"headerlink\" title=\"记录响应时间超过阀值的sql语句\"></a>记录响应时间超过阀值的sql语句</h3><p>时间阈值是由 long_query_time 控制的.<br>long_query_time：设置慢查询的时间阈值，默认阈值是10s。可以使用命令修改，也可以在my.cnf参数里面修改。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>; #查看long_query_time的值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">5</span>; #设置查询超过<span class=\"number\">5</span>秒则算慢查询<span class=\"keyword\">sql</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">long_query_time=5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"记录没有使用索引的查询语句\"><a href=\"#记录没有使用索引的查询语句\" class=\"headerlink\" title=\"记录没有使用索引的查询语句\"></a>记录没有使用索引的查询语句</h3><p>log_quries_not_using_indexes：是否将不使用索引的查询语句记录到慢查询日志中，无论查询速度有多快。</p>\n<p>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%log_queries_not_using_indexes%&#x27;</span>; #查看值</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> log_queries_not_using_indexes<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启记录没有使用索引的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：（永久开启）<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"慢查询-sql-案例\"><a href=\"#慢查询-sql-案例\" class=\"headerlink\" title=\"慢查询 sql 案例\"></a>慢查询 sql 案例</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>; #设置开启慢查询日志</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">3</span>; #设置查询超过<span class=\"number\">3</span>秒则算慢查询<span class=\"keyword\">sql</span>（注意，这里是全局命令设置，需要重新连接才生效）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> sleep(<span class=\"number\">4</span>) #模拟一次查询，查询耗时<span class=\"number\">4</span>秒</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_queries%&#x27;</span>; #查询当前慢查询<span class=\"keyword\">sql</span>条数命令</span><br></pre></td></tr></table></figure>\n\n<p>去mysql的data目录下找到慢查询日志文件：<br>我没有去配置日志文件名，所以是一个默认的文件名：localhost-slow.log<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/1624261484667.jpg\" alt=\"慢查询日志图片\"></p>\n<p>可以看到当前慢查询日志中会记录查询超过了阈值的sql，我们刚刚的select sleep(4)就在当中，而且可以明确的看到当前sql，当前查询时间，锁的时间，一共有多少数据。</p>\n<hr>\n<h2 id=\"日志查询分析器（mysqldumpslow）\"><a href=\"#日志查询分析器（mysqldumpslow）\" class=\"headerlink\" title=\"日志查询分析器（mysqldumpslow）\"></a>日志查询分析器（mysqldumpslow）</h2><p>日志查询分析器的体现：<br>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%BF%E7%94%A8.jpg\" alt=\"日志查询分析器帮助信息图片\"></p>\n<p>mysqldumpslow –help  查看mysqldumpslow的帮助信息</p>\n<ul>\n<li>s：表示按照何种方式排序</li>\n<li>c：访问次数</li>\n<li>l：锁定时间</li>\n<li>r：返回记录</li>\n<li>t：查询时间</li>\n<li>al：平均锁定时间</li>\n<li>ar：平均返回记录数</li>\n<li>at：平均查询时间</li>\n<li>t：即为返回前面多少条数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感。</li>\n</ul>\n<p>分析器常用的方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#得到返回数据集最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>localhost<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到访问次数最多的<span class=\"number\">10</span>个<span class=\"keyword\">SQL</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s c <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#得到按照时间排序的前<span class=\"number\">10</span>条里面含有左连接的查询<span class=\"keyword\">sql</span></span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s t <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">-</span>g &quot;left join&quot; <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log</span><br><span class=\"line\"></span><br><span class=\"line\">#另外建议在使用这些命令时结合 <span class=\"operator\">|</span> 和more 使用 ，否则有可能出现爆屏情况</span><br><span class=\"line\">mysqldumpslow <span class=\"operator\">-</span>s r <span class=\"operator\">-</span>t <span class=\"number\">10</span> <span class=\"operator\">/</span>var<span class=\"operator\">/</span>lib<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>atguigu<span class=\"operator\">-</span>slow.log <span class=\"operator\">|</span> more</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"bin-log（二进制日志）\"><a href=\"#bin-log（二进制日志）\" class=\"headerlink\" title=\"bin log（二进制日志）\"></a>bin log（二进制日志）</h1><h2 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>bin log 是 MySQL 的二进制文件，也叫归档日志，是Mysql Server层记录的。<br>主要记录 MySQL 数据库中的所有更新操作，如：use，insert，delete，update，create，alter，drop等操作。不改变数据的sql不会记录，比如 select 语句一般不会被记录，因为他们不会对数据产生任何改动。  </p>\n<p><strong>用一句更简介易懂的话概况就是：所有涉及数据变动的操作，都会记录到二进制日志文件中。</strong></p>\n<hr>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>1）数据恢复<br>做数据恢复。因为binlog详细的记录了所有修改数据的sql，在某个时间段因操作导致数据出现问题，或数据库党纪数据丢失，那么就可以通过binlog来恢复历史数据。<br>2）mysql主从复制<br>做数据备份和读写分离。在 master 端开启 bin log，master 把它的二进制日志传递给 slaves 来达到master-slave数据一致的目的。  </p>\n<hr>\n<h2 id=\"二进制日志文件常用操作命令\"><a href=\"#二进制日志文件常用操作命令\" class=\"headerlink\" title=\"二进制日志文件常用操作命令\"></a>二进制日志文件常用操作命令</h2><p>1）查看是否启动bin log 日志<br>show variables like ‘log_bin’;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>2）查看binlog的目录<br>show global variables like “%log_bin%”;</p>\n<p>3）查看主库的日志文件，以及position信息<br>show master logs;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master logs;</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| Log_name         | File_size |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">| mysql-bin.000001 |       314 |</span><br><span class=\"line\">| mysql-bin.000002 |       639 |</span><br><span class=\"line\">+------------------+-----------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>4）查看master状态，即最后（最新）一个bin log日志的编号名称，及其最后一个操作事件pos结束点(Position)值。<br>show master status;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show master status;</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">| mysql-bin.000002 |      639 |              |                  |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>5）flush 刷新log日志，自此刻开始产生一个新编号的bin log日志文件;<br>flush logs;<br>注意：每当mysqld服务重启时，会自动执行此命令，刷新bin log日志；在mysqlddump备份数据时加-F选项也会刷新bin log日志；</p>\n<p>6）重置（清空）所有bin log日志;<br>reset master;</p>\n<hr>\n<h2 id=\"开启bin-log\"><a href=\"#开启bin-log\" class=\"headerlink\" title=\"开启bin log\"></a>开启bin log</h2><p>注意：mysql 8.0 版本之前，默认不开启，建议开启。</p>\n<p>查看二进制日志的当前配置：<br>可以看到，二进制日志默认是不开启的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| Variable_name | Value |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">| log_bin       | OFF   |</span><br><span class=\"line\">+---------------+-------+</span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件：(永久开启)<br>修改 my.cnf 文件，在 [mysqld] 下增加或修改参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld] </span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">server-id=001</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件后，重启服务配置生效<br>查看 bin log 日志文件<br><img src=\"https://kubpang.gitee.io/sourceFile/MySQL/1624350274231.jpg\" alt=\"bin log 日志文件\"></p>\n<hr>\n<h2 id=\"bin-log-的写入时机\"><a href=\"#bin-log-的写入时机\" class=\"headerlink\" title=\"bin log 的写入时机\"></a>bin log 的写入时机</h2><p>对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。</p>\n<p>sync_binlog参数讲解：<br>1）如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；<br>2）如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。<br>3）设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。</p>\n<p>如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。</p>\n<p>在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。一般情况下会设置为1或者0，牺牲一定的一致性来获取更好的性能。</p>\n<hr>\n<h2 id=\"bin-log-文件以及扩展\"><a href=\"#bin-log-文件以及扩展\" class=\"headerlink\" title=\"bin log 文件以及扩展\"></a>bin log 文件以及扩展</h2><p>二进制日志包含两种文件：  </p>\n<ul>\n<li>二进制日志索引文件（文件名后缀.index），用于记录索引的二进制文件  </li>\n<li>二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件</li>\n</ul>\n<p>binlog是一个二进制文件集合，每个binlog文件以一个4字节的魔数开头，接着是一组Events:  </p>\n<ul>\n<li>魔数：0xfe62696e对应的是0xfebin； </li>\n<li>Event：每个Event包含header和data两个部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的是针对该* Event的具体信息，如具体数据的修改；</li>\n<li>第一个Event用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式；</li>\n<li>其余的Event按照第一个Event的格式版本写入；</li>\n<li>最后一个Event用于说明下一个binlog文件；</li>\n<li>binlog的索引文件是一个文本文件，其中内容为当前的binlog文件列表</li>\n</ul>\n<p>当遇到以下3种情况时，MySQL会重新生成一个新的日志文件，文件序号递增：</p>\n<ul>\n<li>MySQL服务器停止或重启时</li>\n<li>使用 flush logs 命令；</li>\n<li>当 binlog 文件大小超过 max_binlog_size 变量的值时；</li>\n</ul>\n<p>max_binlog_size 的最小值是4096字节，最大值和默认值是 1GB (1073741824字节)。事务被写入到binlog的一个块中，所以它不会在几个二进制日志之间被拆分。因此，如果你有很大的事务，为了保证事务的完整性，不可能做切换日志的动作，只能将该事务的日志都记录到当前日志文件中，直到事务结束，你可能会看到binlog文件大于 max_binlog_size 的情况。</p>\n<p>注意：bin log与数据库文件在同目录中。  </p>\n<hr>\n<h2 id=\"bin-log-的日志格式\"><a href=\"#bin-log-的日志格式\" class=\"headerlink\" title=\"bin log 的日志格式\"></a>bin log 的日志格式</h2><p>记录在二进制日志中的事件的格式取决于二进制记录格式。支持三种格式类型：</p>\n<ul>\n<li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li>\n<li>ROW：基于行的复制（row-based replication, RBR）</li>\n<li>MIXED：混合模式复制（mixed-based replication, MBR）</li>\n</ul>\n<p><strong>注意：在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。</strong></p>\n<h3 id=\"Statement\"><a href=\"#Statement\" class=\"headerlink\" title=\"Statement\"></a>Statement</h3><p>每一条会修改数据的sql都会记录在binlog中</p>\n<p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p>\n<p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。</p>\n<h3 id=\"Row\"><a href=\"#Row\" class=\"headerlink\" title=\"Row\"></a>Row</h3><p>5.1.5版本的MySQL才开始支持 row level 的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>\n<p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p>\n<p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p>\n<p>注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。</p>\n<h3 id=\"Mixed\"><a href=\"#Mixed\" class=\"headerlink\" title=\"Mixed\"></a>Mixed</h3><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>\n<h3 id=\"bin-log企业模式的选择\"><a href=\"#bin-log企业模式的选择\" class=\"headerlink\" title=\"bin log企业模式的选择\"></a>bin log企业模式的选择</h3><p>互联网公司使用MySQL的功能较少（不用存储过程、触发器、函数），选择默认的Statement level；<br>用到MySQL的特殊功能（存储过程、触发器、函数）则选择Mixed模式；<br>用到MySQL的特殊功能（存储过程、触发器、函数），又希望数据最大化一直则选择Row模式；</p>\n<h2 id=\"查看二进制日志文件\"><a href=\"#查看二进制日志文件\" class=\"headerlink\" title=\"查看二进制日志文件\"></a>查看二进制日志文件</h2><p>bin log是二进制文件，普通文件查看器cat、more、vim等都无法打开，必须使用自带的 mysqlbinlog 命令查看。  </p>\n<h3 id=\"mysqlbinlog-工具查看\"><a href=\"#mysqlbinlog-工具查看\" class=\"headerlink\" title=\"mysqlbinlog 工具查看\"></a>mysqlbinlog 工具查看</h3><p>mysqlbinlog 是 MySQL 中自带的工具，具体位置在 MySQL 的 bin 目录下。<br>在Mysql5.5以下版本使用mysqlbinlog命令时如果报错，就加上”–no-defaults”选项</p>\n<p>mysqlbinlog 使用语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysqlbinlog 的执行格式</span></span><br><span class=\"line\">mysqlbinlog [options] log_file ...</span><br><span class=\"line\">-s                          以精简的方式显示日志内容</span><br><span class=\"line\">-v                          以详细的方式显示日志内容</span><br><span class=\"line\">-d=数据库名                  只显示指定数据库的日志内容</span><br><span class=\"line\">-o=n                        忽略日志中前n行MySQL命令</span><br><span class=\"line\">-r=file                     将指定内容写入指定文件</span><br><span class=\"line\">--start-datetime  </span><br><span class=\"line\">                            显示指定时间范围内的日志内容</span><br><span class=\"line\">--stop-datetime         </span><br><span class=\"line\"></span><br><span class=\"line\">--start-position        </span><br><span class=\"line\">                            显示指定位置间隔内的日志内容</span><br><span class=\"line\">--stop-position     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（shell方式）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看bin-log二进制文件（带查询条件）</span></span><br><span class=\"line\">mysqlbinlog -v --base64-output=decode-rows /var/lib/mysql/master.000003 \\</span><br><span class=\"line\">    --start-datetime=<span class=\"string\">&quot;2019-03-01 00:00:00&quot;</span>  \\</span><br><span class=\"line\">    --stop-datetime=<span class=\"string\">&quot;2019-03-10 00:00:00&quot;</span>   \\</span><br><span class=\"line\">    --start-position=<span class=\"string\">&quot;5000&quot;</span>    \\</span><br><span class=\"line\">    --stop-position=<span class=\"string\">&quot;20000&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>查看二进制日志文件：mysqlbinlog -v –base64-output=decode-rows mysql-bin.000002 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># at 391</span><br><span class=\"line\">#210622 17:06:40 server id 1  end_log_pos 501   Query   thread_id=2     exec_time=0     error_code=0</span><br><span class=\"line\">SET TIMESTAMP=1624352800/*!*/;</span><br><span class=\"line\">insert into admin_info values(1, &quot;admin&quot;, 100) #执行的sql</span><br><span class=\"line\">/*!*/;</span><br></pre></td></tr></table></figure>\n<p>解释：  </p>\n<ul>\n<li>position: 位于文件中的位置，即第一行的（# at 391）,说明该事件记录从文件第391个字节开始</li>\n<li>timestamp: 事件发生的时间戳，即第二行的（#210622 17:06:40）</li>\n<li>server id: 服务器标识（1）</li>\n<li>end_log_pos 表示下一个事件开始的位置（即当前事件的结束位置+1）</li>\n<li>thread_id: 执行该事件的线程id （thread_id=2）</li>\n<li>exec_time: 事件执行的花费时间</li>\n<li>error_code: 错误码，0意味着没有发生错误</li>\n<li>type：事件类型Query</li>\n</ul>\n<h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>mysqlbinlog 查看取出 bin log 日志的全文内容比较多，不容易分辨查看到pos点信息<br>介绍一种更为方便的查询命令 show bin log events</p>\n<p>命令解析 show bin log events [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count];<br>参数解析：<br>a、IN ‘log_name’:指定要查询的bin log文件名（不指定就是第一个bin log文件<br>b、FROM pos:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>c、LIMIT【offset】：偏移量(不指定就是0)<br>d、row_count :查询总条数（不指定就是所有行）  </p>\n<p>show bin log events查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show bin log events in&#x27;mysql-bin.000002&#x27;;</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                                                            |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">| mysql-bin.000002 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.62-log, bin log ver: 4                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 107 | Query       |         1 |         192 | create database admin                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 192 | Query       |         1 |         322 | use `admin`; create table admin_info(id int(11), name varchar(50), age int(11)) |</span><br><span class=\"line\">| mysql-bin.000002 | 322 | Query       |         1 |         391 | BEGIN                                                                           |</span><br><span class=\"line\">| mysql-bin.000002 | 391 | Query       |         1 |         501 | use `admin`; insert into admin_info values(1, &quot;admin&quot;, 100)                     |</span><br><span class=\"line\">| mysql-bin.000002 | 501 | Xid         |         1 |         528 | COMMIT /* xid=7 */                                                              |</span><br><span class=\"line\">| mysql-bin.000002 | 528 | Query       |         1 |         639 | use `admin`; create table role(id int(11), name varchar(25))                    |</span><br><span class=\"line\">+------------------+-----+-------------+-----------+-------------+---------------------------------------------------------------------------------+</span><br><span class=\"line\">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"利用二进制日志恢复数据\"><a href=\"#利用二进制日志恢复数据\" class=\"headerlink\" title=\"利用二进制日志恢复数据\"></a>利用二进制日志恢复数据</h2><p>// TODO</p>\n<hr>\n<h1 id=\"relay-log（中继日志）\"><a href=\"#relay-log（中继日志）\" class=\"headerlink\" title=\"relay log（中继日志）\"></a>relay log（中继日志）</h1><h2 id=\"定义-4\"><a href=\"#定义-4\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>// TODO</p>\n<h1 id=\"MySQL-事务日志（redolog-amp-undolog）\"><a href=\"#MySQL-事务日志（redolog-amp-undolog）\" class=\"headerlink\" title=\"MySQL 事务日志（redolog &amp; undolog）\"></a>MySQL 事务日志（redolog &amp; undolog）</h1><p>请看MySQL事务日志分析博客</p>"},{"title":"Redis-哨兵模式","date":"2020-06-21T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Redis/Redis-哨兵模式.md","raw":"---\ntitle: Redis-哨兵模式\ndate: 2020-06-22 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---","slug":"oyr/Redis/Redis-哨兵模式","published":1,"updated":"2021-07-13T09:52:43.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836b001ahct7dkwhhhcj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL-基础","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n# 常用数据类型\n\n## 数值型\n\n### 整型\n\n特点：  \n1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字  \n2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值  \n3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n### 小数\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n## 字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n## 日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数   \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名（两种方式）\nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n## 条件查询\n\n### 语法\n\n```\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n```\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \n```sql\nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n```\n\n\nCONCAT：  \n作用：拼接字符串  \n```sql\nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n```\n\n\nUPPER：  \n作用：字符串变大写  \n```sql\nSELECT UPPER(\"asc\");\n```\n\nLower：  \n作用：字符串变小写\n```sql\nSELECT LOWER(\"ASC\");\n```\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n```\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n```\n\nReplace：  \n作用：替换字符串  \n```sql\nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n```\n\nInstr:  \n作用：获取子串第一次出现的索引\n```sql\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n```\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```sql\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \n```sql\nSELECT CEIL(1.52);  \n结果：2\n```\n\n\nFloor：  \n作用：向下取整  \n```sql\nSELECT FLOOR(9.99);\n结果：9\n```\n\nTruncate：  \n作用：截断  \n```sql\nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n```\n\nMod：  \n作用：取余  \n```sql\nSELECT MOD(10, 3);  \n结果：1\n```\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \n```sql\nSELECT RAND();\n```\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","source":"_posts/oyr/MySQL/MySQL-基础.md","raw":"---\ntitle: MySQL-基础\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-MySQL\ntags: \n\t- oyr-MySQL\n\t- 数据库\n---\n\nMysql数据库\n\n# MySql基础\n\n## 数据库的好处\n\n可以持久化到本地  \n结构化查询\n\n***\n\n## 主流的数据库介绍（了解）\n\nSql server 数据库  \n是微软，.net程序员最爱，中型和大型项目，性能高\n\nOracle数据库  \n是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。\n\nMysql数据库  \n是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。\n\ndb2数据库  \n是ibm公司，处理海量数据，大型项目。很强悍。\n\nInformix数据库  \n是ibm公司。在银行系统，安全性高\n\nSybase数据库\n\n***\n\n## mysql的优点\n\n开源，免费成本低  \n性能高，移植性也好  \n体积小，便于安装\n\n## mysql数据库的安装和配置\n\n看MySQL-5.7.17安装与配置.docx\n\n## mysql的基本使用\n\n（1）连接到mysql\nCmd>mysql -h 主机名 -u 用户名 -p 密码 回车\n举例：\n\n说明：\n如果你没有写-h localhost 默认是连接本地\n\n如果你需要远程登录到另一个mysql,则需要修改配置。\n一般情况下部让远程登录。\n\n（2）sql服务的退出\nexit或ctrl+c\n\n（3）关闭和启动mysql服务\n界面操作：\n\n命令模式：\n启动：net stop mysql\n停止：net start mysql\n举例：\n\n说明：这里mysql不是固定的，是安装时取的服务名称。\n\n## mysql数据库三层架构介绍\n\n专业术语\n\nDb：  \n数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。\n\nDbms：  \n数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。\n\nSql:  \n结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。\n\n数据库服务器，数据库和表的关系如图所示：\n\n\n示意图：\n\n## mysql常见命令\n\n```\n1.查看当前所有的数据库\nshow databases;\n\n2.打开指定的库\nuse 库名;\n\n3.查看所在的数据库名\nselect database();\n\n4.查看当前库的所有表\nshow tables;\n\n5.查看其它库的所有表\nshow tables from 库名;\n\n6.创建表\ncreate table user(id int, name varchar(20));\n\n7.查看表结构\ndesc 表名;\t\t\n\n8.查看服务器的版本\n方式一：登录到mysql服务端\nSelect version();\n方式二：没有登录到mysql服务端\nMysql --version或mysql --V\n\n9.查看当前时区\nSHOW VARIABLES LIKE 'time_zone'\nSET time_zone='+9:00';\n```\n\n## Mysql的语法规范\n\n1.不区分大小写，单建议关键字大写，表名，列名小写。  \n2.每条语句最好用分号结尾。  \n3.每条命令根据需要，可以进行缩进或换行  \n4.注释  \n单行注释：两种  \n第一种：#注释文字  \n第二种：-- 注释文字  \n多行注释：/* 注释文字 */\n\n# 常用数据类型\n\n## 数值型\n\n### 整型\n\n特点：  \n1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字  \n2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值  \n3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！\n\n\n### 小数\n\n浮点型：\nFloat(m, d)，double(m, d)\n4\t\t\t8\n\n定点型：\nDec(m, d)，decimal(m, d)\nM+2\t\tm+2\n\n特点：\n（1）\nM：整数部位+小数部位（总长度）\nD：小数部位\n如果超出范围插入临界值\n\n（2）\nM和D都可以省略\n如果是decimal，则m默认为10，d默认为0\n如果是double和float，则会随着插入的数值的精度来决定精度\n\n（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用\n\n\n## 字符型\n\n较短的文本：\nChar\nVarchar\n\n特点：\n\n写法\t\tm的意思\t\t\t特点\t\t\t空间的耗费\t\t效率\nChar\tchar(m)\t\t最大的字符数\t固定长度\t\t比较耗费\t\t高\nVarchar\tvarchar(m)\t最大的字符数\t可变长度的字符\t比较节省\t\t低\n\n\n较长的文本：\nText\nBlob（较大的二进制）\n\n\nEnum类型：\n说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n如果列表成员为1~255，则需要1个字节存储\n如果列表成员为255~65535，则需要2个字节存储\n最多需要65535个成员\n\n\nSet类型：\n说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区\n别是：SET类型一次可以选取多个成员，而Enum只能选一个\n根据成员个数不同，存储所占的字节也不同\n\n\n## 日期型\n\n\n总结：\nDate：只保存日期，并没有保存到时分秒\nTime：只保存时间（时分秒）\nYear：只保存年\n\nDatetime：保存日期+时间\nTimestamp：保存日期+时间\n\n\nDatetime VS Timestamp\n\n字节\t范围\t\t时区等的影响\nDatetime \t8\t\t1000-9999\t\t不受\nTimestamp\t4\t\t1970-2038\t\t受\n\n# DQL语言（select）\n\n## 基础查询\n\n### 语法\n\nselect 查询列表 from 表名\n\n### 特点\n\n查询列表开源是字段，常量表达式，函数，也可以有多个。  \n查询结构是一个虚拟表。\n\n### 示例\n\n1.查询单个字段  \nSelect 字段名 from 表名\n\n2.查询多个字段  \nSelect 字段名,字段名 from 表名\n\n3.查询所有的字段  \nSelect * from 表名\n\n4.查询常量  \nSelect 常量值  \n注意：字符型和日期型常量值必须用单引号用起来，数值类不需要\n\n5.查询函数   \nSelect 函数名（实例参数）;\n\n6.查询表达式  \nSelect 100*10;\n\n7.取别名（两种方式）\nAs  \nSelect last_name as 姓名 from 表名  \n\n空格  \nSelect last_name 姓名 from 表名\n\n8.去重  \nSelect distinct 字段名 from 表名\n\n9.+  \n作用：加法运算  \nSelect 数值+数值;直接运算  \nSelect 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，\t再做运算。\n\n10.补充Concat函数  \n功能：拼接字符  \nSelect concat(字符1,字符2,字符3,....)\n\n11.补充ifnull函数  \nSelect ifnull(name, 0) from user\n\n12.补充isnull函数  \nSelect isnull(name) from user  \n功能：拍的某个字段是否为null，如果是返回1，如果不是返回0\n\n## 条件查询\n\n### 语法\n\n```\nSelect 查询列表  \nFrom 表名  \nWhere 筛选条件\n```\n\n### 筛选条件的分类\n\n（1）简单条件运算符  \n\n```> < = <> != >= <= <=>```\n\nSelect * from user where age>15;\n\nSelect * from user where age<15;\n\nSelect * from user where age<>15;\n\n<=>:安全等于，可以判断普通数值，也可以判断是否为null  \nSelect * from user where age<=> null;\n\n（2）逻辑运算符\n\n```and or not```\n\nAnd:  \nSELECT last_name FROM employees WHERE salary>=10000 AND salary<=20000;\n\nOr:  \nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n\nNot:  \nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n（3）模糊查询\n\n```Like, between and, in, is null, is not null ```\n\nlike：  \nSelect * from user where name like’%a%’;  \nSelect * from user where name like’_a%’;\n\n\nbetween and:  \n作用：在哪两个数之间  \nSelect * from user where age between 10 and 20;\n\nin:  \nSelect * from user where id in(1,2,3);\n\nis null:  \n作用：判断是否为null  \nSelect * from user where age is null;\n\nis not null:  \n作用：判断是否不为空  \nSelect * from user where age is not null;\n\n## 排序查询\n\n### 语法\n\nSelect * from 表名  \n[Where 筛选条件]  \nOrder by 排序列表[asc desc]\n\n### 特点\n（1）asc代表升序，desc代表降序，如果不写是升序。  \n（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名  \n（3）order by子句一般是放查询语句的最后面，limit子句除外\n\n### 案例\n\n#案例：查询员工信息，要求工资冲高到底排序  \n```sql\nSELECT * FROM employees ORDER BY salary DESC;\n```\n\n#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  \n```sql\nSELECT *, salary*12*(1+IFNULL(commission_pct, 0)) AS 年薪 \nFROM employees \nORDER BY 年薪 DESC;\n```\n\n#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 \n``` sql\nSELECT * FROM employees \nWHERE email LIKE '%e%' \nORDER BY LENGTH(email) DESC, department_id ASC;\n```\n\n## 常见函数\n\n功能：类似java中的方法  \n好处：提高重用性和隐藏实现细节  \n调用：select 函数名(参数列表)  \n\n### 字符函数\n\nLENGTH：  \n作用：获取参数的字节个数  \n```sql\nSELECT LENGTH('oyr');  \nSELECT LENGTH('欧阳荣');\n```\n\n\nCONCAT：  \n作用：拼接字符串  \n```sql\nSELECT CONCAT('abc', 'jkl');  \nSELECT CONCAT(first_name, last_name) out_put FROM employees;\n```\n\n\nUPPER：  \n作用：字符串变大写  \n```sql\nSELECT UPPER(\"asc\");\n```\n\nLower：  \n作用：字符串变小写\n```sql\nSELECT LOWER(\"ASC\");\n```\n\nSubstr:  \n作用：截取字符串，两种使用方式\n``` sql\n#第一种：截取从指定索引处后面所有字符  \nSELECT SUBSTR(\"欧阳荣真的帅哦\", 4);  \n结果：真的帅哦\n\n#第二种：截取从指定索引处指定字符串的字符  \nSELECT SUBSTR(\"欧阳荣不是一般帅哦\", 1, 3);  \n结果：欧阳荣\n\n# 案例1：姓名首字母大写，其他字符小写然后用_拼接，显示出来\nSELECT CONCAT(UPPER(SUBSTR(last_name, 1, 1)), '_', LOWER(SUBSTR(last_name, 2))) FROM employees;\n```\n\nTrim:\n作用：去除两边空格或去除两边指定字符\n``` sql\n#去除两边空格：\nSELECT LENGTH(TRIM('   欧阳荣 '));\n结果：欧阳荣\n\n#去除两边指定字符：\nSELECT TRIM('a' FROM 'aaaaaaaa欧阳aaa荣aaaaaa');\n结果：欧阳aaa荣\n```\n\nLpad：  \n作用：lpad 用指定的字符实现左填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 10, 'a') out_put;\n```\n\nRpad：  \n作用：用指定的字符实现右填充指定长度  \n```sql\nSELECT LPAD('欧阳荣', 12, 'ab') out_put;\n```\n\nReplace：  \n作用：替换字符串  \n```sql\nSELECT REPLACE('赵吊彬是zz赵吊彬赵吊彬赵吊彬', '赵吊彬', '李执志');\n```\n\nInstr:  \n作用：获取子串第一次出现的索引\n```sql\nSELECT INSTR('欧阳荣多对多', '欧阳');\n结果为：1\n```\n\n### 数学函数\n\nRound:  \n作用：四舍五入\n```sql\n第一种使用：\nSELECT ROUND(1.65);\n结果：2\n\n第二种使用：\nSELECT ROUND(1.657, 2);\n结果：1.66\n```\n\nCeil：  \n作用：向上取整  \n```sql\nSELECT CEIL(1.52);  \n结果：2\n```\n\n\nFloor：  \n作用：向下取整  \n```sql\nSELECT FLOOR(9.99);\n结果：9\n```\n\nTruncate：  \n作用：截断  \n```sql\nSELECT TRUNCATE(10.19, 1);  \n结果：10.1\n```\n\nMod：  \n作用：取余  \n```sql\nSELECT MOD(10, 3);  \n结果：1\n```\n\nRand：  \n作用：获取随机数，返回0-1之间的小数  \n```sql\nSELECT RAND();\n```\n\n### 日期函数\n\nNOW：  \n作用：返回当前系统日期+时间  \nSELECT NOW();\n\nCurdate：  \n作用：返回当前系统日期，不包含时间  \nSELECT CURDATE();\n\nCurtime：  \n作用：返回当前时间，不包含日期  \nSELECT CURTIME();\n\nYear：  \n作用：获取年  \nSelect year(now());  \nSELECT YEAR('1999-1-1') 年;\n\nMonth:  \n作用：获取月  \nSELECT MONTH(NOW()) 月;\n\nDay:  \n作用：获取日  \nSelect DAY(now()) 日;\n\n\n日期格式符：\n\n\n\n\n\nStr_to_date:  \n作用：将日期格式的字符转换成指定格式的日期  \nSELECT STR_TO_DATE('1999-6-2', '%Y-%c-%d') out_put;  \nSELECT * FROM employees WHERE hiredate=STR_TO_DATE('4-3 1992', '%c-%d %Y');\n\n\nDate_format：  \n作用：将日期转换成字符  \nSELECT DATE_FORMAT(NOW(), '%y年%m月%d日') AS out_put;\n\n案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）\nSELECT last_name, DATE_FORMAT(hiredate, '%M月/%d日 %y年') \nFROM employees \nWHERE commission_pct IS NOT NULL;\n\nDatediff：  \n作用：返回两个日期相差的天数  \nSELECT DATEDIFF(NOW(), '1999-06-24');\n\n\n### 其他函数\n\nVERSION：  \n作用：查看当前mysql版本号  \nSELECT VERSION();\n\nDATABASE：  \n作用：查看当前打开的数据库  \nSelect DATABASE();\n\nUSER：  \n作用：查看当前登录的用户  \nSelect USER();\n\n### 流程控制函数\n\nIf：  \n作用：判断真假  \nSELECT IF(10<5, '小', '大');\n\nCase:  \n作用：判断  \n语法：  \ncase 要带的字段或表达式  \nwhen 常量1 then 要显示的值1或语句1;  \nwhen 常量1 then 要显示的值1或语句1;  \n.....  \nelse 要显示的值n或语句n  \nEnd\n\n``` sql\n案例：查询员工的工资，要求\n部门号=30,显示的工资为1.1倍\n部门号=40，显示的工资为1.2倍\n部门号=50，显示的工资为1.3倍\n其他部门，显示的工资为原工资\n\nSELECT last_name, salary 原工资, \nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n\n案例：查询员工的工资的情况\n如果工资>20000，显示A级别\n如果工资>15000，显示B级别\n如果工资>10000,显示C级别\n否则，显示D级别\n\nSELECT last_name,salary,\nCASE\nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 级别\nFROM employees;\n```\n\n## 分组\n\n### 分组函数\n\nsum:\n作用：求和\nSELECT SUM(salary) FROM employees;\n\n\nmax:\n作用：最大值\nSelect max(salary) from employees;\n\n\nmin：\n作用：最小值\nSELECT MIN(salary) FROM employees;\n\n\navg：\n作用：平均数\nSELECT AVG(salary) FROM employees;\n\n\ncount：\n作用：计算个数\nSelect count(*) from user;\n\n\n注意事项：\nsum，avg一般用于数值型\nmax，min，count可以处理任何类型\n以上分组函数都忽略null值\n\n### 分组查询\n\n语法：\nselect 分组函数，列（要求出现在group by的后面）\nfrom 表\n[where 筛选条件]\ngroup by 分组的列表\n[having 分组后的筛选]\n[order by 子句]\n\n注意：\n查询列表必须特殊，要求是分组函数或group by后出现的字段\n分组后筛选在group by子句的后面使用 having 关键字\n分组函数做条件肯定是放在having子句中\n能用分组前筛选，就优先使用分组前筛选\ngroup by 子句支持单个字段分组，多个字段分组（用逗号隔开）\n\n简单分组：\n```sql\n#案例1：查询每个部门的平均工资\nSELECT department_id,AVG(salary) 平均工资 FROM employees GROUP BY department_id; \n\n#案例2：查询每个工种的最高工资\nSELECT job_id, MAX(salary) FROM employees GROUP BY job_id;\n\n#案例3：查询每个位置上的部门个数\nSELECT location_id, COUNT(*) FROM departments GROUP BY location_id;\n```\n\n添加筛选条件：\n```sql\n#案例1：查询邮箱中包含a字符的，每个部门的平均工资\nSELECT department_id, AVG(salary) \nFROM employees \nWHERE email LIKE '%a%' \nGROUP BY department_id;\n\n#案例2：查询有奖金的每个领导手下的最高工资\nSELECT manager_id, MAX(salary)\nFROM employees \nWHERE commission_pct IS NOT NULL \nGROUP BY manager_id;\n\n#案例3：查询哪个部门的员工个数>2\nSelect department_id, count(*) \nfrom employees\ngroup by department_id having count(*)>2;\n\n#案例4：查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT job_id, MAX(salary) \nFROM employees\nGROUP BY job_id HAVING MAX(salary)>12000;\n\n#案例5：查询领导编号>102的每个领导手下的最低工资>5000的领导编号是哪个\nSELECT manager_id, MIN(salary) \nFROM employees \nWHERE manager_id>102 \nGROUP BY manager_id HAVING MIN(salary)>5000;\n\n#案例6：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些\nSELECT last_name, LENGTH(last_name), COUNT(*) 员工个数 \nFROM employees \nGROUP BY LENGTH(last_name) HAVING COUNT(*)>5;\n```\n\n## 连接查询\n\n什么是连接查询：  \n又称多表查询，当查询的字段来自多个表时，就会用到连接查询。\n\n笛卡尔积:  \n笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行\n\n\n### 分类\n\t\n按年代分类：  \nsql92标准：仅仅支持内连接  \nsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\n按功能分类：\n- 内连接：  \n    - 等值连接  \n    - 非等值连接  \n    - 自连接  \n- 外连接：  \n    - 左外连接  \n    - 右外连接  \n    - 全外连接（mysql不支持）  \n- 交叉连接：  \n\n### 语法\n\nSelect 查询列表\nFrom 表1 别名 【连接类型】\nJoin 表2 别名\nOn 连接条件\n【where 筛选条件】\n【group by 分组】\n【having 分组后筛选】\n【order by 排序列表】\n\n### 内连接\n\nSql192语法：\n```\n（1）等值连接\n案例：\n查询女神名和对应男生名\nSELECT b.name,bs.boyName \nFROM beauty b, boys bs \nWHERE b.boyfriend_id = bs.id;\n\n查询员工名和对应的部门名\nSELECT e.last_name, e.department_id, d.department_name \nFROM employees e, departments d \nWHERE e.department_id=d.department_id;\n\n查询有奖金的员工名，部门名\nSELECT e.`last_name`, d.`department_id`, e.`commission_pct` \nFROM employees e,departments d \nWHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;\n\n查询每个工种的工种名和员工的个数，并且按员工个数降序\nSELECT j.job_title, COUNT(*) \nFROM employees e, jobs j \nWHERE e.`job_id`=j.`job_id` \nGROUP BY j.`job_title` ORDER BY COUNT(*) DESC;\n\n（2）非等值连接\n案例：\n查询员工的工资和工资级别\nSELECT e.`salary`, j.`grade_level` \nFROM employees e, job_grades j\nWHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`='E';\n\n（3）自连接\n查询员工名和上级的名称\nSELECT e1.last_name, e2.`last_name` \nFROM employees e1,  employees e2\nWHERE e1.`manager_id`=e2.`employee_id`;\n\n三表连接：查询员工名，部门名和所在的城市\nSELECT e.last_name, d.`department_name`, l.`city` \nFROM employees e, departments d, locations l\nWHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;\n```\n\nsql99语法：Inner \n```sql\n查询员工名，部门名\nSELECT e.last_name, d.`department_name` FROM employees e \nINNER JOIN departments d ON e.`department_id`=d.`department_id`;\n\n查询名字中只能包含e的员工名和工种名\nSELECT e.last_name, j.`job_title` FROM employees e \nINNER JOIN jobs j ON e.`job_id`=j.`job_id`\nWHERE e.`last_name` LIKE '%e%';\n\n查询部门个数>3的城市名和部门个数\nSELECT l.`city`, COUNT(*) FROM locations l \nINNER JOIN departments d ON l.`location_id` = d.`location_id`\nGROUP BY l.`city` HAVING COUNT(*)>3;\n\n查询工资级别的个数>2的个数，并按工资级别降序\nSELECT j.`grade_level`, COUNT(*) 个数 FROM job_grades j\nINNER JOIN employees e ON e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`\nGROUP BY j.`grade_level` HAVING 个数>2 \nORDER BY 个数 DESC;\n```\n\n### 外连接\n\n应用场景：用于查询一个表中有，另一个表没有\n\n1.外连接的查询结构为主表中的所有记录  \n如果从表中有和它匹配的，则显示匹配值  \n如果从表中没有和它匹配的，则显示为null  \n外连接查询结果=内连接结果+主表中有而从表没有的数据\n\t\n2.左外连接，left join左边的是主表  \n右外连接，right join右边的是主表  \n\n3.左外和右外交换两个表的顺序，可以实现同样的效果\n\n（1）左连接：  \n语法：Left 【outer】\n```sql\n查询没有男朋友的女神名\nSELECT * FROM beauty b \nLEFT JOIN boys bo ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM departments d\nLEFT JOIN employees e ON d.`department_id`=e.`department_id`\nWHERE e.`employee_id` IS NULL\nGROUP BY d.`department_id`;\n```\n（2）右连接  \n语法：Right 【outer】\n```sql\n#查询没有男朋友的女神名\nSELECT * FROM boys bo \nRIGHT JOIN beauty b ON b.`boyfriend_id`=bo.`id`\nWHERE bo.`id` IS NULL;\n\n查询哪个部门没有员工\nSELECT d.`department_id`, d.`department_name` FROM employees e \nRIGHT JOIN departments d ON e.`department_id`=d.`department_id`\nWHERE e.`employee_id` IS NULL \nGROUP BY d.`department_id`;\n```\n\n（3）全外（mysql不支持）  \n语法：Full 【outer】\n\n### 交叉连接\n\n语法：Cross\n```sql\n女神男神表交叉连接\nSELECT b.*, bo.* FROM beauty b\nCROSS JOIN boys bo;\n```\n\n## 子查询\n\n### 含义\n\n出现在其他语句的select语句，称为子查询或内出现  \n内部嵌套其他select语句的查询，称为外查询或主查询\n\n### 分类：\n\n按子查询出现的位置：  \n1）select 后面  \n2）from 后面  \n3）wehre 或 having后面  \n4）exists后面（相关子查询）  \n\n按结果集的行列数不同：  \n1）标量子查询（结果集只有一行一列）  \n2）列子查询（结果集只有一列多行）  \n3）行子查询（结果集有多行多列）  \n4）表子查询（结果集一般为多行多列）\n\n### 用法\n\n```> < <> = ```\n\n```sql\n\n谁的工资比 Abel 高？\nSELECT last_name, salary\nFROM employees WHERE salary>(\n\tSELECT salary FROM employees WHERE last_name='Abel'\n);\n\n返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name,job_id,salary FROM employees \nWHERE job_id =(\n\tSELECT job_id FROM employees WHERE employee_id=141\n) AND salary>(\n\tSELECT salary FROM employees WHERE employee_id=141\n);\n\n案例3：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salary FROM employees \nWHERE salary = (\n\tSELECT MIN(salary) FROM employees\n);\n\nIn（常用）：\n作用：可以是子查询中的任一一个\n返回location_id是1400或1700的部们中的所有员工姓名\nSELECT last_name\nFROM employees\nWHERE department_id IN (\n\tSELECT department_id FROM departments WHERE location_id IN(1400, 1700)\n);\n\nAny（不常用）：\n作用：任一一个\n\n返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ANY(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n\nAll（不常用）：\n作用：所有的\n\n返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy\nSELECT employee_id, last_name, job_id,salary FROM employees\nWHERE salary<ALL(\n\tSELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'\n) AND department_id<>'IT_PROG';\n```\n\n## 分页查询（常用）\n\n应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。\n\n### 语法：\n\nselect 参数列表  \nfrom 表  \nleft join 表名 on 连接条件  \nwhere 筛选条件  \ngroup by 分组字段 having 分组后筛选  \norder by 排序字段  \nlimit 【offset,】 size；\n\noffset 要显示条目的起始索引（起始索引从0开始）  \nsize 要显示的条目个数\n特点：limit语句放在查询语句的最后\n\n### 案例：\n\n查询第二页，一页10条记录  \nSelect * from user limit 10, 10;\n\n## Union联合查询\n\nunion 联合 合并：将多条查询语句的结果合并成一个结果\n\n应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时\n\n### 语法\n\n查询语句1\nunion\n查询语句2\nunion\n....\n\n特点：  \n1.要求多条查询语句的查询列数是一致的  \n2.要求多条查询语句的查询的每一列的类型和顺序最好一致  \n3.union关键字默认去重，如果使用union all 可以包含重复项\n\n### 案例\n\n```sql\n--Union\nSelect id, name from user\nUnion\nSelect id,name from emp;\n\n--Union all\nSelect id, name from user\nUnion all\nSelect id,name from emp;\n```\n\n# DML语言\n\n数据库操作语言：  \n插入：insert  \n修改：update  \n删除：delete\n\n## 插入语句\n\n### 方式1\n\n语法：  \nInser into 表名(列名, ...) values(值1, ...);\n\n使用：  \nINSERT INTO users VALUES(1, '欧阳荣', '男', 166842.5);  \nINSERT INTO users(id, NAME, sex, gz) VALUES(2, '赵云彬', '欧阳荣', NULL);\n\n### 方式2\n\n语法：  \ninsert into 表名 set 列名=值,列名=值,....;\n\n使用：  \nINSERT INTO boys SET id=6, boyName='侄子', userCp=147258;\n\n### 两种开发方式pk\n\ninsert方式一次可以加多条，第二种方式不行  \nINSERT INTO boys VALUES(7, '欧阳荣', 10000000), (8, '欧阳荣', 10000000);\n\ninsert方式可以用子查询  \nINSERT INTO boys SELECT 10, 'ii', 150044;\n\n## 修改语句\n\n### 修改单表的记录（常用）\n\n语法：\nUpdate 表名 set 列=新值, 列=新值.... where 筛选条件;\n\n案例：\n修改beauty表中姓唐的女神电话为1389988889\nUPDATE beauty SET phone='1389988889' WHERE NAME LIKE '唐%';\n\n修改boys表中id号为2的名称为张飞，魅力值10\nUPDATE boys SET boyName='张飞', userCP=10 WHERE id=2;\n\n\n4.2.2.修改多表的记录（补充）\n192语法：\nUPDATE 表名 别名,表名 别名 \nSET 列=值,列=值 ... \nWHERE 连接添加 AND 筛选条件\n\n\n\n199语法:\nUPDATE 表名 别名\nINNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件\nSET 列=值，列=值 ...\nWHERE 筛选条件\n\n\n案例（以下实现都为199语法）：\n\n修改张无忌的女朋友的手机号为114\nUPDATE boys bo \nINNER JOIN beauty b ON bo.id=b.boyfriend_id \nSET phone='114' \nWHERE bo.boyName='张无忌';\n\n\n\n修改没有男朋友的女神的男朋友的编号都为2号\nUPDATE boys bo \nRIGHT JOIN beauty b ON bo.id=b.boyfriend_id \nSET b.boyfriend_id=2 \nWHERE bo.id IS NULL;\n\n\n\n4.3.删除语句\n\n4.3.1.方式1：delete\n语法：\n（1）单表删除（重要）：\nDelete from 表名 where 筛选条件;\n\n（2）多表删除（补充）\n192：\nDelete 表1别名, 表2别名 \nfrom 表一 别名, 表二别名\nWhere 连接条件 and 筛选条件\n\n199：\nDelete 表1别名, 表2别名\nFrom 表一 别名\ninner|Left|right| join 表2 别名 on 连接条件\nWhere 筛选条件\n\n\n案例：\n\n删除手机号以9结尾的女神信息\nDELETE FROM beauty WHERE phone LIKE '%9';\n\n\n删除张无忌的女朋友的信息\nDELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id\nWHERE bo.`boyName`='张无忌';\n\n删除黄晓明的信息以及他女朋友的信息\nDELETE b, bo FROM boys bo \nINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id` \nWHERE bo.`boyName`='黄晓明';\n\n4.3.2.方式2：truncate\n语法：\nTruncate table 表名;\n\n特点：\n不能加筛选条件，也叫做清空。\n\n4.3.3.delete pk truncate（面试题）\n\n1.delete可以加where条件，truncate不可以\n2.truncate删除，效率高一丢丢\n3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。\n如果使用truncate删除后，再插入值，自增长列的值从1开始。\n4.truncate删除没有返回值，delete删除有返回值\n5.truncate删除不能回滚，delete删除可以回滚。\n\n\n5.DDL语言\n数据库定义语言，也就是库和表的管理\n\n5.1.库的管理\n\n5.1.1.库的创建\n\n语法：\ncreate database [if not exists] 库名 [character set 字符集]\n\n案例：\n\n创建一个db_book库\nCREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;\n\n\n5.1.2.库的修改\n\n修改库名（现在不能用了）：\n语法：\nrename database 库名 to 新库名;\n\n案例\n把db_oyr库名改成my_oyr\nRENAME DATABASE db_oyr TO my_oyr;\n\n\n修改字符集：\n语法：\nalert database 库名 character set 字符集;\n\n案例：\n\n修改db_oyr的字符集为gbk\nALTER DATABASE db_oyr CHARACTER SET gbk;\n\n5.1.3.库的删除\n\n语法：\nDROP DATABASE [IF EXISTS] 库名;\n\n案例:\n删除db_oyr\nDROP DATABASE db_oyr; \n\n5.2.表的管理\n\n5.2.1.表的创建\n\n语法：\ncreate table 表名(\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t列名 列类型【（类型长度） 约束】,\n\t...\n\t列名 列类型【（类型长度） 约束】\n);\n\n案例：\n创建book表\nCREATE TABLE book(\n\tid INT,#编号\n\tbName VARCHAR(20),#图书名\n\tprice DOUBLE,#价格\n\tauthorId INT,#作者编号\n\tpublishDate DATETIME#出版日期\n);\n\n\n5.2.2.表的修改\n\n语法：\nAlter table 表名 add|drop|modify|change column 列名 【列类型 约束】\n\n（1）修改列名\n\nALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);\n\n（2）修改列的类型或约束\n\nALTER TABLE my_book MODIFY COLUMN myName INT;\n\n（3）添加新列\n\nALTER TABLE book ADD COLUMN oo VARCHAR(20);\n\n（4）删除列\n\nALTER TABLE book DROP COLUMN oo;\n\n（5）修改表名\n\nALTER TABLE book RENAME TO my_book;\n\n\n5.2.3.表的删除\n\n语法：\nDROP TABLE 【IF EXISTS】 表名;\n\n案例：\n\n删除my_book表\nDROP TABLE IF EXISTS my_book;\n\n\n5.2.4.表的复制\n1)复制表的结构\n语法：\nCreate table 新表名 like 被复制的表名;\n\n复制boys的结构\nCREATE TABLE copy LIKE boys;\n\n2)复制表的结构和数据\n语法：\nCreate table 新表名\nSelect * from 被复制表的表名\n\n复制boys表的结构和数据\nCREATE TABLE copy2 \nSELECT * FROM boys;\n\n复制boys部门数据和部分列\nCREATE TABLE copy3\nSELECT id,boyName FROM boys WHERE id<5; \nSELECT * FROM copy3;\n\n复制几个字段的结构\nCREATE TABLE copy4\nSELECT id, boyName FROM boys\nWHERE 1=2;\n\n\n5.3.常见的约束\n\n5.3.1.约束介绍\n\n六大约束：\nNOT NULL：非空约束，用于保证该字段的值不能为空\nUNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空\nPRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空\nCHEACK：检查约束【MYSQL中不支持，没有效果】\nFOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值\nDEFAULT：默认值，用于保证字段有默认值\n\n\n添加约束的时机：\n创建表时\n修改表时\n\n\n约束的添加分类：\n列级约束：\n六大约束语法上都支持，单外检约束没有效果\n表级约束：\n除了非空，默认，其他都支持\n\n列级约束 VS 表级约束\n位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起别名\n列级：\t列的后面\t\t都支持，但外键没有效果\t\t\t不可以\n表级：\t所有列的下面\t默认和非空不支持，其他都支持\t可以主键（没有效果）\n\n\n\n\n5.3.2.添加列级约束\n\n新建一个库students，在里面测试添加列级约束\n\n\n\n# 新建主修表\ncreate table major(\n\tid bigint(20) primary key, #主键约束\n\tmajor_name varchar(25) NOT NULL #非空约束\n)\n\n# 新建学生表\ncreate table student(\n\tid bigint(20) primary key, #主键约束\n\tstu_name varchar(25) NOT NULL, #非空约束\n\tsex char(2) CHECK(sex = '男' or sex = '女'), #检查约束\n\tage int default 20, #默认约束\n\tcard varchar(25) unique,#唯一约束\n\tmajor_id bigint(20) REFERENCES major(id) #外键约束\n)\n\n经过测试后发现，检查约束是无效的，而且外检约束也是无效的。\n其他都是ok的。\n\n\n5.3.3.添加表级约束\n\n语法：\n在表字段的最下面\n[constraint 约束名] 约束类型(字段名)\n表级约束添加外键是有效的。\n\n指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效\n  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束\nCONSTRAINT ch_sex CHECK(sex = '女' or sex ='男'),\n  CONSTRAINT `pk_student_major` FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n\n不指定约束名创建约束：\nCREATE TABLE student (\n  id bigint(20) NOT NULL,\n  stu_name varchar(25) NOT NULL,\n  sex char(2) DEFAULT NULL,\n  age int(11) DEFAULT '20',\n  card varchar(25) DEFAULT NULL,\n  major_id bigint(20) DEFAULT NULL,\n  PRIMARY KEY(id), #主键，约束名不生效\n  UNIQUE KEY(card), #唯一约束\n\tCHECK(sex = '女' or sex ='男'),\n  FOREIGN KEY (major_id) REFERENCES major(id)\n);\n\n\n\n5.3.4.主键约束 VS 唯一约束\n\n保证唯一性\t是否允许为空\t一个表中有几个\t是否允许出现组合\n主键\t\t√\t\t\t×\t\t\t\t最多一个\t\t√，但不推荐\n唯一\t\t√\t\t\t×\t\t\t\t可以多个\t\t√，但不推荐\n\n唯一约束可以允许为空，但null只能出现一次。\n组合就是组合主键或组合唯一约束。\n\n\n5.3.5.外键的特点\n\n从表：当前表\n主表：被关联的表\n\n1.要求在从表中设置外键关系\n2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）\n4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表\n\n\n5.3.6.修改表时添加约束\n\n\n语法：\n1.添加列级约束\nalter table 表名 modify column 字段名 字段类型 新约束\n\n2.添加表级约束\nalter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]\n\n\n添加非空约束：\n列级：\nalter table student modify column stu_name varchar(25) not null;\n\n\n添加默认约束：\n列级：\nalter table student modify column age int default 20\n\n\n添加主键约束：\n列级：\nalter table student modify column id bigint(20) primary key\n表级：\nalter table student add primary key(id)\n\n\n添加唯一约束：\n列级：\nalter table student modify column card varchar(25) unique\n表级：\nalter table student add constraint un_card unique(card)\n\n\n添加外键约束：\n表级：\nalter table student add constraint fk_student_major foreign key(id) references major(id)\n\n\n5.3.7.修改表时删除约束\n\n1.删除非空约束（直接不写就是删除）\nalter table student modify column stu_name varchar(25)\n\n2.删除默认约束（不写即是删除）\nalter table student modify column age int default 20\n\n3.删除主键约束\naler table 表名 drop primary key\n\n4.删除唯一约束\nalter table 表名 drop index 约束名\n\n5.删除外键约束\nalter table 表名 drop foreign key 约束名\n\n\n5.4.标识列\n\n什么是标识列？\n标识列是自增长列\n含义：可以不手动的插入值，系统提供默认的序列值\n\n特点：\n1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）\n2.一个表只能有一个标识列\n3.标识类的类型只能是数值型\n4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值\n\n\n创建表时设置标识列\ncreate table tb_user(\n\tid int primary key auto_increment, #主键并且设置标识列\n\tname varchar(25) not null\n)\n\n\n修改表时设置标识列\nalter table tb_user modify column id int primary key auto_increment\n\n修改表时删除标识列\nalter table tb_user modify column id int primary key\n\n\n6.TCL 语言\nTCL：Transaction Control Language 事物控制语言\n\n事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n\n6.1.MySQL 中的存储引擎\n\n1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n2、通过show engines；来查看mysql支持的存储引擎。\n3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务\n\n\n6.2.事务的ACID属性\n\n1. 原子性（Atomicity）\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。\n\n2. 一致性（Consistency）\n事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。\n\n3. 隔离性（Isolation）\n并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。\n\n4. 持久性（Durability）\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.事物的使用步骤\n\n事物又分两种：隐式事物和显式事物\n隐式事物：事物没有明显的开启和结束的标记\n列如insert，update，delete\n\n显式事物：事物具有明显的开启和结束的标记\n前提：必须设置自动提交功能为禁用\n\n查看当前自动提交功能开关\nshow variables like 'autocommit'\n\n关闭自动提交功能，并不是永久的，只是当前回话被关闭\nset autocommit=0;\n\n\n开启事物的语法：\n#步骤1：开启事物\nset autocommit=0;\nstart transaction;#开启事物，可选的\n#步骤2：编写事物中的sql语句（select insert update delete）\n语句1;\n语句2;\n.......\n#步骤3：结束事物\ncommit;#提交事物\nrollback;回滚事物\n\n\n实战操作：\n初始化\ncreate table account(\n\tid bigint(20) primary key auto_increment,\n\tacc_name varchar(25),\n\tmoney double\n)\nINSERT INTO account (id, acc_name, money) VALUES (1, '欧阳荣', 1500);\nINSERT INTO account (id, acc_name, money) VALUES (2, '罗总', 500);\n\n\n\n\n\n转账成功提交：执行后可以看到数据库数据已经改变了\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\ncommit;\n\n\n转账失败回滚：执行后会发现数据并没有改变\nset autocommit=0;\nstart transaction;\nupdate account set money = money-500 where acc_name='欧阳荣';\nupdate account set money = money+500 where acc_name='罗总';\nrollback;\n\n\n\n6.4.数据库的隔离级别\n\n6.4.1.并发问题\n\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. \n之后, 若 T2 回滚, T1读取的内容就是临时且无效的.\n\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n之后, T1再次读取同一个字段, 值就不同了.\n\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插\n入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n\n6.4.2.四种事务隔离级别\n\n\n\nOracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。\n\nMysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n6.5.回滚点使用（savepotion）\n\nset autocommit=0;#设置不自动提交\nstart transaction;#开启事物\ndelete form account where id=1;\nsavepoint a;#保存点\ndelete from account where id=2;\nrollback to a;#回滚到保存点\n这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。\n\n\n7.视图\n7.1.什么是视图\n\n含义：虚拟表，和普通表一样使用\nMySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。\n\n\n应用场景：\n1.多个地方用到同样的查询结果\n2.该查询结果使用的sql语句较复杂\n\n\n7.2.视图的创建\n\n语法：\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\nOR REPLACE：表示替换已有视图\n\nALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表\n\n[WITH [CASCADED | LOCAL] CHECK OPTION]：\n表示视图在更新时保证在视图的权限范围之内\ncascade是默认值，表示更新视图的时候，要满足视图和表的相关条件\nlocal表示更新视图的时候，要满足该视图定义的一个条件即可\n推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 \n\n\n实际操作：\n\n1.查询邮箱中包含a字符的员工名，部门名，工种信息\n-- 创建视图\ncreate view view_test1\nAS\nSELECT\n\tCONCAT(e.first_name, e.last_name) 员工名,\n\tdept.department_name 部门名,\n\tj.job_title 工种信息\nFROM\n\temployees e\nLEFT JOIN departments dept ON dept.department_id = e.department_id\nLEFT JOIN jobs j ON j.job_id = e.job_id\nwhere email LIKE '%a%'\n-- 查询视图\nselect * from view_test1\n\n\n2.查询各部门的平均工资级别\ncreate view view_test2\nas \nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name\n\nSELECT\n\tvt.dept_name,\n\tjb.grade_level\nFROM\n\tview_test2 vt\nLEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal\nAND jb.highest_sal\n\n\n3.查询平均工资最低的部门\ncreate view view_test3\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n4.查询平均工资最低的部门名和工资\ncreate view view_test4\nas\nSELECT\n\tdept.department_name dept_name,\n\tAVG(e.salary) ag\nFROM\n\tdepartments dept\nLEFT JOIN employees e ON dept.department_id = e.department_id\nGROUP BY dept.department_name having ag is not null \norder by ag asc limit 0, 1\n\n\n视图的好处：\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n7.3.视图的修改\n\n方式一：如果存在，则覆盖\ncreate  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\nview 视图名 as\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION]\n\n\n方式二：指定修改视图\nalter\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = { user | CURRENT_USER }]\n    [SQL SECURITY { DEFINER | INVOKER }]\nview 视图名\nas\n查询语句\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\n方式一实际操作：\ncreate or replace view view_test4\nas \nselect * from employees where employee_id > 105\n\n\n方式二实际操作：\nalter view view_test4\nas\nselect * from employees where employee_id > 120\n\n\n\n7.4.视图的删除\n\n语法：\ndrop view 视图名,视图名,视图名........\n\n实际操作：\ndrop view view_test4, view_test3\n\n\n7.5.查看视图\n方式1：desc 视图名\n\n方式2：show create view 视图名\n\n\n方式1实际操作：\ndesc view_test2\n\n可以看到实际上能看到的是当前视图可以查询出的字段信息\n\n\n方式2实际操作：\nshow create view view_test2\n\n可以看到的是当前拿到的是创建视图的逻辑sql。\n\n\n7.6.视图VS表\n\n创建语法的关键字\t是否实际占用物理空间\t使用\n视图\tcreate view\t\t\t只是保存了逻辑sql\t\t增删改查，一般不能增删改查\n\n表\t\tcreate table\t\t\t保存了数据\t\t\t\t增删改查\n\n\n\n8.变量\n\n8.1.系统变量\n\n说明：变量由系统提供的，不是银行定义，属于服务器层面\n系统变量又可以细分为全局变量和局部变量\n\n使用的语法：\n1.查看所有的系统变量\nshow global|[session] variables\n\n2.查看满足条件的部分系统变量\nshow global | [session] variables like '%char%';\n\n3.查看指定的某个系统变量的值\nselect @@global | [session] .系统变量名\n\n4.为某个系统变量赋值\n方式一：\nset global | [session] 系统变量名 = 值;\n\n方式二：\nSet @@global | [session] .系统变量名 = 值;\n\n注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别\n\n\n8.1.1.全局变量实际操作\n\n作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）\n\n（1）查看所有的全局变量\nshow global variables;\n\n（2）查看部分的全局变量\nshow global variables like '%char%';\n\n（3）查看指定的全局变量的值\nselect @@global.autocommit;\n\n\n（4）为某个指定的全局变量赋值\nset @@global.autocommit = 0;\n\n8.1.2.局部变量实际操作\n\n作用域：仅仅针对于当前会话（连接）有效\n\n（1）查看所有的会话变量\nshow variables\nshow session variables\n\n（2）查看部分的会话变量\nshow variables like '%char%'\nshow session variables like '%char%'\n\n（3）指定查看某个会话变量\nselect @@character_set_client\nselect @@session.character_set_client\n\n（4）为某个会话变量赋值\nset autocommit=0\nset @@session.autocommit=1\n\n8.2.自定义变量\n\n说明：变量是用户自定义的，不是由系统自动生成的。\n自定义变量又可以细分成用户变量（当前会话有效），局部变量\n使用步骤：\n声明\n赋值\n使用（查看，比较，运算等）\n\n8.2.1.用户变量\n\n作用域：针对于电器干会话（连接）有效，同于会话变量的作用域\n应用在任何地方，也就是begin end里面或begin end外面\n\n\n\n使用语法：\n\n（1）声明并初始化：\nset @用户变量名=值 或\nset @用户变量名:=值 或\nselect @用户变量名:=值\n\n（2）赋值（更新用户变量的值）\n方式一：通过set和select\nset @变量名=值 或\nset @变量名:=值 或\nselect @变量名:=值\n\n方式二：通过select into\nselect 字段 INTO @变量名\nfrom 表\n\n（3）使用（查看用户变量的值）\nselect @用户变量名\n\n\n实际操作：\n\n声明并且初始化：\n# 声明并且初始化\nset @name='欧阳荣';\nset @name:=10;\nselect @name:='罗总';\n\n赋值：\n#赋值\nset @count = 10;\nset @count := 15;\nselect @count := 20;\nselect count(*) into @count from account;\n\n使用：\nselect @count;\n\n\n\n\n\n8.2.2.局部变量\n\n作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句\n\n（1）声明\ndeclare 变量名 类型;\ndeclare 变量名 类型 default 值;\n\n（2）赋值\n方式一：通过set和select\nset 局部变量名=值 或\nset 局部变量名:=值 或\nselect @局部变量名:=值\n\n方式二：通过select into\nselect 字段 INTO 局部变量名\nfrom 表\n\n（3）使用\nselect 局部变量名\n\n8.2.3.用户变量 VS 局部变量\n\n作用域\t\t定义和使用的位置\t\t\t\t语法\n用户变量\t当前会话\t会话中的任何地方\t\t\t\t必须加@符，不限定类型\n局部变量\tbegin end中\t只能在begin end中，且为第一句\t不用加@符，需要限定类型\n\n9.存储过程和函数\n存储过程和函数：类似于java中的方法\n好处：\n1、提高代码的重用性\n2、简化操作\n\n\n9.1.存储过程\n\n\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n9.1.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate procedure 存储过程名(参数列表)\nbegin\n存储过程体（一组合法的SQL语句）\nend\n\n注意：\n1.参数列表包含三部分\n参数模式\t参数名\t参数类型\nin\t\t\tstudent\tvarchar(20)\n\n参数模式：\nin：\t该参数可以作为输入，也就是该参数需要调用方法传入值\t\nout：\t该参数可以作为输出，也就是该参数可以作为返回值\ninout：\t该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值\n\n2.如果存储过程体仅仅只有一句话，begin end可以省略。\n存储过程的每条SQL语句的结尾要求必须加上分号。\n存储过程的结尾可以使用delimiter重新设置\n语法：\nDELIMITER 结束标记\nDELIMITER $\n\n\n调用语法：\nCALL 存储过程名（实参列表）\n\n\n查看语法：\nshow create procedure 存储过程名;\n\n\n删除语法：\ndrop procedure 存储过程名;\n\n9.1.2.存储过程实战\n\n（1）空参的存储过程：\n# 创建存储过程\ncreate procedure myp1()\nbegin\n\tinsert into admin(name, money) values('z1', 11), ('z2', 22), ('z3', 33), ('z4', 44), ('z5', 55);\nend;\n\n#调用存储过程\nCALL myp1();\n\n\n带in模式参数的存储过程：\n根据女神名获取男神信息\n# 创建存储过程\ncreate procedure myp1(in beauty_name varchar(25))\nbegin\n\tselect bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n# 调用\ncall myp1('赵敏')\n\n根据用户名和密码判断是否能登录成功\n-- 创建存储过程\ncreate procedure myp2(in username varchar(25), in password varchar(25))\nbegin\n\tdeclare result int default '0';\n\tselect count(*) INTO result from admin a where a.username = username and a.`password` = password;\n\tselect if(result > 0, '成功', '失败');\nend;\n-- 调用\ncall myp2('john', '8888')\n\n\n（2）带out模式的存储过程：\n\n根据女神名，返回对应的男神名\n#创建\ncreate procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))\nbegin\n\tselect bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n-- 调用\nset @boy_name='';\ncall myp3('赵敏', @boy_name);\nselect @boy_name;\n\n根据女神名，返回对应的男神名和男神魅力值\n创建\ncreate procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)\nbegin\n\tselect bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;\nend;\n\n-- 调用\nset @boy_name='';\nset @user_cp=0;\ncall myp4('赵敏', @boy_name, @user_cp);\nselect @boy_name, @user_cp;\n\n\n（3）带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n#创建\ncreate procedure myp5(inout x int, inout y int)\nbegin\n\tset x = x*2;\n\tset y = y*2;\nend;\n#调用\nset @x = 10;\nset @y = 20;\ncall myp5(@x, @y);\nselect @x, @y;\n\n\n\n\n\n9.2.函数\n\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n1、提高代码的重用性\n2、简化操作\n3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n存储过程与函数的区别：\n存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新\n函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果\n\n\n9.2.1.创建&调用&查看&删除语法\n\n创建语法：\ncreate function 函数名(参数列表) returns 返回类型\nbegin\n函数体\nend\n\n注意：\n1.参数列表包含两部分：参数名 参数类型\n2.函数体：肯定会有return语句，如果没有会报错。\n如果return语句没有放在函数体的最后也不报错，但不建议。\n3.函数体重仅有一句话，则可以省略begin end\n4.使用delimiter语句设置结束标记\n\n\n调用语法：\nselect 函数名（参数列表）\n\n\n查看语法：\nshow create function 函数名\n\n\n删除语法：\ndorp function 函数名\n\n\n\n9.2.2.函数实战\n\n（1）无参有返回\n\n返回公司的员工个数：\n#创建\ncreate function myf1() returns int\nbegin\n\tdeclare count int default 0;\n\tselect COUNT(*) into count from employees;\n\treturn count;\nend;\n#调用\nselect myf1();\n\n\n（2）有参返回\n\n根据员工名返回工资：\n#创建\ncreate function myf2(username varchar(25)) returns double\nbegin\n\tdeclare money double default 0;\n\tselect salary into money from employees where last_name = username;\n\treturn money;\nend;\n#调用\nselect myf2('Kochhar');\n\n\n根据部门名，发挥该部门的平均工资\n#创建\ncreate function myf3(dept_name varchar(25)) returns double\nbegin\n\tdeclare ave_salary double default 0;\n\tselect avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id\n\twhere dept.department_name = dept_name group by dept.department_id;\n\treturn ave_salary;\nend;\n#调用\nselect myf3('Adm');\n\n实现传入两个float，返回两者之和：\n\n#创建\ncreate function myf1(x float, y float) returns float\nbegin\n\tdeclare sum float default 0;\n\tset sum = x + y;\n\treturn sum;\nend;\n#调用\nselect myf1(1, 5.1);\n\n\n（3）查看函数\nshow create function myf3;\n\n\n\n（4）删除函数\ndrop function myf3\n\n\n10.流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序从两条或多条路径中选择一条去执行\n循环结构：程序在满足一定条件的基础上重复执行一段代码\n\n\n10.1.分支结构\n\n（1）if函数\n功能：实现简单的双分支\n语法：\nIf(表达式1, 表达式2, 表达式3)\n执行顺序：\n如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值\n应用：任何地方\n实战操作：\nselect if(1 > 2, 1, 2)\n当前sql执行后会返回2\n\n\n（2）case结构\n\n在begin end 外面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 返回的值1\nwhen 要判断的值 then 返回的值2\n....\nelse 返回的值n\nend\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 返回的值1\nwhen 要判断的条件2 then 返回的值2\n....\nelse 返回的值n\nend\n\n\n在begin end里面：\n\n情况1：类似于java中的switch语句，一般用于实现等值的判断\ncase 变量|表达式|字段\nwhen 要判断的值 then 要执行的语句1\nwhen 要判断的值 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n情况2：类似于java的多重IF语句，一般用于视区间判断\ncase \nwhen 要判断的条件1 then 要执行的语句1\nwhen 要判断的条件2 then 要执行的语句2\n....\nelse 要执行的语句n\nend case;\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate procedure show_grade(in grade int)\nbegin\n\tdeclare result varchar(2);\n\tCASE \n\tWHEN grade>=90 and grade<=100 THEN set result = 'A';\n\tWHEN grade>=80 THEN set result = 'B';\n\tWHEN grade>=60 THEN set result = 'C';\n\tELSE set result = 'D';\n\tEND CASE;\n\tselect result;\nend;\n\nCALL show_grade(99);\n\n\n#根据传递的数据库类型，显示对应的数据库名\ncreate procedure show_database_type(in val int)\nbegin\n\tdeclare result varchar(20);\n\tCASE val\n\tWHEN 1 THEN set result = 'mysql';\n\tWHEN 2 THEN set result = 'oracle';\n\tWHEN 3 THEN set result = 'sql server';\n\tELSE set result = '不认识的类型，滚啊。。。';\n\tEND CASE;\n\tselect result;\nend;\n\ncall show_database_type(1);\n\n\n（3）if结构\n功能：实现多重分类\n语法：\nif 条件1 then 语法1;\nesleif 条件2 then 语法2;\n...\n[else 语句n;]\nend if;\n\n应用场景：应用在begin end中\n\n实战操作：\n\n# 创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\ncreate function show_grade(grade int) returns char(1)\nbegin\n\tdeclare result char(1);\n\tif grade>=90 and grade<=100 THEN set result = 'A';\n\telseif grade>=80 THEN set result = 'B';\n\telseif grade>=60 THEN set result = 'C';\n\telse set result = 'D';\n\tend if;\n\treturn result;\nend;\n\nselect show_grade(55);\n\n\n#批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止\ncreate procedure pro_while_insert2(in count int)\nbegin\n\tdeclare i int default 1;\n\ta:while i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tif i>=20 then leave a;\n\t\tend if;\n\t\tset i=i+1;\n\tend while a;\nend;\n\ncall pro_while_insert2(30);\n\n\n\n10.2.循环结构\n\n循环分类：\nwhile、 loop、repeat\n\n循环控制：\niterate类似于continue，结束本次循环，继续下一次循环\nleave类似于break，结束当前所在循环。\n\n\n三种循环语法：\n\n（1）while\n[标签:] while 循环条件 do\n循环体\nend while [标签]\n\n（2）loop\n[标签:] loop\n循环体\nend loop [标签]\n\n（3）repeat\n[标签:] repeat\n循环体\nuntil 结束循环的条件\nend repeat [标签]\n\n\n循环实战操作：\n\n#批量插入，根据次数插入到amdin表中多条数据\ncreate procedure pro_while_insert(in count int)\nbegin\n\tdeclare i int default 1;\n\twhile i<=count do\n\t\tinsert into admin(username, password) values(CONCAT('user', i), CONCAT('psw', i));\n\t\tset i=i+1;\n\tend while;\nend;\n\ncall pro_while_insert(10);\n\n\n\nwhile VS repeat VS loop\nwhile：先判断后执行\nrepeat：先执行后判断\nloop：没有条件的死循环\n\n# 博客园所学\n\n## 索引\n\n索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.  \n单列索引:一个索引只包含一个列,一个表可以有多个单列索引.   \n组合索引:一个组合索引包含两个或两个以上的列。\n\n### 索引的创建\n\n1）单列索引\n\n普通索引：\n第一种方式 :\nCREATE INDEX 索引名ON 表名(`字段名`(length))\n\n第二种方式: \nALTER TABLE award ADD INDEX account_Index(`account`)\n\n唯一索引：\nCREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));\nALTER TABLE TableName ADD UNIQUE (column_list)\n\n主键索引：不允许有空值\n\n2）组合索引：\n\n语法：\nCREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);\n\n\n### 索引的删除\n语法：\nDORP INDEX IndexName ON `TableName`\n\n## 触发器\n\n触发器：监视某种情况，并触发某种操作。\n\n### 创建语法\n\n触发器创建语法四要素：1.监视地点(table)\n　　　　　　　　　　　2.监视事件(insert/update/delete)\n　　　　　　　　　　 3.触发时间(after/before)\n　　　　　　　　　　　4.触发事件(insert/update/delete)\n\n语法：\ncreate trigger triggerName after/before insert/update/delete\non 表名 for each row #这句话是固定的\n begin\n     #需要执行的sql语句\n end\n注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发\n注意2:insert/update/delete:只能选一个\n\n创建一个视图：\ncreate trigger tag1 after insert on order_table\nfor each row\nbegin\n\tupdate goods set num=num-3 where id=1;\nend;\n\n\n我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。\n对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。\n所以现在我们可以这样来改我们的触发器:\ncreate trigger tg1 after insert on order_table\nfor each row\nBEGIN\n\tupdate goods set num = num-new.much where id=new.gid; \nEND;\n\n当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？\n 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。\ncreate trigger tg2 after delete on order_table\nfor each ROW\nBEGIN\n\tupdate goods set num = num+old.much where id=old.gid;\nEND;\n\n### 删除触发器\n语法：drop trigger 触发器名称;\n使用：drop trigger dg1;","slug":"oyr/MySQL/MySQL-基础","published":1,"updated":"2021-07-13T09:52:43.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836c001fhct7auk196sk","content":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>特点：<br>1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<h3 id=\"小数\"><a href=\"#小数\" class=\"headerlink\" title=\"小数\"></a>小数</h3><p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<h2 id=\"日期型\"><a href=\"#日期型\" class=\"headerlink\" title=\"日期型\"></a>日期型</h2><p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名（两种方式）<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select 查询列表  </span><br><span class=\"line\">From 表名  </span><br><span class=\"line\">Where 筛选条件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;oyr&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;欧阳荣&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>CONCAT：<br>作用：拼接字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"string\">&#x27;abc&#x27;</span>, <span class=\"string\">&#x27;jkl&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(first_name, last_name) out_put <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n\n<p>UPPER：<br>作用：字符串变大写  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">UPPER</span>(&quot;asc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Lower：<br>作用：字符串变小写</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">LOWER</span>(&quot;ASC&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;a&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">12</span>, <span class=\"string\">&#x27;ab&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Replace：<br>作用：替换字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> REPLACE(<span class=\"string\">&#x27;赵吊彬是zz赵吊彬赵吊彬赵吊彬&#x27;</span>, <span class=\"string\">&#x27;赵吊彬&#x27;</span>, <span class=\"string\">&#x27;李执志&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Instr:<br>作用：获取子串第一次出现的索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> INSTR(<span class=\"string\">&#x27;欧阳荣多对多&#x27;</span>, <span class=\"string\">&#x27;欧阳&#x27;</span>);</span><br><span class=\"line\">结果为：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.65</span>);</span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.657</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">结果：<span class=\"number\">1.66</span></span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CEIL</span>(<span class=\"number\">1.52</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n<p>Floor：<br>作用：向下取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">FLOOR</span>(<span class=\"number\">9.99</span>);</span><br><span class=\"line\">结果：<span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<p>Truncate：<br>作用：截断  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TRUNCATE</span>(<span class=\"number\">10.19</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">10.1</span></span><br></pre></td></tr></table></figure>\n\n<p>Mod：<br>作用：取余  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">MOD</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> RAND();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mysql数据库</p>\n<h1 id=\"MySql基础\"><a href=\"#MySql基础\" class=\"headerlink\" title=\"MySql基础\"></a>MySql基础</h1><h2 id=\"数据库的好处\"><a href=\"#数据库的好处\" class=\"headerlink\" title=\"数据库的好处\"></a>数据库的好处</h2><p>可以持久化到本地<br>结构化查询</p>\n<hr>\n<h2 id=\"主流的数据库介绍（了解）\"><a href=\"#主流的数据库介绍（了解）\" class=\"headerlink\" title=\"主流的数据库介绍（了解）\"></a>主流的数据库介绍（了解）</h2><p>Sql server 数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>\n<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>\n<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>\n<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>\n<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>\n<p>Sybase数据库</p>\n<hr>\n<h2 id=\"mysql的优点\"><a href=\"#mysql的优点\" class=\"headerlink\" title=\"mysql的优点\"></a>mysql的优点</h2><p>开源，免费成本低<br>性能高，移植性也好<br>体积小，便于安装</p>\n<h2 id=\"mysql数据库的安装和配置\"><a href=\"#mysql数据库的安装和配置\" class=\"headerlink\" title=\"mysql数据库的安装和配置\"></a>mysql数据库的安装和配置</h2><p>看MySQL-5.7.17安装与配置.docx</p>\n<h2 id=\"mysql的基本使用\"><a href=\"#mysql的基本使用\" class=\"headerlink\" title=\"mysql的基本使用\"></a>mysql的基本使用</h2><p>（1）连接到mysql<br>Cmd&gt;mysql -h 主机名 -u 用户名 -p 密码 回车<br>举例：</p>\n<p>说明：<br>如果你没有写-h localhost 默认是连接本地</p>\n<p>如果你需要远程登录到另一个mysql,则需要修改配置。<br>一般情况下部让远程登录。</p>\n<p>（2）sql服务的退出<br>exit或ctrl+c</p>\n<p>（3）关闭和启动mysql服务<br>界面操作：</p>\n<p>命令模式：<br>启动：net stop mysql<br>停止：net start mysql<br>举例：</p>\n<p>说明：这里mysql不是固定的，是安装时取的服务名称。</p>\n<h2 id=\"mysql数据库三层架构介绍\"><a href=\"#mysql数据库三层架构介绍\" class=\"headerlink\" title=\"mysql数据库三层架构介绍\"></a>mysql数据库三层架构介绍</h2><p>专业术语</p>\n<p>Db：<br>数据库（database）存储数据的”仓库”。它保存了一系列有组织的数据。</p>\n<p>Dbms：<br>数据库管理系统（database management system）。数据库是通过dbms创建和操作的容器。</p>\n<p>Sql:<br>结构化查询语言（Structure Query Langeuage）：专门用来与数据库通信的语言。</p>\n<p>数据库服务器，数据库和表的关系如图所示：</p>\n<p>示意图：</p>\n<h2 id=\"mysql常见命令\"><a href=\"#mysql常见命令\" class=\"headerlink\" title=\"mysql常见命令\"></a>mysql常见命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看当前所有的数据库</span><br><span class=\"line\">show databases;</span><br><span class=\"line\"></span><br><span class=\"line\">2.打开指定的库</span><br><span class=\"line\">use 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">3.查看所在的数据库名</span><br><span class=\"line\">select database();</span><br><span class=\"line\"></span><br><span class=\"line\">4.查看当前库的所有表</span><br><span class=\"line\">show tables;</span><br><span class=\"line\"></span><br><span class=\"line\">5.查看其它库的所有表</span><br><span class=\"line\">show tables from 库名;</span><br><span class=\"line\"></span><br><span class=\"line\">6.创建表</span><br><span class=\"line\">create table user(id int, name varchar(20));</span><br><span class=\"line\"></span><br><span class=\"line\">7.查看表结构</span><br><span class=\"line\">desc 表名;\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">8.查看服务器的版本</span><br><span class=\"line\">方式一：登录到mysql服务端</span><br><span class=\"line\">Select version();</span><br><span class=\"line\">方式二：没有登录到mysql服务端</span><br><span class=\"line\">Mysql --version或mysql --V</span><br><span class=\"line\"></span><br><span class=\"line\">9.查看当前时区</span><br><span class=\"line\">SHOW VARIABLES LIKE &#x27;time_zone&#x27;</span><br><span class=\"line\">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mysql的语法规范\"><a href=\"#Mysql的语法规范\" class=\"headerlink\" title=\"Mysql的语法规范\"></a>Mysql的语法规范</h2><p>1.不区分大小写，单建议关键字大写，表名，列名小写。<br>2.每条语句最好用分号结尾。<br>3.每条命令根据需要，可以进行缩进或换行<br>4.注释<br>单行注释：两种<br>第一种：#注释文字<br>第二种：– 注释文字<br>多行注释：/* 注释文字 */</p>\n<h1 id=\"常用数据类型\"><a href=\"#常用数据类型\" class=\"headerlink\" title=\"常用数据类型\"></a>常用数据类型</h1><h2 id=\"数值型\"><a href=\"#数值型\" class=\"headerlink\" title=\"数值型\"></a>数值型</h2><h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>特点：<br>1）如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>2）如果插入的数值超出了整型范围，会报out of range异常，并且插入临界值<br>3）如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够用0在左边填充，但必须搭配zerofill使用！</p>\n<h3 id=\"小数\"><a href=\"#小数\" class=\"headerlink\" title=\"小数\"></a>小数</h3><p>浮点型：<br>Float(m, d)，double(m, d)<br>4            8</p>\n<p>定点型：<br>Dec(m, d)，decimal(m, d)<br>M+2        m+2</p>\n<p>特点：<br>（1）<br>M：整数部位+小数部位（总长度）<br>D：小数部位<br>如果超出范围插入临界值</p>\n<p>（2）<br>M和D都可以省略<br>如果是decimal，则m默认为10，d默认为0<br>如果是double和float，则会随着插入的数值的精度来决定精度</p>\n<p>（3）定点型的精确度较高，如果要求插入数值的精度较高，如：货币运算等则考虑使用</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>较短的文本：<br>Char<br>Varchar</p>\n<p>特点：</p>\n<p>写法        m的意思            特点            空间的耗费        效率<br>Char    char(m)        最大的字符数    固定长度        比较耗费        高<br>Varchar    varchar(m)    最大的字符数    可变长度的字符    比较节省        低</p>\n<p>较长的文本：<br>Text<br>Blob（较大的二进制）</p>\n<p>Enum类型：<br>说明:又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。<br>如果列表成员为1<del>255，则需要1个字节存储<br>如果列表成员为255</del>65535，则需要2个字节存储<br>最多需要65535个成员</p>\n<p>Set类型：<br>说明：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区<br>别是：SET类型一次可以选取多个成员，而Enum只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>\n<h2 id=\"日期型\"><a href=\"#日期型\" class=\"headerlink\" title=\"日期型\"></a>日期型</h2><p>总结：<br>Date：只保存日期，并没有保存到时分秒<br>Time：只保存时间（时分秒）<br>Year：只保存年</p>\n<p>Datetime：保存日期+时间<br>Timestamp：保存日期+时间</p>\n<p>Datetime VS Timestamp</p>\n<p>字节    范围        时区等的影响<br>Datetime     8        1000-9999        不受<br>Timestamp    4        1970-2038        受</p>\n<h1 id=\"DQL语言（select）\"><a href=\"#DQL语言（select）\" class=\"headerlink\" title=\"DQL语言（select）\"></a>DQL语言（select）</h1><h2 id=\"基础查询\"><a href=\"#基础查询\" class=\"headerlink\" title=\"基础查询\"></a>基础查询</h2><h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>select 查询列表 from 表名</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>查询列表开源是字段，常量表达式，函数，也可以有多个。<br>查询结构是一个虚拟表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>1.查询单个字段<br>Select 字段名 from 表名</p>\n<p>2.查询多个字段<br>Select 字段名,字段名 from 表名</p>\n<p>3.查询所有的字段<br>Select * from 表名</p>\n<p>4.查询常量<br>Select 常量值<br>注意：字符型和日期型常量值必须用单引号用起来，数值类不需要</p>\n<p>5.查询函数<br>Select 函数名（实例参数）;</p>\n<p>6.查询表达式<br>Select 100*10;</p>\n<p>7.取别名（两种方式）<br>As<br>Select last_name as 姓名 from 表名  </p>\n<p>空格<br>Select last_name 姓名 from 表名</p>\n<p>8.去重<br>Select distinct 字段名 from 表名</p>\n<p>9.+<br>作用：加法运算<br>Select 数值+数值;直接运算<br>Select 字符+数值，先将字符转成数值，如果转换成功，则继续运算，否则转换成0，    再做运算。</p>\n<p>10.补充Concat函数<br>功能：拼接字符<br>Select concat(字符1,字符2,字符3,….)</p>\n<p>11.补充ifnull函数<br>Select ifnull(name, 0) from user</p>\n<p>12.补充isnull函数<br>Select isnull(name) from user<br>功能：拍的某个字段是否为null，如果是返回1，如果不是返回0</p>\n<h2 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h2><h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select 查询列表  </span><br><span class=\"line\">From 表名  </span><br><span class=\"line\">Where 筛选条件</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选条件的分类\"><a href=\"#筛选条件的分类\" class=\"headerlink\" title=\"筛选条件的分类\"></a>筛选条件的分类</h3><p>（1）简单条件运算符  </p>\n<p><code>&gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;</code></p>\n<p>Select * from user where age&gt;15;</p>\n<p>Select * from user where age&lt;15;</p>\n<p>Select * from user where age&lt;&gt;15;</p>\n<p>&lt;=&gt;:安全等于，可以判断普通数值，也可以判断是否为null<br>Select * from user where age&lt;=&gt; null;</p>\n<p>（2）逻辑运算符</p>\n<p><code>and or not</code></p>\n<p>And:<br>SELECT last_name FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;</p>\n<p>Or:<br>SELECT * FROM employees WHERE department_id&lt;90 OR department_id&gt;110 OR salary&gt;15000;</p>\n<p>Not:<br>SELECT * FROM employees WHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;</p>\n<p>（3）模糊查询</p>\n<p><code>Like, between and, in, is null, is not null </code></p>\n<p>like：<br>Select * from user where name like’%a%’;<br>Select * from user where name like’_a%’;</p>\n<p>between and:<br>作用：在哪两个数之间<br>Select * from user where age between 10 and 20;</p>\n<p>in:<br>Select * from user where id in(1,2,3);</p>\n<p>is null:<br>作用：判断是否为null<br>Select * from user where age is null;</p>\n<p>is not null:<br>作用：判断是否不为空<br>Select * from user where age is not null;</p>\n<h2 id=\"排序查询\"><a href=\"#排序查询\" class=\"headerlink\" title=\"排序查询\"></a>排序查询</h2><h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select * from 表名<br>[Where 筛选条件]<br>Order by 排序列表[asc desc]</p>\n<h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>（1）asc代表升序，desc代表降序，如果不写是升序。<br>（2）order by子句可以支持单个字段，多个字段，表达式，函数，别名<br>（3）order by子句一般是放查询语句的最后面，limit子句除外</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>#案例：查询员工信息，要求工资冲高到底排序  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：按年薪的高低显示员工的信息和年薪【按表达式排序】  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span>, salary<span class=\"operator\">*</span><span class=\"number\">12</span><span class=\"operator\">*</span>(<span class=\"number\">1</span><span class=\"operator\">+</span>IFNULL(commission_pct, <span class=\"number\">0</span>)) <span class=\"keyword\">AS</span> 年薪 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 年薪 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>#案例：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> LENGTH(email) <span class=\"keyword\">DESC</span>, department_id <span class=\"keyword\">ASC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><p>功能：类似java中的方法<br>好处：提高重用性和隐藏实现细节<br>调用：select 函数名(参数列表)  </p>\n<h3 id=\"字符函数\"><a href=\"#字符函数\" class=\"headerlink\" title=\"字符函数\"></a>字符函数</h3><p>LENGTH：<br>作用：获取参数的字节个数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;oyr&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"string\">&#x27;欧阳荣&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n\n<p>CONCAT：<br>作用：拼接字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"string\">&#x27;abc&#x27;</span>, <span class=\"string\">&#x27;jkl&#x27;</span>);  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(first_name, last_name) out_put <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n\n<p>UPPER：<br>作用：字符串变大写  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">UPPER</span>(&quot;asc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Lower：<br>作用：字符串变小写</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">LOWER</span>(&quot;ASC&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>Substr:<br>作用：截取字符串，两种使用方式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一种：截取从指定索引处后面所有字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣真的帅哦&quot;, <span class=\"number\">4</span>);  </span><br><span class=\"line\">结果：真的帅哦</span><br><span class=\"line\"></span><br><span class=\"line\">#第二种：截取从指定索引处指定字符串的字符  </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SUBSTR(&quot;欧阳荣不是一般帅哦&quot;, <span class=\"number\">1</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\"># 案例<span class=\"number\">1</span>：姓名首字母大写，其他字符小写然后用_拼接，显示出来</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> CONCAT(<span class=\"built_in\">UPPER</span>(SUBSTR(last_name, <span class=\"number\">1</span>, <span class=\"number\">1</span>)), <span class=\"string\">&#x27;_&#x27;</span>, <span class=\"built_in\">LOWER</span>(SUBSTR(last_name, <span class=\"number\">2</span>))) <span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<p>Trim:<br>作用：去除两边空格或去除两边指定字符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#去除两边空格：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> LENGTH(<span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;   欧阳荣 &#x27;</span>));</span><br><span class=\"line\">结果：欧阳荣</span><br><span class=\"line\"></span><br><span class=\"line\">#去除两边指定字符：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">TRIM</span>(<span class=\"string\">&#x27;a&#x27;</span> <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;aaaaaaaa欧阳aaa荣aaaaaa&#x27;</span>);</span><br><span class=\"line\">结果：欧阳aaa荣</span><br></pre></td></tr></table></figure>\n\n<p>Lpad：<br>作用：lpad 用指定的字符实现左填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">10</span>, <span class=\"string\">&#x27;a&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Rpad：<br>作用：用指定的字符实现右填充指定长度  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> LPAD(<span class=\"string\">&#x27;欧阳荣&#x27;</span>, <span class=\"number\">12</span>, <span class=\"string\">&#x27;ab&#x27;</span>) out_put;</span><br></pre></td></tr></table></figure>\n\n<p>Replace：<br>作用：替换字符串  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> REPLACE(<span class=\"string\">&#x27;赵吊彬是zz赵吊彬赵吊彬赵吊彬&#x27;</span>, <span class=\"string\">&#x27;赵吊彬&#x27;</span>, <span class=\"string\">&#x27;李执志&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Instr:<br>作用：获取子串第一次出现的索引</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> INSTR(<span class=\"string\">&#x27;欧阳荣多对多&#x27;</span>, <span class=\"string\">&#x27;欧阳&#x27;</span>);</span><br><span class=\"line\">结果为：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h3><p>Round:<br>作用：四舍五入</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.65</span>);</span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">第二种使用：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1.657</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">结果：<span class=\"number\">1.66</span></span><br></pre></td></tr></table></figure>\n\n<p>Ceil：<br>作用：向上取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CEIL</span>(<span class=\"number\">1.52</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n<p>Floor：<br>作用：向下取整  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">FLOOR</span>(<span class=\"number\">9.99</span>);</span><br><span class=\"line\">结果：<span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<p>Truncate：<br>作用：截断  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">TRUNCATE</span>(<span class=\"number\">10.19</span>, <span class=\"number\">1</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">10.1</span></span><br></pre></td></tr></table></figure>\n\n<p>Mod：<br>作用：取余  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">MOD</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">结果：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Rand：<br>作用：获取随机数，返回0-1之间的小数  </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> RAND();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h3><p>NOW：<br>作用：返回当前系统日期+时间<br>SELECT NOW();</p>\n<p>Curdate：<br>作用：返回当前系统日期，不包含时间<br>SELECT CURDATE();</p>\n<p>Curtime：<br>作用：返回当前时间，不包含日期<br>SELECT CURTIME();</p>\n<p>Year：<br>作用：获取年<br>Select year(now());<br>SELECT YEAR(‘1999-1-1’) 年;</p>\n<p>Month:<br>作用：获取月<br>SELECT MONTH(NOW()) 月;</p>\n<p>Day:<br>作用：获取日<br>Select DAY(now()) 日;</p>\n<p>日期格式符：</p>\n<p>Str_to_date:<br>作用：将日期格式的字符转换成指定格式的日期<br>SELECT STR_TO_DATE(‘1999-6-2’, ‘%Y-%c-%d’) out_put;<br>SELECT * FROM employees WHERE hiredate=STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’);</p>\n<p>Date_format：<br>作用：将日期转换成字符<br>SELECT DATE_FORMAT(NOW(), ‘%y年%m月%d日’) AS out_put;</p>\n<p>案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）<br>SELECT last_name, DATE_FORMAT(hiredate, ‘%M月/%d日 %y年’)<br>FROM employees<br>WHERE commission_pct IS NOT NULL;</p>\n<p>Datediff：<br>作用：返回两个日期相差的天数<br>SELECT DATEDIFF(NOW(), ‘1999-06-24’);</p>\n<h3 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h3><p>VERSION：<br>作用：查看当前mysql版本号<br>SELECT VERSION();</p>\n<p>DATABASE：<br>作用：查看当前打开的数据库<br>Select DATABASE();</p>\n<p>USER：<br>作用：查看当前登录的用户<br>Select USER();</p>\n<h3 id=\"流程控制函数\"><a href=\"#流程控制函数\" class=\"headerlink\" title=\"流程控制函数\"></a>流程控制函数</h3><p>If：<br>作用：判断真假<br>SELECT IF(10&lt;5, ‘小’, ‘大’);</p>\n<p>Case:<br>作用：判断<br>语法：<br>case 要带的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量1 then 要显示的值1或语句1;<br>…..<br>else 要显示的值n或语句n<br>End</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：查询员工的工资，要求</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">30</span>,显示的工资为<span class=\"number\">1.1</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">40</span>，显示的工资为<span class=\"number\">1.2</span>倍</span><br><span class=\"line\">部门号<span class=\"operator\">=</span><span class=\"number\">50</span>，显示的工资为<span class=\"number\">1.3</span>倍</span><br><span class=\"line\">其他部门，显示的工资为原工资</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary 原工资, </span><br><span class=\"line\"><span class=\"keyword\">CASE</span> department_id</span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">30</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">40</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> <span class=\"number\">50</span> <span class=\"keyword\">THEN</span> salary<span class=\"operator\">*</span><span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> salary</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 新工资</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br><span class=\"line\"></span><br><span class=\"line\">案例：查询员工的工资的情况</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">20000</span>，显示A级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">15000</span>，显示B级别</span><br><span class=\"line\">如果工资<span class=\"operator\">&gt;</span><span class=\"number\">10000</span>,显示C级别</span><br><span class=\"line\">否则，显示D级别</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,salary,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">20000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;A&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">15000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">WHEN</span> salary<span class=\"operator\">&gt;</span><span class=\"number\">10000</span> <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;C&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;D&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> 级别</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><h3 id=\"分组函数\"><a href=\"#分组函数\" class=\"headerlink\" title=\"分组函数\"></a>分组函数</h3><p>sum:<br>作用：求和<br>SELECT SUM(salary) FROM employees;</p>\n<p>max:<br>作用：最大值<br>Select max(salary) from employees;</p>\n<p>min：<br>作用：最小值<br>SELECT MIN(salary) FROM employees;</p>\n<p>avg：<br>作用：平均数<br>SELECT AVG(salary) FROM employees;</p>\n<p>count：<br>作用：计算个数<br>Select count(*) from user;</p>\n<p>注意事项：<br>sum，avg一般用于数值型<br>max，min，count可以处理任何类型<br>以上分组函数都忽略null值</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p>语法：<br>select 分组函数，列（要求出现在group by的后面）<br>from 表<br>[where 筛选条件]<br>group by 分组的列表<br>[having 分组后的筛选]<br>[order by 子句]</p>\n<p>注意：<br>查询列表必须特殊，要求是分组函数或group by后出现的字段<br>分组后筛选在group by子句的后面使用 having 关键字<br>分组函数做条件肯定是放在having子句中<br>能用分组前筛选，就优先使用分组前筛选<br>group by 子句支持单个字段分组，多个字段分组（用逗号隔开）</p>\n<p>简单分组：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id,<span class=\"built_in\">AVG</span>(salary) 平均工资 <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id; </span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询每个工种的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询每个位置上的部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> location_id, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> location_id;</span><br></pre></td></tr></table></figure>\n\n<p>添加筛选条件：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#案例<span class=\"number\">1</span>：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> department_id, <span class=\"built_in\">AVG</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> email <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%a%&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">2</span>：查询有奖金的每个领导手下的最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MAX</span>(salary)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> commission_pct <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">3</span>：查询哪个部门的员工个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> department_id, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) </span><br><span class=\"line\"><span class=\"keyword\">from</span> employees</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> department_id <span class=\"keyword\">having</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">4</span>：查询每个工种有奖金的员工的最高工资<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>的工种编号和最高工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> job_id, <span class=\"built_in\">MAX</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> job_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MAX</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">12000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">5</span>：查询领导编号<span class=\"operator\">&gt;</span><span class=\"number\">102</span>的每个领导手下的最低工资<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>的领导编号是哪个</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> manager_id, <span class=\"built_in\">MIN</span>(salary) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> manager_id<span class=\"operator\">&gt;</span><span class=\"number\">102</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> manager_id <span class=\"keyword\">HAVING</span> <span class=\"built_in\">MIN</span>(salary)<span class=\"operator\">&gt;</span><span class=\"number\">5000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#案例<span class=\"number\">6</span>：按员工姓名长度分组，查询每一组的员工个数，筛选员工个数<span class=\"operator\">&gt;</span><span class=\"number\">5</span>的有哪些</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, LENGTH(last_name), <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 员工个数 </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> LENGTH(last_name) <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接查询\"><a href=\"#连接查询\" class=\"headerlink\" title=\"连接查询\"></a>连接查询</h2><p>什么是连接查询：<br>又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>\n<p>笛卡尔积:<br>笛卡尔积乘积现象：表1 有m行，表2有n行，结果=m*n行</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</p>\n<p>按功能分类：</p>\n<ul>\n<li>内连接：  <ul>\n<li>等值连接  </li>\n<li>非等值连接  </li>\n<li>自连接  </li>\n</ul>\n</li>\n<li>外连接：  <ul>\n<li>左外连接  </li>\n<li>右外连接  </li>\n<li>全外连接（mysql不支持）  </li>\n</ul>\n</li>\n<li>交叉连接：  </li>\n</ul>\n<h3 id=\"语法-3\"><a href=\"#语法-3\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>Select 查询列表<br>From 表1 别名 【连接类型】<br>Join 表2 别名<br>On 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 分组后筛选】<br>【order by 排序列表】</p>\n<h3 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h3><p>Sql192语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询女神名和对应男生名</span><br><span class=\"line\">SELECT b.name,bs.boyName </span><br><span class=\"line\">FROM beauty b, boys bs </span><br><span class=\"line\">WHERE b.boyfriend_id = bs.id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询员工名和对应的部门名</span><br><span class=\"line\">SELECT e.last_name, e.department_id, d.department_name </span><br><span class=\"line\">FROM employees e, departments d </span><br><span class=\"line\">WHERE e.department_id=d.department_id;</span><br><span class=\"line\"></span><br><span class=\"line\">查询有奖金的员工名，部门名</span><br><span class=\"line\">SELECT e.`last_name`, d.`department_id`, e.`commission_pct` </span><br><span class=\"line\">FROM employees e,departments d </span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND commission_pct IS NOT NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class=\"line\">SELECT j.job_title, COUNT(*) </span><br><span class=\"line\">FROM employees e, jobs j </span><br><span class=\"line\">WHERE e.`job_id`=j.`job_id` </span><br><span class=\"line\">GROUP BY j.`job_title` ORDER BY COUNT(*) DESC;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）非等值连接</span><br><span class=\"line\">案例：</span><br><span class=\"line\">查询员工的工资和工资级别</span><br><span class=\"line\">SELECT e.`salary`, j.`grade_level` </span><br><span class=\"line\">FROM employees e, job_grades j</span><br><span class=\"line\">WHERE e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal` AND j.`grade_level`=&#x27;E&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）自连接</span><br><span class=\"line\">查询员工名和上级的名称</span><br><span class=\"line\">SELECT e1.last_name, e2.`last_name` </span><br><span class=\"line\">FROM employees e1,  employees e2</span><br><span class=\"line\">WHERE e1.`manager_id`=e2.`employee_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">三表连接：查询员工名，部门名和所在的城市</span><br><span class=\"line\">SELECT e.last_name, d.`department_name`, l.`city` </span><br><span class=\"line\">FROM employees e, departments d, locations l</span><br><span class=\"line\">WHERE e.`department_id`=d.`department_id` AND d.`location_id`=l.`location_id`;</span><br></pre></td></tr></table></figure>\n\n<p>sql99语法：Inner </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询员工名，部门名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`;</span><br><span class=\"line\"></span><br><span class=\"line\">查询名字中只能包含e的员工名和工种名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> e.last_name, j.`job_title` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> jobs j <span class=\"keyword\">ON</span> e.`job_id`<span class=\"operator\">=</span>j.`job_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`last_name` <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%e%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询部门个数<span class=\"operator\">&gt;</span><span class=\"number\">3</span>的城市名和部门个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> l.`city`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> locations l </span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> l.`location_id` <span class=\"operator\">=</span> d.`location_id`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> l.`city` <span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>)<span class=\"operator\">&gt;</span><span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询工资级别的个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span>的个数，并按工资级别降序</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> j.`grade_level`, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) 个数 <span class=\"keyword\">FROM</span> job_grades j</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> e.`salary` <span class=\"keyword\">BETWEEN</span> j.`lowest_sal` <span class=\"keyword\">AND</span> j.`highest_sal`</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> j.`grade_level` <span class=\"keyword\">HAVING</span> 个数<span class=\"operator\">&gt;</span><span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> 个数 <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>应用场景：用于查询一个表中有，另一个表没有</p>\n<p>1.外连接的查询结构为主表中的所有记录<br>如果从表中有和它匹配的，则显示匹配值<br>如果从表中没有和它匹配的，则显示为null<br>外连接查询结果=内连接结果+主表中有而从表没有的数据</p>\n<p>2.左外连接，left join左边的是主表<br>右外连接，right join右边的是主表  </p>\n<p>3.左外和右外交换两个表的顺序，可以实现同样的效果</p>\n<p>（1）左连接：<br>语法：Left 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b </span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> boys bo <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> departments d</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees e <span class=\"keyword\">ON</span> d.`department_id`<span class=\"operator\">=</span>e.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n<p>（2）右连接<br>语法：Right 【outer】</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#查询没有男朋友的女神名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> boys bo </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> beauty b <span class=\"keyword\">ON</span> b.`boyfriend_id`<span class=\"operator\">=</span>bo.`id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> bo.`id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查询哪个部门没有员工</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> d.`department_id`, d.`department_name` <span class=\"keyword\">FROM</span> employees e </span><br><span class=\"line\"><span class=\"keyword\">RIGHT</span> <span class=\"keyword\">JOIN</span> departments d <span class=\"keyword\">ON</span> e.`department_id`<span class=\"operator\">=</span>d.`department_id`</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> e.`employee_id` <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> d.`department_id`;</span><br></pre></td></tr></table></figure>\n\n<p>（3）全外（mysql不支持）<br>语法：Full 【outer】</p>\n<h3 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h3><p>语法：Cross</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女神男神表交叉连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> b.<span class=\"operator\">*</span>, bo.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> beauty b</span><br><span class=\"line\"><span class=\"keyword\">CROSS</span> <span class=\"keyword\">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>出现在其他语句的select语句，称为子查询或内出现<br>内部嵌套其他select语句的查询，称为外查询或主查询</p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p>按子查询出现的位置：<br>1）select 后面<br>2）from 后面<br>3）wehre 或 having后面<br>4）exists后面（相关子查询）  </p>\n<p>按结果集的行列数不同：<br>1）标量子查询（结果集只有一行一列）<br>2）列子查询（结果集只有一列多行）<br>3）行子查询（结果集有多行多列）<br>4）表子查询（结果集一般为多行多列）</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p><code>&gt; &lt; &lt;&gt; = </code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">谁的工资比 Abel 高？</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, salary</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> last_name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abel&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">返回job_id与<span class=\"number\">141</span>号员工相同，salary比<span class=\"number\">143</span>号员工多的员工姓名，job_id和工资</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name,job_id,salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> job_id <span class=\"operator\">=</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> job_id <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> salary<span class=\"operator\">&gt;</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> employee_id<span class=\"operator\">=</span><span class=\"number\">141</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">案例<span class=\"number\">3</span>：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name, job_id, salary <span class=\"keyword\">FROM</span> employees </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary <span class=\"operator\">=</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span>（常用）：</span><br><span class=\"line\">作用：可以是子查询中的任一一个</span><br><span class=\"line\">返回location_id是<span class=\"number\">1400</span>或<span class=\"number\">1700</span>的部们中的所有员工姓名</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> department_id <span class=\"keyword\">IN</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> department_id <span class=\"keyword\">FROM</span> departments <span class=\"keyword\">WHERE</span> location_id <span class=\"keyword\">IN</span>(<span class=\"number\">1400</span>, <span class=\"number\">1700</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Any</span>（不常用）：</span><br><span class=\"line\">作用：任一一个</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ANY</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">All</span>（不常用）：</span><br><span class=\"line\">作用：所有的</span><br><span class=\"line\"></span><br><span class=\"line\">返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的员工号，姓名，job_id,以及salasy</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> employee_id, last_name, job_id,salary <span class=\"keyword\">FROM</span> employees</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> salary<span class=\"operator\">&lt;</span><span class=\"keyword\">ALL</span>(</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> salary <span class=\"keyword\">FROM</span> employees <span class=\"keyword\">WHERE</span> job_id<span class=\"operator\">=</span><span class=\"string\">&#x27;IT_PROG&#x27;</span></span><br><span class=\"line\">) <span class=\"keyword\">AND</span> department_id<span class=\"operator\">&lt;&gt;</span><span class=\"string\">&#x27;IT_PROG&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页查询（常用）\"><a href=\"#分页查询（常用）\" class=\"headerlink\" title=\"分页查询（常用）\"></a>分页查询（常用）</h2><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>\n<h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><p>select 参数列表<br>from 表<br>left join 表名 on 连接条件<br>where 筛选条件<br>group by 分组字段 having 分组后筛选<br>order by 排序字段<br>limit 【offset,】 size；</p>\n<p>offset 要显示条目的起始索引（起始索引从0开始）<br>size 要显示的条目个数<br>特点：limit语句放在查询语句的最后</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>查询第二页，一页10条记录<br>Select * from user limit 10, 10;</p>\n<h2 id=\"Union联合查询\"><a href=\"#Union联合查询\" class=\"headerlink\" title=\"Union联合查询\"></a>Union联合查询</h2><p>union 联合 合并：将多条查询语句的结果合并成一个结果</p>\n<p>应用场景：要查询的结果来自于多个表，且多个表没有证据的连接关系，单查询的信息一致时</p>\n<h3 id=\"语法-4\"><a href=\"#语法-4\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>查询语句1<br>union<br>查询语句2<br>union<br>….</p>\n<p>特点：<br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以包含重复项</p>\n<h3 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Union all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id, name <span class=\"keyword\">from</span> <span class=\"keyword\">user</span></span><br><span class=\"line\"><span class=\"keyword\">Union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> id,name <span class=\"keyword\">from</span> emp;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"DML语言\"><a href=\"#DML语言\" class=\"headerlink\" title=\"DML语言\"></a>DML语言</h1><p>数据库操作语言：<br>插入：insert<br>修改：update<br>删除：delete</p>\n<h2 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h2><h3 id=\"方式1\"><a href=\"#方式1\" class=\"headerlink\" title=\"方式1\"></a>方式1</h3><p>语法：<br>Inser into 表名(列名, …) values(值1, …);</p>\n<p>使用：<br>INSERT INTO users VALUES(1, ‘欧阳荣’, ‘男’, 166842.5);<br>INSERT INTO users(id, NAME, sex, gz) VALUES(2, ‘赵云彬’, ‘欧阳荣’, NULL);</p>\n<h3 id=\"方式2\"><a href=\"#方式2\" class=\"headerlink\" title=\"方式2\"></a>方式2</h3><p>语法：<br>insert into 表名 set 列名=值,列名=值,….;</p>\n<p>使用：<br>INSERT INTO boys SET id=6, boyName=’侄子’, userCp=147258;</p>\n<h3 id=\"两种开发方式pk\"><a href=\"#两种开发方式pk\" class=\"headerlink\" title=\"两种开发方式pk\"></a>两种开发方式pk</h3><p>insert方式一次可以加多条，第二种方式不行<br>INSERT INTO boys VALUES(7, ‘欧阳荣’, 10000000), (8, ‘欧阳荣’, 10000000);</p>\n<p>insert方式可以用子查询<br>INSERT INTO boys SELECT 10, ‘ii’, 150044;</p>\n<h2 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h2><h3 id=\"修改单表的记录（常用）\"><a href=\"#修改单表的记录（常用）\" class=\"headerlink\" title=\"修改单表的记录（常用）\"></a>修改单表的记录（常用）</h3><p>语法：<br>Update 表名 set 列=新值, 列=新值…. where 筛选条件;</p>\n<p>案例：<br>修改beauty表中姓唐的女神电话为1389988889<br>UPDATE beauty SET phone=’1389988889’ WHERE NAME LIKE ‘唐%’;</p>\n<p>修改boys表中id号为2的名称为张飞，魅力值10<br>UPDATE boys SET boyName=’张飞’, userCP=10 WHERE id=2;</p>\n<p>4.2.2.修改多表的记录（补充）<br>192语法：<br>UPDATE 表名 别名,表名 别名<br>SET 列=值,列=值 …<br>WHERE 连接添加 AND 筛选条件</p>\n<p>199语法:<br>UPDATE 表名 别名<br>INNER|LEFT|RIGHT| JOIN 表名 别名 ON 连接条件<br>SET 列=值，列=值 …<br>WHERE 筛选条件</p>\n<p>案例（以下实现都为199语法）：</p>\n<p>修改张无忌的女朋友的手机号为114<br>UPDATE boys bo<br>INNER JOIN beauty b ON bo.id=b.boyfriend_id<br>SET phone=’114’<br>WHERE bo.boyName=’张无忌’;</p>\n<p>修改没有男朋友的女神的男朋友的编号都为2号<br>UPDATE boys bo<br>RIGHT JOIN beauty b ON bo.id=b.boyfriend_id<br>SET b.boyfriend_id=2<br>WHERE bo.id IS NULL;</p>\n<p>4.3.删除语句</p>\n<p>4.3.1.方式1：delete<br>语法：<br>（1）单表删除（重要）：<br>Delete from 表名 where 筛选条件;</p>\n<p>（2）多表删除（补充）<br>192：<br>Delete 表1别名, 表2别名<br>from 表一 别名, 表二别名<br>Where 连接条件 and 筛选条件</p>\n<p>199：<br>Delete 表1别名, 表2别名<br>From 表一 别名<br>inner|Left|right| join 表2 别名 on 连接条件<br>Where 筛选条件</p>\n<p>案例：</p>\n<p>删除手机号以9结尾的女神信息<br>DELETE FROM beauty WHERE phone LIKE ‘%9’;</p>\n<p>删除张无忌的女朋友的信息<br>DELETE b FROM beauty b INNER JOIN boys bo ON bo.id=b.boyfriend_id<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>\n<p>删除黄晓明的信息以及他女朋友的信息<br>DELETE b, bo FROM boys bo<br>INNER JOIN beauty b ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>\n<p>4.3.2.方式2：truncate<br>语法：<br>Truncate table 表名;</p>\n<p>特点：<br>不能加筛选条件，也叫做清空。</p>\n<p>4.3.3.delete pk truncate（面试题）</p>\n<p>1.delete可以加where条件，truncate不可以<br>2.truncate删除，效率高一丢丢<br>3.假如删除的表中有自增长，使用delete删除后，再插入数据，自增长列的值从断点开始。<br>如果使用truncate删除后，再插入值，自增长列的值从1开始。<br>4.truncate删除没有返回值，delete删除有返回值<br>5.truncate删除不能回滚，delete删除可以回滚。</p>\n<p>5.DDL语言<br>数据库定义语言，也就是库和表的管理</p>\n<p>5.1.库的管理</p>\n<p>5.1.1.库的创建</p>\n<p>语法：<br>create database [if not exists] 库名 [character set 字符集]</p>\n<p>案例：</p>\n<p>创建一个db_book库<br>CREATE DATABASE IF NOT EXISTS db_oyr CHARACTER SET utf8;</p>\n<p>5.1.2.库的修改</p>\n<p>修改库名（现在不能用了）：<br>语法：<br>rename database 库名 to 新库名;</p>\n<p>案例<br>把db_oyr库名改成my_oyr<br>RENAME DATABASE db_oyr TO my_oyr;</p>\n<p>修改字符集：<br>语法：<br>alert database 库名 character set 字符集;</p>\n<p>案例：</p>\n<p>修改db_oyr的字符集为gbk<br>ALTER DATABASE db_oyr CHARACTER SET gbk;</p>\n<p>5.1.3.库的删除</p>\n<p>语法：<br>DROP DATABASE [IF EXISTS] 库名;</p>\n<p>案例:<br>删除db_oyr<br>DROP DATABASE db_oyr; </p>\n<p>5.2.表的管理</p>\n<p>5.2.1.表的创建</p>\n<p>语法：<br>create table 表名(<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    列名 列类型【（类型长度） 约束】,<br>    …<br>    列名 列类型【（类型长度） 约束】<br>);</p>\n<p>案例：<br>创建book表<br>CREATE TABLE book(<br>    id INT,#编号<br>    bName VARCHAR(20),#图书名<br>    price DOUBLE,#价格<br>    authorId INT,#作者编号<br>    publishDate DATETIME#出版日期<br>);</p>\n<p>5.2.2.表的修改</p>\n<p>语法：<br>Alter table 表名 add|drop|modify|change column 列名 【列类型 约束】</p>\n<p>（1）修改列名</p>\n<p>ALTER TABLE book CHANGE COLUMN bName myName VARCHAR(25);</p>\n<p>（2）修改列的类型或约束</p>\n<p>ALTER TABLE my_book MODIFY COLUMN myName INT;</p>\n<p>（3）添加新列</p>\n<p>ALTER TABLE book ADD COLUMN oo VARCHAR(20);</p>\n<p>（4）删除列</p>\n<p>ALTER TABLE book DROP COLUMN oo;</p>\n<p>（5）修改表名</p>\n<p>ALTER TABLE book RENAME TO my_book;</p>\n<p>5.2.3.表的删除</p>\n<p>语法：<br>DROP TABLE 【IF EXISTS】 表名;</p>\n<p>案例：</p>\n<p>删除my_book表<br>DROP TABLE IF EXISTS my_book;</p>\n<p>5.2.4.表的复制<br>1)复制表的结构<br>语法：<br>Create table 新表名 like 被复制的表名;</p>\n<p>复制boys的结构<br>CREATE TABLE copy LIKE boys;</p>\n<p>2)复制表的结构和数据<br>语法：<br>Create table 新表名<br>Select * from 被复制表的表名</p>\n<p>复制boys表的结构和数据<br>CREATE TABLE copy2<br>SELECT * FROM boys;</p>\n<p>复制boys部门数据和部分列<br>CREATE TABLE copy3<br>SELECT id,boyName FROM boys WHERE id&lt;5;<br>SELECT * FROM copy3;</p>\n<p>复制几个字段的结构<br>CREATE TABLE copy4<br>SELECT id, boyName FROM boys<br>WHERE 1=2;</p>\n<p>5.3.常见的约束</p>\n<p>5.3.1.约束介绍</p>\n<p>六大约束：<br>NOT NULL：非空约束，用于保证该字段的值不能为空<br>UNIQUE：唯一约束，用于保证该字段的值有唯一性，可以为空<br>PRIMARY KEY：主键约束，用于保证该字段的值有唯一性，并且不能为空<br>CHEACK：检查约束【MYSQL中不支持，没有效果】<br>FOREIGN KEY：外检约束，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，用于引用主表中某列的值<br>DEFAULT：默认值，用于保证字段有默认值</p>\n<p>添加约束的时机：<br>创建表时<br>修改表时</p>\n<p>约束的添加分类：<br>列级约束：<br>六大约束语法上都支持，单外检约束没有效果<br>表级约束：<br>除了非空，默认，其他都支持</p>\n<p>列级约束 VS 表级约束<br>位置            支持的约束类型                    是否可以起别名<br>列级：    列的后面        都支持，但外键没有效果            不可以<br>表级：    所有列的下面    默认和非空不支持，其他都支持    可以主键（没有效果）</p>\n<p>5.3.2.添加列级约束</p>\n<p>新建一个库students，在里面测试添加列级约束</p>\n<h1 id=\"新建主修表\"><a href=\"#新建主修表\" class=\"headerlink\" title=\"新建主修表\"></a>新建主修表</h1><p>create table major(<br>    id bigint(20) primary key, #主键约束<br>    major_name varchar(25) NOT NULL #非空约束<br>)</p>\n<h1 id=\"新建学生表\"><a href=\"#新建学生表\" class=\"headerlink\" title=\"新建学生表\"></a>新建学生表</h1><p>create table student(<br>    id bigint(20) primary key, #主键约束<br>    stu_name varchar(25) NOT NULL, #非空约束<br>    sex char(2) CHECK(sex = ‘男’ or sex = ‘女’), #检查约束<br>    age int default 20, #默认约束<br>    card varchar(25) unique,#唯一约束<br>    major_id bigint(20) REFERENCES major(id) #外键约束<br>)</p>\n<p>经过测试后发现，检查约束是无效的，而且外检约束也是无效的。<br>其他都是ok的。</p>\n<p>5.3.3.添加表级约束</p>\n<p>语法：<br>在表字段的最下面<br>[constraint 约束名] 约束类型(字段名)<br>表级约束添加外键是有效的。</p>\n<p>指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  CONSTRAINT pk PRIMARY KEY(id), #主键，约束名不生效<br>  CONSTRAINT un_card UNIQUE KEY(card), #唯一约束<br>CONSTRAINT ch_sex CHECK(sex = ‘女’ or sex =’男’),<br>  CONSTRAINT <code>pk_student_major</code> FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>不指定约束名创建约束：<br>CREATE TABLE student (<br>  id bigint(20) NOT NULL,<br>  stu_name varchar(25) NOT NULL,<br>  sex char(2) DEFAULT NULL,<br>  age int(11) DEFAULT ‘20’,<br>  card varchar(25) DEFAULT NULL,<br>  major_id bigint(20) DEFAULT NULL,<br>  PRIMARY KEY(id), #主键，约束名不生效<br>  UNIQUE KEY(card), #唯一约束<br>    CHECK(sex = ‘女’ or sex =’男’),<br>  FOREIGN KEY (major_id) REFERENCES major(id)<br>);</p>\n<p>5.3.4.主键约束 VS 唯一约束</p>\n<p>保证唯一性    是否允许为空    一个表中有几个    是否允许出现组合<br>主键        √            ×                最多一个        √，但不推荐<br>唯一        √            ×                可以多个        √，但不推荐</p>\n<p>唯一约束可以允许为空，但null只能出现一次。<br>组合就是组合主键或组合唯一约束。</p>\n<p>5.3.5.外键的特点</p>\n<p>从表：当前表<br>主表：被关联的表</p>\n<p>1.要求在从表中设置外键关系<br>2.从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>3.主表的关联列必须是一个key（主键和唯一，不然会抛出异常）<br>4.插入数据时，先插入主表，再插入从表，删除数据时，先删除从表，再删除主表</p>\n<p>5.3.6.修改表时添加约束</p>\n<p>语法：<br>1.添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束</p>\n<p>2.添加表级约束<br>alter table 表名 add [constraint 约束名] 约束类型(字段名)  [外键的引用]</p>\n<p>添加非空约束：<br>列级：<br>alter table student modify column stu_name varchar(25) not null;</p>\n<p>添加默认约束：<br>列级：<br>alter table student modify column age int default 20</p>\n<p>添加主键约束：<br>列级：<br>alter table student modify column id bigint(20) primary key<br>表级：<br>alter table student add primary key(id)</p>\n<p>添加唯一约束：<br>列级：<br>alter table student modify column card varchar(25) unique<br>表级：<br>alter table student add constraint un_card unique(card)</p>\n<p>添加外键约束：<br>表级：<br>alter table student add constraint fk_student_major foreign key(id) references major(id)</p>\n<p>5.3.7.修改表时删除约束</p>\n<p>1.删除非空约束（直接不写就是删除）<br>alter table student modify column stu_name varchar(25)</p>\n<p>2.删除默认约束（不写即是删除）<br>alter table student modify column age int default 20</p>\n<p>3.删除主键约束<br>aler table 表名 drop primary key</p>\n<p>4.删除唯一约束<br>alter table 表名 drop index 约束名</p>\n<p>5.删除外键约束<br>alter table 表名 drop foreign key 约束名</p>\n<p>5.4.标识列</p>\n<p>什么是标识列？<br>标识列是自增长列<br>含义：可以不手动的插入值，系统提供默认的序列值</p>\n<p>特点：<br>1.标识列必须和key值搭配（也就是说当前列必须是主键或者唯一）<br>2.一个表只能有一个标识列<br>3.标识类的类型只能是数值型<br>4.标识列可以通过 set auto_increment_increment=3;设置步长。可以手动插入值来设置起始值</p>\n<p>创建表时设置标识列<br>create table tb_user(<br>    id int primary key auto_increment, #主键并且设置标识列<br>    name varchar(25) not null<br>)</p>\n<p>修改表时设置标识列<br>alter table tb_user modify column id int primary key auto_increment</p>\n<p>修改表时删除标识列<br>alter table tb_user modify column id int primary key</p>\n<p>6.TCL 语言<br>TCL：Transaction Control Language 事物控制语言</p>\n<p>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。</p>\n<p>6.1.MySQL 中的存储引擎</p>\n<p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。<br>2、通过show engines；来查看mysql支持的存储引擎。<br>3、 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中innodb支持事务，而myisam、memory等不支持事务</p>\n<p>6.2.事务的ACID属性</p>\n<ol>\n<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么都执行失败。</p>\n</li>\n<li><p>一致性（Consistency）<br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</p>\n</li>\n<li><p>隔离性（Isolation）<br>并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</p>\n</li>\n<li><p>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>\n</li>\n</ol>\n<p>6.3.事物的使用步骤</p>\n<p>事物又分两种：隐式事物和显式事物<br>隐式事物：事物没有明显的开启和结束的标记<br>列如insert，update，delete</p>\n<p>显式事物：事物具有明显的开启和结束的标记<br>前提：必须设置自动提交功能为禁用</p>\n<p>查看当前自动提交功能开关<br>show variables like ‘autocommit’</p>\n<p>关闭自动提交功能，并不是永久的，只是当前回话被关闭<br>set autocommit=0;</p>\n<p>开启事物的语法：<br>#步骤1：开启事物<br>set autocommit=0;<br>start transaction;#开启事物，可选的<br>#步骤2：编写事物中的sql语句（select insert update delete）<br>语句1;<br>语句2;<br>…….<br>#步骤3：结束事物<br>commit;#提交事物<br>rollback;回滚事物</p>\n<p>实战操作：<br>初始化<br>create table account(<br>    id bigint(20) primary key auto_increment,<br>    acc_name varchar(25),<br>    money double<br>)<br>INSERT INTO account (id, acc_name, money) VALUES (1, ‘欧阳荣’, 1500);<br>INSERT INTO account (id, acc_name, money) VALUES (2, ‘罗总’, 500);</p>\n<p>转账成功提交：执行后可以看到数据库数据已经改变了<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>commit;</p>\n<p>转账失败回滚：执行后会发现数据并没有改变<br>set autocommit=0;<br>start transaction;<br>update account set money = money-500 where acc_name=’欧阳荣’;<br>update account set money = money+500 where acc_name=’罗总’;<br>rollback;</p>\n<p>6.4.数据库的隔离级别</p>\n<p>6.4.1.并发问题</p>\n<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>\n<p>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段.<br>之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>\n<p>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段.<br>之后, T1再次读取同一个字段, 值就不同了.</p>\n<p>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插<br>入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行。</p>\n<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>\n<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>\n<p>6.4.2.四种事务隔离级别</p>\n<p>Oracle支持2种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED。</p>\n<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>\n<p>6.5.回滚点使用（savepotion）</p>\n<p>set autocommit=0;#设置不自动提交<br>start transaction;#开启事物<br>delete form account where id=1;<br>savepoint a;#保存点<br>delete from account where id=2;<br>rollback to a;#回滚到保存点<br>这上面的sql意思是只回滚到保存点，其实就是删除了id=1的数据，id=2的数据并没有被删除。</p>\n<p>7.视图<br>7.1.什么是视图</p>\n<p>含义：虚拟表，和普通表一样使用<br>MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</p>\n<p>应用场景：<br>1.多个地方用到同样的查询结果<br>2.该查询结果使用的sql语句较复杂</p>\n<p>7.2.视图的创建</p>\n<p>语法：<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>OR REPLACE：表示替换已有视图</p>\n<p>ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p>\n<p>[WITH [CASCADED | LOCAL] CHECK OPTION]：<br>表示视图在更新时保证在视图的权限范围之内<br>cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件<br>local表示更新视图的时候，要满足该视图定义的一个条件即可<br>推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 </p>\n<p>实际操作：</p>\n<p>1.查询邮箱中包含a字符的员工名，部门名，工种信息<br>– 创建视图<br>create view view_test1<br>AS<br>SELECT<br>    CONCAT(e.first_name, e.last_name) 员工名,<br>    dept.department_name 部门名,<br>    j.job_title 工种信息<br>FROM<br>    employees e<br>LEFT JOIN departments dept ON dept.department_id = e.department_id<br>LEFT JOIN jobs j ON j.job_id = e.job_id<br>where email LIKE ‘%a%’<br>– 查询视图<br>select * from view_test1</p>\n<p>2.查询各部门的平均工资级别<br>create view view_test2<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name</p>\n<p>SELECT<br>    vt.dept_name,<br>    jb.grade_level<br>FROM<br>    view_test2 vt<br>LEFT JOIN job_grades jb ON vt.ag BETWEEN jb.lowest_sal<br>AND jb.highest_sal</p>\n<p>3.查询平均工资最低的部门<br>create view view_test3<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>4.查询平均工资最低的部门名和工资<br>create view view_test4<br>as<br>SELECT<br>    dept.department_name dept_name,<br>    AVG(e.salary) ag<br>FROM<br>    departments dept<br>LEFT JOIN employees e ON dept.department_id = e.department_id<br>GROUP BY dept.department_name having ag is not null<br>order by ag asc limit 0, 1</p>\n<p>视图的好处：<br>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性</p>\n<p>7.3.视图的修改</p>\n<p>方式一：如果存在，则覆盖<br>create  [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>view 视图名 as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION]</p>\n<p>方式二：指定修改视图<br>alter<br>[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]<br>    [DEFINER = { user | CURRENT_USER }]<br>    [SQL SECURITY { DEFINER | INVOKER }]<br>view 视图名<br>as<br>查询语句<br>[WITH [CASCADED | LOCAL] CHECK OPTION];</p>\n<p>方式一实际操作：<br>create or replace view view_test4<br>as<br>select * from employees where employee_id &gt; 105</p>\n<p>方式二实际操作：<br>alter view view_test4<br>as<br>select * from employees where employee_id &gt; 120</p>\n<p>7.4.视图的删除</p>\n<p>语法：<br>drop view 视图名,视图名,视图名……..</p>\n<p>实际操作：<br>drop view view_test4, view_test3</p>\n<p>7.5.查看视图<br>方式1：desc 视图名</p>\n<p>方式2：show create view 视图名</p>\n<p>方式1实际操作：<br>desc view_test2</p>\n<p>可以看到实际上能看到的是当前视图可以查询出的字段信息</p>\n<p>方式2实际操作：<br>show create view view_test2</p>\n<p>可以看到的是当前拿到的是创建视图的逻辑sql。</p>\n<p>7.6.视图VS表</p>\n<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view            只是保存了逻辑sql        增删改查，一般不能增删改查</p>\n<p>表        create table            保存了数据                增删改查</p>\n<p>8.变量</p>\n<p>8.1.系统变量</p>\n<p>说明：变量由系统提供的，不是银行定义，属于服务器层面<br>系统变量又可以细分为全局变量和局部变量</p>\n<p>使用的语法：<br>1.查看所有的系统变量<br>show global|[session] variables</p>\n<p>2.查看满足条件的部分系统变量<br>show global | [session] variables like ‘%char%’;</p>\n<p>3.查看指定的某个系统变量的值<br>select @@global | [session] .系统变量名</p>\n<p>4.为某个系统变量赋值<br>方式一：<br>set global | [session] 系统变量名 = 值;</p>\n<p>方式二：<br>Set @@global | [session] .系统变量名 = 值;</p>\n<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认是session级别</p>\n<p>8.1.1.全局变量实际操作</p>\n<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对所有会话（连接）</p>\n<p>（1）查看所有的全局变量<br>show global variables;</p>\n<p>（2）查看部分的全局变量<br>show global variables like ‘%char%’;</p>\n<p>（3）查看指定的全局变量的值<br>select @@global.autocommit;</p>\n<p>（4）为某个指定的全局变量赋值<br>set @@global.autocommit = 0;</p>\n<p>8.1.2.局部变量实际操作</p>\n<p>作用域：仅仅针对于当前会话（连接）有效</p>\n<p>（1）查看所有的会话变量<br>show variables<br>show session variables</p>\n<p>（2）查看部分的会话变量<br>show variables like ‘%char%’<br>show session variables like ‘%char%’</p>\n<p>（3）指定查看某个会话变量<br>select @@character_set_client<br>select @@session.character_set_client</p>\n<p>（4）为某个会话变量赋值<br>set autocommit=0<br>set @@session.autocommit=1</p>\n<p>8.2.自定义变量</p>\n<p>说明：变量是用户自定义的，不是由系统自动生成的。<br>自定义变量又可以细分成用户变量（当前会话有效），局部变量<br>使用步骤：<br>声明<br>赋值<br>使用（查看，比较，运算等）</p>\n<p>8.2.1.用户变量</p>\n<p>作用域：针对于电器干会话（连接）有效，同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end外面</p>\n<p>使用语法：</p>\n<p>（1）声明并初始化：<br>set @用户变量名=值 或<br>set @用户变量名:=值 或<br>select @用户变量名:=值</p>\n<p>（2）赋值（更新用户变量的值）<br>方式一：通过set和select<br>set @变量名=值 或<br>set @变量名:=值 或<br>select @变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO @变量名<br>from 表</p>\n<p>（3）使用（查看用户变量的值）<br>select @用户变量名</p>\n<p>实际操作：</p>\n<p>声明并且初始化：</p>\n<h1 id=\"声明并且初始化\"><a href=\"#声明并且初始化\" class=\"headerlink\" title=\"声明并且初始化\"></a>声明并且初始化</h1><p>set @name=’欧阳荣’;<br>set @name:=10;<br>select @name:=’罗总’;</p>\n<p>赋值：<br>#赋值<br>set @count = 10;<br>set @count := 15;<br>select @count := 20;<br>select count(*) into @count from account;</p>\n<p>使用：<br>select @count;</p>\n<p>8.2.2.局部变量</p>\n<p>作用域：仅仅在定义它的begin end中有效，应用在begin end的第一句</p>\n<p>（1）声明<br>declare 变量名 类型;<br>declare 变量名 类型 default 值;</p>\n<p>（2）赋值<br>方式一：通过set和select<br>set 局部变量名=值 或<br>set 局部变量名:=值 或<br>select @局部变量名:=值</p>\n<p>方式二：通过select into<br>select 字段 INTO 局部变量名<br>from 表</p>\n<p>（3）使用<br>select 局部变量名</p>\n<p>8.2.3.用户变量 VS 局部变量</p>\n<p>作用域        定义和使用的位置                语法<br>用户变量    当前会话    会话中的任何地方                必须加@符，不限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句    不用加@符，需要限定类型</p>\n<p>9.存储过程和函数<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作</p>\n<p>9.1.存储过程</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>9.1.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create procedure 存储过程名(参数列表)<br>begin<br>存储过程体（一组合法的SQL语句）<br>end</p>\n<p>注意：<br>1.参数列表包含三部分<br>参数模式    参数名    参数类型<br>in            student    varchar(20)</p>\n<p>参数模式：<br>in：    该参数可以作为输入，也就是该参数需要调用方法传入值<br>out：    该参数可以作为输出，也就是该参数可以作为返回值<br>inout：    该参数既可以作为输入也可以作为输出，也就是该参数即需要传入值，又可以返回值</p>\n<p>2.如果存储过程体仅仅只有一句话，begin end可以省略。<br>存储过程的每条SQL语句的结尾要求必须加上分号。<br>存储过程的结尾可以使用delimiter重新设置<br>语法：<br>DELIMITER 结束标记<br>DELIMITER $</p>\n<p>调用语法：<br>CALL 存储过程名（实参列表）</p>\n<p>查看语法：<br>show create procedure 存储过程名;</p>\n<p>删除语法：<br>drop procedure 存储过程名;</p>\n<p>9.1.2.存储过程实战</p>\n<p>（1）空参的存储过程：</p>\n<h1 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1()<br>begin<br>    insert into admin(name, money) values(‘z1’, 11), (‘z2’, 22), (‘z3’, 33), (‘z4’, 44), (‘z5’, 55);<br>end;</p>\n<p>#调用存储过程<br>CALL myp1();</p>\n<p>带in模式参数的存储过程：<br>根据女神名获取男神信息</p>\n<h1 id=\"创建存储过程-1\"><a href=\"#创建存储过程-1\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h1><p>create procedure myp1(in beauty_name varchar(25))<br>begin<br>    select bs.* from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<h1 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h1><p>call myp1(‘赵敏’)</p>\n<p>根据用户名和密码判断是否能登录成功<br>– 创建存储过程<br>create procedure myp2(in username varchar(25), in password varchar(25))<br>begin<br>    declare result int default ‘0’;<br>    select count(*) INTO result from admin a where a.username = username and a.<code>password</code> = password;<br>    select if(result &gt; 0, ‘成功’, ‘失败’);<br>end;<br>– 调用<br>call myp2(‘john’, ‘8888’)</p>\n<p>（2）带out模式的存储过程：</p>\n<p>根据女神名，返回对应的男神名<br>#创建<br>create procedure myp3(in beauty_name varchar(25), out boy_name varchar(25))<br>begin<br>    select bs.boyName into boy_name from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;<br>– 调用<br>set @boy_name=’’;<br>call myp3(‘赵敏’, @boy_name);<br>select @boy_name;</p>\n<p>根据女神名，返回对应的男神名和男神魅力值<br>创建<br>create procedure myp4(in beauty_name varchar(25), out boy_name varchar(25), out user_cp int)<br>begin<br>    select bs.boyName, bs.userCP into boy_name,user_cp  from beauty b right join boys bs on b.boyfriend_id = bs.id where b.name = beauty_name;<br>end;</p>\n<p>– 调用<br>set @boy_name=’’;<br>set @user_cp=0;<br>call myp4(‘赵敏’, @boy_name, @user_cp);<br>select @boy_name, @user_cp;</p>\n<p>（3）带inout模式参数的存储过程</p>\n<p>传入a和b两个值，最终a和b都翻倍并返回<br>#创建<br>create procedure myp5(inout x int, inout y int)<br>begin<br>    set x = x<em>2;<br>    set y = y</em>2;<br>end;<br>#调用<br>set @x = 10;<br>set @y = 20;<br>call myp5(@x, @y);<br>select @x, @y;</p>\n<p>9.2.函数</p>\n<p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>\n<p>存储过程与函数的区别：<br>存储过程：可以有0个返回，也可以与多个返回，适合做批量插入，批量更新<br>函数：有且仅有一个返回，适合做处理数据后返回一个结果，适合做处理数据后返回一个结果</p>\n<p>9.2.1.创建&amp;调用&amp;查看&amp;删除语法</p>\n<p>创建语法：<br>create function 函数名(参数列表) returns 返回类型<br>begin<br>函数体<br>end</p>\n<p>注意：<br>1.参数列表包含两部分：参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错。<br>如果return语句没有放在函数体的最后也不报错，但不建议。<br>3.函数体重仅有一句话，则可以省略begin end<br>4.使用delimiter语句设置结束标记</p>\n<p>调用语法：<br>select 函数名（参数列表）</p>\n<p>查看语法：<br>show create function 函数名</p>\n<p>删除语法：<br>dorp function 函数名</p>\n<p>9.2.2.函数实战</p>\n<p>（1）无参有返回</p>\n<p>返回公司的员工个数：<br>#创建<br>create function myf1() returns int<br>begin<br>    declare count int default 0;<br>    select COUNT(*) into count from employees;<br>    return count;<br>end;<br>#调用<br>select myf1();</p>\n<p>（2）有参返回</p>\n<p>根据员工名返回工资：<br>#创建<br>create function myf2(username varchar(25)) returns double<br>begin<br>    declare money double default 0;<br>    select salary into money from employees where last_name = username;<br>    return money;<br>end;<br>#调用<br>select myf2(‘Kochhar’);</p>\n<p>根据部门名，发挥该部门的平均工资<br>#创建<br>create function myf3(dept_name varchar(25)) returns double<br>begin<br>    declare ave_salary double default 0;<br>    select avg(e.salary) into ave_salary from departments dept left join employees e on dept.department_id = e.department_id<br>    where dept.department_name = dept_name group by dept.department_id;<br>    return ave_salary;<br>end;<br>#调用<br>select myf3(‘Adm’);</p>\n<p>实现传入两个float，返回两者之和：</p>\n<p>#创建<br>create function myf1(x float, y float) returns float<br>begin<br>    declare sum float default 0;<br>    set sum = x + y;<br>    return sum;<br>end;<br>#调用<br>select myf1(1, 5.1);</p>\n<p>（3）查看函数<br>show create function myf3;</p>\n<p>（4）删除函数<br>drop function myf3</p>\n<p>10.流程控制结构<br>顺序结构：程序从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上重复执行一段代码</p>\n<p>10.1.分支结构</p>\n<p>（1）if函数<br>功能：实现简单的双分支<br>语法：<br>If(表达式1, 表达式2, 表达式3)<br>执行顺序：<br>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值<br>应用：任何地方<br>实战操作：<br>select if(1 &gt; 2, 1, 2)<br>当前sql执行后会返回2</p>\n<p>（2）case结构</p>\n<p>在begin end 外面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 返回的值1<br>when 要判断的值 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 返回的值1<br>when 要判断的条件2 then 返回的值2<br>….<br>else 返回的值n<br>end</p>\n<p>在begin end里面：</p>\n<p>情况1：类似于java中的switch语句，一般用于实现等值的判断<br>case 变量|表达式|字段<br>when 要判断的值 then 要执行的语句1<br>when 要判断的值 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>情况2：类似于java的多重IF语句，一般用于视区间判断<br>case<br>when 要判断的条件1 then 要执行的语句1<br>when 要判断的条件2 then 要执行的语句2<br>….<br>else 要执行的语句n<br>end case;</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create procedure show_grade(in grade int)<br>begin<br>    declare result varchar(2);<br>    CASE<br>    WHEN grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    WHEN grade&gt;=80 THEN set result = ‘B’;<br>    WHEN grade&gt;=60 THEN set result = ‘C’;<br>    ELSE set result = ‘D’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>CALL show_grade(99);</p>\n<p>#根据传递的数据库类型，显示对应的数据库名<br>create procedure show_database_type(in val int)<br>begin<br>    declare result varchar(20);<br>    CASE val<br>    WHEN 1 THEN set result = ‘mysql’;<br>    WHEN 2 THEN set result = ‘oracle’;<br>    WHEN 3 THEN set result = ‘sql server’;<br>    ELSE set result = ‘不认识的类型，滚啊。。。’;<br>    END CASE;<br>    select result;<br>end;</p>\n<p>call show_database_type(1);</p>\n<p>（3）if结构<br>功能：实现多重分类<br>语法：<br>if 条件1 then 语法1;<br>esleif 条件2 then 语法2;<br>…<br>[else 语句n;]<br>end if;</p>\n<p>应用场景：应用在begin end中</p>\n<p>实战操作：</p>\n<h1 id=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\"><a href=\"#创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80-显示C，否则显示D-1\" class=\"headerlink\" title=\"创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D\"></a>创建存储过程，根据传入的成绩，来显示登记，比如传入的成绩：90-100显示A，80-90显示B，60-80,显示C，否则显示D</h1><p>create function show_grade(grade int) returns char(1)<br>begin<br>    declare result char(1);<br>    if grade&gt;=90 and grade&lt;=100 THEN set result = ‘A’;<br>    elseif grade&gt;=80 THEN set result = ‘B’;<br>    elseif grade&gt;=60 THEN set result = ‘C’;<br>    else set result = ‘D’;<br>    end if;<br>    return result;<br>end;</p>\n<p>select show_grade(55);</p>\n<p>#批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>create procedure pro_while_insert2(in count int)<br>begin<br>    declare i int default 1;<br>    a:while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        if i&gt;=20 then leave a;<br>        end if;<br>        set i=i+1;<br>    end while a;<br>end;</p>\n<p>call pro_while_insert2(30);</p>\n<p>10.2.循环结构</p>\n<p>循环分类：<br>while、 loop、repeat</p>\n<p>循环控制：<br>iterate类似于continue，结束本次循环，继续下一次循环<br>leave类似于break，结束当前所在循环。</p>\n<p>三种循环语法：</p>\n<p>（1）while<br>[标签:] while 循环条件 do<br>循环体<br>end while [标签]</p>\n<p>（2）loop<br>[标签:] loop<br>循环体<br>end loop [标签]</p>\n<p>（3）repeat<br>[标签:] repeat<br>循环体<br>until 结束循环的条件<br>end repeat [标签]</p>\n<p>循环实战操作：</p>\n<p>#批量插入，根据次数插入到amdin表中多条数据<br>create procedure pro_while_insert(in count int)<br>begin<br>    declare i int default 1;<br>    while i&lt;=count do<br>        insert into admin(username, password) values(CONCAT(‘user’, i), CONCAT(‘psw’, i));<br>        set i=i+1;<br>    end while;<br>end;</p>\n<p>call pro_while_insert(10);</p>\n<p>while VS repeat VS loop<br>while：先判断后执行<br>repeat：先执行后判断<br>loop：没有条件的死循环</p>\n<h1 id=\"博客园所学\"><a href=\"#博客园所学\" class=\"headerlink\" title=\"博客园所学\"></a>博客园所学</h1><h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引分为单列索引(主键索引,唯一索引,普通索引)和组合索引.<br>单列索引:一个索引只包含一个列,一个表可以有多个单列索引.<br>组合索引:一个组合索引包含两个或两个以上的列。</p>\n<h3 id=\"索引的创建\"><a href=\"#索引的创建\" class=\"headerlink\" title=\"索引的创建\"></a>索引的创建</h3><p>1）单列索引</p>\n<p>普通索引：<br>第一种方式 :<br>CREATE INDEX 索引名ON 表名(<code>字段名</code>(length))</p>\n<p>第二种方式: <br>ALTER TABLE award ADD INDEX account_Index(<code>account</code>)</p>\n<p>唯一索引：<br>CREATE UNIQUE INDEX IndexName ON <code>TableName</code>(<code>字段名</code>(length));<br>ALTER TABLE TableName ADD UNIQUE (column_list)</p>\n<p>主键索引：不允许有空值</p>\n<p>2）组合索引：</p>\n<p>语法：<br>CREATE INDEX IndexName On <code>TableName</code>(<code>字段名</code>(length),<code>字段名</code>(length),…);</p>\n<h3 id=\"索引的删除\"><a href=\"#索引的删除\" class=\"headerlink\" title=\"索引的删除\"></a>索引的删除</h3><p>语法：<br>DORP INDEX IndexName ON <code>TableName</code></p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><p>触发器：监视某种情况，并触发某种操作。</p>\n<h3 id=\"创建语法\"><a href=\"#创建语法\" class=\"headerlink\" title=\"创建语法\"></a>创建语法</h3><p>触发器创建语法四要素：1.监视地点(table)<br>　　　　　　　　　　　2.监视事件(insert/update/delete)<br>　　　　　　　　　　 3.触发时间(after/before)<br>　　　　　　　　　　　4.触发事件(insert/update/delete)</p>\n<p>语法：<br>create trigger triggerName after/before insert/update/delete<br>on 表名 for each row #这句话是固定的<br> begin<br>     #需要执行的sql语句<br> end<br>注意1:after/before: 只能选一个 ,afte表示后置触发, before表示前置触发<br>注意2:insert/update/delete:只能选一个</p>\n<p>创建一个视图：<br>create trigger tag1 after insert on order_table<br>for each row<br>begin<br>    update goods set num=num-3 where id=1;<br>end;</p>\n<p>我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的gid或much的值。<br>对于insert而言，新插入的行用new来表示，行中的每一列的值用new.列名来表示。<br>所以现在我们可以这样来改我们的触发器:<br>create trigger tg1 after insert on order_table<br>for each row<br>BEGIN<br>    update goods set num = num-new.much where id=new.gid;<br>END;</p>\n<p>当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？<br> 对于delete而言：原本有一行,后来被删除，想引用被删除的这一行，用old来表示旧表中的值，old.列名可以引用原(旧)表中的值。<br>create trigger tg2 after delete on order_table<br>for each ROW<br>BEGIN<br>    update goods set num = num+old.much where id=old.gid;<br>END;</p>\n<h3 id=\"删除触发器\"><a href=\"#删除触发器\" class=\"headerlink\" title=\"删除触发器\"></a>删除触发器</h3><p>语法：drop trigger 触发器名称;<br>使用：drop trigger dg1;</p>\n"},{"title":"Redis-数据过期策略","date":"2021-06-20T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 前提补充\n\n我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。\n\n## 我往redis里写的数据怎么没了？\n\n我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？\n\n什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。\n\n那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。\n\n所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。\n\nset key value 过期时间（1小时）\nset进去的key，1小时之后就没了，就失效了\n\n## 我的数据明明都过期了，怎么还占用着内存啊？\n\n还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。\n\nredis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。\n\n如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？\n\n# 对key设置过期时间\n\nexpire key time(以秒为单位)--这是最常用的方式\n\nRedis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。\nExpires字典保存了所有键的过期时间，Expires也被称为过期字段。\n\n注意：  \n1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间  \n2、如果没有设置时间，那缓存就是永不过期  \n3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key\n\n# 过期策略\n\n## 三种过期策略机制\n\n1）定时删除（没人用）\n含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。\n\n优点：可以保证内存被尽快释放\n\n缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key\n\n2）惰性删除\n含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。\n\n优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）\n\n缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n3）定期删除\n含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。\n\n优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理\"定时删除\"的缺点\n\n缺点：\n在内存友好方面，不如\"定时删除\"\n在CPU时间友好方面，不如\"惰性删除\"\n\n**定期删除过期key可以处理\"惰性删除\"的缺点**\n\n## 三种过期策略机制总结\n\n看完上面三种策略后可以得出以下结论：  \n定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key\n惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。\n\n定期删除可以通过：  \n第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大）   \n第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略\n\n# Redis默认采用的过期策略\n\nRedis服务器默认过期内置策略是：惰性删除+定期删除\n\n惰性删除流程：  \n在进行get或setnx等操作时，先检查key是否过期；  \n若过期，删除key，然后执行相应操作；  \n若没过期，直接执行相应操作。  \n\n定期删除流程：  \n（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）   \n遍历每个数据库（就是redis.conf中配置的\"database\"数量，默认为16）   \n检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）   \n如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。  \n随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。  \n判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。\n\n提问：为什么不使用定时删除，而使用定期删除呢？\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n# 持久化机制对过期key的处理\n\n## RDB对过期key的处理\n\n过期key对RDB没有任何影响  \n从内存数据库持久化数据到RDB文件   \n持久化key之前，会检查是否过期，过期的key不进入RDB文件  \n从RDB文件恢复数据到内存数据库   \n数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）\n\n## AOF对过期key的处理\n\n过期key对AOF没有任何影响  \n从内存数据库持久化数据到AOF文件：   \n当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）  \n当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）  \nAOF重写 \n重写时，会先判断key是否过期，已过期的key不会重写到aof文件\n\n# 内存淘汰机制\n\n## 内存淘汰引入\n\n想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。\n\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。\n通过上述两种手段结合起来，保证过期的key一定会被干掉。\n\n很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。\n\n但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？\n如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？\n\n**答案是：走内存淘汰机制。**\n\n## 内存淘汰机制\n\n如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：\nredis 10个key，现在已经满了，redis需要删除掉5个key\n1个key，最近1分钟被查询了100次\n1个key，最近10分钟被查询了50次\n1个key，最近1个小时倍查询了1次\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了  \n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）  \n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊  \n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）  \n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key  \n6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除","source":"_posts/oyr/Redis/Redis-数据过期策略.md","raw":"---\ntitle: Redis-数据过期策略\ndate: 2021-06-21 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---\n\n# 前提补充\n\n我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。\n\n## 我往redis里写的数据怎么没了？\n\n我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？\n\n什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。\n\n那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。\n\n所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。\n\nset key value 过期时间（1小时）\nset进去的key，1小时之后就没了，就失效了\n\n## 我的数据明明都过期了，怎么还占用着内存啊？\n\n还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。\n\nredis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。\n\n如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？\n\n# 对key设置过期时间\n\nexpire key time(以秒为单位)--这是最常用的方式\n\nRedis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。\nExpires字典保存了所有键的过期时间，Expires也被称为过期字段。\n\n注意：  \n1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间  \n2、如果没有设置时间，那缓存就是永不过期  \n3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key\n\n# 过期策略\n\n## 三种过期策略机制\n\n1）定时删除（没人用）\n含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。\n\n优点：可以保证内存被尽快释放\n\n缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key\n\n2）惰性删除\n含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。\n\n优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）\n\n缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n3）定期删除\n含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。\n\n优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理\"定时删除\"的缺点\n\n缺点：\n在内存友好方面，不如\"定时删除\"\n在CPU时间友好方面，不如\"惰性删除\"\n\n**定期删除过期key可以处理\"惰性删除\"的缺点**\n\n## 三种过期策略机制总结\n\n看完上面三种策略后可以得出以下结论：  \n定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key\n惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。\n\n定期删除可以通过：  \n第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大）   \n第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略\n\n# Redis默认采用的过期策略\n\nRedis服务器默认过期内置策略是：惰性删除+定期删除\n\n惰性删除流程：  \n在进行get或setnx等操作时，先检查key是否过期；  \n若过期，删除key，然后执行相应操作；  \n若没过期，直接执行相应操作。  \n\n定期删除流程：  \n（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）   \n遍历每个数据库（就是redis.conf中配置的\"database\"数量，默认为16）   \n检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）   \n如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。  \n随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。  \n判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。\n\n提问：为什么不使用定时删除，而使用定期删除呢？\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n# 持久化机制对过期key的处理\n\n## RDB对过期key的处理\n\n过期key对RDB没有任何影响  \n从内存数据库持久化数据到RDB文件   \n持久化key之前，会检查是否过期，过期的key不进入RDB文件  \n从RDB文件恢复数据到内存数据库   \n数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）\n\n## AOF对过期key的处理\n\n过期key对AOF没有任何影响  \n从内存数据库持久化数据到AOF文件：   \n当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）  \n当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）  \nAOF重写 \n重写时，会先判断key是否过期，已过期的key不会重写到aof文件\n\n# 内存淘汰机制\n\n## 内存淘汰引入\n\n想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。\n\n所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。\n\n但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。\n通过上述两种手段结合起来，保证过期的key一定会被干掉。\n\n很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。\n\n但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？\n如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？\n\n**答案是：走内存淘汰机制。**\n\n## 内存淘汰机制\n\n如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：\nredis 10个key，现在已经满了，redis需要删除掉5个key\n1个key，最近1分钟被查询了100次\n1个key，最近10分钟被查询了50次\n1个key，最近1个小时倍查询了1次\n\n1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了  \n2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）  \n3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊  \n4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）  \n5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key  \n6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除","slug":"oyr/Redis/Redis-数据过期策略","published":1,"updated":"2021-09-01T02:49:57.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836d001ghct76l7r7i7f","content":"<h1 id=\"前提补充\"><a href=\"#前提补充\" class=\"headerlink\" title=\"前提补充\"></a>前提补充</h1><p>我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。</p>\n<h2 id=\"我往redis里写的数据怎么没了？\"><a href=\"#我往redis里写的数据怎么没了？\" class=\"headerlink\" title=\"我往redis里写的数据怎么没了？\"></a>我往redis里写的数据怎么没了？</h2><p>我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？</p>\n<p>什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。</p>\n<p>那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。</p>\n<p>所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。</p>\n<p>set key value 过期时间（1小时）<br>set进去的key，1小时之后就没了，就失效了</p>\n<h2 id=\"我的数据明明都过期了，怎么还占用着内存啊？\"><a href=\"#我的数据明明都过期了，怎么还占用着内存啊？\" class=\"headerlink\" title=\"我的数据明明都过期了，怎么还占用着内存啊？\"></a>我的数据明明都过期了，怎么还占用着内存啊？</h2><p>还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。</p>\n<p>redis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。</p>\n<p>如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？</p>\n<h1 id=\"对key设置过期时间\"><a href=\"#对key设置过期时间\" class=\"headerlink\" title=\"对key设置过期时间\"></a>对key设置过期时间</h1><p>expire key time(以秒为单位)–这是最常用的方式</p>\n<p>Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。<br>Expires字典保存了所有键的过期时间，Expires也被称为过期字段。</p>\n<p>注意：<br>1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间<br>2、如果没有设置时间，那缓存就是永不过期<br>3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key</p>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><h2 id=\"三种过期策略机制\"><a href=\"#三种过期策略机制\" class=\"headerlink\" title=\"三种过期策略机制\"></a>三种过期策略机制</h2><p>1）定时删除（没人用）<br>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</p>\n<p>优点：可以保证内存被尽快释放</p>\n<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</p>\n<p>2）惰性删除<br>含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。</p>\n<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>\n<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<p>3）定期删除<br>含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p>\n<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</p>\n<p>缺点：<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p>\n<p><strong>定期删除过期key可以处理”惰性删除”的缺点</strong></p>\n<h2 id=\"三种过期策略机制总结\"><a href=\"#三种过期策略机制总结\" class=\"headerlink\" title=\"三种过期策略机制总结\"></a>三种过期策略机制总结</h2><p>看完上面三种策略后可以得出以下结论：<br>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key<br>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。</p>\n<p>定期删除可以通过：<br>第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） <br>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</p>\n<h1 id=\"Redis默认采用的过期策略\"><a href=\"#Redis默认采用的过期策略\" class=\"headerlink\" title=\"Redis默认采用的过期策略\"></a>Redis默认采用的过期策略</h1><p>Redis服务器默认过期内置策略是：惰性删除+定期删除</p>\n<p>惰性删除流程：<br>在进行get或setnx等操作时，先检查key是否过期；<br>若过期，删除key，然后执行相应操作；<br>若没过期，直接执行相应操作。  </p>\n<p>定期删除流程：<br>（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<br>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<br>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。<br>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。<br>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</p>\n<p>提问：为什么不使用定时删除，而使用定期删除呢？<br>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<h1 id=\"持久化机制对过期key的处理\"><a href=\"#持久化机制对过期key的处理\" class=\"headerlink\" title=\"持久化机制对过期key的处理\"></a>持久化机制对过期key的处理</h1><h2 id=\"RDB对过期key的处理\"><a href=\"#RDB对过期key的处理\" class=\"headerlink\" title=\"RDB对过期key的处理\"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响<br>从内存数据库持久化数据到RDB文件<br>持久化key之前，会检查是否过期，过期的key不进入RDB文件<br>从RDB文件恢复数据到内存数据库<br>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</p>\n<h2 id=\"AOF对过期key的处理\"><a href=\"#AOF对过期key的处理\" class=\"headerlink\" title=\"AOF对过期key的处理\"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响<br>从内存数据库持久化数据到AOF文件：<br>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）<br>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）<br>AOF重写<br>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</p>\n<h1 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h1><h2 id=\"内存淘汰引入\"><a href=\"#内存淘汰引入\" class=\"headerlink\" title=\"内存淘汰引入\"></a>内存淘汰引入</h2><p>想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。</p>\n<p>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<p>但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。<br>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。<br>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p>\n<p>很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。</p>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？<br>如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p>\n<p><strong>答案是：走内存淘汰机制。</strong></p>\n<h2 id=\"内存淘汰机制-1\"><a href=\"#内存淘汰机制-1\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h2><p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：<br>redis 10个key，现在已经满了，redis需要删除掉5个key<br>1个key，最近1分钟被查询了100次<br>1个key，最近10分钟被查询了50次<br>1个key，最近1个小时倍查询了1次</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了<br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊<br>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）<br>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前提补充\"><a href=\"#前提补充\" class=\"headerlink\" title=\"前提补充\"></a>前提补充</h1><p>我们讲过期策略之前，我们先来看几个问题，后面学习的时候带着这几个问题去学习。</p>\n<h2 id=\"我往redis里写的数据怎么没了？\"><a href=\"#我往redis里写的数据怎么没了？\" class=\"headerlink\" title=\"我往redis里写的数据怎么没了？\"></a>我往redis里写的数据怎么没了？</h2><p>我相信大家在使用redis的时候，都会遇到redis经常丢掉一些数据，写进去了，过一会儿可能就没了。那么这个问题我们需要反思一下：redis是缓存，你给当存储了是吧？</p>\n<p>什么是缓存？用内存当缓存。内存是无限的吗，内存是很宝贵而且是有限的，磁盘是廉价而且是大量的。可能一台机器就几十个G的内存，但是可以有几个T的硬盘空间。redis主要是基于内存来进行高性能、高并发的读写操作的。</p>\n<p>那既然内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了。</p>\n<p>所以说，这是缓存的一个最基本的概念，数据是会过期的，要么是你自己设置个过期时间，要么是redis自己给干掉了。</p>\n<p>set key value 过期时间（1小时）<br>set进去的key，1小时之后就没了，就失效了</p>\n<h2 id=\"我的数据明明都过期了，怎么还占用着内存啊？\"><a href=\"#我的数据明明都过期了，怎么还占用着内存啊？\" class=\"headerlink\" title=\"我的数据明明都过期了，怎么还占用着内存啊？\"></a>我的数据明明都过期了，怎么还占用着内存啊？</h2><p>还有一种就是如果你设置好了一个过期时间，你知道redis是怎么给你弄成过期的吗？什么时候删除掉？如果你不知道，那么你就需要思考，为啥好多数据明明应该过期了，结果发现redis内存占用还是很高？那是因为你不知道redis是怎么删除那些过期key的。</p>\n<p>redis内存一共是10g，你现在往里面写了5g的数据，结果这些数据明明你都设置了过期时间，要求这些数据1小时之后都会过期，结果1小时之后，你回来一看，redis机器，怎么内存占用还是50%呢？5g数据过期了，我从redis里查，是查不到了，结果过期的数据还占用着redis的内存。</p>\n<p>如果你连这个问题都不知道，上来就懵了，回答不出来，那线上你写代码的时候，想当然的认为写进redis的数据就一定会存在，后面导致系统各种漏洞和bug，谁来负责？</p>\n<h1 id=\"对key设置过期时间\"><a href=\"#对key设置过期时间\" class=\"headerlink\" title=\"对key设置过期时间\"></a>对key设置过期时间</h1><p>expire key time(以秒为单位)–这是最常用的方式</p>\n<p>Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。<br>Expires字典保存了所有键的过期时间，Expires也被称为过期字段。</p>\n<p>注意：<br>1、除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间<br>2、如果没有设置时间，那缓存就是永不过期<br>3、如果设置了过期时间，之后又想让缓存永不过期，使用persist key</p>\n<h1 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h1><h2 id=\"三种过期策略机制\"><a href=\"#三种过期策略机制\" class=\"headerlink\" title=\"三种过期策略机制\"></a>三种过期策略机制</h2><p>1）定时删除（没人用）<br>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</p>\n<p>优点：可以保证内存被尽快释放</p>\n<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</p>\n<p>2）惰性删除<br>含义：key过期的时候不删除，每次从redis获取key的时候去检查是否过期，若过期，则删除，返回null。</p>\n<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>\n<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<p>3）定期删除<br>含义：所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p>\n<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</p>\n<p>缺点：<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p>\n<p><strong>定期删除过期key可以处理”惰性删除”的缺点</strong></p>\n<h2 id=\"三种过期策略机制总结\"><a href=\"#三种过期策略机制总结\" class=\"headerlink\" title=\"三种过期策略机制总结\"></a>三种过期策略机制总结</h2><p>看完上面三种策略后可以得出以下结论：<br>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key<br>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除。</p>\n<p>定期删除可以通过：<br>第一、配置redis.conf的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） <br>第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</p>\n<h1 id=\"Redis默认采用的过期策略\"><a href=\"#Redis默认采用的过期策略\" class=\"headerlink\" title=\"Redis默认采用的过期策略\"></a>Redis默认采用的过期策略</h1><p>Redis服务器默认过期内置策略是：惰性删除+定期删除</p>\n<p>惰性删除流程：<br>在进行get或setnx等操作时，先检查key是否过期；<br>若过期，删除key，然后执行相应操作；<br>若没过期，直接执行相应操作。  </p>\n<p>定期删除流程：<br>（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）<br>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）<br>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历。<br>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key。<br>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</p>\n<p>提问：为什么不使用定时删除，而使用定期删除呢？<br>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<h1 id=\"持久化机制对过期key的处理\"><a href=\"#持久化机制对过期key的处理\" class=\"headerlink\" title=\"持久化机制对过期key的处理\"></a>持久化机制对过期key的处理</h1><h2 id=\"RDB对过期key的处理\"><a href=\"#RDB对过期key的处理\" class=\"headerlink\" title=\"RDB对过期key的处理\"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响<br>从内存数据库持久化数据到RDB文件<br>持久化key之前，会检查是否过期，过期的key不进入RDB文件<br>从RDB文件恢复数据到内存数据库<br>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</p>\n<h2 id=\"AOF对过期key的处理\"><a href=\"#AOF对过期key的处理\" class=\"headerlink\" title=\"AOF对过期key的处理\"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响<br>从内存数据库持久化数据到AOF文件：<br>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）<br>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）<br>AOF重写<br>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</p>\n<h1 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h1><h2 id=\"内存淘汰引入\"><a href=\"#内存淘汰引入\" class=\"headerlink\" title=\"内存淘汰引入\"></a>内存淘汰引入</h2><p>想一想，redis服务器默认过期内置策略是：惰性删除+定期删除。</p>\n<p>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p>\n<p>但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。<br>并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。<br>通过上述两种手段结合起来，保证过期的key一定会被干掉。</p>\n<p>很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。</p>\n<p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？<br>如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？</p>\n<p><strong>答案是：走内存淘汰机制。</strong></p>\n<h2 id=\"内存淘汰机制-1\"><a href=\"#内存淘汰机制-1\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h2><p>如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：<br>redis 10个key，现在已经满了，redis需要删除掉5个key<br>1个key，最近1分钟被查询了100次<br>1个key，最近10分钟被查询了50次<br>1个key，最近1个小时倍查询了1次</p>\n<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了<br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊<br>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）<br>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p>\n"},{"title":"Redis-基础","date":"2020-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# 入门概述\n\n## Redis是什么？\n\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 \n\nredis 的官网：redis.io\n\n## Redis 与其他 key/value 缓存产品有以下三个特点\n\n1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用  \n2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储  \n3）Redis支持数据的备份，即master-slave模式的数据备份\n\n## 应用场景（redis能干些什么）\n\n1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务  \n2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面  \n3）模拟类似于HttpSession这种需要设定过期时间的功能  \n4）发布、订阅消息系统（消息中间件）  \n5）定时器、计数器  \n6）可以实现session共享  \n7）可以实现分布式锁\n\n# Redis的安装\n\n提示：  \n由于企业里面做Redis开发，99%都是Linux版的运用和安装。\n几乎不会涉及到Windows版，windows安装只是为了学习而已了。\n\n# Redis启动后的杂项知识（重要）\n\n1）单进程，redis速度很快。  \nredis读写性能测试，redis官网测试读写能到10万左右。\n\n2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。\n\n3）select命令切换数据库。\n\n4）dbsize查看当前数据库的key的数量。\n\n5）flushdb：清空当前库key。\n\n6）flushall：清空全部库。\n\n7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。\n\n8）redis索引都是从零开始。\n\n9）redis默认端口是6379。\n\n# Redis五大数据类型\n\n常用命令：   \nping：ping下redis    \ndbsize：查看当前数据库的key的数量  \nselect 1：切换到下标为1的数据库中  \nflushdb：清空当前库key  \nflushall：清空全部库key\n\n## Redis键的操作（常用）\n\n查看当前数据库的所有key:  \nKeys *\n\n判断当前key是否存在：  \nexists name\n\n将当前key移动到2号库中：  \nMove name 2\n\n设置key在6秒后过期：  \nexpire name 6\n\n查看当前key还有多久过期  \nttl name \n\n查看当前key是什么结构的类型  \ntype name\n\n## String 类型（常用）\n\n### 简介\n\nString是redis最基本的类型，可以理解成一个key对应一个value。  \nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。  \nredis一个字符串value最多可以是512M。\n\n### 操作\n\n```\nset name oyr：\t\t\t给键name设置值为oyr\n\nget name：\t\t\t\t获取键name的值\n\ndel name：\t\t\t\t删除建为name值\n\nappend name 123：\t\t在name对应的值后面追加123\n\nstrlen name：\t\t\t得到当前name对应的值的长度\n\nincr age：\t\t\t\tage+1，一定要是数字才能操作\n\nincrby age 10：\t\t\tage+10\n\ndecr age：\t\t\t\tage-1，一定要是数字才能操作\n\ndecrby age 10： \t\tage-10\n\nsetex name 10 oyr：\t\t\n（set with expire）\n设置key为name，过期时间为10秒，值为oyr\n\nsexnx name ooo：\n（sex if not exist）\n设置键位name，值为ooo，只有不存在的时候才会设置进去\n\nmset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值\n\nmget k1 k2 k3：\t\t\t\t\t一次获取多个值\n\nmsetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。\n```\n\n## Hash 类型（常用）\n\n### 简介\n\nRedis hash 是一个键值对集合。  \nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。  \n类似Java里面的Map<String,Object>，K-V模式不变，但V是一个键值对。\n\n### 操作\n\n```\n（1）hset\nhset user name oyr\t\t\t给键user的name属性设置值\n\n（2）hget\nhget user name\t\t\t\t获取键user的name值\n\n（3）hmset\nhmset user age 18 sex nan  \t\t同时设置多个值\n\n（4）hmget\nhmget user name age sex\t\t\t同时获取多个属性值\n\n（5）hgetall\nhgetall user \t\t\t\t\t获取键user中的所有键和值\n\n（6）hdel\nhdel user name\t\t\t\t\t删除键user中的name属性\n\n（7）hlen\nhlen user\t\t\t\t\t\t获取键user下有几个属性\n\n（8）hexists\nhexists user nane\t\t\t\t判断键user下是否有name属性\n\n（9）hkeys\nhkys user\t\t\t\t\t\t获取键user下的所有属性\n\n（10）hvals\nhvals user \t\t\t\t\t \t获取键user下的所有值\n\n（11）hsetnx\nhsetnx user name \"oyr\"\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。\n\n（12）hincrby \nhincrby  user age 10\t\t\t给键user里的age 属性添加10\n```\n\n## Lists 类型（双向链表）\n\n### 简介\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。  \n它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出\n\n### 操作\n\n```\nlpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加\n\nlrange list1 0 -1\t\t\t获取list1链表所有数据\n\nrpush list2 1 2 3\t\t\t给链表list2尾部插入元素\n\nlpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）\n\nrpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）\n\nlindex list1 3\t\t\t\t获取链表的3索引位置的值\n\n\tlist1\t\t\t\t\t获取list1 链表的长度\n\nlset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s\n\nlrem list3 2 d\t\t\t\t删除链表2个d元素\n\nltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃\n\nlinsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素\n\nrpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表\n```\n\n### 性能总结\n\n它是一个字符串链表，left、right都可以插入添加；  \n如果键不存在，创建新的链表；  \n如果键已存在，新增内容；  \n如果值全移除，对应的键也就消失了。  \n链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n## Set 类型（不能重复）\n\n### 简介\n\nRedis的Set是string类型的无序集合。它是通过HashTable实现实现的，\n\n### 操作\n\n```\nsadd set1 a b c d \t\t\t\t给set1集合添加元素\n\nsmembers set1\t\t\t\t\t查看set1集合的所有元素\n\nsismember set1 a\t\t\t\t判断set1集合中是否有a元素\nscard set1\t\t\t\t\t\t获取集合set1 的元素个数\n\nsrem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）\n\nsrandmember set2 3\t\t\t\t在集合set2中随机出3个元素\n\ndiff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素\n\nsinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素\n\nsunion set3 set4\t\t\t\t并集\n```\n\n## Sortedsets 类型\n\n### 简介\n\nzset 和 set 一样也是string类型元素的集合,且不允许重复的成员。  \n不同的是每个元素都会关联一个double类型的分数。  \nredis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n\n### 操作\n\n```\nzadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。\n\nzrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数\n\nzrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素\n\nzcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。\n\nzcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间\n\nzcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值\n\nzrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间\n\nzrem zset1 a b\t\t\t集合删除元素a b\n```\n\n# Redis配置文件\n\n## Redis配置文件在哪?\n\nredis.conf是redis的配置文件，它在那？\n在redis安装包解压出来的目录下。\n\n## 常用配置（redis.conf）\n\n```\n参数说明\nredis.conf 配置项说明如下：\n1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n  daemonize no\n2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n  pidfile /var/run/redis.pid\n3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n  port 6379\n4. 绑定的主机地址\n  bind 127.0.0.1\n5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n  timeout 300\n6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n  loglevel verbose\n7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n  logfile stdout\n8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id\n  databases 16\n9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n  save <seconds> <changes>\n  Redis默认配置文件中提供了三个条件：\n  save 900 1\n  save 300 10\n  save 60 10000\n  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n \n10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n  rdbcompression yes\n11. 指定本地数据库文件名，默认值为dump.rdb\n  dbfilename dump.rdb\n12. 指定本地数据库存放目录\n  dir ./\n13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n  slaveof <masterip> <masterport>\n14. 当master服务设置了密码保护时，slav服务连接master的密码\n  masterauth <master-password>\n15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n  requirepass foobared\n16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n  maxclients 128\n17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n  maxmemory <bytes>\n18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n  appendonly no\n19. 指定更新日志文件名，默认为appendonly.aof\n   appendfilename appendonly.aof\n20. 指定更新日志条件，共有3个可选值： \n  no：表示等操作系统进行数据缓存同步到磁盘（快） \n  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） \n  everysec：表示每秒同步一次（折衷，默认值）\n  appendfsync everysec\n \n21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n   vm-enabled no\n22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n   vm-swap-file /tmp/redis.swap\n23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\n   vm-max-memory 0\n24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n   vm-page-size 32\n25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\n   vm-pages 134217728\n26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n   vm-max-threads 4\n27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n  glueoutputbuf yes\n28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n  hash-max-zipmap-entries 64\n  hash-max-zipmap-value 512\n29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n  activerehashing yes\n30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n  include /path/to/local.conf\n```\n\n# Redis的持久化\n\nRedis的持久化一共有两种：  \nrdb持久化  \naof持久化（推荐使用）\n\n## RDB（Redis Database）\n\n### 什么是rdb持久化\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘.   \n也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\nRedis官方解释：  \nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，\n待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。  \n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方\n式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n（因为可能出现redis宕机的情况）\n\n### Fork的解释\n\nfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n## AOF（Append Only File）\n\n# Redis的事物\n\n## 事物介绍\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：  \n1）批量操作在发送 EXEC 命令前被放入队列缓存。  \n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）  \n2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n**注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。**\n\nRedis的一个事务从开始到执行会经历以下三个阶段：\n1）开始事务。\n2）命令入队。\n3）执行事务。\n\n## 事物常用命令\n\n```\nmulti\t\t\t\t\t\t标记一个事物块的开始\n\nexec：\t\t\t\t\t\t执行所有事物块内的命令\n\ndiscard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令\n\nwatch key [key ...]：\t\t\t\n监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\nunwatch\t\t\t\t\t\t取消watch命令对所有key的监控\n```\n\n// TODO","source":"_posts/oyr/Redis/Redis-基础.md","raw":"---\ntitle: Redis-基础\ndate: 2020-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---\n\n# 入门概述\n\n## Redis是什么？\n\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 \n\nredis 的官网：redis.io\n\n## Redis 与其他 key/value 缓存产品有以下三个特点\n\n1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用  \n2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储  \n3）Redis支持数据的备份，即master-slave模式的数据备份\n\n## 应用场景（redis能干些什么）\n\n1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务  \n2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面  \n3）模拟类似于HttpSession这种需要设定过期时间的功能  \n4）发布、订阅消息系统（消息中间件）  \n5）定时器、计数器  \n6）可以实现session共享  \n7）可以实现分布式锁\n\n# Redis的安装\n\n提示：  \n由于企业里面做Redis开发，99%都是Linux版的运用和安装。\n几乎不会涉及到Windows版，windows安装只是为了学习而已了。\n\n# Redis启动后的杂项知识（重要）\n\n1）单进程，redis速度很快。  \nredis读写性能测试，redis官网测试读写能到10万左右。\n\n2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。\n\n3）select命令切换数据库。\n\n4）dbsize查看当前数据库的key的数量。\n\n5）flushdb：清空当前库key。\n\n6）flushall：清空全部库。\n\n7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。\n\n8）redis索引都是从零开始。\n\n9）redis默认端口是6379。\n\n# Redis五大数据类型\n\n常用命令：   \nping：ping下redis    \ndbsize：查看当前数据库的key的数量  \nselect 1：切换到下标为1的数据库中  \nflushdb：清空当前库key  \nflushall：清空全部库key\n\n## Redis键的操作（常用）\n\n查看当前数据库的所有key:  \nKeys *\n\n判断当前key是否存在：  \nexists name\n\n将当前key移动到2号库中：  \nMove name 2\n\n设置key在6秒后过期：  \nexpire name 6\n\n查看当前key还有多久过期  \nttl name \n\n查看当前key是什么结构的类型  \ntype name\n\n## String 类型（常用）\n\n### 简介\n\nString是redis最基本的类型，可以理解成一个key对应一个value。  \nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。  \nredis一个字符串value最多可以是512M。\n\n### 操作\n\n```\nset name oyr：\t\t\t给键name设置值为oyr\n\nget name：\t\t\t\t获取键name的值\n\ndel name：\t\t\t\t删除建为name值\n\nappend name 123：\t\t在name对应的值后面追加123\n\nstrlen name：\t\t\t得到当前name对应的值的长度\n\nincr age：\t\t\t\tage+1，一定要是数字才能操作\n\nincrby age 10：\t\t\tage+10\n\ndecr age：\t\t\t\tage-1，一定要是数字才能操作\n\ndecrby age 10： \t\tage-10\n\nsetex name 10 oyr：\t\t\n（set with expire）\n设置key为name，过期时间为10秒，值为oyr\n\nsexnx name ooo：\n（sex if not exist）\n设置键位name，值为ooo，只有不存在的时候才会设置进去\n\nmset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值\n\nmget k1 k2 k3：\t\t\t\t\t一次获取多个值\n\nmsetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。\n```\n\n## Hash 类型（常用）\n\n### 简介\n\nRedis hash 是一个键值对集合。  \nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。  \n类似Java里面的Map<String,Object>，K-V模式不变，但V是一个键值对。\n\n### 操作\n\n```\n（1）hset\nhset user name oyr\t\t\t给键user的name属性设置值\n\n（2）hget\nhget user name\t\t\t\t获取键user的name值\n\n（3）hmset\nhmset user age 18 sex nan  \t\t同时设置多个值\n\n（4）hmget\nhmget user name age sex\t\t\t同时获取多个属性值\n\n（5）hgetall\nhgetall user \t\t\t\t\t获取键user中的所有键和值\n\n（6）hdel\nhdel user name\t\t\t\t\t删除键user中的name属性\n\n（7）hlen\nhlen user\t\t\t\t\t\t获取键user下有几个属性\n\n（8）hexists\nhexists user nane\t\t\t\t判断键user下是否有name属性\n\n（9）hkeys\nhkys user\t\t\t\t\t\t获取键user下的所有属性\n\n（10）hvals\nhvals user \t\t\t\t\t \t获取键user下的所有值\n\n（11）hsetnx\nhsetnx user name \"oyr\"\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。\n\n（12）hincrby \nhincrby  user age 10\t\t\t给键user里的age 属性添加10\n```\n\n## Lists 类型（双向链表）\n\n### 简介\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。  \n它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出\n\n### 操作\n\n```\nlpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加\n\nlrange list1 0 -1\t\t\t获取list1链表所有数据\n\nrpush list2 1 2 3\t\t\t给链表list2尾部插入元素\n\nlpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）\n\nrpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）\n\nlindex list1 3\t\t\t\t获取链表的3索引位置的值\n\n\tlist1\t\t\t\t\t获取list1 链表的长度\n\nlset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s\n\nlrem list3 2 d\t\t\t\t删除链表2个d元素\n\nltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃\n\nlinsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素\n\nrpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表\n```\n\n### 性能总结\n\n它是一个字符串链表，left、right都可以插入添加；  \n如果键不存在，创建新的链表；  \n如果键已存在，新增内容；  \n如果值全移除，对应的键也就消失了。  \n链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。\n\n## Set 类型（不能重复）\n\n### 简介\n\nRedis的Set是string类型的无序集合。它是通过HashTable实现实现的，\n\n### 操作\n\n```\nsadd set1 a b c d \t\t\t\t给set1集合添加元素\n\nsmembers set1\t\t\t\t\t查看set1集合的所有元素\n\nsismember set1 a\t\t\t\t判断set1集合中是否有a元素\nscard set1\t\t\t\t\t\t获取集合set1 的元素个数\n\nsrem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）\n\nsrandmember set2 3\t\t\t\t在集合set2中随机出3个元素\n\ndiff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素\n\nsinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素\n\nsunion set3 set4\t\t\t\t并集\n```\n\n## Sortedsets 类型\n\n### 简介\n\nzset 和 set 一样也是string类型元素的集合,且不允许重复的成员。  \n不同的是每个元素都会关联一个double类型的分数。  \nredis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\n\n### 操作\n\n```\nzadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。\n\nzrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数\n\nzrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素\n\nzcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。\n\nzcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间\n\nzcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值\n\nzrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间\n\nzrem zset1 a b\t\t\t集合删除元素a b\n```\n\n# Redis配置文件\n\n## Redis配置文件在哪?\n\nredis.conf是redis的配置文件，它在那？\n在redis安装包解压出来的目录下。\n\n## 常用配置（redis.conf）\n\n```\n参数说明\nredis.conf 配置项说明如下：\n1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\n  daemonize no\n2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n  pidfile /var/run/redis.pid\n3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字\n  port 6379\n4. 绑定的主机地址\n  bind 127.0.0.1\n5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n  timeout 300\n6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n  loglevel verbose\n7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null\n  logfile stdout\n8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id\n  databases 16\n9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n  save <seconds> <changes>\n  Redis默认配置文件中提供了三个条件：\n  save 900 1\n  save 300 10\n  save 60 10000\n  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n \n10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n  rdbcompression yes\n11. 指定本地数据库文件名，默认值为dump.rdb\n  dbfilename dump.rdb\n12. 指定本地数据库存放目录\n  dir ./\n13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n  slaveof <masterip> <masterport>\n14. 当master服务设置了密码保护时，slav服务连接master的密码\n  masterauth <master-password>\n15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n  requirepass foobared\n16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息\n  maxclients 128\n17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n  maxmemory <bytes>\n18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\n  appendonly no\n19. 指定更新日志文件名，默认为appendonly.aof\n   appendfilename appendonly.aof\n20. 指定更新日志条件，共有3个可选值： \n  no：表示等操作系统进行数据缓存同步到磁盘（快） \n  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） \n  everysec：表示每秒同步一次（折衷，默认值）\n  appendfsync everysec\n \n21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\n   vm-enabled no\n22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\n   vm-swap-file /tmp/redis.swap\n23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\n   vm-max-memory 0\n24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值\n   vm-page-size 32\n25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\n   vm-pages 134217728\n26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n   vm-max-threads 4\n27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n  glueoutputbuf yes\n28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n  hash-max-zipmap-entries 64\n  hash-max-zipmap-value 512\n29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\n  activerehashing yes\n30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n  include /path/to/local.conf\n```\n\n# Redis的持久化\n\nRedis的持久化一共有两种：  \nrdb持久化  \naof持久化（推荐使用）\n\n## RDB（Redis Database）\n\n### 什么是rdb持久化\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘.   \n也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。\n\nRedis官方解释：  \nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，\n待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。  \n整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。\n如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方\n式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n（因为可能出现redis宕机的情况）\n\n### Fork的解释\n\nfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n\n\n## AOF（Append Only File）\n\n# Redis的事物\n\n## 事物介绍\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：  \n1）批量操作在发送 EXEC 命令前被放入队列缓存。  \n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）  \n2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n**注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。**\n\nRedis的一个事务从开始到执行会经历以下三个阶段：\n1）开始事务。\n2）命令入队。\n3）执行事务。\n\n## 事物常用命令\n\n```\nmulti\t\t\t\t\t\t标记一个事物块的开始\n\nexec：\t\t\t\t\t\t执行所有事物块内的命令\n\ndiscard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令\n\nwatch key [key ...]：\t\t\t\n监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\nunwatch\t\t\t\t\t\t取消watch命令对所有key的监控\n```\n\n// TODO","slug":"oyr/Redis/Redis-基础","published":1,"updated":"2021-07-13T09:50:40.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836e001khct7hhh19u2r","content":"<h1 id=\"入门概述\"><a href=\"#入门概述\" class=\"headerlink\" title=\"入门概述\"></a>入门概述</h1><h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><p>是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 </p>\n<p>redis 的官网：redis.io</p>\n<h2 id=\"Redis-与其他-key-value-缓存产品有以下三个特点\"><a href=\"#Redis-与其他-key-value-缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis 与其他 key/value 缓存产品有以下三个特点\"></a>Redis 与其他 key/value 缓存产品有以下三个特点</h2><p>1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用<br>2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>3）Redis支持数据的备份，即master-slave模式的数据备份</p>\n<h2 id=\"应用场景（redis能干些什么）\"><a href=\"#应用场景（redis能干些什么）\" class=\"headerlink\" title=\"应用场景（redis能干些什么）\"></a>应用场景（redis能干些什么）</h2><p>1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<br>2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面<br>3）模拟类似于HttpSession这种需要设定过期时间的功能<br>4）发布、订阅消息系统（消息中间件）<br>5）定时器、计数器<br>6）可以实现session共享<br>7）可以实现分布式锁</p>\n<h1 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h1><p>提示：<br>由于企业里面做Redis开发，99%都是Linux版的运用和安装。<br>几乎不会涉及到Windows版，windows安装只是为了学习而已了。</p>\n<h1 id=\"Redis启动后的杂项知识（重要）\"><a href=\"#Redis启动后的杂项知识（重要）\" class=\"headerlink\" title=\"Redis启动后的杂项知识（重要）\"></a>Redis启动后的杂项知识（重要）</h1><p>1）单进程，redis速度很快。<br>redis读写性能测试，redis官网测试读写能到10万左右。</p>\n<p>2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>\n<p>3）select命令切换数据库。</p>\n<p>4）dbsize查看当前数据库的key的数量。</p>\n<p>5）flushdb：清空当前库key。</p>\n<p>6）flushall：清空全部库。</p>\n<p>7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。</p>\n<p>8）redis索引都是从零开始。</p>\n<p>9）redis默认端口是6379。</p>\n<h1 id=\"Redis五大数据类型\"><a href=\"#Redis五大数据类型\" class=\"headerlink\" title=\"Redis五大数据类型\"></a>Redis五大数据类型</h1><p>常用命令：<br>ping：ping下redis<br>dbsize：查看当前数据库的key的数量<br>select 1：切换到下标为1的数据库中<br>flushdb：清空当前库key<br>flushall：清空全部库key</p>\n<h2 id=\"Redis键的操作（常用）\"><a href=\"#Redis键的操作（常用）\" class=\"headerlink\" title=\"Redis键的操作（常用）\"></a>Redis键的操作（常用）</h2><p>查看当前数据库的所有key:<br>Keys *</p>\n<p>判断当前key是否存在：<br>exists name</p>\n<p>将当前key移动到2号库中：<br>Move name 2</p>\n<p>设置key在6秒后过期：<br>expire name 6</p>\n<p>查看当前key还有多久过期<br>ttl name </p>\n<p>查看当前key是什么结构的类型<br>type name</p>\n<h2 id=\"String-类型（常用）\"><a href=\"#String-类型（常用）\" class=\"headerlink\" title=\"String 类型（常用）\"></a>String 类型（常用）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>String是redis最基本的类型，可以理解成一个key对应一个value。<br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。<br>redis一个字符串value最多可以是512M。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set name oyr：\t\t\t给键name设置值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">get name：\t\t\t\t获取键name的值</span><br><span class=\"line\"></span><br><span class=\"line\">del name：\t\t\t\t删除建为name值</span><br><span class=\"line\"></span><br><span class=\"line\">append name 123：\t\t在name对应的值后面追加123</span><br><span class=\"line\"></span><br><span class=\"line\">strlen name：\t\t\t得到当前name对应的值的长度</span><br><span class=\"line\"></span><br><span class=\"line\">incr age：\t\t\t\tage+1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">incrby age 10：\t\t\tage+10</span><br><span class=\"line\"></span><br><span class=\"line\">decr age：\t\t\t\tage-1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">decrby age 10： \t\tage-10</span><br><span class=\"line\"></span><br><span class=\"line\">setex name 10 oyr：\t\t</span><br><span class=\"line\">（set with expire）</span><br><span class=\"line\">设置key为name，过期时间为10秒，值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">sexnx name ooo：</span><br><span class=\"line\">（sex if not exist）</span><br><span class=\"line\">设置键位name，值为ooo，只有不存在的时候才会设置进去</span><br><span class=\"line\"></span><br><span class=\"line\">mset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">mget k1 k2 k3：\t\t\t\t\t一次获取多个值</span><br><span class=\"line\"></span><br><span class=\"line\">msetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hash-类型（常用）\"><a href=\"#Hash-类型（常用）\" class=\"headerlink\" title=\"Hash 类型（常用）\"></a>Hash 类型（常用）</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;，K-V模式不变，但V是一个键值对。</p>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）hset</span><br><span class=\"line\">hset user name oyr\t\t\t给键user的name属性设置值</span><br><span class=\"line\"></span><br><span class=\"line\">（2）hget</span><br><span class=\"line\">hget user name\t\t\t\t获取键user的name值</span><br><span class=\"line\"></span><br><span class=\"line\">（3）hmset</span><br><span class=\"line\">hmset user age 18 sex nan  \t\t同时设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">（4）hmget</span><br><span class=\"line\">hmget user name age sex\t\t\t同时获取多个属性值</span><br><span class=\"line\"></span><br><span class=\"line\">（5）hgetall</span><br><span class=\"line\">hgetall user \t\t\t\t\t获取键user中的所有键和值</span><br><span class=\"line\"></span><br><span class=\"line\">（6）hdel</span><br><span class=\"line\">hdel user name\t\t\t\t\t删除键user中的name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（7）hlen</span><br><span class=\"line\">hlen user\t\t\t\t\t\t获取键user下有几个属性</span><br><span class=\"line\"></span><br><span class=\"line\">（8）hexists</span><br><span class=\"line\">hexists user nane\t\t\t\t判断键user下是否有name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（9）hkeys</span><br><span class=\"line\">hkys user\t\t\t\t\t\t获取键user下的所有属性</span><br><span class=\"line\"></span><br><span class=\"line\">（10）hvals</span><br><span class=\"line\">hvals user \t\t\t\t\t \t获取键user下的所有值</span><br><span class=\"line\"></span><br><span class=\"line\">（11）hsetnx</span><br><span class=\"line\">hsetnx user name &quot;oyr&quot;\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">（12）hincrby </span><br><span class=\"line\">hincrby  user age 10\t\t\t给键user里的age 属性添加10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lists-类型（双向链表）\"><a href=\"#Lists-类型（双向链表）\" class=\"headerlink\" title=\"Lists 类型（双向链表）\"></a>Lists 类型（双向链表）</h2><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出</p>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加</span><br><span class=\"line\"></span><br><span class=\"line\">lrange list1 0 -1\t\t\t获取list1链表所有数据</span><br><span class=\"line\"></span><br><span class=\"line\">rpush list2 1 2 3\t\t\t给链表list2尾部插入元素</span><br><span class=\"line\"></span><br><span class=\"line\">lpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）</span><br><span class=\"line\"></span><br><span class=\"line\">rpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）</span><br><span class=\"line\"></span><br><span class=\"line\">lindex list1 3\t\t\t\t获取链表的3索引位置的值</span><br><span class=\"line\"></span><br><span class=\"line\">\tlist1\t\t\t\t\t获取list1 链表的长度</span><br><span class=\"line\"></span><br><span class=\"line\">lset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s</span><br><span class=\"line\"></span><br><span class=\"line\">lrem list3 2 d\t\t\t\t删除链表2个d元素</span><br><span class=\"line\"></span><br><span class=\"line\">ltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃</span><br><span class=\"line\"></span><br><span class=\"line\">linsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素</span><br><span class=\"line\"></span><br><span class=\"line\">rpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><p>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>\n<h2 id=\"Set-类型（不能重复）\"><a href=\"#Set-类型（不能重复）\" class=\"headerlink\" title=\"Set 类型（不能重复）\"></a>Set 类型（不能重复）</h2><h3 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>\n<h3 id=\"操作-3\"><a href=\"#操作-3\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd set1 a b c d \t\t\t\t给set1集合添加元素</span><br><span class=\"line\"></span><br><span class=\"line\">smembers set1\t\t\t\t\t查看set1集合的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">sismember set1 a\t\t\t\t判断set1集合中是否有a元素</span><br><span class=\"line\">scard set1\t\t\t\t\t\t获取集合set1 的元素个数</span><br><span class=\"line\"></span><br><span class=\"line\">srem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）</span><br><span class=\"line\"></span><br><span class=\"line\">srandmember set2 3\t\t\t\t在集合set2中随机出3个元素</span><br><span class=\"line\"></span><br><span class=\"line\">diff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sunion set3 set4\t\t\t\t并集</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Sortedsets-类型\"><a href=\"#Sortedsets-类型\" class=\"headerlink\" title=\"Sortedsets 类型\"></a>Sortedsets 类型</h2><h3 id=\"简介-4\"><a href=\"#简介-4\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>\n<h3 id=\"操作-4\"><a href=\"#操作-4\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值</span><br><span class=\"line\"></span><br><span class=\"line\">zrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zrem zset1 a b\t\t\t集合删除元素a b</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis配置文件\"><a href=\"#Redis配置文件\" class=\"headerlink\" title=\"Redis配置文件\"></a>Redis配置文件</h1><h2 id=\"Redis配置文件在哪\"><a href=\"#Redis配置文件在哪\" class=\"headerlink\" title=\"Redis配置文件在哪?\"></a>Redis配置文件在哪?</h2><p>redis.conf是redis的配置文件，它在那？<br>在redis安装包解压出来的目录下。</p>\n<h2 id=\"常用配置（redis-conf）\"><a href=\"#常用配置（redis-conf）\" class=\"headerlink\" title=\"常用配置（redis.conf）\"></a>常用配置（redis.conf）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数说明</span><br><span class=\"line\">redis.conf 配置项说明如下：</span><br><span class=\"line\">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class=\"line\">  daemonize no</span><br><span class=\"line\">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class=\"line\">  pidfile /var/run/redis.pid</span><br><span class=\"line\">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class=\"line\">  port 6379</span><br><span class=\"line\">4. 绑定的主机地址</span><br><span class=\"line\">  bind 127.0.0.1</span><br><span class=\"line\">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">  timeout 300</span><br><span class=\"line\">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class=\"line\">  loglevel verbose</span><br><span class=\"line\">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class=\"line\">  logfile stdout</span><br><span class=\"line\">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class=\"line\">  databases 16</span><br><span class=\"line\">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class=\"line\">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class=\"line\">  Redis默认配置文件中提供了三个条件：</span><br><span class=\"line\">  save 900 1</span><br><span class=\"line\">  save 300 10</span><br><span class=\"line\">  save 60 10000</span><br><span class=\"line\">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class=\"line\"> </span><br><span class=\"line\">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class=\"line\">  rdbcompression yes</span><br><span class=\"line\">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class=\"line\">  dbfilename dump.rdb</span><br><span class=\"line\">12. 指定本地数据库存放目录</span><br><span class=\"line\">  dir ./</span><br><span class=\"line\">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class=\"line\">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class=\"line\">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class=\"line\">  masterauth &lt;master-password&gt;</span><br><span class=\"line\">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class=\"line\">  requirepass foobared</span><br><span class=\"line\">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class=\"line\">  maxclients 128</span><br><span class=\"line\">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class=\"line\">  maxmemory &lt;bytes&gt;</span><br><span class=\"line\">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class=\"line\">  appendonly no</span><br><span class=\"line\">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class=\"line\">   appendfilename appendonly.aof</span><br><span class=\"line\">20. 指定更新日志条件，共有3个可选值： </span><br><span class=\"line\">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class=\"line\">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class=\"line\">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class=\"line\">  appendfsync everysec</span><br><span class=\"line\"> </span><br><span class=\"line\">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class=\"line\">   vm-enabled no</span><br><span class=\"line\">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class=\"line\">   vm-swap-file /tmp/redis.swap</span><br><span class=\"line\">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class=\"line\">   vm-max-memory 0</span><br><span class=\"line\">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class=\"line\">   vm-page-size 32</span><br><span class=\"line\">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class=\"line\">   vm-pages 134217728</span><br><span class=\"line\">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class=\"line\">   vm-max-threads 4</span><br><span class=\"line\">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class=\"line\">  glueoutputbuf yes</span><br><span class=\"line\">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class=\"line\">  hash-max-zipmap-entries 64</span><br><span class=\"line\">  hash-max-zipmap-value 512</span><br><span class=\"line\">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class=\"line\">  activerehashing yes</span><br><span class=\"line\">30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class=\"line\">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><p>Redis的持久化一共有两种：<br>rdb持久化<br>aof持久化（推荐使用）</p>\n<h2 id=\"RDB（Redis-Database）\"><a href=\"#RDB（Redis-Database）\" class=\"headerlink\" title=\"RDB（Redis Database）\"></a>RDB（Redis Database）</h2><h3 id=\"什么是rdb持久化\"><a href=\"#什么是rdb持久化\" class=\"headerlink\" title=\"什么是rdb持久化\"></a>什么是rdb持久化</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘.<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n<p>Redis官方解释：<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，<br>待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。<br>（因为可能出现redis宕机的情况）</p>\n<h3 id=\"Fork的解释\"><a href=\"#Fork的解释\" class=\"headerlink\" title=\"Fork的解释\"></a>Fork的解释</h3><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><h1 id=\"Redis的事物\"><a href=\"#Redis的事物\" class=\"headerlink\" title=\"Redis的事物\"></a>Redis的事物</h1><h2 id=\"事物介绍\"><a href=\"#事物介绍\" class=\"headerlink\" title=\"事物介绍\"></a>事物介绍</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1）批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）<br>2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p><strong>注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong></p>\n<p>Redis的一个事务从开始到执行会经历以下三个阶段：<br>1）开始事务。<br>2）命令入队。<br>3）执行事务。</p>\n<h2 id=\"事物常用命令\"><a href=\"#事物常用命令\" class=\"headerlink\" title=\"事物常用命令\"></a>事物常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi\t\t\t\t\t\t标记一个事物块的开始</span><br><span class=\"line\"></span><br><span class=\"line\">exec：\t\t\t\t\t\t执行所有事物块内的命令</span><br><span class=\"line\"></span><br><span class=\"line\">discard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令</span><br><span class=\"line\"></span><br><span class=\"line\">watch key [key ...]：\t\t\t</span><br><span class=\"line\">监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br><span class=\"line\"></span><br><span class=\"line\">unwatch\t\t\t\t\t\t取消watch命令对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<p>// TODO</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"入门概述\"><a href=\"#入门概述\" class=\"headerlink\" title=\"入门概述\"></a>入门概述</h1><h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><p>是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 </p>\n<p>redis 的官网：redis.io</p>\n<h2 id=\"Redis-与其他-key-value-缓存产品有以下三个特点\"><a href=\"#Redis-与其他-key-value-缓存产品有以下三个特点\" class=\"headerlink\" title=\"Redis 与其他 key/value 缓存产品有以下三个特点\"></a>Redis 与其他 key/value 缓存产品有以下三个特点</h2><p>1）Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用<br>2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>3）Redis支持数据的备份，即master-slave模式的数据备份</p>\n<h2 id=\"应用场景（redis能干些什么）\"><a href=\"#应用场景（redis能干些什么）\" class=\"headerlink\" title=\"应用场景（redis能干些什么）\"></a>应用场景（redis能干些什么）</h2><p>1）内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<br>2）取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面<br>3）模拟类似于HttpSession这种需要设定过期时间的功能<br>4）发布、订阅消息系统（消息中间件）<br>5）定时器、计数器<br>6）可以实现session共享<br>7）可以实现分布式锁</p>\n<h1 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h1><p>提示：<br>由于企业里面做Redis开发，99%都是Linux版的运用和安装。<br>几乎不会涉及到Windows版，windows安装只是为了学习而已了。</p>\n<h1 id=\"Redis启动后的杂项知识（重要）\"><a href=\"#Redis启动后的杂项知识（重要）\" class=\"headerlink\" title=\"Redis启动后的杂项知识（重要）\"></a>Redis启动后的杂项知识（重要）</h1><p>1）单进程，redis速度很快。<br>redis读写性能测试，redis官网测试读写能到10万左右。</p>\n<p>2）默认16个数据库，类似数组下表从零开始，初始默认使用零号库。</p>\n<p>3）select命令切换数据库。</p>\n<p>4）dbsize查看当前数据库的key的数量。</p>\n<p>5）flushdb：清空当前库key。</p>\n<p>6）flushall：清空全部库。</p>\n<p>7）统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上。</p>\n<p>8）redis索引都是从零开始。</p>\n<p>9）redis默认端口是6379。</p>\n<h1 id=\"Redis五大数据类型\"><a href=\"#Redis五大数据类型\" class=\"headerlink\" title=\"Redis五大数据类型\"></a>Redis五大数据类型</h1><p>常用命令：<br>ping：ping下redis<br>dbsize：查看当前数据库的key的数量<br>select 1：切换到下标为1的数据库中<br>flushdb：清空当前库key<br>flushall：清空全部库key</p>\n<h2 id=\"Redis键的操作（常用）\"><a href=\"#Redis键的操作（常用）\" class=\"headerlink\" title=\"Redis键的操作（常用）\"></a>Redis键的操作（常用）</h2><p>查看当前数据库的所有key:<br>Keys *</p>\n<p>判断当前key是否存在：<br>exists name</p>\n<p>将当前key移动到2号库中：<br>Move name 2</p>\n<p>设置key在6秒后过期：<br>expire name 6</p>\n<p>查看当前key还有多久过期<br>ttl name </p>\n<p>查看当前key是什么结构的类型<br>type name</p>\n<h2 id=\"String-类型（常用）\"><a href=\"#String-类型（常用）\" class=\"headerlink\" title=\"String 类型（常用）\"></a>String 类型（常用）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>String是redis最基本的类型，可以理解成一个key对应一个value。<br>String类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化对象。<br>redis一个字符串value最多可以是512M。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set name oyr：\t\t\t给键name设置值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">get name：\t\t\t\t获取键name的值</span><br><span class=\"line\"></span><br><span class=\"line\">del name：\t\t\t\t删除建为name值</span><br><span class=\"line\"></span><br><span class=\"line\">append name 123：\t\t在name对应的值后面追加123</span><br><span class=\"line\"></span><br><span class=\"line\">strlen name：\t\t\t得到当前name对应的值的长度</span><br><span class=\"line\"></span><br><span class=\"line\">incr age：\t\t\t\tage+1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">incrby age 10：\t\t\tage+10</span><br><span class=\"line\"></span><br><span class=\"line\">decr age：\t\t\t\tage-1，一定要是数字才能操作</span><br><span class=\"line\"></span><br><span class=\"line\">decrby age 10： \t\tage-10</span><br><span class=\"line\"></span><br><span class=\"line\">setex name 10 oyr：\t\t</span><br><span class=\"line\">（set with expire）</span><br><span class=\"line\">设置key为name，过期时间为10秒，值为oyr</span><br><span class=\"line\"></span><br><span class=\"line\">sexnx name ooo：</span><br><span class=\"line\">（sex if not exist）</span><br><span class=\"line\">设置键位name，值为ooo，只有不存在的时候才会设置进去</span><br><span class=\"line\"></span><br><span class=\"line\">mset k1 v1 k2 v2 k3 v3：\t\t一次设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">mget k1 k2 k3：\t\t\t\t\t一次获取多个值</span><br><span class=\"line\"></span><br><span class=\"line\">msetnx k1 v1 k2 v2 k3 v3：\t\t一次设置多个值，如果有一个键是存在的那么全部失效。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hash-类型（常用）\"><a href=\"#Hash-类型（常用）\" class=\"headerlink\" title=\"Hash 类型（常用）\"></a>Hash 类型（常用）</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;，K-V模式不变，但V是一个键值对。</p>\n<h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）hset</span><br><span class=\"line\">hset user name oyr\t\t\t给键user的name属性设置值</span><br><span class=\"line\"></span><br><span class=\"line\">（2）hget</span><br><span class=\"line\">hget user name\t\t\t\t获取键user的name值</span><br><span class=\"line\"></span><br><span class=\"line\">（3）hmset</span><br><span class=\"line\">hmset user age 18 sex nan  \t\t同时设置多个值</span><br><span class=\"line\"></span><br><span class=\"line\">（4）hmget</span><br><span class=\"line\">hmget user name age sex\t\t\t同时获取多个属性值</span><br><span class=\"line\"></span><br><span class=\"line\">（5）hgetall</span><br><span class=\"line\">hgetall user \t\t\t\t\t获取键user中的所有键和值</span><br><span class=\"line\"></span><br><span class=\"line\">（6）hdel</span><br><span class=\"line\">hdel user name\t\t\t\t\t删除键user中的name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（7）hlen</span><br><span class=\"line\">hlen user\t\t\t\t\t\t获取键user下有几个属性</span><br><span class=\"line\"></span><br><span class=\"line\">（8）hexists</span><br><span class=\"line\">hexists user nane\t\t\t\t判断键user下是否有name属性</span><br><span class=\"line\"></span><br><span class=\"line\">（9）hkeys</span><br><span class=\"line\">hkys user\t\t\t\t\t\t获取键user下的所有属性</span><br><span class=\"line\"></span><br><span class=\"line\">（10）hvals</span><br><span class=\"line\">hvals user \t\t\t\t\t \t获取键user下的所有值</span><br><span class=\"line\"></span><br><span class=\"line\">（11）hsetnx</span><br><span class=\"line\">hsetnx user name &quot;oyr&quot;\t\t\t如果user对象里存在 name 属性，则不做操作，不存在，创建并赋值。</span><br><span class=\"line\"></span><br><span class=\"line\">（12）hincrby </span><br><span class=\"line\">hincrby  user age 10\t\t\t给键user里的age 属性添加10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lists-类型（双向链表）\"><a href=\"#Lists-类型（双向链表）\" class=\"headerlink\" title=\"Lists 类型（双向链表）\"></a>Lists 类型（双向链表）</h2><h3 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表，而且是双向链表。注意：先进后出，后进先出</p>\n<h3 id=\"操作-2\"><a href=\"#操作-2\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush list1 a b c d\t\t\t给list1链表添加数据a b c d,从头部添加</span><br><span class=\"line\"></span><br><span class=\"line\">lrange list1 0 -1\t\t\t获取list1链表所有数据</span><br><span class=\"line\"></span><br><span class=\"line\">rpush list2 1 2 3\t\t\t给链表list2尾部插入元素</span><br><span class=\"line\"></span><br><span class=\"line\">lpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从头部出）</span><br><span class=\"line\"></span><br><span class=\"line\">rpop list1\t\t\t\t\t出栈 mylist，出栈后，元素消失（从尾部出）</span><br><span class=\"line\"></span><br><span class=\"line\">lindex list1 3\t\t\t\t获取链表的3索引位置的值</span><br><span class=\"line\"></span><br><span class=\"line\">\tlist1\t\t\t\t\t获取list1 链表的长度</span><br><span class=\"line\"></span><br><span class=\"line\">lset list2 2 s\t\t\t\t给链表索引2的位置设置值为 s</span><br><span class=\"line\"></span><br><span class=\"line\">lrem list3 2 d\t\t\t\t删除链表2个d元素</span><br><span class=\"line\"></span><br><span class=\"line\">ltrim list2 2 5\t\t\t从索引2截取到索引5，其他元素被遗弃</span><br><span class=\"line\"></span><br><span class=\"line\">linsert list2 before/after s u\t\t在链表f元素前面或者后面插入 h 元素</span><br><span class=\"line\"></span><br><span class=\"line\">rpoplpush list1 list2 \t\t从list1链表中尾部出站，出栈元素添加给list2链表</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"性能总结\"><a href=\"#性能总结\" class=\"headerlink\" title=\"性能总结\"></a>性能总结</h3><p>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>\n<h2 id=\"Set-类型（不能重复）\"><a href=\"#Set-类型（不能重复）\" class=\"headerlink\" title=\"Set 类型（不能重复）\"></a>Set 类型（不能重复）</h2><h3 id=\"简介-3\"><a href=\"#简介-3\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>\n<h3 id=\"操作-3\"><a href=\"#操作-3\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd set1 a b c d \t\t\t\t给set1集合添加元素</span><br><span class=\"line\"></span><br><span class=\"line\">smembers set1\t\t\t\t\t查看set1集合的所有元素</span><br><span class=\"line\"></span><br><span class=\"line\">sismember set1 a\t\t\t\t判断set1集合中是否有a元素</span><br><span class=\"line\">scard set1\t\t\t\t\t\t获取集合set1 的元素个数</span><br><span class=\"line\"></span><br><span class=\"line\">srem set1 a\t\t\t\t\t\t删除集合set1中的元素（可以一次删除多个）</span><br><span class=\"line\"></span><br><span class=\"line\">srandmember set2 3\t\t\t\t在集合set2中随机出3个元素</span><br><span class=\"line\"></span><br><span class=\"line\">diff set3 set4\t\t\t\t\t差集，取set3中存在但是set4中不存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sinter set3 set4\t\t\t\t交集，取set3和set4都存在的元素</span><br><span class=\"line\"></span><br><span class=\"line\">sunion set3 set4\t\t\t\t并集</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Sortedsets-类型\"><a href=\"#Sortedsets-类型\" class=\"headerlink\" title=\"Sortedsets 类型\"></a>Sortedsets 类型</h2><h3 id=\"简介-4\"><a href=\"#简介-4\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>\n<h3 id=\"操作-4\"><a href=\"#操作-4\" class=\"headerlink\" title=\"操作\"></a>操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd zset1 60 a 70 b 80 c 90 d 100 f\t给zset1 有序集合设置元素，同时设置元素分数。</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 -1 withscores\t\t查询集合所有元素,0:开始,-1:结束,withscores显示分数</span><br><span class=\"line\"></span><br><span class=\"line\">zrange zset1 0 2\t\t\t\t\t\t查询集合下标0到下标2的元素</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 70 90 \t\t\t\t\t\t统计分数在 70 到 90 之间元素，闭区间。</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 (70 90 \t\t    统计分数在70到90之间元素，左边开区间，右边闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zcount zset1 -inf +inf\t\t    统计所有元素  -inf:最小值 +inf:最大值</span><br><span class=\"line\"></span><br><span class=\"line\">zrangebyscore mysset 12 19 withscores limit 0 1     根据分数查询12到19集合，从坐标0开始。每页显示1条，12-19都是闭区间</span><br><span class=\"line\"></span><br><span class=\"line\">zrem zset1 a b\t\t\t集合删除元素a b</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis配置文件\"><a href=\"#Redis配置文件\" class=\"headerlink\" title=\"Redis配置文件\"></a>Redis配置文件</h1><h2 id=\"Redis配置文件在哪\"><a href=\"#Redis配置文件在哪\" class=\"headerlink\" title=\"Redis配置文件在哪?\"></a>Redis配置文件在哪?</h2><p>redis.conf是redis的配置文件，它在那？<br>在redis安装包解压出来的目录下。</p>\n<h2 id=\"常用配置（redis-conf）\"><a href=\"#常用配置（redis-conf）\" class=\"headerlink\" title=\"常用配置（redis.conf）\"></a>常用配置（redis.conf）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数说明</span><br><span class=\"line\">redis.conf 配置项说明如下：</span><br><span class=\"line\">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class=\"line\">  daemonize no</span><br><span class=\"line\">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class=\"line\">  pidfile /var/run/redis.pid</span><br><span class=\"line\">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class=\"line\">  port 6379</span><br><span class=\"line\">4. 绑定的主机地址</span><br><span class=\"line\">  bind 127.0.0.1</span><br><span class=\"line\">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class=\"line\">  timeout 300</span><br><span class=\"line\">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class=\"line\">  loglevel verbose</span><br><span class=\"line\">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class=\"line\">  logfile stdout</span><br><span class=\"line\">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class=\"line\">  databases 16</span><br><span class=\"line\">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class=\"line\">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class=\"line\">  Redis默认配置文件中提供了三个条件：</span><br><span class=\"line\">  save 900 1</span><br><span class=\"line\">  save 300 10</span><br><span class=\"line\">  save 60 10000</span><br><span class=\"line\">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class=\"line\"> </span><br><span class=\"line\">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class=\"line\">  rdbcompression yes</span><br><span class=\"line\">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class=\"line\">  dbfilename dump.rdb</span><br><span class=\"line\">12. 指定本地数据库存放目录</span><br><span class=\"line\">  dir ./</span><br><span class=\"line\">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class=\"line\">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class=\"line\">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class=\"line\">  masterauth &lt;master-password&gt;</span><br><span class=\"line\">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class=\"line\">  requirepass foobared</span><br><span class=\"line\">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class=\"line\">  maxclients 128</span><br><span class=\"line\">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class=\"line\">  maxmemory &lt;bytes&gt;</span><br><span class=\"line\">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class=\"line\">  appendonly no</span><br><span class=\"line\">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class=\"line\">   appendfilename appendonly.aof</span><br><span class=\"line\">20. 指定更新日志条件，共有3个可选值： </span><br><span class=\"line\">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class=\"line\">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class=\"line\">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class=\"line\">  appendfsync everysec</span><br><span class=\"line\"> </span><br><span class=\"line\">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class=\"line\">   vm-enabled no</span><br><span class=\"line\">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class=\"line\">   vm-swap-file /tmp/redis.swap</span><br><span class=\"line\">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class=\"line\">   vm-max-memory 0</span><br><span class=\"line\">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class=\"line\">   vm-page-size 32</span><br><span class=\"line\">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class=\"line\">   vm-pages 134217728</span><br><span class=\"line\">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class=\"line\">   vm-max-threads 4</span><br><span class=\"line\">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class=\"line\">  glueoutputbuf yes</span><br><span class=\"line\">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class=\"line\">  hash-max-zipmap-entries 64</span><br><span class=\"line\">  hash-max-zipmap-value 512</span><br><span class=\"line\">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class=\"line\">  activerehashing yes</span><br><span class=\"line\">30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class=\"line\">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis的持久化\"><a href=\"#Redis的持久化\" class=\"headerlink\" title=\"Redis的持久化\"></a>Redis的持久化</h1><p>Redis的持久化一共有两种：<br>rdb持久化<br>aof持久化（推荐使用）</p>\n<h2 id=\"RDB（Redis-Database）\"><a href=\"#RDB（Redis-Database）\" class=\"headerlink\" title=\"RDB（Redis Database）\"></a>RDB（Redis Database）</h2><h3 id=\"什么是rdb持久化\"><a href=\"#什么是rdb持久化\" class=\"headerlink\" title=\"什么是rdb持久化\"></a>什么是rdb持久化</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘.<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>\n<p>Redis官方解释：<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，<br>待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。<br>（因为可能出现redis宕机的情况）</p>\n<h3 id=\"Fork的解释\"><a href=\"#Fork的解释\" class=\"headerlink\" title=\"Fork的解释\"></a>Fork的解释</h3><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>\n<h2 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h2><h1 id=\"Redis的事物\"><a href=\"#Redis的事物\" class=\"headerlink\" title=\"Redis的事物\"></a>Redis的事物</h1><h2 id=\"事物介绍\"><a href=\"#事物介绍\" class=\"headerlink\" title=\"事物介绍\"></a>事物介绍</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1）批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。（并不回滚）<br>2）在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p><strong>注意：redis单命令是原子性的，但redis事物并不是原子性。Redis事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong></p>\n<p>Redis的一个事务从开始到执行会经历以下三个阶段：<br>1）开始事务。<br>2）命令入队。<br>3）执行事务。</p>\n<h2 id=\"事物常用命令\"><a href=\"#事物常用命令\" class=\"headerlink\" title=\"事物常用命令\"></a>事物常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multi\t\t\t\t\t\t标记一个事物块的开始</span><br><span class=\"line\"></span><br><span class=\"line\">exec：\t\t\t\t\t\t执行所有事物块内的命令</span><br><span class=\"line\"></span><br><span class=\"line\">discard： \t\t\t\t\t取消事物，放弃执行事物块的所有命令</span><br><span class=\"line\"></span><br><span class=\"line\">watch key [key ...]：\t\t\t</span><br><span class=\"line\">监视一个（或多个）key，如果在事物执行前这个(或这些) key 被其他命令所改动，那么事务将被打断。</span><br><span class=\"line\"></span><br><span class=\"line\">unwatch\t\t\t\t\t\t取消watch命令对所有key的监控</span><br></pre></td></tr></table></figure>\n\n<p>// TODO</p>\n"},{"title":"Redis-穿透&雪崩&击穿","date":"2021-06-19T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"\n# Redis缓存穿透\n\n## 什么是缓存穿透\n\n缓存穿透：是指查询一个数据库不存在的数据。\n\nRedis正常使用流程：  \n数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。\n\n问题引出：  \n想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。\n\n## 解决方案\n\n1）redis缓存空值（推荐方案）  \n对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。\n\n2）判断key的数据格式（有局限，列如key没有任何规则）  \n网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。\n\n# Redis缓存雪崩\n\n## 什么是缓存雪崩\n\n缓存雪崩：指在某一个时间段，缓存集中过期失效。\n\n举例：  \n马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。\n\n## 解决方案\n\n1）使用锁（不推荐效率低）  \n单点项目使用本地锁，分布式项目使用分布式锁。  \n对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。\n\n2）使用二级缓存（推荐）  \n一级缓存使用ehcache，二级缓存使用redis。  \n一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。\n\n3）均摊分配redis key的失效时间（推荐）  \n不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。\n\n# Redis缓存击穿\n\n## 什么是缓存击穿\n\n缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n\n## 解决方案\n1）设置热点数据永远不过期。（推荐）  \n\n2）使用互斥锁（不推荐，没必要）  \n指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。","source":"_posts/oyr/Redis/Redis-穿透&雪崩&击穿.md","raw":"---\ntitle: Redis-穿透&雪崩&击穿\ndate: 2021-06-20 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---\n\n# Redis缓存穿透\n\n## 什么是缓存穿透\n\n缓存穿透：是指查询一个数据库不存在的数据。\n\nRedis正常使用流程：  \n数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。\n\n问题引出：  \n想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。\n\n## 解决方案\n\n1）redis缓存空值（推荐方案）  \n对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。\n\n2）判断key的数据格式（有局限，列如key没有任何规则）  \n网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。\n\n# Redis缓存雪崩\n\n## 什么是缓存雪崩\n\n缓存雪崩：指在某一个时间段，缓存集中过期失效。\n\n举例：  \n马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。\n\n## 解决方案\n\n1）使用锁（不推荐效率低）  \n单点项目使用本地锁，分布式项目使用分布式锁。  \n对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。\n\n2）使用二级缓存（推荐）  \n一级缓存使用ehcache，二级缓存使用redis。  \n一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。\n\n3）均摊分配redis key的失效时间（推荐）  \n不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。\n\n# Redis缓存击穿\n\n## 什么是缓存击穿\n\n缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n\n## 解决方案\n1）设置热点数据永远不过期。（推荐）  \n\n2）使用互斥锁（不推荐，没必要）  \n指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。","slug":"oyr/Redis/Redis-穿透&雪崩&击穿","published":1,"updated":"2021-07-13T09:50:21.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836f001mhct7aybb06z6","content":"<h1 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h1><h2 id=\"什么是缓存穿透\"><a href=\"#什么是缓存穿透\" class=\"headerlink\" title=\"什么是缓存穿透\"></a>什么是缓存穿透</h2><p>缓存穿透：是指查询一个数据库不存在的数据。</p>\n<p>Redis正常使用流程：<br>数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。</p>\n<p>问题引出：<br>想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）redis缓存空值（推荐方案）<br>对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。</p>\n<p>2）判断key的数据格式（有局限，列如key没有任何规则）<br>网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。</p>\n<h1 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h1><h2 id=\"什么是缓存雪崩\"><a href=\"#什么是缓存雪崩\" class=\"headerlink\" title=\"什么是缓存雪崩\"></a>什么是缓存雪崩</h2><p>缓存雪崩：指在某一个时间段，缓存集中过期失效。</p>\n<p>举例：<br>马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）使用锁（不推荐效率低）<br>单点项目使用本地锁，分布式项目使用分布式锁。<br>对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<p>2）使用二级缓存（推荐）<br>一级缓存使用ehcache，二级缓存使用redis。<br>一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。</p>\n<p>3）均摊分配redis key的失效时间（推荐）<br>不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。</p>\n<h1 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h1><h2 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿\"></a>什么是缓存击穿</h2><p>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）设置热点数据永远不过期。（推荐）  </p>\n<p>2）使用互斥锁（不推荐，没必要）<br>指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis缓存穿透\"><a href=\"#Redis缓存穿透\" class=\"headerlink\" title=\"Redis缓存穿透\"></a>Redis缓存穿透</h1><h2 id=\"什么是缓存穿透\"><a href=\"#什么是缓存穿透\" class=\"headerlink\" title=\"什么是缓存穿透\"></a>什么是缓存穿透</h2><p>缓存穿透：是指查询一个数据库不存在的数据。</p>\n<p>Redis正常使用流程：<br>数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存中，直接向外返回空。</p>\n<p>问题引出：<br>想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行对数据库的攻击。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）redis缓存空值（推荐方案）<br>对上诉所讲传入一个不存在的key，对数据库进行攻击，我们可以将这个不存在的key缓存一个null值放入到redis中，给null值得缓存设置一个比平常缓存短的过期时间即可。当这个不存在的key存在时，即可将null值删除，将数据存入key中即可。</p>\n<p>2）判断key的数据格式（有局限，列如key没有任何规则）<br>网管判断客户端传入对应的key规则，如果不符合数据库的查询规则直接返回null值。</p>\n<h1 id=\"Redis缓存雪崩\"><a href=\"#Redis缓存雪崩\" class=\"headerlink\" title=\"Redis缓存雪崩\"></a>Redis缓存雪崩</h1><h2 id=\"什么是缓存雪崩\"><a href=\"#什么是缓存雪崩\" class=\"headerlink\" title=\"什么是缓存雪崩\"></a>什么是缓存雪崩</h2><p>缓存雪崩：指在某一个时间段，缓存集中过期失效。</p>\n<p>举例：<br>马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p>\n<h2 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）使用锁（不推荐效率低）<br>单点项目使用本地锁，分布式项目使用分布式锁。<br>对于某种规则key中，在缓存失效后，通过加锁来控制读数据库写缓存的线程数量。也就是同一时间只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<p>2）使用二级缓存（推荐）<br>一级缓存使用ehcache，二级缓存使用redis。<br>一级缓存为原始缓存，二级缓存为拷贝缓存，一级缓存失效时，可以访问二级缓存。一级缓存失效时间设置为短期，二级缓存设置为长期。</p>\n<p>3）均摊分配redis key的失效时间（推荐）<br>不同的key，设置不同的过期时间，让缓存失效的时间点不要过于集中。这种方式需要根据业务需求和正式场景看情况设置失效时间。</p>\n<h1 id=\"Redis缓存击穿\"><a href=\"#Redis缓存击穿\" class=\"headerlink\" title=\"Redis缓存击穿\"></a>Redis缓存击穿</h1><h2 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿\"></a>什么是缓存击穿</h2><p>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>1）设置热点数据永远不过期。（推荐）  </p>\n<p>2）使用互斥锁（不推荐，没必要）<br>指让一个线程获取锁后，查询数据库将数据放入缓存中，其他线程等待后去查询缓存并不查询数据库。</p>\n"},{"title":"Redis-集群模式","date":"2020-06-22T16:00:00.000Z","author":"神奇的荣荣","summary":"","_content":"","source":"_posts/oyr/Redis/Redis-集群模式.md","raw":"---\ntitle: Redis-集群模式\ndate: 2020-06-23 00:00:00\nauthor: 神奇的荣荣\nsummary: \"\"\ncategories: oyr-Redis\ntags: \n    - oyr-Redis\n    - 中间件\n---","slug":"oyr/Redis/Redis-集群模式","published":1,"updated":"2021-07-13T09:52:42.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836g001qhct71ipo9tzm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"DDD领域模型初讲","date":"2021-07-26T16:00:00.000Z","author":"lh","summary":"","_content":"# 还在一脸懵逼中。。。","source":"_posts/lh/DDD/DDD领域模型设计.md","raw":"---\ntitle: DDD领域模型初讲\ndate: 2021-07-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: DDD\ntags: \n    - DDD\n---\n# 还在一脸懵逼中。。。","slug":"lh/DDD/DDD领域模型设计","published":1,"updated":"2021-08-10T09:16:11.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836g001rhct74on43lq2","content":"<h1 id=\"还在一脸懵逼中。。。\"><a href=\"#还在一脸懵逼中。。。\" class=\"headerlink\" title=\"还在一脸懵逼中。。。\"></a>还在一脸懵逼中。。。</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"还在一脸懵逼中。。。\"><a href=\"#还在一脸懵逼中。。。\" class=\"headerlink\" title=\"还在一脸懵逼中。。。\"></a>还在一脸懵逼中。。。</h1>"},{"title":"注解编程","date":"2021-08-30T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 为什么要使用注解编程\n    注解编程可以使得代码更简洁，提供开发效率。  \n    替换xml这种配置形式，简化配置\n例如 开发一个User类：\n```java\npublic class User(){....}\n```\n添加注解@Component后如下：\n```java\n@Component\npublic class User(){....}\n```\n\n该形式等价于在spring配置文件中的\n```xml\n<bean id=\"user\" class=\"com.study.User\"></bean>\n```\n\n# 容器相关注解\n## 组件注册 \n### @Configuration\n作用在类上，表示这个是一个配置类，相当于配置文件xml一样\n\n### @Bean \n作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定\n\n### @ComponentScan \n作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    \n\n使用excludeFilters：过滤掉哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n})\t//配置扫描包\n```\n\n使用includeFilters：包含哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, includeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Service.class})\n}, useDefaultFilters=false)\t//配置扫描包\n```\n\n### @ComponentScans\n配置扫描包，可以设置多个值 \n\n```java \n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n\t})\t//配置扫描包\n})\n```\n自动过滤规则：\n```java\npublic class MyTypeFilter implements TypeFilter{\n\n\tpublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\n\t\t//注解信息\n\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t//类信息\n\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();\n\t\t//路径信息\n\t\tResource resource = metadataReader.getResource();\n\t\t//获取类名\n\t\tString className = classMetadata.getClassName();\n\t\tSystem.out.println(className);\n\t\tif(className.contains(\"er\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class}),\n\t\t\t@Filter(type=FilterType.CUSTOM, value={MyTypeFilter.class})\t//使用自定义的过滤规则\n\t})\t//配置扫描包\n})\n```\n\n### @Scope\n作用在方法上，相当于 bean 中的scope属性\n```java\n/**\n\t * prototype\t多实例，当要用到时才会创建实例\n\t * singleton\t单例（默认），在spring容器创建时就创建实例了\n\t * request\t\t同一个请求创建一个实例（很少用到）\n\t * session\t\t同一个session创建一个实例（很少用到）\n\t * @return\n\t */\n\t@Scope(\"prototype\")\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n\n```\n\n### @Lazy\n懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。\n\n```java\n@Lazy\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n```\n\n### @Conditional\n可以作用在类或方法上。  \n作用在方法上： 如果条件返回true，则创建bean\n作用在类上： 如果返回true，此类的注册bean才会生效。\n```java\n    @Conditional({WindowsCondition.class})\n\t@Bean(\"windows\")\n\tpublic Student student2(){\n\t\treturn new Student(\"my is windows\", 60);\n\t}\n\t\n\t@Conditional({LinuxCondition.class})\n\t@Bean(\"linux\")\n\tpublic Student student3(){\n\t\treturn new Student(\"my is linux\", 50);\n\t}\n```\n\n```java\n//判断是否是Linux系统\npublic class LinuxCondition implements Condition {\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tEnvironment environment = context.getEnvironment();\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"linux\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n\n//判断是否是windows系统\npublic class WindowsCondition implements Condition{\n\n\t/**\n\t * context：程序上下文\n\t * metadata：注解信息\n\t */\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t//bean工厂\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t//程序运行环境\n\t\tEnvironment environment = context.getEnvironment();\n\t\t//bean注册信息\n\t\tBeanDefinitionRegistry registry = context.getRegistry();\n\t\t\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"Windows\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n```","source":"_posts/lh/spring/注解编程.md","raw":"---\ntitle: 注解编程\ndate: 2021-08-31 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: spring\ntags: \n    - spring\n---\n\n# 为什么要使用注解编程\n    注解编程可以使得代码更简洁，提供开发效率。  \n    替换xml这种配置形式，简化配置\n例如 开发一个User类：\n```java\npublic class User(){....}\n```\n添加注解@Component后如下：\n```java\n@Component\npublic class User(){....}\n```\n\n该形式等价于在spring配置文件中的\n```xml\n<bean id=\"user\" class=\"com.study.User\"></bean>\n```\n\n# 容器相关注解\n## 组件注册 \n### @Configuration\n作用在类上，表示这个是一个配置类，相当于配置文件xml一样\n\n### @Bean \n作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定\n\n### @ComponentScan \n作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    \n\n使用excludeFilters：过滤掉哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n})\t//配置扫描包\n```\n\n使用includeFilters：包含哪些类\n```java\n@ComponentScan(value = {\"com.study\"}, includeFilters={\n\t\t@Filter(type=FilterType.ANNOTATION, value={Service.class})\n}, useDefaultFilters=false)\t//配置扫描包\n```\n\n### @ComponentScans\n配置扫描包，可以设置多个值 \n\n```java \n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})\n\t})\t//配置扫描包\n})\n```\n自动过滤规则：\n```java\npublic class MyTypeFilter implements TypeFilter{\n\n\tpublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\n\t\t//注解信息\n\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t//类信息\n\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();\n\t\t//路径信息\n\t\tResource resource = metadataReader.getResource();\n\t\t//获取类名\n\t\tString className = classMetadata.getClassName();\n\t\tSystem.out.println(className);\n\t\tif(className.contains(\"er\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n@ComponentScans({\n\t@ComponentScan(value = {\"com.study\"}, excludeFilters={\n\t\t\t@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class}),\n\t\t\t@Filter(type=FilterType.CUSTOM, value={MyTypeFilter.class})\t//使用自定义的过滤规则\n\t})\t//配置扫描包\n})\n```\n\n### @Scope\n作用在方法上，相当于 bean 中的scope属性\n```java\n/**\n\t * prototype\t多实例，当要用到时才会创建实例\n\t * singleton\t单例（默认），在spring容器创建时就创建实例了\n\t * request\t\t同一个请求创建一个实例（很少用到）\n\t * session\t\t同一个session创建一个实例（很少用到）\n\t * @return\n\t */\n\t@Scope(\"prototype\")\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n\n```\n\n### @Lazy\n懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。\n\n```java\n@Lazy\n\t@Bean\n\tpublic Student student(){\n\t\tSystem.out.println(\"创建student对象\");\n\t\treturn new Student(\"张三\", 15);\n\t}\n```\n\n### @Conditional\n可以作用在类或方法上。  \n作用在方法上： 如果条件返回true，则创建bean\n作用在类上： 如果返回true，此类的注册bean才会生效。\n```java\n    @Conditional({WindowsCondition.class})\n\t@Bean(\"windows\")\n\tpublic Student student2(){\n\t\treturn new Student(\"my is windows\", 60);\n\t}\n\t\n\t@Conditional({LinuxCondition.class})\n\t@Bean(\"linux\")\n\tpublic Student student3(){\n\t\treturn new Student(\"my is linux\", 50);\n\t}\n```\n\n```java\n//判断是否是Linux系统\npublic class LinuxCondition implements Condition {\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tEnvironment environment = context.getEnvironment();\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"linux\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n```\n\n```java\n\n//判断是否是windows系统\npublic class WindowsCondition implements Condition{\n\n\t/**\n\t * context：程序上下文\n\t * metadata：注解信息\n\t */\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t//bean工厂\n\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t//程序运行环境\n\t\tEnvironment environment = context.getEnvironment();\n\t\t//bean注册信息\n\t\tBeanDefinitionRegistry registry = context.getRegistry();\n\t\t\n\t\tString name = environment.getProperty(\"os.name\");\n\t\tif(name.contains(\"Windows\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n```","slug":"lh/spring/注解编程","published":1,"updated":"2021-08-31T06:51:37.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836h001vhct75w800lgr","content":"<h1 id=\"为什么要使用注解编程\"><a href=\"#为什么要使用注解编程\" class=\"headerlink\" title=\"为什么要使用注解编程\"></a>为什么要使用注解编程</h1><pre><code>注解编程可以使得代码更简洁，提供开发效率。  \n替换xml这种配置形式，简化配置\n</code></pre>\n<p>例如 开发一个User类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n<p>添加注解@Component后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该形式等价于在spring配置文件中的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.User&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器相关注解\"><a href=\"#容器相关注解\" class=\"headerlink\" title=\"容器相关注解\"></a>容器相关注解</h1><h2 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h2><h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h3><p>作用在类上，表示这个是一个配置类，相当于配置文件xml一样</p>\n<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定</p>\n<h3 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h3><p>作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    </p>\n<p>使用excludeFilters：过滤掉哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<p>使用includeFilters：包含哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, includeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;, useDefaultFilters=false)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ComponentScans\"><a href=\"#ComponentScans\" class=\"headerlink\" title=\"@ComponentScans\"></a>@ComponentScans</h3><p>配置扫描包，可以设置多个值 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>自动过滤规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTypeFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeFilter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注解信息</span></span><br><span class=\"line\">\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//类信息</span></span><br><span class=\"line\">\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//路径信息</span></span><br><span class=\"line\">\t\tResource resource = metadataReader.getResource();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取类名</span></span><br><span class=\"line\">\t\tString className = classMetadata.getClassName();</span><br><span class=\"line\">\t\tSystem.out.println(className);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(className.contains(<span class=\"string\">&quot;er&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.CUSTOM, value=&#123;MyTypeFilter.class&#125;)\t//使用自定义的过滤规则</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"@Scope\"></a>@Scope</h3><p>作用在方法上，相当于 bean 中的scope属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * prototype\t多实例，当要用到时才会创建实例</span></span><br><span class=\"line\"><span class=\"comment\">\t * singleton\t单例（默认），在spring容器创建时就创建实例了</span></span><br><span class=\"line\"><span class=\"comment\">\t * request\t\t同一个请求创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * session\t\t同一个session创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h3><p>懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Conditional\"><a href=\"#Conditional\" class=\"headerlink\" title=\"@Conditional\"></a>@Conditional</h3><p>可以作用在类或方法上。<br>作用在方法上： 如果条件返回true，则创建bean<br>作用在类上： 如果返回true，此类的注册bean才会生效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;windows&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is windows&quot;</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;linux&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is linux&quot;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否是Linux系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinuxCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;linux&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断是否是windows系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * context：程序上下文</span></span><br><span class=\"line\"><span class=\"comment\">\t * metadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean工厂</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//程序运行环境</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean注册信息</span></span><br><span class=\"line\">\t\tBeanDefinitionRegistry registry = context.getRegistry();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;Windows&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要使用注解编程\"><a href=\"#为什么要使用注解编程\" class=\"headerlink\" title=\"为什么要使用注解编程\"></a>为什么要使用注解编程</h1><pre><code>注解编程可以使得代码更简洁，提供开发效率。  \n替换xml这种配置形式，简化配置\n</code></pre>\n<p>例如 开发一个User类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n<p>添加注解@Component后如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该形式等价于在spring配置文件中的</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;user&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.User&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器相关注解\"><a href=\"#容器相关注解\" class=\"headerlink\" title=\"容器相关注解\"></a>容器相关注解</h1><h2 id=\"组件注册\"><a href=\"#组件注册\" class=\"headerlink\" title=\"组件注册\"></a>组件注册</h2><h3 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"@Configuration\"></a>@Configuration</h3><p>作用在类上，表示这个是一个配置类，相当于配置文件xml一样</p>\n<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定</p>\n<h3 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h3><p>作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    </p>\n<p>使用excludeFilters：过滤掉哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<p>使用includeFilters：包含哪些类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, includeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">&#125;, useDefaultFilters=false)</span>\t<span class=\"comment\">//配置扫描包</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ComponentScans\"><a href=\"#ComponentScans\" class=\"headerlink\" title=\"@ComponentScans\"></a>@ComponentScans</h3><p>配置扫描包，可以设置多个值 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>自动过滤规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTypeFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">TypeFilter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注解信息</span></span><br><span class=\"line\">\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//类信息</span></span><br><span class=\"line\">\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class=\"line\">\t\t<span class=\"comment\">//路径信息</span></span><br><span class=\"line\">\t\tResource resource = metadataReader.getResource();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取类名</span></span><br><span class=\"line\">\t\tString className = classMetadata.getClassName();</span><br><span class=\"line\">\t\tSystem.out.println(className);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(className.contains(<span class=\"string\">&quot;er&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ComponentScans(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t@ComponentScan(value = &#123;&quot;com.study&quot;&#125;, excludeFilters=&#123;</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.ANNOTATION, value=&#123;Controller.class, Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t@Filter(type=FilterType.CUSTOM, value=&#123;MyTypeFilter.class&#125;)\t//使用自定义的过滤规则</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;)\t//配置扫描包</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"@Scope\"></a>@Scope</h3><p>作用在方法上，相当于 bean 中的scope属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * prototype\t多实例，当要用到时才会创建实例</span></span><br><span class=\"line\"><span class=\"comment\">\t * singleton\t单例（默认），在spring容器创建时就创建实例了</span></span><br><span class=\"line\"><span class=\"comment\">\t * request\t\t同一个请求创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * session\t\t同一个session创建一个实例（很少用到）</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lazy\"><a href=\"#Lazy\" class=\"headerlink\" title=\"@Lazy\"></a>@Lazy</h3><p>懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;创建student对象&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;张三&quot;</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Conditional\"><a href=\"#Conditional\" class=\"headerlink\" title=\"@Conditional\"></a>@Conditional</h3><p>可以作用在类或方法上。<br>作用在方法上： 如果条件返回true，则创建bean<br>作用在类上： 如果返回true，此类的注册bean才会生效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">@Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;windows&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is windows&quot;</span>, <span class=\"number\">60</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(&quot;linux&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">student3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;my is linux&quot;</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否是Linux系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinuxCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;linux&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断是否是windows系统</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * context：程序上下文</span></span><br><span class=\"line\"><span class=\"comment\">\t * metadata：注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean工厂</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//程序运行环境</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\t<span class=\"comment\">//bean注册信息</span></span><br><span class=\"line\">\t\tBeanDefinitionRegistry registry = context.getRegistry();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tString name = environment.getProperty(<span class=\"string\">&quot;os.name&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(name.contains(<span class=\"string\">&quot;Windows&quot;</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"CAS","date":"2021-08-10T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是CAS \n    CAS compare and swap的缩写，中文翻译成 比较并替换\n    \n    CAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n    如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n    无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\n    CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n\n## CAS的目的\n    利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n    其他院子操作都是利用类似的特性完成的。\n    而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n\n## CAS 存在的问题\n    CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n* ABA问题  \n    因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。  \n    但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。  \n    ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一  \n    那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。\n\n* 循环时间长开销大  \n    自选CAS如果长时间不成功，会给CPU带来很大的开销。\n    如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。  \n    pause 指令的作用\n    * 它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零\n    * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   \n\n* 只能保证一个共享变量的原子操作  \n    当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。  \n    解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作\n``` java\npublic class HelloWorld{\n    private int data = 0;\n\n    public synchronized void increment(){\n        data++;\n    }\n\n    // 多个线程同时调用方法：increment（）;\n}\n```\n\n## atmoic原子类及其底层原理\n    对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n    他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n```java\npublic class HelloWorld {\n    \n    private AtomicInteger data = new AtomicInteger(0);\n\n    //多个线程并发的执行：data.incrementAndGet()\n}\n```\n多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。\n\n    Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-1.jpg)\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-2.png)\n\n    上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n    先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n\n## java8 如何对CAS 进行了优化\n    atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n    如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n    于是JAVA 8 推出了一个新的类 LongAdder.  \n    LongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\n    LongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n    竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n    这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\n    LongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n    但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \n    LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \n    LongAdder 在保证高效的同时，也需要消耗更多的空间\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/LongAdder-1.jpg) \n\n```java\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.LongAdder;\n\n/**\n * <pre>\n * 程序目的：和 AtomicLong 进行性能对比\n * </pre>\n * created at 2020/8/11 06:25\n * @author lerry\n */\npublic class LongAdderDemo {\n /**\n  * 线程池内线程数\n  */\n final static int POOL_SIZE = 1000;\n\n public static void main(String[] args) throws InterruptedException {\n    long start = System.currentTimeMillis();\n\n    LongAdder counter = new LongAdder();\n    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);\n\n    ArrayList<Future> futures = new ArrayList<>(POOL_SIZE);\n    for (int i = 0; i < POOL_SIZE * 100; i++) {\n    futures.add(service.submit(new LongAdderDemo.Task(counter)));\n    }\n\n    // 等待所有线程执行完\n    for (Future future : futures) {\n    try {\n        future.get();\n    }\n    catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n    }\n\n    NumberFormat numberFormat = NumberFormat.getInstance();\n    System.out.printf(\"统计结果为：[%s]\\n\", numberFormat.format(counter.sum()));\n    System.out.printf(\"耗时：[%d]毫秒\", (System.currentTimeMillis() - start));\n    // 关闭线程池\n    service.shutdown();\n }\n\n /**\n  * 有一个 LongAdder 成员变量，每次执行N次+1操作\n  */\n static class Task implements Runnable {\n\n  private final LongAdder counter;\n\n  public Task(LongAdder counter) {\n   this.counter = counter;\n  }\n\n  /**\n   * 每个线程执行N次+1操作\n   */\n  @Override\n  public void run() {\n    for (int i = 0; i < 100; i++) {\n        counter.increment();\n    }\n  }// end run\n }// end class\n}\n```\n\n[来源参考] https://shishan100.gitee.io/docs/#/./docs/page/page2\n[微信参考链接] https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\n[LongAdder实践](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect)\n\n","source":"_posts/lh/并发编程/CAS.md","raw":"---\ntitle: CAS\ndate: 2021-08-11 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是CAS \n    CAS compare and swap的缩写，中文翻译成 比较并替换\n    \n    CAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n    如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n    无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\n    CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n\n## CAS的目的\n    利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n    其他院子操作都是利用类似的特性完成的。\n    而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n\n## CAS 存在的问题\n    CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n* ABA问题  \n    因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。  \n    但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。  \n    ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一  \n    那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。\n\n* 循环时间长开销大  \n    自选CAS如果长时间不成功，会给CPU带来很大的开销。\n    如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。  \n    pause 指令的作用\n    * 它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零\n    * 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   \n\n* 只能保证一个共享变量的原子操作  \n    当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。  \n    解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作\n``` java\npublic class HelloWorld{\n    private int data = 0;\n\n    public synchronized void increment(){\n        data++;\n    }\n\n    // 多个线程同时调用方法：increment（）;\n}\n```\n\n## atmoic原子类及其底层原理\n    对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n    他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n```java\npublic class HelloWorld {\n    \n    private AtomicInteger data = new AtomicInteger(0);\n\n    //多个线程并发的执行：data.incrementAndGet()\n}\n```\n多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。\n\n    Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-1.jpg)\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/atomic-2.png)\n\n    上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n    先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n\n## java8 如何对CAS 进行了优化\n    atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n    如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n    于是JAVA 8 推出了一个新的类 LongAdder.  \n    LongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\n    LongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n    竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n    这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\n    LongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n    但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \n    LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \n    LongAdder 在保证高效的同时，也需要消耗更多的空间\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/LongAdder-1.jpg) \n\n```java\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.LongAdder;\n\n/**\n * <pre>\n * 程序目的：和 AtomicLong 进行性能对比\n * </pre>\n * created at 2020/8/11 06:25\n * @author lerry\n */\npublic class LongAdderDemo {\n /**\n  * 线程池内线程数\n  */\n final static int POOL_SIZE = 1000;\n\n public static void main(String[] args) throws InterruptedException {\n    long start = System.currentTimeMillis();\n\n    LongAdder counter = new LongAdder();\n    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);\n\n    ArrayList<Future> futures = new ArrayList<>(POOL_SIZE);\n    for (int i = 0; i < POOL_SIZE * 100; i++) {\n    futures.add(service.submit(new LongAdderDemo.Task(counter)));\n    }\n\n    // 等待所有线程执行完\n    for (Future future : futures) {\n    try {\n        future.get();\n    }\n    catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n    }\n\n    NumberFormat numberFormat = NumberFormat.getInstance();\n    System.out.printf(\"统计结果为：[%s]\\n\", numberFormat.format(counter.sum()));\n    System.out.printf(\"耗时：[%d]毫秒\", (System.currentTimeMillis() - start));\n    // 关闭线程池\n    service.shutdown();\n }\n\n /**\n  * 有一个 LongAdder 成员变量，每次执行N次+1操作\n  */\n static class Task implements Runnable {\n\n  private final LongAdder counter;\n\n  public Task(LongAdder counter) {\n   this.counter = counter;\n  }\n\n  /**\n   * 每个线程执行N次+1操作\n   */\n  @Override\n  public void run() {\n    for (int i = 0; i < 100; i++) {\n        counter.increment();\n    }\n  }// end run\n }// end class\n}\n```\n\n[来源参考] https://shishan100.gitee.io/docs/#/./docs/page/page2\n[微信参考链接] https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\n[LongAdder实践](https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect)\n\n","slug":"lh/并发编程/CAS","published":1,"updated":"2021-09-01T02:45:39.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836i001xhct72v3dh98e","content":"<h1 id=\"什么是CAS\"><a href=\"#什么是CAS\" class=\"headerlink\" title=\"什么是CAS\"></a>什么是CAS</h1><pre><code>CAS compare and swap的缩写，中文翻译成 比较并替换\n\nCAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\nCAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n</code></pre>\n<h2 id=\"CAS的目的\"><a href=\"#CAS的目的\" class=\"headerlink\" title=\"CAS的目的\"></a>CAS的目的</h2><pre><code>利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n其他院子操作都是利用类似的特性完成的。\n而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n</code></pre>\n<h2 id=\"CAS-存在的问题\"><a href=\"#CAS-存在的问题\" class=\"headerlink\" title=\"CAS 存在的问题\"></a>CAS 存在的问题</h2><pre><code>CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n</code></pre>\n<ul>\n<li><p>ABA问题<br>  因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。<br>  但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。<br>  ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一<br>  那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。</p>\n</li>\n<li><p>循环时间长开销大<br>  自选CAS如果长时间不成功，会给CPU带来很大的开销。<br>  如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。<br>  pause 指令的作用</p>\n<ul>\n<li>它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   </li>\n</ul>\n</li>\n<li><p>只能保证一个共享变量的原子操作<br>  当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。<br>  解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        data++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个线程同时调用方法：increment（）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"atmoic原子类及其底层原理\"><a href=\"#atmoic原子类及其底层原理\" class=\"headerlink\" title=\"atmoic原子类及其底层原理\"></a>atmoic原子类及其底层原理</h2><pre><code>对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger data = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//多个线程并发的执行：data.incrementAndGet()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。</p>\n<pre><code>Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-1.jpg\"></p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-2.png\"></p>\n<pre><code>上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n</code></pre>\n<h2 id=\"java8-如何对CAS-进行了优化\"><a href=\"#java8-如何对CAS-进行了优化\" class=\"headerlink\" title=\"java8 如何对CAS 进行了优化\"></a>java8 如何对CAS 进行了优化</h2><pre><code>atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n于是JAVA 8 推出了一个新的类 LongAdder.  \nLongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\nLongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\nLongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \nLongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \nLongAdder 在保证高效的同时，也需要消耗更多的空间\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/LongAdder-1.jpg\"> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.NumberFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 程序目的：和 AtomicLong 进行性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * created at 2020/8/11 06:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lerry</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongAdderDemo</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 线程池内线程数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> POOL_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    LongAdder counter = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;Future&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(POOL_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; POOL_SIZE * <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    futures.add(service.submit(<span class=\"keyword\">new</span> LongAdderDemo.Task(counter)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有线程执行完</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Future future : futures) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        future.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NumberFormat numberFormat = NumberFormat.getInstance();</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;统计结果为：[%s]\\n&quot;</span>, numberFormat.format(counter.sum()));</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;耗时：[%d]毫秒&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class=\"line\">    <span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    service.shutdown();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 有一个 LongAdder 成员变量，每次执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LongAdder counter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(LongAdder counter)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.counter = counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 每个线程执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        counter.increment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;<span class=\"comment\">// end run</span></span><br><span class=\"line\"> &#125;<span class=\"comment\">// end class</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[来源参考] <a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page2\">https://shishan100.gitee.io/docs/#/./docs/page/page2</a><br>[微信参考链接] <a href=\"https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\">https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect\">LongAdder实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是CAS\"><a href=\"#什么是CAS\" class=\"headerlink\" title=\"什么是CAS\"></a>什么是CAS</h1><pre><code>CAS compare and swap的缩写，中文翻译成 比较并替换\n\nCAS 操作包含三个操作数 内存位置（V）、预期原值(A) 和新值(B)\n如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。\n无论哪种情况，它都会在CAS指令之前返回改位置的值。在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。\n\nCAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。\n</code></pre>\n<h2 id=\"CAS的目的\"><a href=\"#CAS的目的\" class=\"headerlink\" title=\"CAS的目的\"></a>CAS的目的</h2><pre><code>利用CPU的 CAS指令，同事接祖JNI来完成java的非阻塞算法。\n其他院子操作都是利用类似的特性完成的。\n而这个JUC都是建立在CAS之上的，同时对于synchronized阻塞算法，JUC在性能上有了很大的提升。\n</code></pre>\n<h2 id=\"CAS-存在的问题\"><a href=\"#CAS-存在的问题\" class=\"headerlink\" title=\"CAS 存在的问题\"></a>CAS 存在的问题</h2><pre><code>CAS 虽然很高效的解决原子操作，但是CAS任然存在三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作。\n</code></pre>\n<ul>\n<li><p>ABA问题<br>  因为CAS在操作值得时候需要判断值有没有发生变化，没有发生变化则更新。<br>  但是如果一直原来是A，变成了B，又变成了A，那么使用CAS进行检查时发现值么有发生变化，但是实际值却是变化了。<br>  ABA问题的解决思路就是使用版本号。在变量钱追加版本号，每次变量更新的时候版本号加一<br>  那么A -B -A 就会变成 1A -2B -3A. 随着jdk版本迭代也推出了atomic原子类进行优化。</p>\n</li>\n<li><p>循环时间长开销大<br>  自选CAS如果长时间不成功，会给CPU带来很大的开销。<br>  如果JVM能支持处理的提供的pause指令，那么效率会有一定的提升。<br>  pause 指令的作用</p>\n<ul>\n<li>它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。   </li>\n</ul>\n</li>\n<li><p>只能保证一个共享变量的原子操作<br>  当对一个共享变量进行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。<br>  解决办法：可以引入锁机制（比如synchronized），或者将多个共享变量合并成一个共享变量来操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        data++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个线程同时调用方法：increment（）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"atmoic原子类及其底层原理\"><a href=\"#atmoic原子类及其底层原理\" class=\"headerlink\" title=\"atmoic原子类及其底层原理\"></a>atmoic原子类及其底层原理</h2><pre><code>对于简单的data++类的操作，可以换一种做法，JAVA并发包（JUC）下面提供了一系列的Atmoic原子类，比如AtmoicInteger。\n他可以保证多线程并发安全的情况下，高性能的并发更新一个数值。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger data = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//多个线程并发的执行：data.incrementAndGet()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个线程并发的执行AtmoicInteger的incrementAndGet()方法，意思就是给data的值累加1，接着返回累加后最新的值。</p>\n<pre><code>Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-1.jpg\"></p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/atomic-2.png\"></p>\n<pre><code>上面整个过程就是Atomic原子类的原理，没有基于加锁机制串行化，而是基于CAS机制，。\n先获取一个值，然后发起CAS，比较整个值有没有被改过，如果没有，则更新,CAS 是原子的，不会被打断。\n</code></pre>\n<h2 id=\"java8-如何对CAS-进行了优化\"><a href=\"#java8-如何对CAS-进行了优化\" class=\"headerlink\" title=\"java8 如何对CAS 进行了优化\"></a>java8 如何对CAS 进行了优化</h2><pre><code>atomic是基于CAS机制来处理数据的，但是CAS也是有缺陷的。\n如果大量的线程同事并发修改一个AtomicInteger，可能有很多的线程会不停的自旋，判断值是否有修改，有修改，然后进入一个空循环中，消耗CPU性能。\n\n于是JAVA 8 推出了一个新的类 LongAdder.  \nLongAdder是道格·利（Doug Lea的中文名）在java8中发布的类。\n\nLongAdder也有一个volatile修饰的base值，但是当竞争激烈时，多个线程并不会一直自旋来修改这个值，而是采用了分段的思想。  \n竞争激烈时，各个线程会分散累加到自己所对应的Cell[]数组的某一个数组对象元素中，而不会大家共用一个。\n\n这样做，可以把不同线程对应到不同的Cell中进行修改，降低了对临界资源的竞争。本质上，是用空间换时间。\n\nLongAdder是尝试使用分段CAS以及自动分段迁移的方式来大幅提升多线程高并发执行CAS操作的性能，降低了线程间的竞争冲突。\n\n但是在竞争激烈的情况下，LongAdder 的预期吞吐量要高得多，经过试验，  \nLongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价。  \nLongAdder 在保证高效的同时，也需要消耗更多的空间\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/LongAdder-1.jpg\"> </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.NumberFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 程序目的：和 AtomicLong 进行性能对比</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * created at 2020/8/11 06:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> lerry</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongAdderDemo</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 线程池内线程数</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> POOL_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    LongAdder counter = <span class=\"keyword\">new</span> LongAdder();</span><br><span class=\"line\">    ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;Future&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(POOL_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; POOL_SIZE * <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">    futures.add(service.submit(<span class=\"keyword\">new</span> LongAdderDemo.Task(counter)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有线程执行完</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Future future : futures) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        future.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NumberFormat numberFormat = NumberFormat.getInstance();</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;统计结果为：[%s]\\n&quot;</span>, numberFormat.format(counter.sum()));</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;耗时：[%d]毫秒&quot;</span>, (System.currentTimeMillis() - start));</span><br><span class=\"line\">    <span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">    service.shutdown();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 有一个 LongAdder 成员变量，每次执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LongAdder counter;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(LongAdder counter)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.counter = counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 每个线程执行N次+1操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        counter.increment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;<span class=\"comment\">// end run</span></span><br><span class=\"line\"> &#125;<span class=\"comment\">// end class</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[来源参考] <a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page2\">https://shishan100.gitee.io/docs/#/./docs/page/page2</a><br>[微信参考链接] <a href=\"https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg\">https://mp.weixin.qq.com/s/NMm7NQt9A1oVwmPgLdzIHg</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483926&idx=1&sn=2a796ef514dea15790e45d79d233833e&chksm=fba6ea15ccd1630387b8738a00a8c1dc6ae0c535305ec4d6e3c76d64eff48bf1d47ae0eaea07&scene=21#wechat_redirect\">LongAdder实践</a></p>\n"},{"title":"volatile","date":"2021-08-09T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 为什么用volatile\n    假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n    那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n\n   ![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-1.jpg)\n\n    这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n    这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n    一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n    这就是所谓的 java 并发编程中的可见性问题:\n    多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n\n# volatile的作用及背后原理\n    要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？\n```java\npublic class HelloWorld {\n    private volatile int data = 0;\n\n    //线程1会读取和修改data变量值\n\n    //线程2会读取data变量值\n\n}\n```\n\n## volatile的作用\n    1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n    让主内存里的data的值立马变成最新的值\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-3.jpg)\n\n    2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-4.jpg)\n\n    3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-5.jpg)\n\n## volatile的特殊规则\n    read、load、use动作必须连续出现。\n    assign、store、write动作必须连续出现。\n\n\n## 内存屏障\nJVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：\n* LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。\n\n* StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。\n\n* LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。\n\n* StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。\n    * StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。\n\n\n需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-6.png)\n\n\n# 总结\n    每次读取前必须先从主内存刷新到最新的值。\n    每次写入后必须立即同步回主内存当中。\n\n    最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n    有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n    也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n    但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\n    volatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n    原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n\n\n","source":"_posts/lh/并发编程/volatile.md","raw":"---\ntitle: volatile\ndate: 2021-08-10 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 为什么用volatile\n    假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n    那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n\n   ![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-1.jpg)\n\n    这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n    这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n    一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n    这就是所谓的 java 并发编程中的可见性问题:\n    多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n\n# volatile的作用及背后原理\n    要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？\n```java\npublic class HelloWorld {\n    private volatile int data = 0;\n\n    //线程1会读取和修改data变量值\n\n    //线程2会读取data变量值\n\n}\n```\n\n## volatile的作用\n    1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n    让主内存里的data的值立马变成最新的值\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-3.jpg)\n\n    2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-4.jpg)\n\n    3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-5.jpg)\n\n## volatile的特殊规则\n    read、load、use动作必须连续出现。\n    assign、store、write动作必须连续出现。\n\n\n## 内存屏障\nJVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：\n* LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。\n\n* StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。\n\n* LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。\n\n* StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。\n    * StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。\n\n\n需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/volatile-6.png)\n\n\n# 总结\n    每次读取前必须先从主内存刷新到最新的值。\n    每次写入后必须立即同步回主内存当中。\n\n    最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n    有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n    也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n    但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\n    volatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n    原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n\n\n","slug":"lh/并发编程/volatile","published":1,"updated":"2021-09-02T07:08:46.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836i0022hct73ab66cxt","content":"<h1 id=\"为什么用volatile\"><a href=\"#为什么用volatile\" class=\"headerlink\" title=\"为什么用volatile\"></a>为什么用volatile</h1><pre><code>假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n</code></pre>\n<p>   <img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-1.jpg\"></p>\n<pre><code>这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n这就是所谓的 java 并发编程中的可见性问题:\n多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n</code></pre>\n<h1 id=\"volatile的作用及背后原理\"><a href=\"#volatile的作用及背后原理\" class=\"headerlink\" title=\"volatile的作用及背后原理\"></a>volatile的作用及背后原理</h1><pre><code>要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n</code></pre>\n<p>比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程1会读取和修改data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程2会读取data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"volatile的作用\"><a href=\"#volatile的作用\" class=\"headerlink\" title=\"volatile的作用\"></a>volatile的作用</h2><pre><code>1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n让主内存里的data的值立马变成最新的值\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-3.jpg\"></p>\n<pre><code>2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-4.jpg\"></p>\n<pre><code>3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-5.jpg\"></p>\n<h2 id=\"volatile的特殊规则\"><a href=\"#volatile的特殊规则\" class=\"headerlink\" title=\"volatile的特殊规则\"></a>volatile的特殊规则</h2><pre><code>read、load、use动作必须连续出现。\nassign、store、write动作必须连续出现。\n</code></pre>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>JVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：</p>\n<ul>\n<li><p>LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。</p>\n</li>\n<li><p>LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。</p>\n<ul>\n<li>StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-6.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>每次读取前必须先从主内存刷新到最新的值。\n每次写入后必须立即同步回主内存当中。\n\n最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\nvolatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么用volatile\"><a href=\"#为什么用volatile\" class=\"headerlink\" title=\"为什么用volatile\"></a>为什么用volatile</h1><pre><code>假设 线程1 修改了data的变量为1，然后将这个修改写入到了自己的本地工作内存中。\n那么此时，线程1的工作内存中data的值为1，而主内存和线程2中的data的值任然是1!\n</code></pre>\n<p>   <img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-1.jpg\"></p>\n<pre><code>这可尴尬了，那接下来，在线程 1 的代码运行过程中，他可以直接读到 data 最新的值是 1，但是线程 2 的代码运行过程中读到的 data 的值还是 0！\n这就导致，线程 1 和线程 2 其实都是在操作一个变量 data，但是线程 1 修改了 data 变量的值之后，线程 2 是看不到的，\n一直都是看到自己本地工作内存中的一个旧的副本的值！\n\n这就是所谓的 java 并发编程中的可见性问题:\n多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到！也就是对其他线程不可见！\n</code></pre>\n<h1 id=\"volatile的作用及背后原理\"><a href=\"#volatile的作用及背后原理\" class=\"headerlink\" title=\"volatile的作用及背后原理\"></a>volatile的作用及背后原理</h1><pre><code>要解决上面的问题，引入volatile既可以解决并发编程中的可见性问题。\n</code></pre>\n<p>比如下面的这样的代码，在加了 volatile 之后，会有啥作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> data = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程1会读取和修改data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程2会读取data变量值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"volatile的作用\"><a href=\"#volatile的作用\" class=\"headerlink\" title=\"volatile的作用\"></a>volatile的作用</h2><pre><code>1. volatile修饰的共享变量data，线程1修改data的值，就会在修改本地工作内存的data值之后，强制将data变量最新的值刷回主内存，\n让主内存里的data的值立马变成最新的值\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-3.jpg\"></p>\n<pre><code>2. 如果此时如果其他的线程中也存有这个data变量的本地缓存，那么会强制让其他线程的工作内存中的 data 变量缓存直接失效过期，不允许再次读取和使用了！\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-4.jpg\"></p>\n<pre><code>3. 如果其他线程想再次获取data时，尝试获取本地工作内存的data变量值，发现失效了，此时，就必须从主内存中获取data变量最新的值。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-5.jpg\"></p>\n<h2 id=\"volatile的特殊规则\"><a href=\"#volatile的特殊规则\" class=\"headerlink\" title=\"volatile的特殊规则\"></a>volatile的特殊规则</h2><pre><code>read、load、use动作必须连续出现。\nassign、store、write动作必须连续出现。\n</code></pre>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>JVM 中内存屏障是一组处理器指令，用来实现对内存操作的顺序限制（避免了重排序）。它可以分为下面几种：</p>\n<ul>\n<li><p>LoadLoad（Load1; LoadLoad；Load2）：Load2 及后续读操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreStore（Store1; StoreStore; Store2）：Store2 及后续写入操作之前，保证 Store1 的写入对其他处理器可见。</p>\n</li>\n<li><p>LoadStore（Load1; LoadLoad；Store2）：Store2 及后续写操作之前，保证 Load1 先读取完。</p>\n</li>\n<li><p>StoreLoad（Store1; StoreStore; Load2）：Load2 及后续读操作之前，保证 Store1 的写入对其他处理器可见。</p>\n<ul>\n<li>StoreLoad 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是：volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/volatile-6.png\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>每次读取前必须先从主内存刷新到最新的值。\n每次写入后必须立即同步回主内存当中。\n\n最后给大家提一嘴，volatile 主要作用是保证可见性以及有序性。\n\n有序性涉及到较为复杂的指令重排、内存屏障等概念，本文没提及，但是 volatile 是不能保证原子性的！\n\n也就是说，volatile 主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！\n\n但是如果是多个线程同时修改一个变量的值，那还是可能出现多线程并发的安全问题，导致数据值修改错乱，\nvolatile 是不负责解决这个问题的，也就是不负责解决原子性问题！\n\n原子性问题，得依赖 synchronized、ReentrantLock 等加锁机制来解决。\n</code></pre>\n"},{"title":"AQS","date":"2021-08-26T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是AQS\n    AQS Abstract Queued Synchronizer 抽象队列同步器\n    \n    AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n    \n    AQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\n    AQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n    \n![](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_1.jpg)\n\n## java并发与AQS的关系\n\njava 并发api的使用 简单如 \n\n```java\nReentrantLock lock = new ReentrantLock();\n\nlock.lock(); //加锁\n\n//...业务逻辑\n\nlock.unlock();//释放锁\n\n//以上代码：初始化一个lock 对象，然后加锁 和释放锁\n```\n\n    以reentrantLock为例， 与AQS的关系主要是因为：\n    java并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\n    AQS 是java并发包的基础类。\n\n\n## ReentrantLock-重入锁\n    可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n    也就是可以对一个锁加锁解锁多次\n\n每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。\n\n## ReentrantLock的加锁和释放锁的底层原理\n    当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n\n1. 线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。\n    如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功\n    \n    线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己\n    \n![线程1尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_2.jpg)  \n\n    从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n    内核中实现的锁机制都是用来的AQS实现的。\n\n2. 线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败\n\n![线程2尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_3.jpg)  \n\n    接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n    当线程1是否锁后，可以再次尝试去加锁\n\n![AQS加锁失败等待队列](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_4.jpg)  \n\n线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null\n![线程1释放锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_5.jpg)\n\n\n3. 接下来就是从等待队列中唤醒线程2尝试重新加锁。\n    线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己\n\n![线程2唤醒后尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_6.jpg)\n\n# 总结\n    本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\n    AQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n    它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n\n[来源参考]：https://shishan100.gitee.io/docs/#/./docs/page/page3","source":"_posts/lh/并发编程/AQS.md","raw":"---\ntitle: AQS\ndate: 2021-08-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是AQS\n    AQS Abstract Queued Synchronizer 抽象队列同步器\n    \n    AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n    \n    AQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\n    AQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n    \n![](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_1.jpg)\n\n## java并发与AQS的关系\n\njava 并发api的使用 简单如 \n\n```java\nReentrantLock lock = new ReentrantLock();\n\nlock.lock(); //加锁\n\n//...业务逻辑\n\nlock.unlock();//释放锁\n\n//以上代码：初始化一个lock 对象，然后加锁 和释放锁\n```\n\n    以reentrantLock为例， 与AQS的关系主要是因为：\n    java并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\n    AQS 是java并发包的基础类。\n\n\n## ReentrantLock-重入锁\n    可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n    也就是可以对一个锁加锁解锁多次\n\n每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。\n\n## ReentrantLock的加锁和释放锁的底层原理\n    当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n\n1. 线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。\n    如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功\n    \n    线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己\n    \n![线程1尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_2.jpg)  \n\n    从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n    内核中实现的锁机制都是用来的AQS实现的。\n\n2. 线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败\n\n![线程2尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_3.jpg)  \n\n    接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n    当线程1是否锁后，可以再次尝试去加锁\n\n![AQS加锁失败等待队列](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_4.jpg)  \n\n线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null\n![线程1释放锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_5.jpg)\n\n\n3. 接下来就是从等待队列中唤醒线程2尝试重新加锁。\n    线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己\n\n![线程2唤醒后尝试加锁](https://kubpang.gitee.io/sourceFile/Java/并发/ReentrantLock与AQS_6.jpg)\n\n# 总结\n    本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\n    AQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n    它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n\n[来源参考]：https://shishan100.gitee.io/docs/#/./docs/page/page3","slug":"lh/并发编程/AQS","published":1,"updated":"2021-09-01T02:45:26.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836j0023hct7b6cq50ck","content":"<h1 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h1><pre><code>AQS Abstract Queued Synchronizer 抽象队列同步器\n\nAQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n\nAQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\nAQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_1.jpg\"></p>\n<h2 id=\"java并发与AQS的关系\"><a href=\"#java并发与AQS的关系\" class=\"headerlink\" title=\"java并发与AQS的关系\"></a>java并发与AQS的关系</h2><p>java 并发api的使用 简单如 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">//加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">lock.unlock();<span class=\"comment\">//释放锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以上代码：初始化一个lock 对象，然后加锁 和释放锁</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>以reentrantLock为例， 与AQS的关系主要是因为：\njava并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\nAQS 是java并发包的基础类。\n</code></pre>\n<h2 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock-重入锁\"></a>ReentrantLock-重入锁</h2><pre><code>可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n也就是可以对一个锁加锁解锁多次\n</code></pre>\n<p>每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。</p>\n<h2 id=\"ReentrantLock的加锁和释放锁的底层原理\"><a href=\"#ReentrantLock的加锁和释放锁的底层原理\" class=\"headerlink\" title=\"ReentrantLock的加锁和释放锁的底层原理\"></a>ReentrantLock的加锁和释放锁的底层原理</h2><pre><code>当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n</code></pre>\n<ol>\n<li>线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。<br> 如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功 线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_2.jpg\" alt=\"线程1尝试加锁\">  </p>\n<pre><code>从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n内核中实现的锁机制都是用来的AQS实现的。\n</code></pre>\n<ol start=\"2\">\n<li>线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_3.jpg\" alt=\"线程2尝试加锁\">  </p>\n<pre><code>接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n当线程1是否锁后，可以再次尝试去加锁\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_4.jpg\" alt=\"AQS加锁失败等待队列\">  </p>\n<p>线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_5.jpg\" alt=\"线程1释放锁\"></p>\n<ol start=\"3\">\n<li>接下来就是从等待队列中唤醒线程2尝试重新加锁。<br> 线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_6.jpg\" alt=\"线程2唤醒后尝试加锁\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\nAQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n</code></pre>\n<p>[来源参考]：<a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page3\">https://shishan100.gitee.io/docs/#/./docs/page/page3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h1><pre><code>AQS Abstract Queued Synchronizer 抽象队列同步器\n\nAQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它一个\n\nAQS对象内部的有一个核心变量state， int类型，代表加锁状态。初始化状态下state为0\nAQS 内部还有一个关键变量，用来记录当前加锁的事哪个线程，init下这个变量为null\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_1.jpg\"></p>\n<h2 id=\"java并发与AQS的关系\"><a href=\"#java并发与AQS的关系\" class=\"headerlink\" title=\"java并发与AQS的关系\"></a>java并发与AQS的关系</h2><p>java 并发api的使用 简单如 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">//加锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...业务逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">lock.unlock();<span class=\"comment\">//释放锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以上代码：初始化一个lock 对象，然后加锁 和释放锁</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>以reentrantLock为例， 与AQS的关系主要是因为：\njava并发包下很多API都是基于AQS来实现 加锁和释放锁的等功能的，\nAQS 是java并发包的基础类。\n</code></pre>\n<h2 id=\"ReentrantLock-重入锁\"><a href=\"#ReentrantLock-重入锁\" class=\"headerlink\" title=\"ReentrantLock-重入锁\"></a>ReentrantLock-重入锁</h2><pre><code>可重入锁即是 可以对一个ReentrantLock对象多次的执行 lock()与unlock()操作。\n也就是可以对一个锁加锁解锁多次\n</code></pre>\n<p>每次线程可重入加锁一次，会判断一下 当前加锁的线程如果是自己，那么就线程就可重入多次加锁，每次加锁都是将state的 值累加1，其他不变化。</p>\n<h2 id=\"ReentrantLock的加锁和释放锁的底层原理\"><a href=\"#ReentrantLock的加锁和释放锁的底层原理\" class=\"headerlink\" title=\"ReentrantLock的加锁和释放锁的底层原理\"></a>ReentrantLock的加锁和释放锁的底层原理</h2><pre><code>当一个ReentrantLock 尝试对一个对象进行lock 操作时 主要有以下操作\n</code></pre>\n<ol>\n<li>线程1通过调用ReentranLock的lock()来参数进行加锁，这里的加锁过程是直接通过CAS操作将 state 由0 变为1。<br> 如果之前没有线程尝试过获取锁，那么state肯定为0，此时线程1就可以加锁成功 线程1加锁成功后，就可以设置AQS的加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_2.jpg\" alt=\"线程1尝试加锁\">  </p>\n<pre><code>从上面的图中可以简单的看出 ReentrantLock 其实就是一个外层API，\n内核中实现的锁机制都是用来的AQS实现的。\n</code></pre>\n<ol start=\"2\">\n<li>线程1加锁了后，线程2跑过来加锁时，会通过CAS判断state是否为0，为1则代表了当前对象有线程加锁了。紧接着会去判断，加锁线程是否为自己，是自己则获取锁成功，而当前是线程1获取，则线程2 获取锁失败</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_3.jpg\" alt=\"线程2尝试加锁\">  </p>\n<pre><code>接着 线程2 会将自己放入AQS的一个线程的等待队列中等待，\n当线程1是否锁后，可以再次尝试去加锁\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_4.jpg\" alt=\"AQS加锁失败等待队列\">  </p>\n<p>线程1在执行完业务逻辑后，就会释放锁，释放锁的过程很简单，就是将AQS的state值逐步减1，当state为0时，则彻底释放锁，同时设置加锁线程变量为null<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_5.jpg\" alt=\"线程1释放锁\"></p>\n<ol start=\"3\">\n<li>接下来就是从等待队列中唤醒线程2尝试重新加锁。<br> 线程2开始重复步骤2的操作加锁，加锁成功后，将state设置1，并将加锁线程变量设置为自己</li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/ReentrantLock%E4%B8%8EAQS_6.jpg\" alt=\"线程2唤醒后尝试加锁\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><pre><code>本文主要介绍了AQS的作用、ReentrantLock以及AQS与java并发的关系\nAQS 其实就是一个java并发的基础组件，用来实现各种锁、各种同步组件。  \n它包含了：state变量、加锁线程变量、等待队列等并发中的核心组件。\n</code></pre>\n<p>[来源参考]：<a href=\"https://shishan100.gitee.io/docs/#/./docs/page/page3\">https://shishan100.gitee.io/docs/#/./docs/page/page3</a></p>\n"},{"title":"并发编程初讲","date":"2021-08-09T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 基础概念\n\n## 什么是线程和进程\n    在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n\n* 进程：是程序的一次执行过程，系统运行程序的基本单位。\n    * 系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n\n* 线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。\n    * 多个线程共享进程的堆和方法区。\n    * 每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。\n\n## 什么是并发和并行 \n* 并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）\n\n* 并行：单位时间内，多个任务同时执行。\n\n\n## 说说线程的生命周期\n    线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n\n* 初始状态（NEW）：线程被构建，但是没有调用start方法。\n\n* 运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。\n\n* 阻塞状态(BLOCKED): 线程被锁阻塞了。\n\n* 等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。\n\n* 超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。\n\n* 终止状态（TERMIATEB）: 线程执行结束。\n\n    线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/并发状态流程图.png)\n \n    线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n    当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n    而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n    线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n\n## 线程的结束\n1. 设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。\n\n2. 使用interrupt()方法中断线程\n\n3. 使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）\n\n\n## 并发编程的三大特性\n    并发编程的三大特性只要是：原子性、可见性、有序性\n\n* 原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。\n\n* 可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。\n\n* 有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。\n\n\n## java的内存模型 JMM\n用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。\n\n    用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\n    JMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n    本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n![](https://kubpang.gitee.io/sourceFile/Java/并发/JMM-1.png)\n\n\n## JAVA 变量的读写\n我们在看Volatile关键字的时候先了解一下java变量的读写：  \n（1）lock：作用于主内存，把变量标识为线程独占状态。\n\n（2）unlock：作用于主内存，解除独占状态。\n\n（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。\n\n（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。\n\n（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。\n\n（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。\n\n（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。\n\n（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。\n\n## 重排序\n在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n\n* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n* 内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 \n\n    这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。\n\n## happens-before原则\n* 程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。\n* 锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。\n* volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。\n* 传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。\n* 线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。\n* 线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。\n* 线程终结原则：同一个线程所有的操作都优先于线程的终止检测。\n* 对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。\n\n\n## 说说 sleep() 和 wait() 的区别？\n* sleep() 和 wait() 都可以暂停线程的执行。\n* sleep() 不释放锁，wait() 释放锁。\n* sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。\n* sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。\n* sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。\n* wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 \n\n##  为什么不能直接调用 run() 方法？\n* 调用 run() 方法，会被当做普通方法去执行，不是多线程工作。\n\n* 调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作\n\n## 说说 Runnable 和 Callable 的区别？\nRunnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:\n* Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。\n* Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。\n\n    对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。\n    \n    FutureTask 表示一个异步运算的任务。\n    FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。\n    只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。\n \n## volatile 于 synchronized 区别\n    volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\n    synchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\n    volatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\n    n 不仅保证了可见性，也保证了原子性。\n    因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n    多个线程争抢n变量时，会出现阻塞情况\n\n    volatile是轻量级的，因为只能修饰变量。\n    n是重量级的，可以修饰变量、代码块、方法。\n    ","source":"_posts/lh/并发编程/并发编程初讲.md","raw":"---\ntitle: 并发编程初讲\ndate: 2021-08-10 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 基础概念\n\n## 什么是线程和进程\n    在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n\n* 进程：是程序的一次执行过程，系统运行程序的基本单位。\n    * 系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n\n* 线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。\n    * 多个线程共享进程的堆和方法区。\n    * 每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。\n\n## 什么是并发和并行 \n* 并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）\n\n* 并行：单位时间内，多个任务同时执行。\n\n\n## 说说线程的生命周期\n    线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n\n* 初始状态（NEW）：线程被构建，但是没有调用start方法。\n\n* 运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。\n\n* 阻塞状态(BLOCKED): 线程被锁阻塞了。\n\n* 等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。\n\n* 超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。\n\n* 终止状态（TERMIATEB）: 线程执行结束。\n\n    线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。\n\n![](https://kubpang.gitee.io/sourceFile/Java/并发/并发状态流程图.png)\n \n    线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n    当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n    而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n    线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n\n## 线程的结束\n1. 设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。\n\n2. 使用interrupt()方法中断线程\n\n3. 使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）\n\n\n## 并发编程的三大特性\n    并发编程的三大特性只要是：原子性、可见性、有序性\n\n* 原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。\n\n* 可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。\n\n* 有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。\n\n\n## java的内存模型 JMM\n用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。\n\n    用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\n    JMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n    本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n![](https://kubpang.gitee.io/sourceFile/Java/并发/JMM-1.png)\n\n\n## JAVA 变量的读写\n我们在看Volatile关键字的时候先了解一下java变量的读写：  \n（1）lock：作用于主内存，把变量标识为线程独占状态。\n\n（2）unlock：作用于主内存，解除独占状态。\n\n（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。\n\n（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。\n\n（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。\n\n（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。\n\n（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。\n\n（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。\n\n## 重排序\n在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n* 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n\n* 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n\n* 内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 \n\n    这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。\n\n## happens-before原则\n* 程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。\n* 锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。\n* volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。\n* 传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。\n* 线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。\n* 线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。\n* 线程终结原则：同一个线程所有的操作都优先于线程的终止检测。\n* 对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。\n\n\n## 说说 sleep() 和 wait() 的区别？\n* sleep() 和 wait() 都可以暂停线程的执行。\n* sleep() 不释放锁，wait() 释放锁。\n* sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。\n* sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。\n* sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。\n* wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 \n\n##  为什么不能直接调用 run() 方法？\n* 调用 run() 方法，会被当做普通方法去执行，不是多线程工作。\n\n* 调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作\n\n## 说说 Runnable 和 Callable 的区别？\nRunnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:\n* Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。\n* Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。\n\n    对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。\n    \n    FutureTask 表示一个异步运算的任务。\n    FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。\n    只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。\n \n## volatile 于 synchronized 区别\n    volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\n    synchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\n    volatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\n    n 不仅保证了可见性，也保证了原子性。\n    因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n    多个线程争抢n变量时，会出现阻塞情况\n\n    volatile是轻量级的，因为只能修饰变量。\n    n是重量级的，可以修饰变量、代码块、方法。\n    ","slug":"lh/并发编程/并发编程初讲","published":1,"updated":"2021-09-01T02:45:02.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836j0027hct71ny176em","content":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程\"></a>什么是线程和进程</h2><pre><code>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n</code></pre>\n<ul>\n<li><p>进程：是程序的一次执行过程，系统运行程序的基本单位。</p>\n<ul>\n<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>\n</ul>\n</li>\n<li><p>线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。</p>\n<ul>\n<li>多个线程共享进程的堆和方法区。</li>\n<li>每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是并发和并行\"><a href=\"#什么是并发和并行\" class=\"headerlink\" title=\"什么是并发和并行\"></a>什么是并发和并行</h2><ul>\n<li><p>并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）</p>\n</li>\n<li><p>并行：单位时间内，多个任务同时执行。</p>\n</li>\n</ul>\n<h2 id=\"说说线程的生命周期\"><a href=\"#说说线程的生命周期\" class=\"headerlink\" title=\"说说线程的生命周期\"></a>说说线程的生命周期</h2><pre><code>线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n</code></pre>\n<ul>\n<li><p>初始状态（NEW）：线程被构建，但是没有调用start方法。</p>\n</li>\n<li><p>运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。</p>\n</li>\n<li><p>阻塞状态(BLOCKED): 线程被锁阻塞了。</p>\n</li>\n<li><p>等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。</p>\n</li>\n<li><p>超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。</p>\n</li>\n<li><p>终止状态（TERMIATEB）: 线程执行结束。</p>\n<p>  线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。</p>\n</li>\n</ul>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<pre><code>线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n</code></pre>\n<h2 id=\"线程的结束\"><a href=\"#线程的结束\" class=\"headerlink\" title=\"线程的结束\"></a>线程的结束</h2><ol>\n<li><p>设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。</p>\n</li>\n<li><p>使用interrupt()方法中断线程</p>\n</li>\n<li><p>使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）</p>\n</li>\n</ol>\n<h2 id=\"并发编程的三大特性\"><a href=\"#并发编程的三大特性\" class=\"headerlink\" title=\"并发编程的三大特性\"></a>并发编程的三大特性</h2><pre><code>并发编程的三大特性只要是：原子性、可见性、有序性\n</code></pre>\n<ul>\n<li><p>原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。</p>\n</li>\n<li><p>可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。</p>\n</li>\n<li><p>有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。</p>\n</li>\n</ul>\n<h2 id=\"java的内存模型-JMM\"><a href=\"#java的内存模型-JMM\" class=\"headerlink\" title=\"java的内存模型 JMM\"></a>java的内存模型 JMM</h2><p>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>\n<pre><code>用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\nJMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/JMM-1.png\"></p>\n<h2 id=\"JAVA-变量的读写\"><a href=\"#JAVA-变量的读写\" class=\"headerlink\" title=\"JAVA 变量的读写\"></a>JAVA 变量的读写</h2><p>我们在看Volatile关键字的时候先了解一下java变量的读写：<br>（1）lock：作用于主内存，把变量标识为线程独占状态。</p>\n<p>（2）unlock：作用于主内存，解除独占状态。</p>\n<p>（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>\n<p>（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>\n<p>（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>\n<p>（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</p>\n<p>（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</p>\n<p>（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：</p>\n<ul>\n<li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>\n</li>\n<li><p>指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n</li>\n<li><p>内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 </p>\n<p>  这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。</p>\n</li>\n</ul>\n<h2 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h2><ul>\n<li>程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。</li>\n<li>锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。</li>\n<li>volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。</li>\n<li>传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。</li>\n<li>线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。</li>\n<li>线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。</li>\n<li>线程终结原则：同一个线程所有的操作都优先于线程的终止检测。</li>\n<li>对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。</li>\n</ul>\n<h2 id=\"说说-sleep-和-wait-的区别？\"><a href=\"#说说-sleep-和-wait-的区别？\" class=\"headerlink\" title=\"说说 sleep() 和 wait() 的区别？\"></a>说说 sleep() 和 wait() 的区别？</h2><ul>\n<li>sleep() 和 wait() 都可以暂停线程的执行。</li>\n<li>sleep() 不释放锁，wait() 释放锁。</li>\n<li>sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。</li>\n<li>sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。</li>\n<li>sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。</li>\n<li>wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 </li>\n</ul>\n<h2 id=\"为什么不能直接调用-run-方法？\"><a href=\"#为什么不能直接调用-run-方法？\" class=\"headerlink\" title=\"为什么不能直接调用 run() 方法？\"></a>为什么不能直接调用 run() 方法？</h2><ul>\n<li><p>调用 run() 方法，会被当做普通方法去执行，不是多线程工作。</p>\n</li>\n<li><p>调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作</p>\n</li>\n</ul>\n<h2 id=\"说说-Runnable-和-Callable-的区别？\"><a href=\"#说说-Runnable-和-Callable-的区别？\" class=\"headerlink\" title=\"说说 Runnable 和 Callable 的区别？\"></a>说说 Runnable 和 Callable 的区别？</h2><p>Runnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:</p>\n<ul>\n<li><p>Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。</p>\n</li>\n<li><p>Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。</p>\n<p>  对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。</p>\n<p>  FutureTask 表示一个异步运算的任务。<br>  FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。<br>  只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>\n</li>\n</ul>\n<h2 id=\"volatile-于-synchronized-区别\"><a href=\"#volatile-于-synchronized-区别\" class=\"headerlink\" title=\"volatile 于 synchronized 区别\"></a>volatile 于 synchronized 区别</h2><pre><code>volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\nsynchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\nvolatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\nn 不仅保证了可见性，也保证了原子性。\n因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n多个线程争抢n变量时，会出现阻塞情况\n\nvolatile是轻量级的，因为只能修饰变量。\nn是重量级的，可以修饰变量、代码块、方法。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程\"></a>什么是线程和进程</h2><pre><code>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程。\n</code></pre>\n<ul>\n<li><p>进程：是程序的一次执行过程，系统运行程序的基本单位。</p>\n<ul>\n<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>\n</ul>\n</li>\n<li><p>线程：是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。</p>\n<ul>\n<li>多个线程共享进程的堆和方法区。</li>\n<li>每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是并发和并行\"><a href=\"#什么是并发和并行\" class=\"headerlink\" title=\"什么是并发和并行\"></a>什么是并发和并行</h2><ul>\n<li><p>并发：同一时间段，多个任务都在执行 （单位时间内不一定同时执行）</p>\n</li>\n<li><p>并行：单位时间内，多个任务同时执行。</p>\n</li>\n</ul>\n<h2 id=\"说说线程的生命周期\"><a href=\"#说说线程的生命周期\" class=\"headerlink\" title=\"说说线程的生命周期\"></a>说说线程的生命周期</h2><pre><code>线程的生命周期主要分为六个状态：初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态。\n</code></pre>\n<ul>\n<li><p>初始状态（NEW）：线程被构建，但是没有调用start方法。</p>\n</li>\n<li><p>运行状态（RUNNABLE）: 线程在操作系统中处于 就绪或运行两种状态。</p>\n</li>\n<li><p>阻塞状态(BLOCKED): 线程被锁阻塞了。</p>\n</li>\n<li><p>等待状态(WAITING): 线程进入等待状态。需要其他线程通知或直接中断。</p>\n</li>\n<li><p>超时等待状态（TIME_WAITING）: 线程指定了超时时间，可以在超时时间结束后自行返回。</p>\n</li>\n<li><p>终止状态（TERMIATEB）: 线程执行结束。</p>\n<p>  线程不是一直固定在某个状态，而是随着代码的执行在不同状态之间切换。</p>\n</li>\n</ul>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E5%9B%BE.png\"></p>\n<pre><code>线程创建之后它将处于 NEW 状态，调用 start() 方法后开始运行，线程这时候处于就绪状态。就绪状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNABLE 状态。\n\n当线程执行 wait() 方法之后，线程进入 WAITING 状态。进入 WAITING 状态的线程需要依靠其他线程的通知才能够返回到 RUNNABLE 状态，\n而 TIME_WAITING 状态的线程在超时后会自行回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED 状态。\n\n线程在执行完 Runnable 的 run() 方法之后将会进入到 TERMINATED 状态。\n</code></pre>\n<h2 id=\"线程的结束\"><a href=\"#线程的结束\" class=\"headerlink\" title=\"线程的结束\"></a>线程的结束</h2><ol>\n<li><p>设置退出标志，是线程正常退出，也就是当run()方法执行完成后线程终止。</p>\n</li>\n<li><p>使用interrupt()方法中断线程</p>\n</li>\n<li><p>使用stop()方法强行中断线程（不推荐使用，Thread.stop, Thread.suspend, Thread.resume 和Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃，使用它们是极端不安全的）</p>\n</li>\n</ol>\n<h2 id=\"并发编程的三大特性\"><a href=\"#并发编程的三大特性\" class=\"headerlink\" title=\"并发编程的三大特性\"></a>并发编程的三大特性</h2><pre><code>并发编程的三大特性只要是：原子性、可见性、有序性\n</code></pre>\n<ul>\n<li><p>原子性：即一个操作或者多个操作，要么一起执行完成，中途不可中断，要么都不执行。</p>\n</li>\n<li><p>可见性：是在多个线程访问一个共享变量是，其中一个线程修改了这个变量的值，其他线程应该立即看到修改的值。</p>\n</li>\n<li><p>有序性：程序执行的顺序按照代码的先后顺序执行。一般JVM会自动对其进行优化，使其重排序。</p>\n</li>\n</ul>\n<h2 id=\"java的内存模型-JMM\"><a href=\"#java的内存模型-JMM\" class=\"headerlink\" title=\"java的内存模型 JMM\"></a>java的内存模型 JMM</h2><p>用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>\n<pre><code>用来定义一个一致的、跨平台的内存模型，是缓存一致性协议，用来定义数据读写的规则。\n\nJMM决定一个线程对共享变量的写入时,能对另一个线程可见。\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）.\n本地内存中存储了该线程可以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\n</code></pre>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/JMM-1.png\"></p>\n<h2 id=\"JAVA-变量的读写\"><a href=\"#JAVA-变量的读写\" class=\"headerlink\" title=\"JAVA 变量的读写\"></a>JAVA 变量的读写</h2><p>我们在看Volatile关键字的时候先了解一下java变量的读写：<br>（1）lock：作用于主内存，把变量标识为线程独占状态。</p>\n<p>（2）unlock：作用于主内存，解除独占状态。</p>\n<p>（3）read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>\n<p>（4）load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>\n<p>（5）use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>\n<p>（6）assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</p>\n<p>（7）store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</p>\n<p>（8）write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</p>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：</p>\n<ul>\n<li><p>编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>\n</li>\n<li><p>指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>\n</li>\n<li><p>内存系统的重排序：由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。 </p>\n<p>  这里还得提一个概念，as-if-serial：不管怎么重排序，单线程下的执行结果不能被改变。</p>\n</li>\n</ul>\n<h2 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h2><ul>\n<li>程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作优先发生于书写在后面的操作。</li>\n<li>锁定规则：对于一个锁的解锁操作（unLock），优先发生于后续对这个锁的加锁操作（lock）。</li>\n<li>volatile原则：对一个volatile变量的写操作，优先发生于后续对这个变量的读操作。</li>\n<li>传递原则：如果A操作先行发生于操作B，B操作先行发生于操作C，即A操作先行发生于操作C。</li>\n<li>线程启动原则：同一个线程的start（）优先发生于此线程的其他方法。</li>\n<li>线程中断原则：对线程interrupt（）方法的调用，优先发生于被中断线程的代码检测到中断事件的发生。</li>\n<li>线程终结原则：同一个线程所有的操作都优先于线程的终止检测。</li>\n<li>对象创建原则：一个对象的初始化完成，优先于发生于它的 finalize()的开始。</li>\n</ul>\n<h2 id=\"说说-sleep-和-wait-的区别？\"><a href=\"#说说-sleep-和-wait-的区别？\" class=\"headerlink\" title=\"说说 sleep() 和 wait() 的区别？\"></a>说说 sleep() 和 wait() 的区别？</h2><ul>\n<li>sleep() 和 wait() 都可以暂停线程的执行。</li>\n<li>sleep() 不释放锁，wait() 释放锁。</li>\n<li>sleep() 在 Thread 类中声明的，wait() 在 Object 类中声明。</li>\n<li>sleep() 是静态方法，wait() 是非静态方法（必须由同步锁对象调用）。</li>\n<li>sleep() 方法导致线程进入阻塞状态后，当时间到了或者 interrupt() 会醒来。</li>\n<li>wait() 方法导致线程进入阻塞状态后，需要由 notify() 或 notifyAll() 唤醒，或者使用 wait(long timeout) 超时后线程会自动苏醒。 </li>\n</ul>\n<h2 id=\"为什么不能直接调用-run-方法？\"><a href=\"#为什么不能直接调用-run-方法？\" class=\"headerlink\" title=\"为什么不能直接调用 run() 方法？\"></a>为什么不能直接调用 run() 方法？</h2><ul>\n<li><p>调用 run() 方法，会被当做普通方法去执行，不是多线程工作。</p>\n</li>\n<li><p>调用 start() 方法，会启动线程并使线程进入了就绪状态，当分配到时间片后就可以运行 run() 方法内容了，这是真正的多线程工作</p>\n</li>\n</ul>\n<h2 id=\"说说-Runnable-和-Callable-的区别？\"><a href=\"#说说-Runnable-和-Callable-的区别？\" class=\"headerlink\" title=\"说说 Runnable 和 Callable 的区别？\"></a>说说 Runnable 和 Callable 的区别？</h2><p>Runnable 和 Callable 都是接口，都可以编写多线程程序。不同的是:</p>\n<ul>\n<li><p>Runnable 接口 run 方法无返回值，Callable 接口 call 方法有返回值。</p>\n</li>\n<li><p>Runnable 接口 run 方法只能直接抛出运行时异常，Callable 接口 call 方法可以捕获异常。</p>\n<p>  对于 Calleble 来说，Future 和 FutureTask 均可以用来获取任务执行结果，不过 Future 是个接口，FutureTask 是 Future 的具体实现。</p>\n<p>  FutureTask 表示一个异步运算的任务。<br>  FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。<br>  只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p>\n</li>\n</ul>\n<h2 id=\"volatile-于-synchronized-区别\"><a href=\"#volatile-于-synchronized-区别\" class=\"headerlink\" title=\"volatile 于 synchronized 区别\"></a>volatile 于 synchronized 区别</h2><pre><code>volatile 只保证可见性，不保证原子性，禁止重排序保证了有序性。\nsynchronized 既可以保证原子性，也能保证可见性。synchronized确保了一次只有一个线程执行，即happens-before的有序原则，也确保了有序性。\n\nvolatile 只能保证数据的可见性，不能用于同步，因此多个线程访问volatile修饰的变量不会造成zuse。\nn 不仅保证了可见性，也保证了原子性。\n因为经n修饰后，只有获得锁的线程才能进入临界区，从而保证了临界区内的所有语句都全部执行。\n多个线程争抢n变量时，会出现阻塞情况\n\nvolatile是轻量级的，因为只能修饰变量。\nn是重量级的，可以修饰变量、代码块、方法。\n</code></pre>\n"},{"title":"线程池","date":"2021-08-29T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 线程池作用\njava中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处\n1. 降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗\n\n2. 提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n\n3. 提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。\n\n# Executor 框架\nExecutor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。\n\n![Executor框架](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-1.png)  \n\nExecutor 结构主要包含任务、任务的执行和异步结果的计算\n1. 任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。\n    * Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。\n\n2. 任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。\n    * Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。\n\n3. 异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。\n\n在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  \n\n如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。  \n由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 \n\n# ThreadPoolExecutor\n## 核心参数\n* corePoolSize: 核心线程数。\n    * 定义了最小可以同时运行的线程数据\n* maximumPoolSize: 最大线程数\n    * 当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。\n* wordQueue: 任务队列\n    * 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。\n\n## 常见参数\n* keepAliveTime: 多余线程存活时间\n    * 当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁\n* unit: 时间单位\n    * keepAliveTime参数的时间单位\n* threadFactory: 线程工厂\n    * executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。\n* handler: 饱和策略\n![ThreadPoolExecutor饱和策略](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-2.png)  \n\n如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：\n* ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。\n* ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。\n* ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。\n* ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。\n\n阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  \n1. <font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。\n2. <font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  \n\n![线程池执行原理](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-3.png)","source":"_posts/lh/并发编程/线程池.md","raw":"---\ntitle: 线程池\ndate: 2021-08-30 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 线程池作用\njava中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处\n1. 降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗\n\n2. 提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。\n\n3. 提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。\n\n# Executor 框架\nExecutor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。\n\n![Executor框架](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-1.png)  \n\nExecutor 结构主要包含任务、任务的执行和异步结果的计算\n1. 任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。\n    * Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。\n\n2. 任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。\n    * Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。\n\n3. 异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。\n\n在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  \n\n如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。  \n由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 \n\n# ThreadPoolExecutor\n## 核心参数\n* corePoolSize: 核心线程数。\n    * 定义了最小可以同时运行的线程数据\n* maximumPoolSize: 最大线程数\n    * 当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。\n* wordQueue: 任务队列\n    * 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。\n\n## 常见参数\n* keepAliveTime: 多余线程存活时间\n    * 当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁\n* unit: 时间单位\n    * keepAliveTime参数的时间单位\n* threadFactory: 线程工厂\n    * executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。\n* handler: 饱和策略\n![ThreadPoolExecutor饱和策略](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-2.png)  \n\n如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：\n* ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。\n* ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。\n* ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。\n* ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。\n\n阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  \n1. <font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。\n2. <font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  \n\n![线程池执行原理](https://kubpang.gitee.io/sourceFile/Java/并发/线程池相关-3.png)","slug":"lh/并发编程/线程池","published":1,"updated":"2021-09-01T02:45:13.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836k0029hct72o0dejl5","content":"<h1 id=\"线程池作用\"><a href=\"#线程池作用\" class=\"headerlink\" title=\"线程池作用\"></a>线程池作用</h1><p>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处</p>\n<ol>\n<li><p>降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗</p>\n</li>\n<li><p>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>\n</li>\n<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</p>\n</li>\n</ol>\n<h1 id=\"Executor-框架\"><a href=\"#Executor-框架\" class=\"headerlink\" title=\"Executor 框架\"></a>Executor 框架</h1><p>Executor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-1.png\" alt=\"Executor框架\">  </p>\n<p>Executor 结构主要包含任务、任务的执行和异步结果的计算</p>\n<ol>\n<li><p>任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。</p>\n<ul>\n<li>Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。</li>\n</ul>\n</li>\n<li><p>任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。</p>\n<ul>\n<li>Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。</li>\n</ul>\n</li>\n<li><p>异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。</p>\n</li>\n</ol>\n<p>在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  </p>\n<p>如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。<br>由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 </p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li>corePoolSize: 核心线程数。<ul>\n<li>定义了最小可以同时运行的线程数据</li>\n</ul>\n</li>\n<li>maximumPoolSize: 最大线程数<ul>\n<li>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。</li>\n</ul>\n</li>\n<li>wordQueue: 任务队列<ul>\n<li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见参数\"><a href=\"#常见参数\" class=\"headerlink\" title=\"常见参数\"></a>常见参数</h2><ul>\n<li>keepAliveTime: 多余线程存活时间<ul>\n<li>当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁</li>\n</ul>\n</li>\n<li>unit: 时间单位<ul>\n<li>keepAliveTime参数的时间单位</li>\n</ul>\n</li>\n<li>threadFactory: 线程工厂<ul>\n<li>executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。</li>\n</ul>\n</li>\n<li>handler: 饱和策略<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-2.png\" alt=\"ThreadPoolExecutor饱和策略\">  </li>\n</ul>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  </p>\n<ol>\n<li><font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</li>\n<li><font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  </li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-3.png\" alt=\"线程池执行原理\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程池作用\"><a href=\"#线程池作用\" class=\"headerlink\" title=\"线程池作用\"></a>线程池作用</h1><p>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在并发过程中，合理使用线程池可以带来3个好处</p>\n<ol>\n<li><p>降低资源消耗: 通过重复利用已创建的线程降低创建和销毁造成的消耗</p>\n</li>\n<li><p>提高响应速度: 当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>\n</li>\n<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限量的创建，不经不会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。</p>\n</li>\n</ol>\n<h1 id=\"Executor-框架\"><a href=\"#Executor-框架\" class=\"headerlink\" title=\"Executor 框架\"></a>Executor 框架</h1><p>Executor 框架是java5之后引进的，Executor框架不仅包过了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor框架让开发编程变的更加简单。</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-1.png\" alt=\"Executor框架\">  </p>\n<p>Executor 结构主要包含任务、任务的执行和异步结果的计算</p>\n<ol>\n<li><p>任务（Runnable/Callable）: 包括执行任务需要实现的Runnable接口或Callable接口。</p>\n<ul>\n<li>Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor执行。</li>\n</ul>\n</li>\n<li><p>任务的执行（Executor）: 包过任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。</p>\n<ul>\n<li>Executor框架 有两个关键类实现了ExecutorService接口（ThreadPoolExecutor 和 SchecduledThreadPoolExecutor）。</li>\n</ul>\n</li>\n<li><p>异步结果的计算(Future): 包括接口Future 和实现了Future接口的FutureTasklei。</p>\n</li>\n</ol>\n<p>在 Executor 使用过程中，主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 对象（Executors.callable(Runnable task) 或 Executors.callable(Runnable task，Object resule)）。  </p>\n<p>如果执行 ExecutorService.submit()，ExecutorService 将返回一个实现 Future 接口的对象（FutureTask）。<br>由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。 </p>\n<h1 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h1><h2 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h2><ul>\n<li>corePoolSize: 核心线程数。<ul>\n<li>定义了最小可以同时运行的线程数据</li>\n</ul>\n</li>\n<li>maximumPoolSize: 最大线程数<ul>\n<li>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量便为最大线程数。</li>\n</ul>\n</li>\n<li>wordQueue: 任务队列<ul>\n<li>当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到了则放入队列中。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见参数\"><a href=\"#常见参数\" class=\"headerlink\" title=\"常见参数\"></a>常见参数</h2><ul>\n<li>keepAliveTime: 多余线程存活时间<ul>\n<li>当线程池中线程舒朗大于 corePoolSize时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时候超过了keepAliveTime才会被销毁</li>\n</ul>\n</li>\n<li>unit: 时间单位<ul>\n<li>keepAliveTime参数的时间单位</li>\n</ul>\n</li>\n<li>threadFactory: 线程工厂<ul>\n<li>executor创建新线程时用到，可以用来给线程命名，查看当前创建线程数量，设置优先级，设置是否后台运行等。</li>\n</ul>\n</li>\n<li>handler: 饱和策略<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-2.png\" alt=\"ThreadPoolExecutor饱和策略\">  </li>\n</ul>\n<p>如果当前同时运行的线程数量达到最大线程数量并且队列液晶被放满时，ThreadPoolTaskExecutor定义了一些策略：</p>\n<ul>\n<li>ThreadPoolExecutor.AbortPolicy: 抛抛出 RejectedExecutionException 来拒绝新任务的处理。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.DiscardPolicy: 不处理新任务，直接丢弃掉。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<p>阿里建议用<font color=red> ThreadPoolExecutor </font> 构造函数的方式去创建线程池，不建议用 Executors 去创建，弊端如下：  </p>\n<ol>\n<li><font color=#0099FF>FixedThreadPool 和 SingleThreadExecutor </font> ： 允许请求的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，从而导致 OOM。</li>\n<li><font color=#0099FF>CachedThreadPool 和 ScheduledThreadPool</font> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。  </li>\n</ol>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3-3.png\" alt=\"线程池执行原理\"></p>\n"},{"title":"锁相关","date":"2021-08-29T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 什么是锁\n在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n\n# 锁的三个概念\n1. <font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。\n\n2. <font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁\n\n3. <font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。  \n死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。  \n![死锁图解](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-4.jpg)\n\n# Monitor 原理（核心） \njava中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。\n\n在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:\n\n![Monitor的数据结构](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-2.png)  \n* 进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  \n    * 如果对象未被锁住，则成为拥有者。\n    * 否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font>\n* 等待区（Wait Set）: 存放等待状态的线程。  \n    * 表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。\n* 拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。\n\n当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。\n\n# MarkWord 原理（核心） \n注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。\n\n前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：\n* MarkWord: 保存对象当前锁机制的记录信息。\n* klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。\n* 数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。\n\n当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：  \n![MarkWord 32位JVM中存储的内容](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-3.png)  \n\n其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。\n\n# 锁的种类\n![java 主流锁](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-5.png)\n\n1. <font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  \n* 偏向锁  \n自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font>\n\n* 轻量级锁  \n如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font>\n\n* 重量级锁\n重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font>\n\n\n* 锁的升级：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\n\n2. <font color=#0099FF>可重入锁/非可重入锁</font>  \n* 可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。\n    * 可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类\n* 不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  \n\n3. <font color=#0099FF>共享锁/独占锁</font>  \n* 共享锁: 一个对象的锁，能被多个线程同时获取。\n    * 读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有\n* 独占锁: 一个对象的锁，同一时间只能被一个线程使用。\n    * 读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。\n\n4. <font color=#0099FF>公平锁/非公平锁</font> \n* 公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。  \n[AQS中线程2进入等待队列 则提现了公平锁](https://blog.quanlinmen.cn/2021/08/27/lh/并发编程/AQS/)\n![线程2的公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/公平锁.jpg)\n\n* 非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。\n![线程2的不公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/非公平锁.jpg)\n\n* 如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略\n```java\n//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略\nReentrantLock lock = new ReentrantLock(true);\n```\n5. <font color=#0099FF>悲观锁/乐观锁</font>\n* 悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。\n\n* 乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。\n\n6. <font color=#0099FF>自旋锁/非自旋锁</font>\n* 自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。\n\n* 非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。\n\n7. <font color=#0099FF>可中断锁/不可中断锁</font>\n* 可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理\n\n* 不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开\n\n\n\n","source":"_posts/lh/并发编程/锁相关.md","raw":"---\ntitle: 锁相关\ndate: 2021-08-30 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 并发编程\ntags: \n    - 并发编程\n---\n\n# 什么是锁\n在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n\n# 锁的三个概念\n1. <font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。\n\n2. <font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁\n\n3. <font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。  \n死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。  \n![死锁图解](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-4.jpg)\n\n# Monitor 原理（核心） \njava中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。\n\n在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:\n\n![Monitor的数据结构](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-2.png)  \n* 进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  \n    * 如果对象未被锁住，则成为拥有者。\n    * 否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font>\n* 等待区（Wait Set）: 存放等待状态的线程。  \n    * 表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。\n* 拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。\n\n当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。\n\n# MarkWord 原理（核心） \n注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。\n\n前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：\n* MarkWord: 保存对象当前锁机制的记录信息。\n* klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。\n* 数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。\n\n当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：  \n![MarkWord 32位JVM中存储的内容](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-3.png)  \n\n其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。\n\n# 锁的种类\n![java 主流锁](https://kubpang.gitee.io/sourceFile/Java/并发/锁相关-5.png)\n\n1. <font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  \n* 偏向锁  \n自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font>\n\n* 轻量级锁  \n如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font>\n\n* 重量级锁\n重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font>\n\n\n* 锁的升级：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\n\n2. <font color=#0099FF>可重入锁/非可重入锁</font>  \n* 可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。\n    * 可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类\n* 不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  \n\n3. <font color=#0099FF>共享锁/独占锁</font>  \n* 共享锁: 一个对象的锁，能被多个线程同时获取。\n    * 读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有\n* 独占锁: 一个对象的锁，同一时间只能被一个线程使用。\n    * 读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。\n\n4. <font color=#0099FF>公平锁/非公平锁</font> \n* 公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。  \n[AQS中线程2进入等待队列 则提现了公平锁](https://blog.quanlinmen.cn/2021/08/27/lh/并发编程/AQS/)\n![线程2的公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/公平锁.jpg)\n\n* 非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。\n![线程2的不公平锁](https://kubpang.gitee.io/sourceFile/Java/并发/非公平锁.jpg)\n\n* 如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略\n```java\n//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略\nReentrantLock lock = new ReentrantLock(true);\n```\n5. <font color=#0099FF>悲观锁/乐观锁</font>\n* 悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。\n\n* 乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。\n\n6. <font color=#0099FF>自旋锁/非自旋锁</font>\n* 自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。\n\n* 非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。\n\n7. <font color=#0099FF>可中断锁/不可中断锁</font>\n* 可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理\n\n* 不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开\n\n\n\n","slug":"lh/并发编程/锁相关","published":1,"updated":"2021-09-01T02:44:49.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836l002ehct7fnkk8gnz","content":"<h1 id=\"什么是锁\"><a href=\"#什么是锁\" class=\"headerlink\" title=\"什么是锁\"></a>什么是锁</h1><p>在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。</p>\n<h1 id=\"锁的三个概念\"><a href=\"#锁的三个概念\" class=\"headerlink\" title=\"锁的三个概念\"></a>锁的三个概念</h1><ol>\n<li><p><font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。</p>\n</li>\n<li><p><font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁</p>\n</li>\n<li><p><font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。<br>死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-4.jpg\" alt=\"死锁图解\"></p>\n</li>\n</ol>\n<h1 id=\"Monitor-原理（核心）\"><a href=\"#Monitor-原理（核心）\" class=\"headerlink\" title=\"Monitor 原理（核心）\"></a>Monitor 原理（核心）</h1><p>java中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>\n<p>在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-2.png\" alt=\"Monitor的数据结构\">  </p>\n<ul>\n<li>进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  <ul>\n<li>如果对象未被锁住，则成为拥有者。</li>\n<li>否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font></li>\n</ul>\n</li>\n<li>等待区（Wait Set）: 存放等待状态的线程。  <ul>\n<li>表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。</li>\n</ul>\n</li>\n<li>拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。</li>\n</ul>\n<p>当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。</p>\n<h1 id=\"MarkWord-原理（核心）\"><a href=\"#MarkWord-原理（核心）\" class=\"headerlink\" title=\"MarkWord 原理（核心）\"></a>MarkWord 原理（核心）</h1><p>注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。</p>\n<p>前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：</p>\n<ul>\n<li>MarkWord: 保存对象当前锁机制的记录信息。</li>\n<li>klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。</li>\n<li>数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。</li>\n</ul>\n<p>当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-3.png\" alt=\"MarkWord 32位JVM中存储的内容\">  </p>\n<p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。</p>\n<h1 id=\"锁的种类\"><a href=\"#锁的种类\" class=\"headerlink\" title=\"锁的种类\"></a>锁的种类</h1><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-5.png\" alt=\"java 主流锁\"></p>\n<ol>\n<li><font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  </li>\n</ol>\n<ul>\n<li><p>偏向锁<br>自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font></p>\n</li>\n<li><p>轻量级锁<br>如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font></p>\n</li>\n<li><p>重量级锁<br>重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font></p>\n</li>\n</ul>\n<ul>\n<li>锁的升级：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li>\n</ul>\n<ol start=\"2\">\n<li><font color=#0099FF>可重入锁/非可重入锁</font>  </li>\n</ol>\n<ul>\n<li>可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。<ul>\n<li>可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类</li>\n</ul>\n</li>\n<li>不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  </li>\n</ul>\n<ol start=\"3\">\n<li><font color=#0099FF>共享锁/独占锁</font>  </li>\n</ol>\n<ul>\n<li>共享锁: 一个对象的锁，能被多个线程同时获取。<ul>\n<li>读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有</li>\n</ul>\n</li>\n<li>独占锁: 一个对象的锁，同一时间只能被一个线程使用。<ul>\n<li>读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><font color=#0099FF>公平锁/非公平锁</font> </li>\n</ol>\n<ul>\n<li><p>公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。<br><a href=\"https://blog.quanlinmen.cn/2021/08/27/lh/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/\">AQS中线程2进入等待队列 则提现了公平锁</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的公平锁\"></p>\n</li>\n<li><p>非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的不公平锁\"></p>\n</li>\n<li><p>如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"5\">\n<li><font color=#0099FF>悲观锁/乐观锁</font></li>\n</ol>\n<ul>\n<li><p>悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。</p>\n</li>\n<li><p>乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><font color=#0099FF>自旋锁/非自旋锁</font></li>\n</ol>\n<ul>\n<li><p>自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。</p>\n</li>\n<li><p>非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><font color=#0099FF>可中断锁/不可中断锁</font></li>\n</ol>\n<ul>\n<li><p>可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理</p>\n</li>\n<li><p>不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是锁\"><a href=\"#什么是锁\" class=\"headerlink\" title=\"什么是锁\"></a>什么是锁</h1><p>在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。</p>\n<h1 id=\"锁的三个概念\"><a href=\"#锁的三个概念\" class=\"headerlink\" title=\"锁的三个概念\"></a>锁的三个概念</h1><ol>\n<li><p><font color=#0099FF>锁开销(lock overhead)</font>: 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销也就越大。</p>\n</li>\n<li><p><font color=#0099FF>锁竞争(lock contention)</font>: 一个进程或一个线程尝试获取另一个进程或线程持有的锁是，就会发生竞争，锁粒度越小，发生锁竞争的可能性就越小。锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁</p>\n</li>\n<li><p><font color=#0099FF>死锁(deadlock)</font>: 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通讯而造成的一种阻塞现象，若无外力作用，它们都无法推进下去。<br>死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-4.jpg\" alt=\"死锁图解\"></p>\n</li>\n</ol>\n<h1 id=\"Monitor-原理（核心）\"><a href=\"#Monitor-原理（核心）\" class=\"headerlink\" title=\"Monitor 原理（核心）\"></a>Monitor 原理（核心）</h1><p>java中每个对象都会携带一个monitor对象，存在在<font color=red>对象头（指针）</font>中，sychronized就是通过它来实现同步锁的，这也是java中任何对象都可以作为锁的原因。同时也是 notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>\n<p>在HotSpot JVM中，Monitor由ObjectMonitor实现，她的数据结构分为三个区域:</p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-2.png\" alt=\"Monitor的数据结构\">  </p>\n<ul>\n<li>进入区（Entry Set）: 存放处理阻塞状态的线程。表示线程要求获取对象的锁。  <ul>\n<li>如果对象未被锁住，则成为拥有者。</li>\n<li>否则 则进入等待区。<font face=\"黑体\" color=red> 一旦对象锁被其他线程释放，立即参与竞争。</font></li>\n</ul>\n</li>\n<li>等待区（Wait Set）: 存放等待状态的线程。  <ul>\n<li>表示线程通过对象的wait方法，释放了对象的锁，并在等待区等待被唤醒。</li>\n</ul>\n</li>\n<li>拥有者（Owner）: 指向持有monitor对象的线程，表示某一线程成功竞争到对象锁。</li>\n</ul>\n<p>当多个线程同时访问一段同步代码时，首先会进入 EntrySet，当线程获取到对象的 Monitor 后进入 Owner 区域并把 owner 变量设置为当前线程，同时 Monitor 中的计数器加1。若线程调用 wait() 方法，将释放当前持有的 monitor，owner 恢复为 null，计数器减 1，同时该线程进入 WaitSet 等待被唤醒。</p>\n<h1 id=\"MarkWord-原理（核心）\"><a href=\"#MarkWord-原理（核心）\" class=\"headerlink\" title=\"MarkWord 原理（核心）\"></a>MarkWord 原理（核心）</h1><p>注意：整个对象头的描述结构的长度并不是固定不变的，首先在 32 位操作系统和 64 位操作系统中就有结构长度上的差异。另外在启用的对象指针压缩和没有启用对象指针压缩的情况下，整个对象头的长度也不一样：64 位平台下，原生对象头大小为 16 字节，压缩后为 12 字节。</p>\n<p>前面有说明对象头会存放monitor对象的指针，对象头的结构主要三部分：</p>\n<ul>\n<li>MarkWord: 保存对象当前锁机制的记录信息。</li>\n<li>klassPointer: 指向mataspace中该类的元数据，用来表示是那个类的实例。</li>\n<li>数组长度: 只有数组形式的对象会有这个区域，用来表示数组长度。</li>\n</ul>\n<p>当对象被sychronized关键字当成同步锁时，围绕这个锁的一系列操作都和MarkWord有关。Mark Word 在 32 位 JVM 中的长度是 32bit，在 64 位 JVM 中长度是 64bit。Mark Word 在不同的锁状态下存储的内容不同，在 32 位 JVM 中是这么存的：<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-3.png\" alt=\"MarkWord 32位JVM中存储的内容\">  </p>\n<p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1bit 区分了这是无锁状态还是偏向锁状态。Epoch 是指偏向锁的时间戳。</p>\n<h1 id=\"锁的种类\"><a href=\"#锁的种类\" class=\"headerlink\" title=\"锁的种类\"></a>锁的种类</h1><p><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%94%81%E7%9B%B8%E5%85%B3-5.png\" alt=\"java 主流锁\"></p>\n<ol>\n<li><font color=#0099FF>偏向锁/轻量级锁/重量级锁</font>  </li>\n</ol>\n<ul>\n<li><p>偏向锁<br>自始至终，偏向锁都是不存在竞争的。因为其只是打个标记而已。一个对象初始化且没有线程获取它的锁时，即为可偏向。当第一个线程访问并尝试获取锁时，其会将这个线程记录下来。后续如果尝试获取锁的线程是其拥有者，即可直接获得锁，开销很小，性能最好。<font color=red>（锁标志位为01，是否偏向锁是 1）</font></p>\n</li>\n<li><p>轻量级锁<br>如果只有短时间的锁竞争，直接可通过CAS就可以解决而不需要完全互斥的重量级锁。轻量级锁是指在锁为偏向锁时，被另一个线程访问（已获取锁，说明存在竞争），那么偏向锁为自动升级轻量级锁，这时，等待的线程会通过自旋的方式尝试获取锁，这样就不会造成阻塞。<font color=red>（锁标志位为00）</font></p>\n</li>\n<li><p>重量级锁<br>重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销大。一般为多个线程之间长时间的锁竞争，轻量级锁自旋一定的次数后（默认10次，jdk7以后，默认开启自旋，可以使用-XX:PreBlockSpin参数来设置自旋锁等待的次数）锁膨胀为重量级锁。重量级锁会让其他等待获取锁的线程直接进入阻塞状态。<font color=red>（锁标志位为10）</font></p>\n</li>\n</ul>\n<ul>\n<li>锁的升级：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li>\n</ul>\n<ol start=\"2\">\n<li><font color=#0099FF>可重入锁/非可重入锁</font>  </li>\n</ol>\n<ul>\n<li>可重入锁指：是线程持有了对象的锁，能在不释放锁的情况下，再次获得这把锁。<ul>\n<li>可重入锁最典型的就是ReentrantLock了，是Lock接口最主要的一个实现类</li>\n</ul>\n</li>\n<li>不可重入锁：指的是虽然线程当前持有了对象的锁，但是想再次获取锁必须先释放才能获取。  </li>\n</ul>\n<ol start=\"3\">\n<li><font color=#0099FF>共享锁/独占锁</font>  </li>\n</ol>\n<ul>\n<li>共享锁: 一个对象的锁，能被多个线程同时获取。<ul>\n<li>读写锁中的读锁即为共享锁。读锁可以被同时读，可以同时被多个线程持有</li>\n</ul>\n</li>\n<li>独占锁: 一个对象的锁，同一时间只能被一个线程使用。<ul>\n<li>读写锁中的写锁即为独占锁，写锁最多只能同时被一个线程持有。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><font color=#0099FF>公平锁/非公平锁</font> </li>\n</ol>\n<ul>\n<li><p>公平锁：公平锁是指当线程拿不到对象锁时，会进去等待队列，而等待队列中，等待时间长则优先测试获取锁，先进先出。<br><a href=\"https://blog.quanlinmen.cn/2021/08/27/lh/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/\">AQS中线程2进入等待队列 则提现了公平锁</a><br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的公平锁\"></p>\n</li>\n<li><p>非公平锁：非公平锁则会忽略掉等待队列中的线程，直接去尝试获取锁，发生插队现象。<br><img src=\"https://kubpang.gitee.io/sourceFile/Java/%E5%B9%B6%E5%8F%91/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.jpg\" alt=\"线程2的不公平锁\"></p>\n</li>\n<li><p>如果用默认的构建函数来创建ReentrantLock对象，默认的锁策略就是非公平的，如果想构建的ReentrantLock实现公平锁策略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建ReentrantLock的时候 传入true 即代表ReentrantLock是公平锁策略</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"5\">\n<li><font color=#0099FF>悲观锁/乐观锁</font></li>\n</ol>\n<ul>\n<li><p>悲观锁: 在获取对对象时，必须先获取锁，以达到独占的状态。</p>\n</li>\n<li><p>乐观锁: 与悲观锁相反，在获取对象前不要求先获得锁，往往利用CAS，在不独占对象的情况下，实现对象的修改。</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><font color=#0099FF>自旋锁/非自旋锁</font></li>\n</ol>\n<ul>\n<li><p>自旋锁: 指线程在获取不到锁的时候，不直接阻塞或释放CPU资源，而是开始利用循环，不停的尝试获取锁，就像是线程在 “自我旋转” 所以叫自旋，轻量级锁中常用到。</p>\n</li>\n<li><p>非自旋锁: 指线程在获取不到锁的时候，线程直接放弃，或去进行其他操作，如：阻塞、排队等。</p>\n</li>\n</ul>\n<ol start=\"7\">\n<li><font color=#0099FF>可中断锁/不可中断锁</font></li>\n</ol>\n<ul>\n<li><p>可中断锁: java中sychronized关键字修饰的锁就是不可中断的，一旦线程申请了锁，只能等拿到锁后才能进行其他的逻辑处理</p>\n</li>\n<li><p>不可中断锁: ReentrantLock 是一种典型的可中断锁，例如lockInterruptibly 方式在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需等到获取锁才能离开</p>\n</li>\n</ul>\n"},{"title":"设计模式初讲","date":"2021-07-26T16:00:00.000Z","author":"lh","summary":"","_content":"\n# 扩展知识\n\n## 什么是设计模式\n\n设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。\n\n## 设计模式的三大分类及关键点\n\n![设计模式三大分类](https://kubpang.gitee.io/sourceFile/设计模式/设计模式三大分类.jpg)\n\n### 创建型模式  \n\n    对象实例化的模式，创建型模式用于解耦对象实例化的过程\n\n   1. [单列模式](https://blog.csdn.net/guorui_java/article/details/106585965): 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  \n   2. [工厂模式](https://blog.csdn.net/guorui_java/article/details/105087806): 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  \n   3. [抽象工厂模式](https://blog.csdn.net/guorui_java/article/details/106535411) : 创建相关或依赖对象的家族，而无需明确指定具体类。  \n   4. [建造者模式](https://blog.csdn.net/guorui_java/article/details/106684541) : 封装一个复杂对象的创建过程，并可以安步骤构造。  \n   5. [原型模式](https://blog.csdn.net/guorui_java/article/details/106544941) : 通过复制现有的实例来创建新的实例。\n\n\n### 结构型模式\n\n    把类或对象结合在一起形成一个更大的结构\n\n   1. [装饰模式](https://blog.csdn.net/guorui_java/article/details/106613220) : 动态的给对象添加新的功能。  \n   2. [代理模式](https://blog.csdn.net/guorui_java/article/details/106665200) : 未其他对象提供一个代理以便控制这个对象的访问。  \n   3. [桥接模式](https://blog.csdn.net/guorui_java/article/details/106688252) : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  \n   4. [适配器模式](https://blog.csdn.net/guorui_java/article/details/106584559) : 将一个类的方法接口转换到客户希望的另一个接口。  \n   5. [组合模式](https://blog.csdn.net/guorui_java/article/details/106617887) : 将对象组合成树形结构以表示“部分-整体”的结构层次。  \n   6. [外观模式](https://blog.csdn.net/guorui_java/article/details/104247938) : 对外提供一个统一的方法，来访问子系统的一群接口。  \n   7. [享元模式](https://blog.csdn.net/guorui_java/article/details/106640489) : 通过共享技术来有效的支持大量细粒度的对象。  \n\n\n### 行为型模式  \n\n    类和对象如何交互，以及划分责任和算法\n\n   1. [策略模式](https://blog.csdn.net/guorui_java/article/details/104039882) : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  \n   2. [模板模式](https://blog.csdn.net/guorui_java/article/details/106677554) : 定义一个算法结构，而将一些步骤延迟到子类中实现。  \n   3. [命令模式](https://blog.csdn.net/guorui_java/article/details/106718457) : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  \n   4. [迭代器模式](https://blog.csdn.net/guorui_java/article/details/104247911) : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  \n   5. [观察者模式](https://blog.csdn.net/guorui_java/article/details/104247965) : 对象间的一对多的依赖关系。  \n   6. [仲裁者模式](https://blog.csdn.net/guorui_java/article/details/104247966) : 用一个中介对象来封装一系列的对象交互。  \n   7. [备忘录模式](https://blog.csdn.net/guorui_java/article/details/104247969) : 在不破坏封装的前提下，保持对象的内部状态。  \n   8. [解释器模式](https://blog.csdn.net/guorui_java/article/details/104247972) : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  \n   9. [状态模式](https://blog.csdn.net/guorui_java/article/details/104247975) : 允许一个对象在对象内部状态改变时改变它的行为。  \n   10. [责任链模式](https://blog.csdn.net/guorui_java/article/details/104247978) : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  \n   11. [访问者模式](https://blog.csdn.net/guorui_java/article/details/104247935) : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  \n\n\n ## 设计模式的原则\n\n ### 1. 单一职责原则 \n    \n    对于一个类，只有一个引起该类变化的原因。  \n    该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n\n ### 2. 接口隔离原则  \n    \n    客户端不应该依赖它不需要的接口。  \n    一个类对另一个类的依赖应该建立在最小接口上。\n\n### 3. 依赖倒转原则  \n\n    程序要依赖于抽象接口，不要依赖于具体实现。  \n    简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n\n### 4. 里式代替原则  \n\n    1. 任何基类出现的地方，子类一定可以出现。  \n    2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n    3. 里式替代原则是对开闭原则的补充。  \n    4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n\n### 5. 开闭原则  \n\n1. 对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  \n2. 对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  \n\n### 6. 迪米特法则\n\n    迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n\n### 7. 合成复用原则  \n\n    1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n    2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n    3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n\n[设计模式七大原则总结](https://blog.csdn.net/guorui_java/article/details/106469226)  \n\n## 设计模式关系  \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式关系图.jpg) \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式之间的关系.png) \n\n## 设计模式感想  \n一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展\n性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。\n\n同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 \n\n## 设计模式回顾  \n从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；\n\n其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；\n\n然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；\n\n之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；\n\n然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；\n\n之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；\n\n然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；\n\n然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；\n\n然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；\n\n然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；\n\n接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；\n\n接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；\n\n然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；\n\n接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；\n\n然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；\n\n然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；\n\n然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；\n\n然后是享元模式，轻量级对象，通过共用不变对象来实现；\n\n然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；\n\n然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；\n\n最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。\n\n[友情链接](https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)","source":"_posts/lh/设计模式/设计模式初讲.md","raw":"---\ntitle: 设计模式初讲\ndate: 2021-07-27 00:00:00\nauthor: lh\nsummary: \"\"\ncategories: 设计模式\ntags: \n    - 设计模式\n---\n\n# 扩展知识\n\n## 什么是设计模式\n\n设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。\n\n## 设计模式的三大分类及关键点\n\n![设计模式三大分类](https://kubpang.gitee.io/sourceFile/设计模式/设计模式三大分类.jpg)\n\n### 创建型模式  \n\n    对象实例化的模式，创建型模式用于解耦对象实例化的过程\n\n   1. [单列模式](https://blog.csdn.net/guorui_java/article/details/106585965): 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  \n   2. [工厂模式](https://blog.csdn.net/guorui_java/article/details/105087806): 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  \n   3. [抽象工厂模式](https://blog.csdn.net/guorui_java/article/details/106535411) : 创建相关或依赖对象的家族，而无需明确指定具体类。  \n   4. [建造者模式](https://blog.csdn.net/guorui_java/article/details/106684541) : 封装一个复杂对象的创建过程，并可以安步骤构造。  \n   5. [原型模式](https://blog.csdn.net/guorui_java/article/details/106544941) : 通过复制现有的实例来创建新的实例。\n\n\n### 结构型模式\n\n    把类或对象结合在一起形成一个更大的结构\n\n   1. [装饰模式](https://blog.csdn.net/guorui_java/article/details/106613220) : 动态的给对象添加新的功能。  \n   2. [代理模式](https://blog.csdn.net/guorui_java/article/details/106665200) : 未其他对象提供一个代理以便控制这个对象的访问。  \n   3. [桥接模式](https://blog.csdn.net/guorui_java/article/details/106688252) : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  \n   4. [适配器模式](https://blog.csdn.net/guorui_java/article/details/106584559) : 将一个类的方法接口转换到客户希望的另一个接口。  \n   5. [组合模式](https://blog.csdn.net/guorui_java/article/details/106617887) : 将对象组合成树形结构以表示“部分-整体”的结构层次。  \n   6. [外观模式](https://blog.csdn.net/guorui_java/article/details/104247938) : 对外提供一个统一的方法，来访问子系统的一群接口。  \n   7. [享元模式](https://blog.csdn.net/guorui_java/article/details/106640489) : 通过共享技术来有效的支持大量细粒度的对象。  \n\n\n### 行为型模式  \n\n    类和对象如何交互，以及划分责任和算法\n\n   1. [策略模式](https://blog.csdn.net/guorui_java/article/details/104039882) : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  \n   2. [模板模式](https://blog.csdn.net/guorui_java/article/details/106677554) : 定义一个算法结构，而将一些步骤延迟到子类中实现。  \n   3. [命令模式](https://blog.csdn.net/guorui_java/article/details/106718457) : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  \n   4. [迭代器模式](https://blog.csdn.net/guorui_java/article/details/104247911) : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  \n   5. [观察者模式](https://blog.csdn.net/guorui_java/article/details/104247965) : 对象间的一对多的依赖关系。  \n   6. [仲裁者模式](https://blog.csdn.net/guorui_java/article/details/104247966) : 用一个中介对象来封装一系列的对象交互。  \n   7. [备忘录模式](https://blog.csdn.net/guorui_java/article/details/104247969) : 在不破坏封装的前提下，保持对象的内部状态。  \n   8. [解释器模式](https://blog.csdn.net/guorui_java/article/details/104247972) : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  \n   9. [状态模式](https://blog.csdn.net/guorui_java/article/details/104247975) : 允许一个对象在对象内部状态改变时改变它的行为。  \n   10. [责任链模式](https://blog.csdn.net/guorui_java/article/details/104247978) : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  \n   11. [访问者模式](https://blog.csdn.net/guorui_java/article/details/104247935) : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  \n\n\n ## 设计模式的原则\n\n ### 1. 单一职责原则 \n    \n    对于一个类，只有一个引起该类变化的原因。  \n    该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n\n ### 2. 接口隔离原则  \n    \n    客户端不应该依赖它不需要的接口。  \n    一个类对另一个类的依赖应该建立在最小接口上。\n\n### 3. 依赖倒转原则  \n\n    程序要依赖于抽象接口，不要依赖于具体实现。  \n    简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n\n### 4. 里式代替原则  \n\n    1. 任何基类出现的地方，子类一定可以出现。  \n    2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n    3. 里式替代原则是对开闭原则的补充。  \n    4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n\n### 5. 开闭原则  \n\n1. 对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  \n2. 对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  \n\n### 6. 迪米特法则\n\n    迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n\n### 7. 合成复用原则  \n\n    1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n    2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n    3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n\n[设计模式七大原则总结](https://blog.csdn.net/guorui_java/article/details/106469226)  \n\n## 设计模式关系  \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式关系图.jpg) \n\n![设计模式之间的关系](https://kubpang.gitee.io/sourceFile/设计模式/设计模式之间的关系.png) \n\n## 设计模式感想  \n一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展\n性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。\n\n同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 \n\n## 设计模式回顾  \n从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；\n\n其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；\n\n然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；\n\n之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；\n\n然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；\n\n之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；\n\n然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；\n\n然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；\n\n然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；\n\n然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；\n\n接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；\n\n接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；\n\n然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；\n\n接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；\n\n然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；\n\n然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；\n\n然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；\n\n然后是享元模式，轻量级对象，通过共用不变对象来实现；\n\n然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；\n\n然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；\n\n最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。\n\n[友情链接](https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)","slug":"lh/设计模式/设计模式初讲","published":1,"updated":"2021-09-01T02:46:05.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt2l836l002fhct71ho86wyk","content":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p>\n<h2 id=\"设计模式的三大分类及关键点\"><a href=\"#设计模式的三大分类及关键点\" class=\"headerlink\" title=\"设计模式的三大分类及关键点\"></a>设计模式的三大分类及关键点</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB.jpg\" alt=\"设计模式三大分类\"></p>\n<h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h3><pre><code>对象实例化的模式，创建型模式用于解耦对象实例化的过程\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106585965\">单列模式</a>: 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/105087806\">工厂模式</a>: 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106535411\">抽象工厂模式</a> : 创建相关或依赖对象的家族，而无需明确指定具体类。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106684541\">建造者模式</a> : 封装一个复杂对象的创建过程，并可以安步骤构造。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106544941\">原型模式</a> : 通过复制现有的实例来创建新的实例。</li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h3><pre><code>把类或对象结合在一起形成一个更大的结构\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106613220\">装饰模式</a> : 动态的给对象添加新的功能。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106665200\">代理模式</a> : 未其他对象提供一个代理以便控制这个对象的访问。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106688252\">桥接模式</a> : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106584559\">适配器模式</a> : 将一个类的方法接口转换到客户希望的另一个接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106617887\">组合模式</a> : 将对象组合成树形结构以表示“部分-整体”的结构层次。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247938\">外观模式</a> : 对外提供一个统一的方法，来访问子系统的一群接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106640489\">享元模式</a> : 通过共享技术来有效的支持大量细粒度的对象。  </li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h3><pre><code>类和对象如何交互，以及划分责任和算法\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104039882\">策略模式</a> : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106677554\">模板模式</a> : 定义一个算法结构，而将一些步骤延迟到子类中实现。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106718457\">命令模式</a> : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247911\">迭代器模式</a> : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247965\">观察者模式</a> : 对象间的一对多的依赖关系。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247966\">仲裁者模式</a> : 用一个中介对象来封装一系列的对象交互。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247969\">备忘录模式</a> : 在不破坏封装的前提下，保持对象的内部状态。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247972\">解释器模式</a> : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247975\">状态模式</a> : 允许一个对象在对象内部状态改变时改变它的行为。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247978\">责任链模式</a> : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247935\">访问者模式</a> : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  </li>\n</ol>\n<h2 id=\"设计模式的原则\"><a href=\"#设计模式的原则\" class=\"headerlink\" title=\"设计模式的原则\"></a>设计模式的原则</h2><h3 id=\"1-单一职责原则\"><a href=\"#1-单一职责原则\" class=\"headerlink\" title=\"1. 单一职责原则\"></a>1. 单一职责原则</h3><pre><code>对于一个类，只有一个引起该类变化的原因。  \n该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n</code></pre>\n<h3 id=\"2-接口隔离原则\"><a href=\"#2-接口隔离原则\" class=\"headerlink\" title=\"2. 接口隔离原则\"></a>2. 接口隔离原则</h3><pre><code>客户端不应该依赖它不需要的接口。  \n一个类对另一个类的依赖应该建立在最小接口上。\n</code></pre>\n<h3 id=\"3-依赖倒转原则\"><a href=\"#3-依赖倒转原则\" class=\"headerlink\" title=\"3. 依赖倒转原则\"></a>3. 依赖倒转原则</h3><pre><code>程序要依赖于抽象接口，不要依赖于具体实现。  \n简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n</code></pre>\n<h3 id=\"4-里式代替原则\"><a href=\"#4-里式代替原则\" class=\"headerlink\" title=\"4. 里式代替原则\"></a>4. 里式代替原则</h3><pre><code>1. 任何基类出现的地方，子类一定可以出现。  \n2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n3. 里式替代原则是对开闭原则的补充。  \n4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n</code></pre>\n<h3 id=\"5-开闭原则\"><a href=\"#5-开闭原则\" class=\"headerlink\" title=\"5. 开闭原则\"></a>5. 开闭原则</h3><ol>\n<li>对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  </li>\n<li>对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  </li>\n</ol>\n<h3 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6. 迪米特法则\"></a>6. 迪米特法则</h3><pre><code>迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n</code></pre>\n<h3 id=\"7-合成复用原则\"><a href=\"#7-合成复用原则\" class=\"headerlink\" title=\"7. 合成复用原则\"></a>7. 合成复用原则</h3><pre><code>1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n</code></pre>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/106469226\">设计模式七大原则总结</a>  </p>\n<h2 id=\"设计模式关系\"><a href=\"#设计模式关系\" class=\"headerlink\" title=\"设计模式关系\"></a>设计模式关系</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg\" alt=\"设计模式之间的关系\"> </p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"设计模式之间的关系\"> </p>\n<h2 id=\"设计模式感想\"><a href=\"#设计模式感想\" class=\"headerlink\" title=\"设计模式感想\"></a>设计模式感想</h2><p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展<br>性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p>\n<p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 </p>\n<h2 id=\"设计模式回顾\"><a href=\"#设计模式回顾\" class=\"headerlink\" title=\"设计模式回顾\"></a>设计模式回顾</h2><p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p>\n<p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p>\n<p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p>\n<p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p>\n<p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p>\n<p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p>\n<p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p>\n<p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p>\n<p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p>\n<p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p>\n<p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p>\n<p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p>\n<p>然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；</p>\n<p>接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；</p>\n<p>然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；</p>\n<p>然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；</p>\n<p>然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；</p>\n<p>然后是享元模式，轻量级对象，通过共用不变对象来实现；</p>\n<p>然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；</p>\n<p>然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；</p>\n<p>最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。</p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187\">友情链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h1><h2 id=\"什么是设计模式\"><a href=\"#什么是设计模式\" class=\"headerlink\" title=\"什么是设计模式\"></a>什么是设计模式</h2><p>设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。</p>\n<h2 id=\"设计模式的三大分类及关键点\"><a href=\"#设计模式的三大分类及关键点\" class=\"headerlink\" title=\"设计模式的三大分类及关键点\"></a>设计模式的三大分类及关键点</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB.jpg\" alt=\"设计模式三大分类\"></p>\n<h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h3><pre><code>对象实例化的模式，创建型模式用于解耦对象实例化的过程\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106585965\">单列模式</a>: 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/105087806\">工厂模式</a>: 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106535411\">抽象工厂模式</a> : 创建相关或依赖对象的家族，而无需明确指定具体类。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106684541\">建造者模式</a> : 封装一个复杂对象的创建过程，并可以安步骤构造。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106544941\">原型模式</a> : 通过复制现有的实例来创建新的实例。</li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h3><pre><code>把类或对象结合在一起形成一个更大的结构\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106613220\">装饰模式</a> : 动态的给对象添加新的功能。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106665200\">代理模式</a> : 未其他对象提供一个代理以便控制这个对象的访问。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106688252\">桥接模式</a> : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106584559\">适配器模式</a> : 将一个类的方法接口转换到客户希望的另一个接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106617887\">组合模式</a> : 将对象组合成树形结构以表示“部分-整体”的结构层次。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247938\">外观模式</a> : 对外提供一个统一的方法，来访问子系统的一群接口。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106640489\">享元模式</a> : 通过共享技术来有效的支持大量细粒度的对象。  </li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h3><pre><code>类和对象如何交互，以及划分责任和算法\n</code></pre>\n<ol>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104039882\">策略模式</a> : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106677554\">模板模式</a> : 定义一个算法结构，而将一些步骤延迟到子类中实现。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/106718457\">命令模式</a> : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247911\">迭代器模式</a> : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247965\">观察者模式</a> : 对象间的一对多的依赖关系。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247966\">仲裁者模式</a> : 用一个中介对象来封装一系列的对象交互。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247969\">备忘录模式</a> : 在不破坏封装的前提下，保持对象的内部状态。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247972\">解释器模式</a> : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247975\">状态模式</a> : 允许一个对象在对象内部状态改变时改变它的行为。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247978\">责任链模式</a> : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  </li>\n<li><a href=\"https://blog.csdn.net/guorui_java/article/details/104247935\">访问者模式</a> : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  </li>\n</ol>\n<h2 id=\"设计模式的原则\"><a href=\"#设计模式的原则\" class=\"headerlink\" title=\"设计模式的原则\"></a>设计模式的原则</h2><h3 id=\"1-单一职责原则\"><a href=\"#1-单一职责原则\" class=\"headerlink\" title=\"1. 单一职责原则\"></a>1. 单一职责原则</h3><pre><code>对于一个类，只有一个引起该类变化的原因。  \n该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  \n</code></pre>\n<h3 id=\"2-接口隔离原则\"><a href=\"#2-接口隔离原则\" class=\"headerlink\" title=\"2. 接口隔离原则\"></a>2. 接口隔离原则</h3><pre><code>客户端不应该依赖它不需要的接口。  \n一个类对另一个类的依赖应该建立在最小接口上。\n</code></pre>\n<h3 id=\"3-依赖倒转原则\"><a href=\"#3-依赖倒转原则\" class=\"headerlink\" title=\"3. 依赖倒转原则\"></a>3. 依赖倒转原则</h3><pre><code>程序要依赖于抽象接口，不要依赖于具体实现。  \n简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  \n</code></pre>\n<h3 id=\"4-里式代替原则\"><a href=\"#4-里式代替原则\" class=\"headerlink\" title=\"4. 里式代替原则\"></a>4. 里式代替原则</h3><pre><code>1. 任何基类出现的地方，子类一定可以出现。  \n2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  \n3. 里式替代原则是对开闭原则的补充。  \n4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n</code></pre>\n<h3 id=\"5-开闭原则\"><a href=\"#5-开闭原则\" class=\"headerlink\" title=\"5. 开闭原则\"></a>5. 开闭原则</h3><ol>\n<li>对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  </li>\n<li>对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  </li>\n</ol>\n<h3 id=\"6-迪米特法则\"><a href=\"#6-迪米特法则\" class=\"headerlink\" title=\"6. 迪米特法则\"></a>6. 迪米特法则</h3><pre><code>迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  \n</code></pre>\n<h3 id=\"7-合成复用原则\"><a href=\"#7-合成复用原则\" class=\"headerlink\" title=\"7. 合成复用原则\"></a>7. 合成复用原则</h3><pre><code>1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n2. 如果要使用继承关系，则必须严格遵循里式替换原则。  \n3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。\n</code></pre>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/106469226\">设计模式七大原则总结</a>  </p>\n<h2 id=\"设计模式关系\"><a href=\"#设计模式关系\" class=\"headerlink\" title=\"设计模式关系\"></a>设计模式关系</h2><p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg\" alt=\"设计模式之间的关系\"> </p>\n<p><img src=\"https://kubpang.gitee.io/sourceFile/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"设计模式之间的关系\"> </p>\n<h2 id=\"设计模式感想\"><a href=\"#设计模式感想\" class=\"headerlink\" title=\"设计模式感想\"></a>设计模式感想</h2><p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展<br>性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p>\n<p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 </p>\n<h2 id=\"设计模式回顾\"><a href=\"#设计模式回顾\" class=\"headerlink\" title=\"设计模式回顾\"></a>设计模式回顾</h2><p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p>\n<p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p>\n<p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p>\n<p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p>\n<p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p>\n<p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p>\n<p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p>\n<p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p>\n<p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p>\n<p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p>\n<p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p>\n<p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p>\n<p>然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；</p>\n<p>接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；</p>\n<p>然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；</p>\n<p>然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；</p>\n<p>然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；</p>\n<p>然后是享元模式，轻量级对象，通过共用不变对象来实现；</p>\n<p>然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；</p>\n<p>然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；</p>\n<p>最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。</p>\n<p><a href=\"https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187\">友情链接</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckt2l835r0003hct725631zr5","category_id":"ckt2l835t0006hct77ejsdm3t","_id":"ckt2l835y000ghct72jmu7c7l"},{"post_id":"ckt2l835s0005hct78hziett1","category_id":"ckt2l835w000bhct73fr07xis","_id":"ckt2l8361000mhct7ez0l90ba"},{"post_id":"ckt2l835u0008hct7a08v2gcr","category_id":"ckt2l835w000bhct73fr07xis","_id":"ckt2l8363000rhct7ddkn9nij"},{"post_id":"ckt2l835v0009hct73wp85j3y","category_id":"ckt2l8360000lhct7g21b9k06","_id":"ckt2l8366000xhct7fcfmeuhv"},{"post_id":"ckt2l835v000ahct72qmk15uk","category_id":"ckt2l8363000thct76afxg76t","_id":"ckt2l83680014hct7955eds5g"},{"post_id":"ckt2l835x000ehct7348i0i76","category_id":"ckt2l8366000zhct74iyl2006","_id":"ckt2l836b001chct7dhamez5j"},{"post_id":"ckt2l835x000fhct717jp8fs2","category_id":"ckt2l8366000zhct74iyl2006","_id":"ckt2l836d001ihct7hlxqg89p"},{"post_id":"ckt2l835z000jhct7dp206vwl","category_id":"ckt2l8366000zhct74iyl2006","_id":"ckt2l836f001nhct75rawg46d"},{"post_id":"ckt2l8360000khct776qn11mw","category_id":"ckt2l836d001hhct71k6n1lqz","_id":"ckt2l836h001thct7e8h0hdbo"},{"post_id":"ckt2l8361000ohct7fy18e9mp","category_id":"ckt2l8366000zhct74iyl2006","_id":"ckt2l836i001zhct7ap9je08m"},{"post_id":"ckt2l8362000qhct76w4lagqa","category_id":"ckt2l8366000zhct74iyl2006","_id":"ckt2l836j0024hct7cdas4jck"},{"post_id":"ckt2l8363000vhct7gzfb5mkd","category_id":"ckt2l836i001yhct7f4l06tif","_id":"ckt2l836k002bhct7a42f6yvv"},{"post_id":"ckt2l8364000whct72iafhchl","category_id":"ckt2l836j0025hct7forw4pzv","_id":"ckt2l836m002hhct7328x2szd"},{"post_id":"ckt2l83660010hct71l6s7186","category_id":"ckt2l836i001yhct7f4l06tif","_id":"ckt2l836m002lhct7645jdkc6"},{"post_id":"ckt2l83670012hct7ednu2lyk","category_id":"ckt2l836l002ghct7gpei21f9","_id":"ckt2l836n002phct7hki4ance"},{"post_id":"ckt2l83690016hct7apj066o0","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836o002vhct7beye27ol"},{"post_id":"ckt2l836a0019hct75yyqge6u","category_id":"ckt2l836i001yhct7f4l06tif","_id":"ckt2l836o002zhct70oa4a4kg"},{"post_id":"ckt2l836b001ahct7dkwhhhcj","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836p0031hct7gxc5g94b"},{"post_id":"ckt2l836c001fhct7auk196sk","category_id":"ckt2l836i001yhct7f4l06tif","_id":"ckt2l836p0036hct7byhcbtb9"},{"post_id":"ckt2l836d001ghct76l7r7i7f","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836q003ahct7hid3d8i2"},{"post_id":"ckt2l836e001khct7hhh19u2r","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836q003dhct7ae4zcutu"},{"post_id":"ckt2l836f001mhct7aybb06z6","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836r003hhct73zhacmln"},{"post_id":"ckt2l836g001qhct71ipo9tzm","category_id":"ckt2l836m002nhct76hm613qw","_id":"ckt2l836r003khct71l2q0b0f"},{"post_id":"ckt2l836g001rhct74on43lq2","category_id":"ckt2l836r003ghct7gu4e551w","_id":"ckt2l836s003ohct7eehu748y"},{"post_id":"ckt2l836h001vhct75w800lgr","category_id":"ckt2l836r003lhct734shgc2p","_id":"ckt2l836s003shct77md8crbx"},{"post_id":"ckt2l836i001xhct72v3dh98e","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836t003yhct77iimhcgr"},{"post_id":"ckt2l836i0022hct73ab66cxt","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836u0041hct7h0qveio6"},{"post_id":"ckt2l836j0023hct7b6cq50ck","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836u0046hct77u7xdmsq"},{"post_id":"ckt2l836j0027hct71ny176em","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836v0049hct7bjlj1j7w"},{"post_id":"ckt2l836k0029hct72o0dejl5","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836v004ehct76v7k8amy"},{"post_id":"ckt2l836l002ehct7fnkk8gnz","category_id":"ckt2l836s003qhct7gbtk7ywj","_id":"ckt2l836v004ghct7hrjkb4r1"},{"post_id":"ckt2l836l002fhct71ho86wyk","category_id":"ckt2l836v004dhct7a0e2b14h","_id":"ckt2l836w004lhct7d8ph7aeo"}],"PostTag":[{"post_id":"ckt2l835r0003hct725631zr5","tag_id":"ckt2l835u0007hct7erw85xxm","_id":"ckt2l835x000dhct72lfh0f5q"},{"post_id":"ckt2l835s0005hct78hziett1","tag_id":"ckt2l835w000chct79derb8an","_id":"ckt2l8361000phct7asgta6ov"},{"post_id":"ckt2l835s0005hct78hziett1","tag_id":"ckt2l835y000ihct79rvob74a","_id":"ckt2l8363000shct75a3vds09"},{"post_id":"ckt2l835u0008hct7a08v2gcr","tag_id":"ckt2l835w000chct79derb8an","_id":"ckt2l83670011hct7dp1c2wt2"},{"post_id":"ckt2l835u0008hct7a08v2gcr","tag_id":"ckt2l835y000ihct79rvob74a","_id":"ckt2l83680013hct76ww22it4"},{"post_id":"ckt2l835v0009hct73wp85j3y","tag_id":"ckt2l8366000yhct79zwiajre","_id":"ckt2l836a0018hct75hg47eey"},{"post_id":"ckt2l835v000ahct72qmk15uk","tag_id":"ckt2l83680015hct7bs7870ol","_id":"ckt2l836c001ehct76818hhuu"},{"post_id":"ckt2l835x000ehct7348i0i76","tag_id":"ckt2l836b001dhct748wveeau","_id":"ckt2l836e001lhct7hw9642hh"},{"post_id":"ckt2l835x000fhct717jp8fs2","tag_id":"ckt2l836b001dhct748wveeau","_id":"ckt2l836h001whct75k5752dw"},{"post_id":"ckt2l835x000fhct717jp8fs2","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836i0020hct70w0h6dll"},{"post_id":"ckt2l835z000jhct7dp206vwl","tag_id":"ckt2l836b001dhct748wveeau","_id":"ckt2l836k0028hct7arxc74y1"},{"post_id":"ckt2l835z000jhct7dp206vwl","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836k002ahct7f7xy5wgf"},{"post_id":"ckt2l8360000khct776qn11mw","tag_id":"ckt2l836j0026hct72dybf381","_id":"ckt2l836m002jhct774ai5ygv"},{"post_id":"ckt2l8360000khct776qn11mw","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836m002khct7gtwx9yk5"},{"post_id":"ckt2l8361000ohct7fy18e9mp","tag_id":"ckt2l836b001dhct748wveeau","_id":"ckt2l836n002rhct780wb12to"},{"post_id":"ckt2l8361000ohct7fy18e9mp","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836n002shct72s1wemr2"},{"post_id":"ckt2l8362000qhct76w4lagqa","tag_id":"ckt2l836b001dhct748wveeau","_id":"ckt2l836o002whct73su44uzm"},{"post_id":"ckt2l8363000vhct7gzfb5mkd","tag_id":"ckt2l836n002thct79wlj1jmo","_id":"ckt2l836p0033hct71qp81in2"},{"post_id":"ckt2l8363000vhct7gzfb5mkd","tag_id":"ckt2l836o002xhct77l3n752c","_id":"ckt2l836p0034hct7ek349m0d"},{"post_id":"ckt2l8364000whct72iafhchl","tag_id":"ckt2l836p0032hct7hwgh9658","_id":"ckt2l836q0038hct7dwk6hxao"},{"post_id":"ckt2l83660010hct71l6s7186","tag_id":"ckt2l836n002thct79wlj1jmo","_id":"ckt2l836r003fhct7g02z6ke6"},{"post_id":"ckt2l83660010hct71l6s7186","tag_id":"ckt2l836o002xhct77l3n752c","_id":"ckt2l836r003ihct74cxbdzn2"},{"post_id":"ckt2l83670012hct7ednu2lyk","tag_id":"ckt2l836r003ehct7a1vg3440","_id":"ckt2l836s003nhct7c2u5f1kq"},{"post_id":"ckt2l83670012hct7ednu2lyk","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836s003phct76ymseytm"},{"post_id":"ckt2l83690016hct7apj066o0","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836t003vhct760sed5rh"},{"post_id":"ckt2l83690016hct7apj066o0","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836t003whct7hxrs7gvg"},{"post_id":"ckt2l836a0019hct75yyqge6u","tag_id":"ckt2l836n002thct79wlj1jmo","_id":"ckt2l836u0043hct743ibcbc2"},{"post_id":"ckt2l836a0019hct75yyqge6u","tag_id":"ckt2l836o002xhct77l3n752c","_id":"ckt2l836u0044hct706nx5drj"},{"post_id":"ckt2l836b001ahct7dkwhhhcj","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836v004bhct7b0r18bnk"},{"post_id":"ckt2l836b001ahct7dkwhhhcj","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836v004chct72l3idpuq"},{"post_id":"ckt2l836c001fhct7auk196sk","tag_id":"ckt2l836n002thct79wlj1jmo","_id":"ckt2l836w004ihct73axlap63"},{"post_id":"ckt2l836c001fhct7auk196sk","tag_id":"ckt2l836o002xhct77l3n752c","_id":"ckt2l836w004jhct7d916e7l6"},{"post_id":"ckt2l836d001ghct76l7r7i7f","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836w004nhct70f7j4lwg"},{"post_id":"ckt2l836d001ghct76l7r7i7f","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836x004ohct73ztl9tsc"},{"post_id":"ckt2l836e001khct7hhh19u2r","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836x004rhct7abal9v16"},{"post_id":"ckt2l836e001khct7hhh19u2r","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836x004shct77i0e9nl8"},{"post_id":"ckt2l836f001mhct7aybb06z6","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836x004vhct7bmqk37z6"},{"post_id":"ckt2l836f001mhct7aybb06z6","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836y004whct74gkr72r5"},{"post_id":"ckt2l836g001qhct71ipo9tzm","tag_id":"ckt2l836s003mhct7ahaldra9","_id":"ckt2l836y004yhct70jfz5odf"},{"post_id":"ckt2l836g001qhct71ipo9tzm","tag_id":"ckt2l836f001phct7680z8uwi","_id":"ckt2l836y004zhct77neg6a2r"},{"post_id":"ckt2l836g001rhct74on43lq2","tag_id":"ckt2l836y004xhct77nh195sy","_id":"ckt2l836y0051hct76i1lhdj7"},{"post_id":"ckt2l836h001vhct75w800lgr","tag_id":"ckt2l836y0050hct7asrx0k7o","_id":"ckt2l836y0053hct7504w9gnq"},{"post_id":"ckt2l836i001xhct72v3dh98e","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l836z0055hct7dhjx3oz8"},{"post_id":"ckt2l836i0022hct73ab66cxt","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l836z0057hct70ipbewti"},{"post_id":"ckt2l836j0023hct7b6cq50ck","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l836z0059hct7g75efjfr"},{"post_id":"ckt2l836j0027hct71ny176em","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l8370005bhct76r9e4j0h"},{"post_id":"ckt2l836k0029hct72o0dejl5","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l8370005dhct7ck2t6udj"},{"post_id":"ckt2l836l002ehct7fnkk8gnz","tag_id":"ckt2l836y0052hct71bz95xjj","_id":"ckt2l8370005fhct79j31b3v5"},{"post_id":"ckt2l836l002fhct71ho86wyk","tag_id":"ckt2l8370005ehct7gr9qf9ai","_id":"ckt2l8370005ghct77vhp4k2y"}],"Tag":[{"name":"Markdown","_id":"ckt2l835u0007hct7erw85xxm"},{"name":"Dubbo","_id":"ckt2l835w000chct79derb8an"},{"name":"分布式","_id":"ckt2l835y000ihct79rvob74a"},{"name":"Feign","_id":"ckt2l8366000yhct79zwiajre"},{"name":"Hexo","_id":"ckt2l83680015hct7bs7870ol"},{"name":"oyr-MQ","_id":"ckt2l836b001dhct748wveeau"},{"name":"中间件","_id":"ckt2l836f001phct7680z8uwi"},{"name":"MQ","_id":"ckt2l836j0026hct72dybf381"},{"name":"oyr-MySQL","_id":"ckt2l836n002thct79wlj1jmo"},{"name":"数据库","_id":"ckt2l836o002xhct77l3n752c"},{"name":"java","_id":"ckt2l836p0032hct7hwgh9658"},{"name":"Nginx","_id":"ckt2l836r003ehct7a1vg3440"},{"name":"oyr-Redis","_id":"ckt2l836s003mhct7ahaldra9"},{"name":"DDD","_id":"ckt2l836y004xhct77nh195sy"},{"name":"spring","_id":"ckt2l836y0050hct7asrx0k7o"},{"name":"并发编程","_id":"ckt2l836y0052hct71bz95xjj"},{"name":"设计模式","_id":"ckt2l8370005ehct7gr9qf9ai"}]}}