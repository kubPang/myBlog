---
title: 设计模式初讲
date: 2021-07-27 00:00:00
author: lh
summary: ""
categories: 设计模式
tags: 
    - 设计模式
---

# 扩展知识

## 什么是设计模式

设计模式（Design pattern） 是解决软件开发某些特定问题而提出的一些解决方案也可以理解成解决问题的一些思路。通过设计模式可以帮助我们增强代码的可重用性、可扩充性、 可维护性、灵活性好。我们使用设计模式最终的目的是实现代码的高内聚和低耦合。

## 设计模式的三大分类及关键点

![设计模式三大分类](https://kubpang.github.io/sourceFile/设计模式/设计模式三大分类.jpg)

### 创建型模式  

    对象实例化的模式，创建型模式用于解耦对象实例化的过程

   1. [单列模式](https://blog.csdn.net/guorui_java/article/details/106585965): 某个类只有一个实例，提供一个全局的访问点，例如：单点登录。  
   2. [工厂模式](https://blog.csdn.net/guorui_java/article/details/105087806): 一个工厂类根据传入的参数决定创建哪一种产品类的实例。  
   3. [抽象工厂模式](https://blog.csdn.net/guorui_java/article/details/106535411) : 创建相关或依赖对象的家族，而无需明确指定具体类。  
   4. [建造者模式](https://blog.csdn.net/guorui_java/article/details/106684541) : 封装一个复杂对象的创建过程，并可以安步骤构造。  
   5. [原型模式](https://blog.csdn.net/guorui_java/article/details/106544941) : 通过复制现有的实例来创建新的实例。


### 结构型模式

    把类或对象结合在一起形成一个更大的结构

   1. [装饰模式](https://blog.csdn.net/guorui_java/article/details/106613220) : 动态的给对象添加新的功能。  
   2. [代理模式](https://blog.csdn.net/guorui_java/article/details/106665200) : 未其他对象提供一个代理以便控制这个对象的访问。  
   3. [桥接模式](https://blog.csdn.net/guorui_java/article/details/106688252) : 将抽象部分和它的实现部分分离，使它们可以独立的变化。  
   4. [适配器模式](https://blog.csdn.net/guorui_java/article/details/106584559) : 将一个类的方法接口转换到客户希望的另一个接口。  
   5. [组合模式](https://blog.csdn.net/guorui_java/article/details/106617887) : 将对象组合成树形结构以表示“部分-整体”的结构层次。  
   6. [外观模式](https://blog.csdn.net/guorui_java/article/details/104247938) : 对外提供一个统一的方法，来访问子系统的一群接口。  
   7. [享元模式](https://blog.csdn.net/guorui_java/article/details/106640489) : 通过共享技术来有效的支持大量细粒度的对象。  


### 行为型模式  

    类和对象如何交互，以及划分责任和算法

   1. [策略模式](https://blog.csdn.net/guorui_java/article/details/104039882) : 定义一系列算法，把他们封装起来，并且使用它们可以相互替换。  
   2. [模板模式](https://blog.csdn.net/guorui_java/article/details/106677554) : 定义一个算法结构，而将一些步骤延迟到子类中实现。  
   3. [命令模式](https://blog.csdn.net/guorui_java/article/details/106718457) : 将命令请求封装为一个对象，是的可以用不同的请求来进行参数化。  
   4. [迭代器模式](https://blog.csdn.net/guorui_java/article/details/104247911) : 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。  
   5. [观察者模式](https://blog.csdn.net/guorui_java/article/details/104247965) : 对象间的一对多的依赖关系。  
   6. [仲裁者模式](https://blog.csdn.net/guorui_java/article/details/104247966) : 用一个中介对象来封装一系列的对象交互。  
   7. [备忘录模式](https://blog.csdn.net/guorui_java/article/details/104247969) : 在不破坏封装的前提下，保持对象的内部状态。  
   8. [解释器模式](https://blog.csdn.net/guorui_java/article/details/104247972) : 给定一个语言，定义它的语法的一种表示，并定义一个解释器。  
   9. [状态模式](https://blog.csdn.net/guorui_java/article/details/104247975) : 允许一个对象在对象内部状态改变时改变它的行为。  
   10. [责任链模式](https://blog.csdn.net/guorui_java/article/details/104247978) : 将请求的发送者和接受者解耦，使得多个对象都有处理这个请求的机会。  
   11. [访问者模式](https://blog.csdn.net/guorui_java/article/details/104247935) : 不改变数据结构的其前提下，增加作用一组对象元素的新功能。  


 ## 设计模式的原则

 ### 1. 单一职责原则 
    
    对于一个类，只有一个引起该类变化的原因。  
    该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。  

 ### 2. 接口隔离原则  
    
    客户端不应该依赖它不需要的接口。  
    一个类对另一个类的依赖应该建立在最小接口上。

### 3. 依赖倒转原则  

    程序要依赖于抽象接口，不要依赖于具体实现。  
    简单来说就是要求对抽象进行编程，不要对具体实现进行编程，这样就降低了客户与实现模块建的耦合。  

### 4. 里式代替原则  

    1. 任何基类出现的地方，子类一定可以出现。  
    2. 里式代替原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能欧股在基类的基础上增加新的行为。  
    3. 里式替代原则是对开闭原则的补充。  
    4. 实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

### 5. 开闭原则  

1. 对于扩展是开放的（Open for extension）。这就意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。  
2. 对于修改是关闭的（Closed for modification）。对于模块行为进行扩展时，不必改动模块的源代码或者二进制码。模块的二进制码可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。  

### 6. 迪米特法则

    迪米特法则又叫最少知识原则，意思是一个对象应当对其它对象尽可能少的了解。  

### 7. 合成复用原则  

    1. 合成复用原则要求在软件复用时，要尽量使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
    2. 如果要使用继承关系，则必须严格遵循里式替换原则。  
    3. 合成复用原则同里式替换原则相辅相成，两者都是开闭原则的具体实现规范。

[设计模式七大原则总结](https://blog.csdn.net/guorui_java/article/details/106469226)  

## 设计模式关系  

![设计模式之间的关系](https://kubpang.github.io/sourceFile/设计模式/设计模式关系图.jpg) 

![设计模式之间的关系](https://kubpang.github.io/sourceFile/设计模式/设计模式之间的关系.png) 

## 设计模式感想  
一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展
性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。

同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。 

## 设计模式回顾  
从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；

其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；

然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；

之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；

然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；

之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；

然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；

然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；

然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；

然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；

接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；

接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；

然后是外观模式，通过整合各个类之间的调用关系，组建成了统一的接口(API)，便于外部类的调用；

接着是仲裁者模式，将很多类之间互相关联的关系交给仲裁者处理，省去了各个类之间的嵌套和调动，有利于高内聚和低耦合，思路清晰，便于扩展；

然后是观察者模式，通过互相委托从而能够在被观察的类发生改变的时候得到相应的改变的信息并且处理；

然后是备忘录模式，通过在某一时刻的状态保存下来，便于恢复，在游戏中使用的比较多；

然后是状态模式，将状态当做类，从而职责分明，解除了很多繁琐的if和else这些分支逻辑，便于扩展；

然后是享元模式，轻量级对象，通过共用不变对象来实现；

然后是代理模式，懒加载真正的服务器，加快访问速度，代理是帮助服务器代理的；

然后是命令模式，将命令当做类，通过保存一些列命令，从而能够随时执行这些命令，需要清除命令的本质就是一些操作和数据；

最后是解释器模式，利用编程原理的方法，来更高层次的封装代码，将自己开发的java代码当做编译系统，从而不用改变java代码只修改更高语言层次的代码就能实现不同的功能。

[友情链接](https://blog.csdn.net/guorui_java/article/details/104026988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162736597116780261988403%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162736597116780261988403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104026988.first_rank_v2_pc_rank_v29&utm_term=java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)