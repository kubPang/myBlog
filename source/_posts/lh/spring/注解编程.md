---
title: 注解编程
date: 2021-08-31 00:00:00
author: lh
summary: ""
categories: spring
tags: 
    - spring
---

# 为什么要使用注解编程
    注解编程可以使得代码更简洁，提供开发效率。  
    替换xml这种配置形式，简化配置
例如 开发一个User类：
```java
public class User(){....}
```
添加注解@Component后如下：
```java
@Component
public class User(){....}
```

该形式等价于在spring配置文件中的
```xml
<bean id="user" class="com.study.User"></bean>
```

# 容器相关注解
## 组件注册 
### @Configuration
作用在类上，表示这个是一个配置类，相当于配置文件xml一样

### @Bean 
作用在方法上，和 bean 标签功能一致，返回值是class，方法名默认是id，也可以指定

### @ComponentScan 
作用在类上，配置扫描包，可以使用excludeFilters或includeFilters来过滤或指定包含哪个类    

使用excludeFilters：过滤掉哪些类
```java
@ComponentScan(value = {"com.study"}, excludeFilters={
		@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})
})	//配置扫描包
```

使用includeFilters：包含哪些类
```java
@ComponentScan(value = {"com.study"}, includeFilters={
		@Filter(type=FilterType.ANNOTATION, value={Service.class})
}, useDefaultFilters=false)	//配置扫描包
```

### @ComponentScans
配置扫描包，可以设置多个值 

```java 
@ComponentScans({
	@ComponentScan(value = {"com.study"}, excludeFilters={
			@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class})
	})	//配置扫描包
})
```
自动过滤规则：
```java
public class MyTypeFilter implements TypeFilter{

	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
		//注解信息
		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
		//类信息
		ClassMetadata classMetadata = metadataReader.getClassMetadata();
		//路径信息
		Resource resource = metadataReader.getResource();
		//获取类名
		String className = classMetadata.getClassName();
		System.out.println(className);
		if(className.contains("er")){
			return true;
		}
		return false;
	}
}
```

```java
@ComponentScans({
	@ComponentScan(value = {"com.study"}, excludeFilters={
			@Filter(type=FilterType.ANNOTATION, value={Controller.class, Service.class}),
			@Filter(type=FilterType.CUSTOM, value={MyTypeFilter.class})	//使用自定义的过滤规则
	})	//配置扫描包
})
```

### @Scope
作用在方法上，相当于 bean 中的scope属性
```java
/**
	 * prototype	多实例，当要用到时才会创建实例
	 * singleton	单例（默认），在spring容器创建时就创建实例了
	 * request		同一个请求创建一个实例（很少用到）
	 * session		同一个session创建一个实例（很少用到）
	 * @return
	 */
	@Scope("prototype")
	@Bean
	public Student student(){
		System.out.println("创建student对象");
		return new Student("张三", 15);
	}

```

### @Lazy
懒加载，作用单实例bean中，原来的单实例bean在spring容器加载后会自动创建实例，加了此注解后，会在第一次使用到此bean时才会创建。

```java
@Lazy
	@Bean
	public Student student(){
		System.out.println("创建student对象");
		return new Student("张三", 15);
	}
```

### @Conditional
可以作用在类或方法上。  
作用在方法上： 如果条件返回true，则创建bean
作用在类上： 如果返回true，此类的注册bean才会生效。
```java
    @Conditional({WindowsCondition.class})
	@Bean("windows")
	public Student student2(){
		return new Student("my is windows", 60);
	}
	
	@Conditional({LinuxCondition.class})
	@Bean("linux")
	public Student student3(){
		return new Student("my is linux", 50);
	}
```

```java
//判断是否是Linux系统
public class LinuxCondition implements Condition {
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Environment environment = context.getEnvironment();
		String name = environment.getProperty("os.name");
		if(name.contains("linux")){
			return true;
		}
		return false;
	}
}
```

```java

//判断是否是windows系统
public class WindowsCondition implements Condition{

	/**
	 * context：程序上下文
	 * metadata：注解信息
	 */
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		//bean工厂
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		//程序运行环境
		Environment environment = context.getEnvironment();
		//bean注册信息
		BeanDefinitionRegistry registry = context.getRegistry();
		
		String name = environment.getProperty("os.name");
		if(name.contains("Windows")){
			return true;
		}
		return false;
	}

}
```