---
title: RabbitMQ-消息幂等性问题
date: 2021-10-26 00:00:00
author: 神奇的荣荣
summary: ""
categories: ory-MQ
tags:
- MQ
- 中间件
- RabbitMQ
---

# 幂等性

## 概念

用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。
> 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，
> 用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。
> 在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等

## 消息重复消费

消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，
或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。

## 常用消息幂等性解决方案

### 利用数据库的唯一约束实现幂等

比如将订单表中的订单编号设置为唯一索引，创建订单时，根据订单编号就可以保证幂等

### redis的原子性机制

每次操作都直接set到redis里面，然后将redis数据定时同步到数据库中。

### 乐观锁机制

此方案多用于更新的场景下。
其实现的大体思路是：给业务数据增加一个版本号属性，每次更新数据前，比较当前数据的版本号是否和消息中的版本一致，如果不一致则拒绝更新数据，更新数据的同时将版本号+1。

### 全局唯一ID

生产者发送每条数据的时候，增加一个全局唯一的id，这个id通常是业务的唯一标识，比如订单编号。
在消费端消费时，则验证该id是否被消费过，如果还没消费过，则进行业务处理。处理结束后，在把该id存入redis，同时设置状态为已消费。如果已经消费过了，则不进行处理。

### 推荐使用

使用全局唯一ID 或 乐观锁机制。
当在集群环境下，出现消息幂等性问题后，可以使用 [分布式锁+全局唯一id] 或 [分布式锁+乐观锁机制]