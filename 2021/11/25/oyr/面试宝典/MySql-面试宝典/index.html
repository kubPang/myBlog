<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kubpang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据库基础主流的数据库SqlServer数据库是微软，.net程序员最爱，中型和大型项目，性能高 Oracle数据库是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。 Mysql数据库是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。 db2数据库是ibm公司，处理海量数据，大型项目。很强悍。 Informix数据库是ibm公司。在银行系">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql-面试宝典">
<meta property="og:url" content="https://kubpang.github.io/myBlog/2021/11/25/oyr/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/MySql-%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/index.html">
<meta property="og:site_name" content="柯竹">
<meta property="og:description" content="数据库基础主流的数据库SqlServer数据库是微软，.net程序员最爱，中型和大型项目，性能高 Oracle数据库是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。 Mysql数据库是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。 db2数据库是ibm公司，处理海量数据，大型项目。很强悍。 Informix数据库是ibm公司。在银行系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rong0624.gitee.io/images/MySql/20211126131122.png">
<meta property="og:image" content="https://rong0624.gitee.io/images/MySql/20211125190201.png">
<meta property="og:image" content="https://rong0624.gitee.io/images/MySql/20211126124332.png">
<meta property="og:image" content="https://rong0624.gitee.io/images/MySql/20211126231116.png">
<meta property="article:published_time" content="2021-11-24T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-29T10:52:58.263Z">
<meta property="article:author" content="那个猪">
<meta property="article:tag" content="面试宝典">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rong0624.gitee.io/images/MySql/20211126131122.png">

<link rel="canonical" href="https://kubpang.github.io/myBlog/2021/11/25/oyr/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/MySql-%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Mysql-面试宝典 | 柯竹</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">柯竹</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kubpang.github.io/myBlog/2021/11/25/oyr/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/MySql-%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="那个猪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柯竹">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mysql-面试宝典
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-25T00:00:00+08:00">2021-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-29 18:52:58" itemprop="dateModified" datetime="2021-11-29T18:52:58+08:00">2021-11-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" itemprop="url" rel="index"><span itemprop="name">面试宝典</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="主流的数据库"><a href="#主流的数据库" class="headerlink" title="主流的数据库"></a>主流的数据库</h2><p>SqlServer数据库<br>是微软，.net程序员最爱，中型和大型项目，性能高</p>
<p>Oracle数据库<br>是甲骨文的，java程序员（必学），大型项目，特点是适合处理复杂业务逻辑。</p>
<p>Mysql数据库<br>是sun公司，属于甲骨文公司，中型大型项目，特点：并发性好。对简单的sql处理效率高。</p>
<p>db2数据库<br>是ibm公司，处理海量数据，大型项目。很强悍。</p>
<p>Informix数据库<br>是ibm公司。在银行系统，安全性高</p>
<p>Sybase数据库</p>
<span id="more"></span>

<h2 id="数据库中DQL，DML，DDL，TCL语言都是什么？"><a href="#数据库中DQL，DML，DDL，TCL语言都是什么？" class="headerlink" title="数据库中DQL，DML，DDL，TCL语言都是什么？"></a>数据库中DQL，DML，DDL，TCL语言都是什么？</h2><p>DQL语言：查询语句<br>DML语言：新增，修改，删除语句<br>DDL语言：库，表，约束的结构管理<br>TCL语言：事物管理</p>
<h1 id="MySql-基础"><a href="#MySql-基础" class="headerlink" title="MySql 基础"></a>MySql 基础</h1><h2 id="crud语句"><a href="#crud语句" class="headerlink" title="crud语句"></a>crud语句</h2><p>select * from 表名<br>insert into 表名 values(),(),……<br>update 表名 set 列名=？ where 列名=？<br>delete from 表名 where 列名=?</p>
<h2 id="sql怎么去重"><a href="#sql怎么去重" class="headerlink" title="sql怎么去重?"></a>sql怎么去重?</h2><p>使用distinct去重</p>
<h2 id="case的使用"><a href="#case的使用" class="headerlink" title="case的使用"></a>case的使用</h2><p>case<br>作用：判断<br>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 要带的字段或表达式</span><br><span class="line"><span class="keyword">when</span> 常量<span class="number">1</span> <span class="keyword">then</span> 要显示的值或语句;</span><br><span class="line"><span class="keyword">when</span> 常量<span class="number">2</span> <span class="keyword">then</span> 要显示的值或语句;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span> 要显示的值或语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="comment">部门号=30,显示的工资为1.1倍</span></span><br><span class="line"><span class="comment">部门号=40，显示的工资为1.2倍</span></span><br><span class="line"><span class="comment">部门号=50，显示的工资为1.3倍</span></span><br><span class="line"><span class="comment">其他部门，显示的工资为原工资</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name, salary 原工资, </span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">40</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary<span class="operator">*</span><span class="number">1.3</span></span><br><span class="line"><span class="keyword">ELSE</span> salary</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 新工资</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例：查询员工的工资的情况</span></span><br><span class="line"><span class="comment">如果工资&gt;20000，显示A级别</span></span><br><span class="line"><span class="comment">如果工资&gt;15000，显示B级别</span></span><br><span class="line"><span class="comment">如果工资&gt;10000,显示C级别</span></span><br><span class="line"><span class="comment">否则，显示D级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 级别</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="cahr-和-varchar-的区别？"><a href="#cahr-和-varchar-的区别？" class="headerlink" title="cahr 和 varchar 的区别？"></a>cahr 和 varchar 的区别？</h2><p>char：是一个定长字段，假如申请了char(10)的空间，那么无论实际存储多少内容，该字段都占用10个字符<br>varchar：varchar是变长字段，也就是说申请的只是最大长度，占用的空间为实际字符+1，最后一位字符存储了使用多少空间。</p>
<p>在检索效率上来讲，char &gt; varchar，因此在使用中,如果确定某个字段的值的长度，可以使用char，否则应该尽量使用varchar。例如存储用户MD5加密后的密码，则应该使用char。</p>
<h2 id="union-与-union-all有什么区别？"><a href="#union-与-union-all有什么区别？" class="headerlink" title="union 与 union all有什么区别？"></a>union 与 union all有什么区别？</h2><ul>
<li>union：合并去重返回结果集。</li>
<li>union all：合并不去重返回结果集。</li>
</ul>
<h2 id="in-与-exists-的区别"><a href="#in-与-exists-的区别" class="headerlink" title="in 与 exists 的区别"></a>in 与 exists 的区别</h2><ul>
<li>in：作用是判断是否匹配列表中的值，返回true或false。适合于外表大而内表小的情况；</li>
<li>exists：作用是指定一个子查询，返回true或false。适合于外表小而内表大的情况。</li>
</ul>
<h2 id="外连接、内连接与自连接的区别？"><a href="#外连接、内连接与自连接的区别？" class="headerlink" title="外连接、内连接与自连接的区别？"></a>外连接、内连接与自连接的区别？</h2><ul>
<li>内连接：关键字是inner join，功能是把匹配的关联数据显示出来，两边的表数据都会显示。</li>
<li>左连接：关键字是left join，功能是左边的表全部显示出来，右边的表显示出符合条件的数据。</li>
<li>右连接：关键字是right join，功能是右边的表全部显示出来，左边的表显示出符合条件的数据。</li>
</ul>
<h2 id="drop、delete、truncate-的区别？"><a href="#drop、delete、truncate-的区别？" class="headerlink" title="drop、delete、truncate 的区别？"></a>drop、delete、truncate 的区别？</h2><ul>
<li>drop：删除关于表的一切（数据，结构，约束），不会记录日志，是DDL操作。</li>
<li>delete：删除表数据，delete可以加where条件，delete删除有返回值，delete删除可以回滚。使用delete删除后，再插入数据，自增长列的值从断点开始。</li>
<li>truncate：删除表所有数据，truncate不可以加where条件，truncate删除没有返回值，truncate删除不能回滚。使用truncate删除后，再插入值，自增长列的值从1开始。truncate删除效率比delete高。</li>
</ul>
<h2 id="查询sql的写法与机读顺序"><a href="#查询sql的写法与机读顺序" class="headerlink" title="查询sql的写法与机读顺序"></a>查询sql的写法与机读顺序</h2><p>查询sql写法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Select Distinct</span><br><span class="line"><span class="tag">&lt;<span class="name">Select_List</span>&gt;</span></span><br><span class="line">From </span><br><span class="line"><span class="tag">&lt;<span class="name">left_table</span>&gt;</span>	<span class="tag">&lt;<span class="name">join_type</span>&gt;</span> </span><br><span class="line">Join <span class="tag">&lt;<span class="name">right_table</span>&gt;</span> on <span class="tag">&lt;<span class="name">join_condition</span>&gt;</span></span><br><span class="line">WHERE	</span><br><span class="line"><span class="tag">&lt;<span class="name">where_condition</span>&gt;</span></span><br><span class="line">GROUP BY </span><br><span class="line"><span class="tag">&lt;<span class="name">group_by_list</span>&gt;</span></span><br><span class="line">HAVING</span><br><span class="line"><span class="tag">&lt;<span class="name">having_condition</span>&gt;</span></span><br><span class="line">ORDER BY</span><br><span class="line"><span class="tag">&lt;<span class="name">order_by_condition</span>&gt;</span></span><br><span class="line">LIMIT <span class="tag">&lt;<span class="name">limit_number</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>机读顺序：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="tag">&lt;<span class="name">left_table</span>&gt;</span></span><br><span class="line">ON <span class="tag">&lt;<span class="name">join_condition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">join_type</span>&gt;</span> JOIN <span class="tag">&lt;<span class="name">right_table</span>&gt;</span></span><br><span class="line">WHERE <span class="tag">&lt;<span class="name">where_condition</span>&gt;</span></span><br><span class="line">GROUP BY <span class="tag">&lt;<span class="name">group_by_list</span>&gt;</span></span><br><span class="line">HAVING <span class="tag">&lt;<span class="name">having_condition</span>&gt;</span></span><br><span class="line">Select </span><br><span class="line">Distinct <span class="tag">&lt;<span class="name">Select_List</span>&gt;</span></span><br><span class="line">ORDER BY <span class="tag">&lt;<span class="name">order_by_condition</span>&gt;</span></span><br><span class="line">LIMIT <span class="tag">&lt;<span class="name">limit_number</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>机读顺序，如图所示：<br><img src="https://rong0624.gitee.io/images/MySql/20211126131122.png" alt="查询SQL机读顺序"></p>
<h1 id="MySql-事务"><a href="#MySql-事务" class="headerlink" title="MySql 事务"></a>MySql 事务</h1><h2 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h2 id="MySql支持事务吗？"><a href="#MySql支持事务吗？" class="headerlink" title="MySql支持事务吗？"></a>MySql支持事务吗？</h2><p>mysql是否支持事务要根据存储引擎决定。InnoDB支持事务，MyISAM不支持事务。</p>
<h2 id="ACID是什么？"><a href="#ACID是什么？" class="headerlink" title="ACID是什么？"></a>ACID是什么？</h2><p>ACID指的是原子性（Atomicity），一致性（Consistency）， 隔离性（Isolation），持久性（Durability）</p>
<ul>
<li>原子性（Atomicity）：指事务是一个不可分割的工作单位，事务中的操作要么都执行成功，要么都执行失败。</li>
<li>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。不管转账多少次两个人的钱加起来都是800元。</li>
<li>隔离性（Isolation）：并发执行的各个事务之间不能互相干扰。事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。</li>
<li>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li>
</ul>
<h2 id="事务并发会带哪些问题？"><a href="#事务并发会带哪些问题？" class="headerlink" title="事务并发会带哪些问题？"></a>事务并发会带哪些问题？</h2><p>脏读，不可重复读，幻读。</p>
<p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题:</p>
<ul>
<li>脏读：一个事务读取到了其他事务未提交的数据；对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li>不可重复读：一个事务中多次读取同一个字段，值可能不同；对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li>幻读：一个事务中多次读取一张表数据，行可能不同；对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
<h2 id="事物的隔离级别有哪些？"><a href="#事物的隔离级别有哪些？" class="headerlink" title="事物的隔离级别有哪些？"></a>事物的隔离级别有哪些？</h2><p><img src="https://rong0624.gitee.io/images/MySql/20211125190201.png" alt="事务隔离级别"></p>
<p>Mysql支持4种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。</p>
<h1 id="MySql-架构"><a href="#MySql-架构" class="headerlink" title="MySql 架构"></a>MySql 架构</h1><h2 id="MySql-总体架构"><a href="#MySql-总体架构" class="headerlink" title="MySql 总体架构"></a>MySql 总体架构</h2><p><img src="https://rong0624.gitee.io/images/MySql/20211126124332.png" alt="总体架构"></p>
<p>整个MySQL Server由以下组成<br>Connection Pool : 连接池组件<br>Management Services &amp; Utilities : 管理服务和工具组件<br>SQL Interface : SQL接口组件<br>Parser : 查询分析器组件<br>Optimizer : 优化器组件<br>Caches &amp; Buffers : 缓冲池组件<br>Pluggable Storage Engines : 存储引擎<br>File System : 文件系统</p>
<p>主要分为：连接层、服务层、引擎层、存储层。<br>也可以认为是：服务层（连接层和服务层），存储层（引擎层和存储层）</p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能：</p>
<ul>
<li>SQL Interface: SQL接口；接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li>
<li>Parser: 解析器；SQL命令传递到解析器的时候会被解析器验证和解析。 </li>
<li>Optimizer: 查询优化器；SQL语句在查询之前会使用查询优化器对查询进行优化。 </li>
<li>Cache和Buffer：缓存和缓冲；如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</li>
</ul>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
<h2 id="Mysql支持哪些存储引擎？"><a href="#Mysql支持哪些存储引擎？" class="headerlink" title="Mysql支持哪些存储引擎？"></a>Mysql支持哪些存储引擎？</h2><p>MySql在5.0版本，支持的存储引擎有：InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、<br>ARCHIVE、CSV、BLACKHOLE、FEDERATED等。其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安<br>全表。</p>
<p>其中常用的存储引擎是InnoDB和MyISAM。</p>
<h2 id="引擎-InnoDB-和-MyISAM-的区别？"><a href="#引擎-InnoDB-和-MyISAM-的区别？" class="headerlink" title="引擎 InnoDB 和 MyISAM 的区别？"></a>引擎 InnoDB 和 MyISAM 的区别？</h2><p>MyISAM：不支持主外键和事物，支持表级锁，缓存索引但不缓存数据。</p>
<p>InnoDB：是Mysql5.1后默认的存储引擎，支持主外键和事务，支持表级锁和行级锁，默认采用行级锁，缓存索引也缓存数据。</p>
<h2 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h2><p>MyISAM：</p>
<ul>
<li>.frm（Framework）：存放表结构</li>
<li>.myd（data）：存放表数据</li>
<li>.myi（index）：存放表索引</li>
</ul>
<p>InnoDB：</p>
<ul>
<li>frm文件：存放表结构</li>
<li>数据文件：<ul>
<li>使用共享表空间存储，默认情况下使用，数据和索引保存在同一个表空间中，可以是多文件，通过innodb_data_home_dir 和 innodb_data_file_path定义的表空间。</li>
<li>使用多表空间存储，每个表的数据和索引单独保存在.ibd文件中。</li>
</ul>
</li>
</ul>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>Mysql有7种日志文件，分别是：  </p>
<ul>
<li>errorlog（错误日志）  </li>
<li>generallog（普通日志）  </li>
<li>slow query log（慢查询日志）  </li>
<li>binlog（二进制日志）  </li>
<li>relaylog（中继日志）  </li>
<li>redolog（重做日志）  </li>
<li>undolog（回滚日志）</li>
</ul>
<p>总要的日志文件：</p>
<ul>
<li>slow query log：慢查询日志  </li>
<li>undolog-redolog：事务日志（innoDB存储引擎日志）  </li>
<li>binlog：二进制日志（server层日志）  </li>
<li>relaylog：中继日志（主从复制）</li>
</ul>
<h2 id="一条查询SQL语句在执行时，其经历了那些过程？"><a href="#一条查询SQL语句在执行时，其经历了那些过程？" class="headerlink" title="一条查询SQL语句在执行时，其经历了那些过程？"></a>一条查询SQL语句在执行时，其经历了那些过程？</h2><p>会经历服务层和存储层<br>服务层：<br>连接器（连接mysql服务），<br>查询缓存（查询sql缓存），<br>分析器（词法分析，语法分析），<br>优化器（优化查询sql，执行计划生成，索引选择），<br>执行器（操作存储引擎，返回结果）</p>
<p>存储层：<br>存储引擎：存储数据，提供读写接口</p>
<h1 id="MySql-索引"><a href="#MySql-索引" class="headerlink" title="MySql 索引"></a>MySql 索引</h1><h2 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h2><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。<br>索引的目的：提高查找效率，类比字典。<br>索引的本质：索引是数据结构（有序）。</p>
<h2 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h2><p>优势：</p>
<ul>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li>
</ul>
<p>劣势：</p>
<ul>
<li>实际上索引也是一张表，每个索引也需要占用物理空间</li>
<li>当对表数据进行INSERT、UPDATE和DELETE时，也需要动态维护索引，降低了数据的更新速度。</li>
</ul>
<h2 id="索引都运用在哪些地方？"><a href="#索引都运用在哪些地方？" class="headerlink" title="索引都运用在哪些地方？"></a>索引都运用在哪些地方？</h2><ul>
<li>where：查询字段建立索引，通过索引进行检索</li>
<li>join：表连接中，关联字段建立索引，提高关联效率</li>
<li>索引覆盖：如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</li>
<li>order by：排序字段建立索引，通过索引进行排序</li>
</ul>
<h2 id="MySql索引类型有哪些？"><a href="#MySql索引类型有哪些？" class="headerlink" title="MySql索引类型有哪些？"></a>MySql索引类型有哪些？</h2><p>常用的索引类型：</p>
<ul>
<li>单值索引：即一个索引只包含单个列，一个表可以有多个单值索引</li>
<li>复合索引：即一个索引包含多个列</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值</li>
<li>主键索引：索引列的值必须唯一，且不能为空</li>
</ul>
<p>不常用的索引类型：</p>
<ul>
<li>前缀索引</li>
<li>聚簇索引</li>
</ul>
<h2 id="MySql索引结构有哪些？"><a href="#MySql索引结构有哪些？" class="headerlink" title="MySql索引结构有哪些？"></a>MySql索引结构有哪些？</h2><p>MySql索引结构主要分为4种，分别是：B-Tree索引、Hash索引、R-Tree索引、Full-Text索引（全文索引）。</p>
<p>InnoDB引擎支持B-Tree索引、Full-Text索引（全文索引）。<br>MyISAM引擎支持B-Tree索引、R-Tree索引、Full-Text索引（全文索引）</p>
<p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中<br>聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为索引。</p>
<h2 id="B-Tree索引原理"><a href="#B-Tree索引原理" class="headerlink" title="B+Tree索引原理"></a>B+Tree索引原理</h2><p>// TODO</p>
<h2 id="什么情况下需要创建索引，什么情况下不用创建索引？"><a href="#什么情况下需要创建索引，什么情况下不用创建索引？" class="headerlink" title="什么情况下需要创建索引，什么情况下不用创建索引？"></a>什么情况下需要创建索引，什么情况下不用创建索引？</h2><p>哪些情况下需要创建索引：</p>
<ul>
<li>频繁作为查询条件的字段创建索引</li>
<li>在关联表查询中，外键关联字段创建索引</li>
<li>查询中排序的字段创建索引，通过索引排序提高效率</li>
<li>查询中统计或分组的字段</li>
</ul>
<p>哪些情况下不要创建索引：</p>
<ul>
<li>表数据量少（mysql查询也是很强的，在数据量大的时候去建索引，百万条数据后查询性能逐渐下降）</li>
<li>更新频繁字段不适合创建索引（提高了查询速度，同时却会降低更新表的速度，MySQL不仅要保存数据，还要维护一下索引文件）</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要创建索引</li>
</ul>
<h2 id="什么是最左前缀原则？什么是最左匹配原则？"><a href="#什么是最左前缀原则？什么是最左匹配原则？" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则？"></a>什么是最左前缀原则？什么是最左匹配原则？</h2><p>如果是复合索引（由多字段组成），要遵守最左前缀法则。指的是查询从索引的最左列开始并且不跳过索引中的列。所以在创建复合索引时，要根据业务需求，where中使用最频繁的一列放在最左边，用于命中索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建复合索引: </span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_email_status <span class="keyword">ON</span> tb_seller(NAME,email,STATUS); </span><br><span class="line"></span><br><span class="line">就相当于对：</span><br><span class="line">name 创建索引 ;</span><br><span class="line">对name , email 创建了索引; </span><br><span class="line">对name , email, status 创建了索引;</span><br></pre></td></tr></table></figure>

<h2 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h2><p>前缀索引：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认索引是使用字段的全部内容。适用于前缀的标识度高，比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<h2 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引？" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引？"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</h2><ul>
<li>聚簇索引：将数据与索引存储到了一起，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引：<br><img src="https://rong0624.gitee.io/images/MySql/20211126231116.png" alt="何时使用聚簇索引与非聚簇索引"></p>
<h2 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h2><p>不一定，如果索引覆盖了，字段全部命中索引，就不需要再进行回表查询了。</p>
<blockquote>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
</blockquote>
<h2 id="索引如何查看、创建、删除？"><a href="#索引如何查看、创建、删除？" class="headerlink" title="索引如何查看、创建、删除？"></a>索引如何查看、创建、删除？</h2><p>查看索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tableName</span><br></pre></td></tr></table></figure>

<p>创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX IndexName <span class="keyword">ON</span> tableName(columnName(length));</span><br><span class="line"><span class="comment">-- 第二种方式</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">Table</span>Name <span class="keyword">add</span> [<span class="keyword">unique</span>] INDEX [IndexName] <span class="keyword">ON</span> (columnName(length));</span><br><span class="line"><span class="comment">-- 添加普通索引，索引值可出现多次。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX index_name (column_list): </span><br><span class="line"><span class="comment">-- 该条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name (column_list): </span><br><span class="line"><span class="comment">-- 该语句添加主键索引,这意味着索引值必须是唯一的，且不能为NULL。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(column_list); </span><br><span class="line"><span class="comment">-- 该语句指定了索引为 FULLTEXT ，用于全文索引。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> FULLTEXT index_name (column_list):</span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DORP INDEX IndexName <span class="keyword">ON</span> TableName;</span><br></pre></td></tr></table></figure>

<h1 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h1><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>explanin关键字可以模拟服务层sql优化器执行sql查询，从而知到mysql如何执行sql查询语句的。可以分析sql的性能瓶颈。</p>
<p>explain 关键字分析sql查询的执行情况，能明确看到当前sql查询类型，是否使用索引，使用的索引名，索引精度，还有其他的关键信息（使用了覆盖索引，使用了文件内排序，使用了临时表等等）。</p>
<p>explain使用语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- explain sql</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>explain分析sql，相关属性有：id、select_type、table、type、possible_keys、key、key_len、ref、rows、extra。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>id：select查询的序号，由数字组成。表示一个查询中各个子查询的执行顺序。</p>
<ul>
<li>id相同，执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。（如果是子查询，id的序号会递增）</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中</li>
</ul>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type：表示每个查询的类型。主要用于区分普通查询、联合查询、子查询等的复杂查询。</p>
<ul>
<li>SIMPLE：简单的 select 查询，查询中不包含任何子查询或者UNION等查询</li>
<li>PRIMARY：查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</li>
<li>SUBQUERY：在 select 或 where 中包含的子查询</li>
<li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。</li>
<li>DEPENDENT SUBQUERY：在SELECT或WHERE列表中包含了子查询,子查询基于外层</li>
<li>UNCACHEABLE SUBQUREY：无法被缓存的子查询</li>
<li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li>
<li>UNION RESULT：从UNION表获取结果的SELECT</li>
</ul>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>table：表示当前id查询的数据是那张表的。</p>
<h3 id="type（非常重要）"><a href="#type（非常重要）" class="headerlink" title="type（非常重要）"></a>type（非常重要）</h3><p>table：表示查询的类型，最常见的最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL。</p>
<ul>
<li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</li>
<li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>
<li>eq_ref：唯一性索引查找，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li>
<li>ref：非唯一性索引查找，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li>
<li>range：索引范围查找，只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>
<li>index：Full Index Scan，遍历索引，index与all区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从表所有数据中读的）</li>
<li>all：Full Table Scan，扫描全表数据，找到匹配的行。</li>
</ul>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>possible_keys：显示可能使用到的索引，注意不一定会使用。显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key：表示实际使用的索引，如果为null，则没有使用索引。查询中若使用了覆盖索引，则该索引就出现在key列表中。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常量。显示哪些列或常量被用于查找索引列上的值。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。越少越好。</p>
<h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>extra：包含不适合在其他列中显示，但十分重要的额外信息。</p>
<ul>
<li>USING index：使用覆盖索引，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</li>
<li>Using where：表明使用了where过滤。</li>
<li>Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<br>MySQL中无法利用索引完成的排序操作称为“文件排序”。内部再捣鼓了一次，性能下降。（九死一生，很重要，必须优化）</li>
<li>Using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。（十死无生，很重要，必须优化）</li>
</ul>
<h2 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h2><p>show profile 分析力度比 explain 更细。<br>show profile 可以分析sql运行的生命周期，可以帮助我们了解sql执行时间都耗费到哪里去了。可以看到很多信息，列如：可以看到开启表，查询数据，使用临时表，关闭表等等步骤信息，也可以见到每个步骤的cpu和io的消耗等等。</p>
<h2 id="如何避免索引失效？"><a href="#如何避免索引失效？" class="headerlink" title="如何避免索引失效？"></a>如何避免索引失效？</h2><ol>
<li>使用复合索引时，要遵守最左前缀法则。（指的是查询从索引的最左列开始并且不跳过索引中的列）</li>
<li>不在索引列上做任何操作（计算、函数、自动或手动类型转换），会导致索引失效而转向全表扫描</li>
<li>在同一复合索引下，范围条件右边索引失效，若是不同索引则不会失效</li>
<li>在使用不等于(!= 或者&lt;&gt;)的时候会导致索引失效</li>
<li>is null 或 is not null会导致索引失效（在索引列中不要保存null，用0代替，避免判null操作）</li>
<li>like通配符%开头索引失效（可以使用覆盖索引）</li>
<li>用or连接时索引失效（可以使用union来处理，使用各自的索引）</li>
</ol>
<h2 id="or关键字优化？"><a href="#or关键字优化？" class="headerlink" title="or关键字优化？"></a>or关键字优化？</h2><p>建议使用 union 来替代 or ，多个查询使用各自的索引。</p>
<h2 id="is-null-amp-is-not-null-关键字优化？"><a href="#is-null-amp-is-not-null-关键字优化？" class="headerlink" title="is null &amp; is not null 关键字优化？"></a>is null &amp; is not null 关键字优化？</h2><p>is null 或 is not null会导致索引失效？<br>尽量给索引字段设置为not null，用0代替null，避免判null操作。</p>
<h2 id="order-by-关键字优化？"><a href="#order-by-关键字优化？" class="headerlink" title="order by 关键字优化？"></a>order by 关键字优化？</h2><p>尽量使用索引排序：</p>
<ul>
<li>order by语句使用索引，如果是复合索引需要满足最左前缀法则，会使用索引排序</li>
<li>where子句 和 order子句条件列满足复合索引最左前缀法则，会使用索引排序</li>
<li>在使用order by时，不要用select *，只查询所需的字段，尽量使用索引内字段</li>
</ul>
<p>如果没有办法使用索引排序就会触发文件排序，单路排序或双路排序。<br>文件排序（filesort）优化</p>
<ul>
<li>尝试提高sort_buffer_size。</li>
<li>尝试提高max_length_for_sort_data。</li>
</ul>
<h2 id="group-by-关键字优化？"><a href="#group-by-关键字优化？" class="headerlink" title="group by 关键字优化？"></a>group by 关键字优化？</h2><p>group by实质是先排序后进行分组，遵照索引的最左前缀法则。<br>尽量使用索引列分组，可以通过<code>order by null</code>禁止排序，提高效率。</p>
<h2 id="子查询优化？"><a href="#子查询优化？" class="headerlink" title="子查询优化？"></a>子查询优化？</h2><p>建议使用连接（join）查询代替，避免创建临时表。</p>
<h2 id="连接（join）查询优化？"><a href="#连接（join）查询优化？" class="headerlink" title="连接（join）查询优化？"></a>连接（join）查询优化？</h2><ul>
<li>尽量保证小表驱动大表。</li>
<li>在被驱动表关联字段上建立索引。</li>
</ul>
<h2 id="超大分页怎么优化？"><a href="#超大分页怎么优化？" class="headerlink" title="超大分页怎么优化？"></a>超大分页怎么优化？</h2><p>初始：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> limit <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这种查询其实也是有可以优化的余地的. 这条语句需要加载1000000数据然后基本上全部丢弃，只取10条当然比较慢。</p>
<p>优化思路一：在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> limit <span class="number">1000000</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。</p>
<p>优化思路二：该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> limit <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少加载的数据.</p>
<h2 id="sql优化思路"><a href="#sql优化思路" class="headerlink" title="sql优化思路"></a>sql优化思路</h2><p>常见的SQL优化：<br>连接查询替代子查询<br>连接查询时保证小表驱动大表，给被驱动表join字段建索引<br>给条件查询字段上建索引<br>尽量避免索引失效<br>尽量在order by中使用索引（避免文件内排序，索引即可查询，也可以排序。）<br>尽量在group by中使用索引（避免使用临时表，禁止排序，能在where中过滤掉的数据，就不要使用having了）</p>
<p>测试环境分析优化sql：<br>开启慢查询日志（捕获慢查询sql）<br>分析慢查询sql（explanin+show profile）<br>对慢sql做优化（关键字相关优化，建立索引，避免索引失效）<br>mysql数据库参数调优（dba或运维经理）</p>
<p>大数据量优化：(数据库架构和架构方面)<br>读写分离，负载均衡<br>垂直切分和水平切分<br>如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。<br>如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上。</p>
<p>当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
<p>服务器硬件优化：<br>砸钱。一个办法。</p>
<h1 id="MySql-锁"><a href="#MySql-锁" class="headerlink" title="MySql 锁"></a>MySql 锁</h1><h2 id="为什么要使用锁？"><a href="#为什么要使用锁？" class="headerlink" title="为什么要使用锁？"></a>为什么要使用锁？</h2><p>当事务并发情况下，可能会产生数据的不一致，这时候需要一些机制来保证数据安全问题，锁就是这样的一个机制。</p>
<h2 id="MySQL从锁的类别上划分为哪几种锁？"><a href="#MySQL从锁的类别上划分为哪几种锁？" class="headerlink" title="MySQL从锁的类别上划分为哪几种锁？"></a>MySQL从锁的类别上划分为哪几种锁？</h2><p>从锁的类别上分类：</p>
<ul>
<li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
<p>事务并发的读写锁原则：<br>读-读能共存<br>读-写不能共存<br>写-写不能共存</p>
<h2 id="MySQL从锁的粒度划分为哪几种锁？"><a href="#MySQL从锁的粒度划分为哪几种锁？" class="headerlink" title="MySQL从锁的粒度划分为哪几种锁？"></a>MySQL从锁的粒度划分为哪几种锁？</h2><p>从锁的粒度上分类：</p>
<ul>
<li>表锁：操作数据时锁整张表</li>
<li>行锁：操作数据时只锁关联的数据行</li>
<li>页锁：锁定粒度基于表锁和行锁之间</li>
</ul>
<p>MyISAM支持行锁。InnoDB支持表锁和行锁，默认使用行锁。</p>
<h2 id="说说MySql的行锁和表锁？"><a href="#说说MySql的行锁和表锁？" class="headerlink" title="说说MySql的行锁和表锁？"></a>说说MySql的行锁和表锁？</h2><ul>
<li>表锁：即在执行读（SELECT）操作前，会自动给涉及的所有表加读锁，在执行写（增删改）操作前，会自动给涉及的所有表加写锁。偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率高，并发能力低。</li>
<li>行锁：根据索引执行写操作时只锁关联的数据行；如果索引不可用则升级为表锁。偏向于InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发能力高。</li>
</ul>
<h2 id="InnoDB的行锁是怎么实现的？"><a href="#InnoDB的行锁是怎么实现的？" class="headerlink" title="InnoDB的行锁是怎么实现的？"></a>InnoDB的行锁是怎么实现的？</h2><p>InnoDB 实现了以下两种类型的行锁:</p>
<ul>
<li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数<br>据，但是只能读不能修改。</li>
<li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他<br>锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行<br>读取和修改。</li>
</ul>
<p>InnoDB的行锁关键点：</p>
<ul>
<li>InnoDB行锁是通过给索引上的索引项加锁来实现的，意味着：只有通过索引检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>InnoDB行锁对普通的Select语句不加锁，对操作数据（update，insert，delete）语句，会自动给涉及数据加排它锁。</li>
</ul>
<p>手动添加行锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加行锁-共享锁：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加行锁-排它锁：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB有几种锁算法？"><a href="#InnoDB有几种锁算法？" class="headerlink" title="InnoDB有几种锁算法？"></a>InnoDB有几种锁算法？</h2><ul>
<li>Record Lock：记录锁，单个行记录上的锁；</li>
<li>Gap Lock：间隙锁，锁定一个范围，不包括记录本身；</li>
<li>Next-Key Lock：临键锁，锁定一个范围，包括记录本身。（记录锁+间隙锁）</li>
</ul>
<h2 id="间隙锁详情"><a href="#间隙锁详情" class="headerlink" title="间隙锁详情"></a>间隙锁详情</h2><ul>
<li>记录锁、间隙锁、临键锁，都属于排它锁；</li>
<li>间隙锁只有在事务隔离级别 RR 中才会产生；事务级别是RC（读已提交）级别的话，间隙锁将会失效</li>
<li>唯一索情况下，只有锁住多条记录或者一条不存在的记录的时候，才会产生间隙锁，指定给某条存在的记录加锁的时候，只会加记录锁，不会产生间隙锁；</li>
<li>普通一索情况下，不管是锁住单条，还是多条记录，都会产生间隙锁；</li>
<li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。</li>
<li>间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其它事务在这个区域内插入、修改、删除数据，这是为了防止出现 幻读 现象；</li>
</ul>
<h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>
<h2 id="MySql如何处理死锁？"><a href="#MySql如何处理死锁？" class="headerlink" title="MySql如何处理死锁？"></a>MySql如何处理死锁？</h2><p>对待死锁常见的两种策略：</p>
<ul>
<li>通过 innodblockwait_timeout 来设置超时时间，一直等待直到超时；</li>
<li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</li>
</ul>
<h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><ul>
<li>为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT … FOR UPDATE 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过 SELECT … LOCK IN SHARE MODE 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别。</li>
</ul>
<h2 id="事务隔离级别与锁的关系？"><a href="#事务隔离级别与锁的关系？" class="headerlink" title="事务隔离级别与锁的关系？"></a>事务隔离级别与锁的关系？</h2><ul>
<li>Read Uncommitted（读未提交）：读操作不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。</li>
<li>Read committed（读已提交）：读操作需要加共享锁，但在语句执行完后释放共享锁。</li>
<li>Repeatable read（可重复读）：读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>Serializable（串行化）：最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>mvcc中文全称叫多版本并发控制，用于于提高数据库高并发场景下的吞吐性能。只适用于RC（读已提交），RR（可重复读）。</p>
<p>RC、RR 两种隔离级别的事务在执行普通的读操作时，通过访问版本链的方法，使得事务间的读写操作得以并发执行，从而提升系统性能。RC、RR 这两个隔离级别的一个很大不同就是生成 ReadView 的时间点不同：</p>
<ul>
<li>RC 在每一次 SELECT 语句前都会生成一个 ReadView，事务期间会更新，因此在其他事务提交前后所得到的 m_ids 列表可能发生变化，使得先前不可见的版本后续又突然可见了。</li>
<li>RR 只在事务的第一个 SELECT 语句时生成一个 ReadView，事务操作期间不更新。</li>
</ul>
<h2 id="优化锁方面你有什么建议？"><a href="#优化锁方面你有什么建议？" class="headerlink" title="优化锁方面你有什么建议？"></a>优化锁方面你有什么建议？</h2><ul>
<li>合理设计索引，并尽量使用索引检索数据，避免无索引行锁升级表锁，从而减少锁冲突的机会</li>
<li>尽量控制事务大小，缩短锁定资源和时间长度，从而减少锁冲突的机会</li>
<li>除非必须，查询时不要显示加锁，mysql的mvcc可以实现事物中的查询不用加锁，优化事务性能</li>
<li>尽量减少索引条件，以及索引范围，避免间隙锁</li>
<li>尽量使用较低的隔离级别（需要业务层面满足需求）</li>
</ul>
<h1 id="MySql-日志"><a href="#MySql-日志" class="headerlink" title="MySql 日志"></a>MySql 日志</h1><p>// TODO</p>
<h1 id="MySql-主从复制"><a href="#MySql-主从复制" class="headerlink" title="MySql 主从复制"></a>MySql 主从复制</h1><p>// TODO</p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="什么是分库分表？"><a href="#什么是分库分表？" class="headerlink" title="什么是分库分表？"></a>什么是分库分表？</h2><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数<br>据表的数据量变小，从而达到提升数据库性能的目的。</p>
<h2 id="分库分表方式有哪些？"><a href="#分库分表方式有哪些？" class="headerlink" title="分库分表方式有哪些？"></a>分库分表方式有哪些？</h2><p>分库分表主要分为垂直切分和水平切分，垂直切分后还是有大数据量问题考虑水平切分（数据分片）</p>
<p>垂直切分：</p>
<ul>
<li>垂直分库：将单一数据库根据业务分成多库，一个业务对应一个数据库</li>
<li>垂直分表：将一张表根据字段分成多表，如商品表分成商品基本信息表+商品详情信息表</li>
</ul>
<p>水平切分：（数据分片，分布式数据存储）</p>
<ul>
<li>水平分库：将一个库数据分片到相同结构类型的多个库中（一个库数据分片为多库）</li>
<li>水平分表：将一张表数据分片到同结构类型的多张表中（一个表数据分片成多表）</li>
</ul>
<h2 id="分库分表带来的问题？"><a href="#分库分表带来的问题？" class="headerlink" title="分库分表带来的问题？"></a>分库分表带来的问题？</h2><ul>
<li>分布式事务问题：根据业务场景，选择强一致性或最终一致性；使用分布式事务中间件解决。</li>
<li>跨节点关联查询join问题：之前，我们可以通过Join来完成。而切分之后，数据可能分布在不同的节点上，此时Join带来的问题就比较麻烦了，考虑到性能，尽量避免使用Join查询。<ul>
<li>全局表：类似数据字典，每个数据库都保存即可</li>
<li>字段冗余：根据业务场景选择合适的字段进行冗余</li>
<li>数据组装：在服务层面上进行数据组装，列如先查出数据A，根据数据A查出数据B</li>
</ul>
</li>
<li>夸节点函数，排序，分页问题：<ul>
<li>夸节点进行查询时，会出现Limit分页、Order by排序等问题。</li>
<li>分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；</li>
<li>当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。</li>
</ul>
</li>
<li>全局主键避重问题：在数据分片情况下，主键自增肯定不合理了，如果用UUID那么无法做到根据主键排序，所以我们可以考虑通过雪花ID来作为数据库的主键，</li>
<li>数据迁移问题</li>
</ul>
<h2 id="分库分表常用中间件有哪些？"><a href="#分库分表常用中间件有哪些？" class="headerlink" title="分库分表常用中间件有哪些？"></a>分库分表常用中间件有哪些？</h2><p>mycat，sharding-jdbc</p>
<h2 id="sharding-jdbc使用"><a href="#sharding-jdbc使用" class="headerlink" title="sharding-jdbc使用"></a>sharding-jdbc使用</h2><h2 id="数据分片算法"><a href="#数据分片算法" class="headerlink" title="数据分片算法"></a>数据分片算法</h2><ul>
<li>自动分片算法<ul>
<li>取模分片算法</li>
<li>哈希取模分片算法</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="分布式主键"><a href="#分布式主键" class="headerlink" title="分布式主键"></a>分布式主键</h2><p>sharding-jdbc分布式主键生成策略有两种</p>
<ul>
<li>UUID：采用<code>UUID.randomUUID()</code>的方式生成分布式主键</li>
<li>SNOWFLAKE：默认使用雪花算法（snowflake）生成 64bit 的长整型数据。<ul>
<li>雪花算法是由 Twitter 公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。</li>
</ul>
</li>
</ul>
<h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>分库-key</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="数据库的三大范式，范式化设计优缺点？"><a href="#数据库的三大范式，范式化设计优缺点？" class="headerlink" title="数据库的三大范式，范式化设计优缺点？"></a>数据库的三大范式，范式化设计优缺点？</h2><p>三大范式：</p>
<ul>
<li>第一范式(1NF)：是对属性的原子性约束，要求属性具有原子性，不可再分解；</li>
<li>第二范式(2NF)：是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</li>
<li>第三范式(3NF)：是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</li>
</ul>
<p>优点：可以尽量得减少数据冗余，使得更新快，体积小。<br>缺点：对于查询需要多个表进行关联，减少写操作的效率和增加读操作的效率，更难进行索引优化。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/" rel="tag"># 面试宝典</a>
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/24/oyr/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E7%90%86%E8%AE%BA&BASE%E7%90%86%E8%AE%BA/" rel="prev" title="分布式相关概念">
      <i class="fa fa-chevron-left"></i> 分布式相关概念
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">数据库基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.1.</span> <span class="nav-text">主流的数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADDQL%EF%BC%8CDML%EF%BC%8CDDL%EF%BC%8CTCL%E8%AF%AD%E8%A8%80%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">数据库中DQL，DML，DDL，TCL语言都是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">MySql 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#crud%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.</span> <span class="nav-text">crud语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql%E6%80%8E%E4%B9%88%E5%8E%BB%E9%87%8D"><span class="nav-number">2.2.</span> <span class="nav-text">sql怎么去重?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#case%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">case的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cahr-%E5%92%8C-varchar-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">cahr 和 varchar 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#union-%E4%B8%8E-union-all%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">union 与 union all有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-%E4%B8%8E-exists-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.6.</span> <span class="nav-text">in 与 exists 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%86%85%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">外连接、内连接与自连接的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#drop%E3%80%81delete%E3%80%81truncate-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">drop、delete、truncate 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2sql%E7%9A%84%E5%86%99%E6%B3%95%E4%B8%8E%E6%9C%BA%E8%AF%BB%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.9.</span> <span class="nav-text">查询sql的写法与机读顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">MySql 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">事务是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">MySql支持事务吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">ACID是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BC%9A%E5%B8%A6%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">事务并发会带哪些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E7%89%A9%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.5.</span> <span class="nav-text">事物的隔离级别有哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">MySql 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">MySql 总体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="nav-number">4.1.1.</span> <span class="nav-text">连接层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="nav-number">4.1.2.</span> <span class="nav-text">服务层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E5%B1%82"><span class="nav-number">4.1.3.</span> <span class="nav-text">引擎层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82"><span class="nav-number">4.1.4.</span> <span class="nav-text">存储层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">Mysql支持哪些存储引擎？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E6%93%8E-InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">引擎 InnoDB 和 MyISAM 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="nav-number">4.4.</span> <span class="nav-text">数据文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">4.5.</span> <span class="nav-text">日志文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%85%B6%E7%BB%8F%E5%8E%86%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">4.6.</span> <span class="nav-text">一条查询SQL语句在执行时，其经历了那些过程？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">MySql 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">索引是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><span class="nav-number">5.2.</span> <span class="nav-text">索引的优势和劣势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%83%BD%E8%BF%90%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">索引都运用在哪些地方？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">MySql索引类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">MySql索引结构有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">B+Tree索引原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E7%94%A8%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.7.</span> <span class="nav-text">什么情况下需要创建索引，什么情况下不用创建索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-number">5.8.</span> <span class="nav-text">什么是最左前缀原则？什么是最左匹配原则？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.9.</span> <span class="nav-text">什么是前缀索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">5.10.</span> <span class="nav-text">什么是聚簇索引？何时使用聚簇索引与非聚簇索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F"><span class="nav-number">5.11.</span> <span class="nav-text">非聚簇索引一定会回表查询吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-number">5.12.</span> <span class="nav-text">索引如何查看、创建、删除？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sql%E4%BC%98%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">Sql优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">6.1.</span> <span class="nav-text">慢查询日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explain"><span class="nav-number">6.2.</span> <span class="nav-text">explain</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#id"><span class="nav-number">6.2.1.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-type"><span class="nav-number">6.2.2.</span> <span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#table"><span class="nav-number">6.2.3.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">6.2.4.</span> <span class="nav-text">type（非常重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#possible-keys"><span class="nav-number">6.2.5.</span> <span class="nav-text">possible_keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key"><span class="nav-number">6.2.6.</span> <span class="nav-text">key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-len"><span class="nav-number">6.2.7.</span> <span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">6.2.8.</span> <span class="nav-text">ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rows"><span class="nav-number">6.2.9.</span> <span class="nav-text">rows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extra"><span class="nav-number">6.2.10.</span> <span class="nav-text">extra</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#show-profile"><span class="nav-number">6.3.</span> <span class="nav-text">show profile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">如何避免索引失效？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#or%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">or关键字优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#is-null-amp-is-not-null-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.6.</span> <span class="nav-text">is null &amp; is not null 关键字优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.7.</span> <span class="nav-text">order by 关键字优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#group-by-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.8.</span> <span class="nav-text">group by 关键字优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.9.</span> <span class="nav-text">子查询优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%EF%BC%88join%EF%BC%89%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.10.</span> <span class="nav-text">连接（join）查询优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">6.11.</span> <span class="nav-text">超大分页怎么优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="nav-number">6.12.</span> <span class="nav-text">sql优化思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">MySql 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%94%81%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">为什么要使用锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%92%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">MySQL从锁的类别上划分为哪几种锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BB%8E%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">MySQL从锁的粒度划分为哪几种锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4MySql%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">说说MySql的行锁和表锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">7.5.</span> <span class="nav-text">InnoDB的行锁是怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E6%9C%89%E5%87%A0%E7%A7%8D%E9%94%81%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">7.6.</span> <span class="nav-text">InnoDB有几种锁算法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E8%AF%A6%E6%83%85"><span class="nav-number">7.7.</span> <span class="nav-text">间隙锁详情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">7.8.</span> <span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">7.9.</span> <span class="nav-text">MySql如何处理死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">7.10.</span> <span class="nav-text">如何避免死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">7.11.</span> <span class="nav-text">事务隔离级别与锁的关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC"><span class="nav-number">7.12.</span> <span class="nav-text">MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%EF%BC%9F"><span class="nav-number">7.13.</span> <span class="nav-text">优化锁方面你有什么建议？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E6%97%A5%E5%BF%97"><span class="nav-number">8.</span> <span class="nav-text">MySql 日志</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySql-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">MySql 主从复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">什么是分库分表？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">10.2.</span> <span class="nav-text">分库分表方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">10.3.</span> <span class="nav-text">分库分表带来的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">10.4.</span> <span class="nav-text">分库分表常用中间件有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sharding-jdbc%E4%BD%BF%E7%94%A8"><span class="nav-number">10.5.</span> <span class="nav-text">sharding-jdbc使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95"><span class="nav-number">10.6.</span> <span class="nav-text">数据分片算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE"><span class="nav-number">10.7.</span> <span class="nav-text">分布式主键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">10.8.</span> <span class="nav-text">怎么用？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">11.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%8C%E8%8C%83%E5%BC%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">数据库的三大范式，范式化设计优缺点？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">那个猪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/niubilityoyr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;niubilityoyr" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">那个猪</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
